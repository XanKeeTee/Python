<!DOCTYPE html>

<html lang="es" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Gestión de la memoria" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/c-api/memory.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Visión general: La gestión de memoria en Python implica un montón privado que contiene todos los objetos de Python y estructuras de datos. El administrador de memoria de Python garantiza internamen..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.15/es/_images/social_previews/summary_c-api_memory_d96da723.png" />
<meta property="og:image:alt" content="Visión general: La gestión de memoria en Python implica un montón privado que contiene todos los objetos de Python y estructuras de datos. El administrador de memoria de Python garantiza internamen..." />
<meta name="description" content="Visión general: La gestión de memoria en Python implica un montón privado que contiene todos los objetos de Python y estructuras de datos. El administrador de memoria de Python garantiza internamen..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>Gestión de la memoria &#8212; documentación de Python - 3.15.0a0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=bf1f176d"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f85f4cfb"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.15.0a0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Derechos de autor" href="../copyright.html" />
    <link rel="next" title="Soporte de implementación de objetos" href="objimpl.html" />
    <link rel="prev" title="Configuración de inicialización de Python" href="init_config.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/c-api/memory.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menú">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Gestión de la memoria</a><ul>
<li><a class="reference internal" href="#overview">Visión general</a></li>
<li><a class="reference internal" href="#allocator-domains">Dominios del asignador</a></li>
<li><a class="reference internal" href="#raw-memory-interface">Interfaz de memoria sin procesar</a></li>
<li><a class="reference internal" href="#memory-interface">Interfaz de memoria</a></li>
<li><a class="reference internal" href="#object-allocators">Asignadores de objetos</a></li>
<li><a class="reference internal" href="#default-memory-allocators">Asignadores de memoria predeterminados</a></li>
<li><a class="reference internal" href="#customize-memory-allocators">Personalizar asignadores de memoria</a></li>
<li><a class="reference internal" href="#debug-hooks-on-the-python-memory-allocators">Configurar enlaces para detectar errores en las funciones del asignador de memoria de Python</a></li>
<li><a class="reference internal" href="#the-pymalloc-allocator">El asignador pymalloc</a><ul>
<li><a class="reference internal" href="#customize-pymalloc-arena-allocator">Personalizar asignador de arena de pymalloc</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-mimalloc-allocator">The mimalloc allocator</a></li>
<li><a class="reference internal" href="#tracemalloc-c-api">tracemalloc C API</a></li>
<li><a class="reference internal" href="#examples">Ejemplos</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="init_config.html"
                          title="capítulo anterior">Configuración de inicialización de Python</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="objimpl.html"
                          title="próximo capítulo">Soporte de implementación de objetos</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/c-api/memory.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="objimpl.html" title="Soporte de implementación de objetos"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="init_config.html" title="Configuración de inicialización de Python"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Manual de referencia de la API en C de Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Gestión de la memoria</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="memory-management">
<span id="memory"></span><h1 class="translated">Gestión de la memoria<a class="headerlink" href="#memory-management" title="Link to this heading">¶</a></h1>
<section id="overview">
<span id="memoryoverview"></span><h2 class="translated">Visión general<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p class="translated">La gestión de memoria en Python implica un montón privado que contiene todos los objetos de Python y estructuras de datos. El <em>administrador de memoria de Python</em> garantiza internamente la gestión de este montón privado. El administrador de memoria de Python tiene diferentes componentes que se ocupan de varios aspectos de la gestión dinámica del almacenamiento, como compartir, segmentación, asignación previa o almacenamiento en caché.</p>
<p class="translated">En el nivel más bajo, un asignador de memoria sin procesar asegura que haya suficiente espacio en el montón privado para almacenar todos los datos relacionados con Python al interactuar con el administrador de memoria del sistema operativo. Además del asignador de memoria sin procesar, varios asignadores específicos de objeto operan en el mismo montón e implementan políticas de administración de memoria distintas adaptadas a las peculiaridades de cada tipo de objeto. Por ejemplo, los objetos enteros se administran de manera diferente dentro del montón que las cadenas, tuplas o diccionarios porque los enteros implican diferentes requisitos de almacenamiento y compensaciones de velocidad / espacio. El administrador de memoria de Python delega parte del trabajo a los asignadores específicos de objeto, pero asegura que este último opere dentro de los límites del montón privado.</p>
<p class="translated">Es importante comprender que la gestión del montón de Python la realiza el propio intérprete y que el usuario no tiene control sobre él, incluso si manipulan regularmente punteros de objetos a bloques de memoria dentro de ese montón. El administrador de memoria de Python realiza la asignación de espacio de almacenamiento dinámico para los objetos de Python y otros búferes internos a pedido a través de las funciones de API de Python/C enumeradas en este documento.</p>
<p class="translated" id="index-0">Para evitar daños en la memoria, los escritores de extensiones nunca deberían intentar operar en objetos Python con las funciones exportadas por la biblioteca C: <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">calloc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">realloc()</span></code> y <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>. Esto dará como resultado llamadas mixtas entre el asignador de C y el administrador de memoria de Python con consecuencias fatales, ya que implementan diferentes algoritmos y operan en diferentes montones. Sin embargo, uno puede asignar y liberar de forma segura bloques de memoria con el asignador de la biblioteca C para fines individuales, como se muestra en el siguiente ejemplo:</p>
<div class="untranslated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span><span class="w"> </span><span class="cm">/* for I/O */</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buf</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="p">...</span><span class="n">Do</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">I</span><span class="o">/</span><span class="n">O</span><span class="w"> </span><span class="n">operation</span><span class="w"> </span><span class="n">involving</span><span class="w"> </span><span class="n">buf</span><span class="p">...</span>
<span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyBytes_FromString</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"> </span><span class="cm">/* malloc&#39;ed */</span>
<span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
</pre></div>
</div>
<p class="translated">En este ejemplo, la solicitud de memoria para el búfer de E/S es manejada por el asignador de la biblioteca C. El administrador de memoria de Python solo participa en la asignación del objeto de bytes retornado como resultado.</p>
<p class="translated">Sin embargo, en la mayoría de las situaciones, se recomienda asignar memoria del montón de Python específicamente porque este último está bajo el control del administrador de memoria de Python. Por ejemplo, esto es necesario cuando el intérprete se amplía con nuevos tipos de objetos escritos en C. Otra razón para usar el montón de Python es el deseo de <em>informar</em> al administrador de memoria de Python sobre las necesidades de memoria del módulo de extensión. Incluso cuando la memoria solicitada se usa exclusivamente para fines internos y altamente específicos, delegar todas las solicitudes de memoria al administrador de memoria de Python hace que el intérprete tenga una imagen más precisa de su huella de memoria en su conjunto. En consecuencia, bajo ciertas circunstancias, el administrador de memoria de Python puede o no desencadenar acciones apropiadas, como recolección de basura, compactación de memoria u otros procedimientos preventivos. Tenga en cuenta que al usar el asignador de la biblioteca C como se muestra en el ejemplo anterior, la memoria asignada para el búfer de E/S escapa completamente al administrador de memoria Python.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="translated">La variable de entorno <span class="target" id="index-11"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOC"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONMALLOC</span></code></a> puede usarse para configurar los asignadores de memoria utilizados por Python.</p>
<p class="translated">La variable de entorno <span class="target" id="index-12"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOCSTATS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONMALLOCSTATS</span></code></a> se puede utilizar para imprimir estadísticas de <a class="reference internal" href="#pymalloc"><span class="std std-ref">asignador de memoria pymalloc</span></a> cada vez que se crea un nuevo escenario de objetos pymalloc, y en el apagado.</p>
</div>
</section>
<section id="allocator-domains">
<h2 class="translated">Dominios del asignador<a class="headerlink" href="#allocator-domains" title="Link to this heading">¶</a></h2>
<p class="untranslated" id="id1">All allocating functions belong to one of three different «domains» (see also
<a class="reference internal" href="#c.PyMemAllocatorDomain" title="PyMemAllocatorDomain"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMemAllocatorDomain</span></code></a>). These domains represent different allocation
strategies and are optimized for different purposes. The specific details on
how every domain allocates memory or what internal functions each domain calls
is considered an implementation detail, but for debugging purposes a simplified
table can be found at <a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">here</span></a>.
The APIs used to allocate and free a block of memory must be from the same domain.
For example, <a class="reference internal" href="#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> must be used to free memory allocated using <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>.</p>
<p class="translated">Los tres dominios de asignación son:</p>
<ul class="simple">
<li><p class="untranslated">Raw domain: intended for allocating memory for general-purpose memory
buffers where the allocation <em>must</em> go to the system allocator or where the
allocator can operate without an <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>. The memory
is requested directly from the system. See <a class="reference internal" href="#raw-memoryinterface"><span class="std std-ref">Raw Memory Interface</span></a>.</p></li>
<li><p class="untranslated">«Mem» domain: intended for allocating memory for Python buffers and
general-purpose memory buffers where the allocation must be performed with
an <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>. The memory is taken from the Python private heap.
See <a class="reference internal" href="#memoryinterface"><span class="std std-ref">Memory Interface</span></a>.</p></li>
<li><p class="untranslated">Object domain: intended for allocating memory for Python objects. The
memory is taken from the Python private heap. See <a class="reference internal" href="#objectinterface"><span class="std std-ref">Object allocators</span></a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">The <a class="reference internal" href="../glossary.html#term-free-threading"><span class="xref std std-term">free-threaded</span></a> build requires that only Python objects are allocated using the «object» domain
and that all Python objects are allocated using that domain. This differs from the prior Python versions,
where this was only a best practice and not a hard requirement.</p>
<p class="untranslated">For example, buffers (non-Python objects) should be allocated using <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>,
<a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a>, or <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code>, but not <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a>.</p>
<p class="untranslated">See <a class="reference internal" href="../howto/free-threading-extensions.html#free-threaded-memory-allocation"><span class="std std-ref">Memory Allocation APIs</span></a>.</p>
</div>
</section>
<section id="raw-memory-interface">
<span id="raw-memoryinterface"></span><h2 class="translated">Interfaz de memoria sin procesar<a class="headerlink" href="#raw-memory-interface" title="Link to this heading">¶</a></h2>
<p class="untranslated">The following function sets are wrappers to the system allocator. These
functions are thread-safe, so a <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a> does not
need to be <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached</span></a>.</p>
<p class="untranslated">The <a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">default raw memory allocator</span></a> uses
the following functions: <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">calloc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">realloc()</span></code>
and <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>; call <code class="docutils literal notranslate"><span class="pre">malloc(1)</span></code> (or <code class="docutils literal notranslate"><span class="pre">calloc(1,</span> <span class="pre">1)</span></code>) when requesting
zero bytes.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_RawMalloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_RawMalloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_RawMalloc" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p class="translated">Asigna <em>n</em> bytes y retorna un puntero de tipo <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> a la memoria asignada, o <code class="docutils literal notranslate"><span class="pre">NULL</span></code> si la solicitud falla.</p>
<p class="translated">Solicitar cero bytes retorna un puntero distinto que no sea <code class="docutils literal notranslate"><span class="pre">NULL</span></code> si es posible, como si en su lugar se hubiera llamado a <code class="docutils literal notranslate"><span class="pre">PyMem_RawMalloc(1)</span></code>. La memoria no se habrá inicializado de ninguna manera.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_RawCalloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_RawCalloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">nelem</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">elsize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_RawCalloc" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p class="translated">Asigna <em>nelem</em> elementos cada uno cuyo tamaño en bytes es <em>elsize</em> y retorna un puntero de tipo <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> a la memoria asignada, o <code class="docutils literal notranslate"><span class="pre">NULL</span></code> si la solicitud falla. La memoria se inicializa a ceros.</p>
<p class="translated">Solicitar elementos cero o elementos de tamaño cero bytes retorna un puntero distinto <code class="docutils literal notranslate"><span class="pre">NULL</span></code> si es posible, como si en su lugar se hubiera llamado <code class="docutils literal notranslate"><span class="pre">PyMem_RawCalloc(1,</span> <span class="pre">1)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_RawRealloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_RawRealloc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_RawRealloc" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p class="translated">Cambia el tamaño del bloque de memoria señalado por <em>p</em> a <em>n</em> bytes. Los contenidos no se modificarán al mínimo de los tamaños antiguo y nuevo.</p>
<p class="translated">Si <em>p</em> es <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, la llamada es equivalente a <code class="docutils literal notranslate"><span class="pre">PyMem_RawMalloc(n)</span></code>; de lo contrario, si <em>n</em> es igual a cero, el bloque de memoria cambia de tamaño pero no se libera, y el puntero retornado no es <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p class="translated">A menos que <em>p</em> sea <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, debe haber sido retornado por una llamada previa a <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a>, <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a> o <a class="reference internal" href="#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawCalloc()</span></code></a>.</p>
<p class="translated">Si la solicitud falla, <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a> retorna <code class="docutils literal notranslate"><span class="pre">NULL</span></code> y <em>p</em> sigue siendo un puntero válido al área de memoria anterior.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_RawFree">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_RawFree</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_RawFree" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.13.</em><p class="translated">Libera el bloque de memoria al que apunta <em>p</em>, que debe haber sido retornado por una llamada anterior a <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a>, <a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a> o <a class="reference internal" href="#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawCalloc()</span></code></a>. De lo contrario, o si se ha llamado antes a <code class="docutils literal notranslate"><span class="pre">PyMem_RawFree(p)</span></code>, se produce un comportamiento indefinido.</p>
<p class="translated">Si <em>p</em> es <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, no se realiza ninguna operación.</p>
</dd></dl>

</section>
<section id="memory-interface">
<span id="memoryinterface"></span><h2 class="translated">Interfaz de memoria<a class="headerlink" href="#memory-interface" title="Link to this heading">¶</a></h2>
<p class="translated">Los siguientes conjuntos de funciones, modelados según el estándar ANSI C, pero que especifican el comportamiento cuando se solicitan cero bytes, están disponibles para asignar y liberar memoria del montón de Python.</p>
<p class="translated">El <a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">asignador de memoria predeterminado</span></a> usa el <a class="reference internal" href="#pymalloc"><span class="std std-ref">asignador de memorya pymalloc</span></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p class="untranslated">There must be an <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> when using these functions.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>El asignador predeterminado ahora es pymalloc en lugar del <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> del sistema.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_Malloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_Malloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Malloc" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p class="translated">Asigna <em>n</em> bytes y retorna un puntero de tipo <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> a la memoria asignada, o <code class="docutils literal notranslate"><span class="pre">NULL</span></code> si la solicitud falla.</p>
<p class="translated">Solicitar cero bytes retorna un puntero distinto que no sea <code class="docutils literal notranslate"><span class="pre">NULL</span></code> si es posible, como si en su lugar se hubiera llamado a <code class="docutils literal notranslate"><span class="pre">PyMem_Malloc(1)</span></code>. La memoria no se habrá inicializado de ninguna manera.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_Calloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_Calloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">nelem</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">elsize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Calloc" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p class="translated">Asigna <em>nelem</em> elementos cada uno cuyo tamaño en bytes es <em>elsize</em> y retorna un puntero de tipo <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> a la memoria asignada, o <code class="docutils literal notranslate"><span class="pre">NULL</span></code> si la solicitud falla. La memoria se inicializa a ceros.</p>
<p class="translated">Solicitar elementos cero o elementos de tamaño cero bytes retorna un puntero distinto <code class="docutils literal notranslate"><span class="pre">NULL</span></code> si es posible, como si en su lugar se hubiera llamado <code class="docutils literal notranslate"><span class="pre">PyMem_Calloc(1,</span> <span class="pre">1)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_Realloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_Realloc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Realloc" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p class="translated">Cambia el tamaño del bloque de memoria señalado por <em>p</em> a <em>n</em> bytes. Los contenidos no se modificarán al mínimo de los tamaños antiguo y nuevo.</p>
<p class="translated">Si <em>p</em> es <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, la llamada es equivalente a <code class="docutils literal notranslate"><span class="pre">PyMem_Malloc(n)</span></code>; de lo contrario, si <em>n</em> es igual a cero, el bloque de memoria cambia de tamaño pero no se libera, y el puntero retornado no es <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p class="translated">A menos que <em>p</em> sea <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, debe haber sido retornado por una llamada previa a <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>, <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a> o <a class="reference internal" href="#c.PyMem_Calloc" title="PyMem_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Calloc()</span></code></a>.</p>
<p class="translated">Si la solicitud falla, <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a> retorna <code class="docutils literal notranslate"><span class="pre">NULL</span></code> y <em>p</em> sigue siendo un puntero válido al área de memoria anterior.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_Free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_Free</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Free" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p class="translated">Libera el bloque de memoria señalado por <em>p</em>, que debe haber sido retornado por una llamada anterior a <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>, <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a> o <a class="reference internal" href="#c.PyMem_Calloc" title="PyMem_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Calloc()</span></code></a>. De lo contrario, o si se ha llamado antes a <code class="docutils literal notranslate"><span class="pre">PyMem_Free(p)</span></code>, se produce un comportamiento indefinido.</p>
<p class="translated">Si <em>p</em> es <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, no se realiza ninguna operación.</p>
</dd></dl>

<p class="translated">Las siguientes macros orientadas a tipos se proporcionan por conveniencia. Tenga en cuenta que <em>TYPE</em> se refiere a cualquier tipo de C.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.PyMem_New">
<span class="sig-name descname"><span class="n"><span class="pre">PyMem_New</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">TYPE</span></span>, <span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_New" title="Link to this definition">¶</a><br /></dt>
<dd><p class="untranslated">Same as <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>, but allocates <code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">*</span> <span class="pre">sizeof(TYPE))</span></code> bytes of
memory.  Returns a pointer cast to <code class="docutils literal notranslate"><span class="pre">TYPE*</span></code>.  The memory will not have
been initialized in any way.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PyMem_Resize">
<span class="sig-name descname"><span class="n"><span class="pre">PyMem_Resize</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">TYPE</span></span>, <span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Resize" title="Link to this definition">¶</a><br /></dt>
<dd><p class="untranslated">Same as <a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a>, but the memory block is resized to <code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">*</span>
<span class="pre">sizeof(TYPE))</span></code> bytes.  Returns a pointer cast to <code class="docutils literal notranslate"><span class="pre">TYPE*</span></code>. On return,
<em>p</em> will be a pointer to the new memory area, or <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in the event of
failure.</p>
<p class="translated">Esta es una macro de preprocesador C; <em>p</em> siempre se reasigna. Guarde el valor original de <em>p</em> para evitar perder memoria al manejar errores.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_Del">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_Del</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_Del" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">La misma que <a class="reference internal" href="#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a>.</p>
</dd></dl>

<p class="translated">Además, se proporcionan los siguientes conjuntos de macros para llamar al asignador de memoria de Python directamente, sin involucrar las funciones de API de C mencionadas anteriormente. Sin embargo, tenga en cuenta que su uso no conserva la compatibilidad binaria entre las versiones de Python y, por lo tanto, está en desuso en los módulos de extensión.</p>
<ul class="simple">
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">PyMem_MALLOC(size)</span></code></p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">PyMem_NEW(type,</span> <span class="pre">size)</span></code></p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">PyMem_REALLOC(ptr,</span> <span class="pre">size)</span></code></p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">PyMem_RESIZE(ptr,</span> <span class="pre">type,</span> <span class="pre">size)</span></code></p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">PyMem_FREE(ptr)</span></code></p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">PyMem_DEL(ptr)</span></code></p></li>
</ul>
</section>
<section id="object-allocators">
<span id="objectinterface"></span><h2 class="translated">Asignadores de objetos<a class="headerlink" href="#object-allocators" title="Link to this heading">¶</a></h2>
<p class="translated">Los siguientes conjuntos de funciones, modelados según el estándar ANSI C, pero que especifican el comportamiento cuando se solicitan cero bytes, están disponibles para asignar y liberar memoria del montón de Python.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">No hay garantía de que la memoria retornada por estos asignadores se pueda convertir con éxito en un objeto Python al interceptar las funciones de asignación en este dominio mediante los métodos descritos en la sección <a class="reference internal" href="#customize-memory-allocators"><span class="std std-ref">Personalizar Asignadores de Memoria</span></a>.</p>
</div>
<p class="translated">El <a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">asignador predeterminado de objetos</span></a> usa el <a class="reference internal" href="#pymalloc"><span class="std std-ref">asignador de memoria pymalloc</span></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p class="untranslated">There must be an <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> when using these functions.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyObject_Malloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyObject_Malloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_Malloc" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p class="translated">Asigna <em>n</em> bytes y retorna un puntero de tipo <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> a la memoria asignada, o <code class="docutils literal notranslate"><span class="pre">NULL</span></code> si la solicitud falla.</p>
<p class="translated">Solicitar cero bytes retorna un puntero distinto que no sea <code class="docutils literal notranslate"><span class="pre">NULL</span></code> si es posible, como si en su lugar se hubiera llamado a <code class="docutils literal notranslate"><span class="pre">PyObject_Malloc(1)</span></code>. La memoria no se habrá inicializado de ninguna manera.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyObject_Calloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyObject_Calloc</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">nelem</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">elsize</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_Calloc" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a> since version 3.7.</em><p class="translated">Asigna <em>nelem</em> elementos cada uno cuyo tamaño en bytes es <em>elsize</em> y retorna un puntero de tipo <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> a la memoria asignada, o <code class="docutils literal notranslate"><span class="pre">NULL</span></code> si la solicitud falla. La memoria se inicializa a ceros.</p>
<p class="translated">Solicitar elementos cero o elementos de tamaño cero bytes retorna un puntero distinto <code class="docutils literal notranslate"><span class="pre">NULL</span></code> si es posible, como si en su lugar se hubiera llamado <code class="docutils literal notranslate"><span class="pre">PyObject_Calloc(1,</span> <span class="pre">1)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyObject_Realloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyObject_Realloc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_Realloc" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p class="translated">Cambia el tamaño del bloque de memoria señalado por <em>p</em> a <em>n</em> bytes. Los contenidos no se modificarán al mínimo de los tamaños antiguo y nuevo.</p>
<p class="translated">Si <em>p</em> es <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, la llamada es equivalente a <code class="docutils literal notranslate"><span class="pre">PyObject_Malloc(n)</span></code>; de lo contrario, si <em>n</em> es igual a cero, el bloque de memoria cambia de tamaño pero no se libera, y el puntero retornado no es <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<p class="translated">A menos que <em>p</em> sea <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, debe haber sido retornado por una llamada previa a <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a>, <a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a> o <a class="reference internal" href="#c.PyObject_Calloc" title="PyObject_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Calloc()</span></code></a>.</p>
<p class="translated">Si la solicitud falla, <a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a> retorna <code class="docutils literal notranslate"><span class="pre">NULL</span></code> y <em>p</em> sigue siendo un puntero válido al área de memoria anterior.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyObject_Free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyObject_Free</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_Free" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> Part of the <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Stable ABI</span></a>.</em><p class="translated">Libera el bloque de memoria al que apunta <em>p</em>, que debe haber sido retornado por una llamada anterior a <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a>, <a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a> o <a class="reference internal" href="#c.PyObject_Calloc" title="PyObject_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Calloc()</span></code></a>. De lo contrario, o si se ha llamado antes a <code class="docutils literal notranslate"><span class="pre">PyObject_Free(p)</span></code>, se produce un comportamiento indefinido.</p>
<p class="translated">Si <em>p</em> es <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, no se realiza ninguna operación.</p>
<p class="untranslated">Do not call this directly to free an object’s memory; call the type’s
<a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_free</span></code></a> slot instead.</p>
<p class="untranslated">Do not use this for memory allocated by <a class="reference internal" href="gcsupport.html#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_GC_New</span></code></a> or
<a class="reference internal" href="gcsupport.html#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_GC_NewVar</span></code></a>; use <a class="reference internal" href="gcsupport.html#c.PyObject_GC_Del" title="PyObject_GC_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Del()</span></code></a> instead.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<ul class="simple">
<li><p class="untranslated"><a class="reference internal" href="gcsupport.html#c.PyObject_GC_Del" title="PyObject_GC_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Del()</span></code></a> is the equivalent of this function for memory
allocated by types that support garbage collection.</p></li>
<li><p class="translated"><a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.PyObject_Calloc" title="PyObject_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Calloc()</span></code></a></p></li>
<li><p class="untranslated"><a class="reference internal" href="allocation.html#c.PyObject_New" title="PyObject_New"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_New</span></code></a></p></li>
<li><p class="untranslated"><a class="reference internal" href="allocation.html#c.PyObject_NewVar" title="PyObject_NewVar"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_NewVar</span></code></a></p></li>
<li><p class="untranslated"><a class="reference internal" href="type.html#c.PyType_GenericAlloc" title="PyType_GenericAlloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GenericAlloc()</span></code></a></p></li>
<li><p class="untranslated"><a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_free</span></code></a></p></li>
</ul>
</div>
</dd></dl>

</section>
<section id="default-memory-allocators">
<span id="id2"></span><h2 class="translated">Asignadores de memoria predeterminados<a class="headerlink" href="#default-memory-allocators" title="Link to this heading">¶</a></h2>
<p class="translated">Asignadores de memoria predeterminados:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Configuración</p></th>
<th class="head"><p class="translated">Nombre</p></th>
<th class="head"><p class="translated">PyMem_RawMalloc</p></th>
<th class="head"><p class="translated">PyMem_Malloc</p></th>
<th class="head"><p class="translated">PyObject_Malloc</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated">Lanzamiento de compilación</p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">&quot;pymalloc&quot;</span></code></p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">malloc</span></code></p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">malloc</span></code> + debug</p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">malloc</span></code> + debug</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">Compilación de depuración</p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">&quot;pymalloc_debug&quot;</span></code></p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">malloc</span></code> + debug</p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">pymalloc</span></code> + debug</p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">pymalloc</span></code> + debug</p></td>
</tr>
<tr class="row-even"><td><p class="translated">Lanzamiento de compilación, sin pymalloc</p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">&quot;malloc&quot;</span></code></p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">malloc</span></code></p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">malloc</span></code></p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">malloc</span></code></p></td>
</tr>
<tr class="row-odd"><td><p class="translated">Compilación de depuración, sin pymalloc</p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">&quot;malloc_debug&quot;</span></code></p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">malloc</span></code> + debug</p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">malloc</span></code> + debug</p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">malloc</span></code> + debug</p></td>
</tr>
</tbody>
</table>
<p class="translated">Leyenda:</p>
<ul class="simple">
<li><p class="translated">Nombre: valor para variable de entorno <span class="target" id="index-13"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOC"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONMALLOC</span></code></a>.</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">malloc</span></code>: asignadores del sistema de la biblioteca C estándar, funciones C: <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">calloc()</span></code>, <code class="xref c c-func docutils literal notranslate"><span class="pre">realloc()</span></code> y <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>.</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">pymalloc</span></code>: <a class="reference internal" href="#pymalloc"><span class="std std-ref">asignador de memoria pymalloc</span></a>.</p></li>
<li><p class="untranslated"><code class="docutils literal notranslate"><span class="pre">mimalloc</span></code>: <a class="reference internal" href="#mimalloc"><span class="std std-ref">mimalloc memory allocator</span></a>.  The pymalloc
allocator will be used if mimalloc support isn’t available.</p></li>
<li><p class="translated">«+ debug»: con <a class="reference internal" href="#pymem-debug-hooks"><span class="std std-ref">enlaces de depuración en los asignadores de memoria de Python</span></a>.</p></li>
<li><p class="translated">«Debug build»: <a class="reference internal" href="../using/configure.html#debug-build"><span class="std std-ref">Compilación de Python en modo de depuración</span></a>.</p></li>
</ul>
</section>
<section id="customize-memory-allocators">
<span id="id3"></span><h2 class="translated">Personalizar asignadores de memoria<a class="headerlink" href="#customize-memory-allocators" title="Link to this heading">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyMemAllocatorEx">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMemAllocatorEx</span></span></span><a class="headerlink" href="#c.PyMemAllocatorEx" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">Estructura utilizada para describir un asignador de bloque de memoria. La estructura tiene cuatro campos:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Campo</p></th>
<th class="head"><p class="translated">Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ctx</span></code></p></td>
<td><p class="translated">contexto de usuario pasado como primer argumento</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">void*</span> <span class="pre">malloc(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">size)</span></code></p></td>
<td><p class="translated">asignar un bloque de memoria</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">void*</span> <span class="pre">calloc(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">nelem,</span> <span class="pre">size_t</span> <span class="pre">elsize)</span></code></p></td>
<td><p class="translated">asignar un bloque de memoria inicializado con ceros</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">void*</span> <span class="pre">realloc(void</span> <span class="pre">*ctx,</span> <span class="pre">void</span> <span class="pre">*ptr,</span> <span class="pre">size_t</span> <span class="pre">new_size)</span></code></p></td>
<td><p class="translated">asignar o cambiar el tamaño de un bloque de memoria</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">free(void</span> <span class="pre">*ctx,</span> <span class="pre">void</span> <span class="pre">*ptr)</span></code></p></td>
<td><p class="translated">liberar un bloque de memoria</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>The <code class="xref c c-type docutils literal notranslate"><span class="pre">PyMemAllocator</span></code> structure was renamed to
<a class="reference internal" href="#c.PyMemAllocatorEx" title="PyMemAllocatorEx"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMemAllocatorEx</span></code></a> and a new <code class="docutils literal notranslate"><span class="pre">calloc</span></code> field was added.</p>
</div>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.PyMemAllocatorDomain">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMemAllocatorDomain</span></span></span><a class="headerlink" href="#c.PyMemAllocatorDomain" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">Enum se utiliza para identificar un dominio asignador. Dominios:</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.PYMEM_DOMAIN_RAW">
<span class="sig-name descname"><span class="n"><span class="pre">PYMEM_DOMAIN_RAW</span></span></span><a class="headerlink" href="#c.PYMEM_DOMAIN_RAW" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">Funciones:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawCalloc()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.PyMem_RawFree" title="PyMem_RawFree"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawFree()</span></code></a></p></li>
</ul>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PYMEM_DOMAIN_MEM">
<span class="sig-name descname"><span class="n"><span class="pre">PYMEM_DOMAIN_MEM</span></span></span><a class="headerlink" href="#c.PYMEM_DOMAIN_MEM" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">Funciones:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>,</p></li>
<li><p class="translated"><a class="reference internal" href="#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.PyMem_Calloc" title="PyMem_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Calloc()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a></p></li>
</ul>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PYMEM_DOMAIN_OBJ">
<span class="sig-name descname"><span class="n"><span class="pre">PYMEM_DOMAIN_OBJ</span></span></span><a class="headerlink" href="#c.PYMEM_DOMAIN_OBJ" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">Funciones:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.PyObject_Calloc" title="PyObject_Calloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Calloc()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a></p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_GetAllocator">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_GetAllocator</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyMemAllocatorDomain" title="PyMemAllocatorDomain"><span class="n"><span class="pre">PyMemAllocatorDomain</span></span></a><span class="w"> </span><span class="n"><span class="pre">domain</span></span>, <a class="reference internal" href="#c.PyMemAllocatorEx" title="PyMemAllocatorEx"><span class="n"><span class="pre">PyMemAllocatorEx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">allocator</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_GetAllocator" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">Obtenga el asignador de bloque de memoria del dominio especificado.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_SetAllocator">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_SetAllocator</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyMemAllocatorDomain" title="PyMemAllocatorDomain"><span class="n"><span class="pre">PyMemAllocatorDomain</span></span></a><span class="w"> </span><span class="n"><span class="pre">domain</span></span>, <a class="reference internal" href="#c.PyMemAllocatorEx" title="PyMemAllocatorEx"><span class="n"><span class="pre">PyMemAllocatorEx</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">allocator</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_SetAllocator" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">Establece el asignador de bloque de memoria del dominio especificado.</p>
<p class="translated">El nuevo asignador debe retornar un puntero distinto <code class="docutils literal notranslate"><span class="pre">NULL</span></code> al solicitar cero bytes.</p>
<p class="untranslated">For the <a class="reference internal" href="#c.PYMEM_DOMAIN_RAW" title="PYMEM_DOMAIN_RAW"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_RAW</span></code></a> domain, the allocator must be
thread-safe: a <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a> is not <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached</span></a>
when the allocator is called.</p>
<p class="untranslated">For the remaining domains, the allocator must also be thread-safe:
the allocator may be called in different interpreters that do not
share a <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a>.</p>
<p class="translated">Si el nuevo asignador no es un enlace (no llama al asignador anterior), se debe llamar a la función <a class="reference internal" href="#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetupDebugHooks()</span></code></a> para reinstalar los enlaces de depuración en la parte superior del nuevo asignador.</p>
<p class="translated">Vea también <a class="reference internal" href="init_config.html#c.PyPreConfig.allocator" title="PyPreConfig.allocator"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyPreConfig.allocator</span></code></a> y <a class="reference internal" href="init_config.html#c-preinit"><span class="std std-ref">Preinicialización de Python con PyPreConfig</span></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p class="untranslated"><a class="reference internal" href="#c.PyMem_SetAllocator" title="PyMem_SetAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetAllocator()</span></code></a> does have the following contract:</p>
<ul class="simple">
<li><p class="untranslated">It can be called after <a class="reference internal" href="init_config.html#c.Py_PreInitialize" title="Py_PreInitialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_PreInitialize()</span></code></a> and before
<a class="reference internal" href="init.html#c.Py_InitializeFromConfig" title="Py_InitializeFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_InitializeFromConfig()</span></code></a> to install a custom memory
allocator. There are no restrictions over the installed allocator
other than the ones imposed by the domain (for instance, the Raw
Domain allows the allocator to be called without an <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>).
See <a class="reference internal" href="#id1"><span class="std std-ref">the section on allocator domains</span></a> for more
information.</p></li>
<li><p class="untranslated">If called after Python has finish initializing (after
<a class="reference internal" href="init.html#c.Py_InitializeFromConfig" title="Py_InitializeFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_InitializeFromConfig()</span></code></a> has been called) the allocator
<strong>must</strong> wrap the existing allocator. Substituting the current
allocator for some other arbitrary one is <strong>not supported</strong>.</p></li>
</ul>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>All allocators must be thread-safe.</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMem_SetupDebugHooks">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMem_SetupDebugHooks</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMem_SetupDebugHooks" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">Configurar <a class="reference internal" href="#pymem-debug-hooks"><span class="std std-ref">enlaces de depuración en los asignadores de memoria de Python</span></a> para detectar errores de memoria.</p>
</dd></dl>

</section>
<section id="debug-hooks-on-the-python-memory-allocators">
<span id="pymem-debug-hooks"></span><h2 class="translated">Configurar enlaces para detectar errores en las funciones del asignador de memoria de Python<a class="headerlink" href="#debug-hooks-on-the-python-memory-allocators" title="Link to this heading">¶</a></h2>
<p class="translated">Cuando <a class="reference internal" href="../using/configure.html#debug-build"><span class="std std-ref">Python está construido en modo de depuración</span></a>, la función <a class="reference internal" href="#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetupDebugHooks()</span></code></a> se llama en <a class="reference internal" href="init_config.html#c-preinit"><span class="std std-ref">Preinicialización de Python</span></a> para configurar los enlaces de depuración en Python asignadores de memoria para detectar errores de memoria.</p>
<p class="translated">La variable de entorno <span class="target" id="index-14"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOC"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONMALLOC</span></code></a> se puede utilizar para instalar enlaces de depuración en un Python compilado en modo de lanzamiento (por ejemplo: <code class="docutils literal notranslate"><span class="pre">PYTHONMALLOC=debug</span></code>).</p>
<p class="translated">La función <a class="reference internal" href="#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetupDebugHooks()</span></code></a> se puede utilizar para establecer enlaces de depuración después de llamar a <a class="reference internal" href="#c.PyMem_SetAllocator" title="PyMem_SetAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetAllocator()</span></code></a>.</p>
<p class="translated">Estos enlaces de depuración llenan bloques de memoria asignados dinámicamente con patrones de bits especiales y reconocibles. La memoria recién asignada se llena con el byte <code class="docutils literal notranslate"><span class="pre">0xCD</span></code> (<code class="docutils literal notranslate"><span class="pre">PYMEM_CLEANBYTE</span></code>), la memoria liberada se llena con el byte <code class="docutils literal notranslate"><span class="pre">0xDD</span></code> (<code class="docutils literal notranslate"><span class="pre">PYMEM_DEADBYTE</span></code>). Los bloques de memoria están rodeados por «bytes prohibidos» rellenos con el byte <code class="docutils literal notranslate"><span class="pre">0xFD</span></code> (<code class="docutils literal notranslate"><span class="pre">PYMEM_FORBIDDENBYTE</span></code>). Es poco probable que las cadenas de estos bytes sean direcciones válidas, flotantes o cadenas ASCII.</p>
<p class="translated">Verificaciones de tiempo de ejecución:</p>
<ul class="simple">
<li><p class="translated">Detecte violaciones de API, por ejemplo: <a class="reference internal" href="#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a> llamado en un búfer asignado por <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>.</p></li>
<li><p class="translated">Detectar escritura antes del inicio del búfer (desbordamiento del búfer)</p></li>
<li><p class="translated">Detectar escritura después del final del búfer (desbordamiento del búfer)</p></li>
<li><p class="untranslated">Check that there is an <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> when
allocator functions of <a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_OBJ</span></code></a> (ex:
<a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a>) and <a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_MEM</span></code></a> (ex:
<a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>) domains are called.</p></li>
</ul>
<p class="translated">En caso de error, los enlaces de depuración usan el módulo <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a> para obtener el rastreo donde se asignó un bloque de memoria. El rastreo solo se muestra si <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a> rastrea las asignaciones de memoria de Python y se rastrea el bloque de memoria.</p>
<p class="translated">Sea <em>S</em> = <code class="docutils literal notranslate"><span class="pre">sizeof(size_t)</span></code>. Se agregan <code class="docutils literal notranslate"><span class="pre">2*S</span></code> bytes en cada extremo de cada bloque de <em>N</em> bytes solicitados. El diseño de la memoria es así, donde p representa la dirección retornada por una función similar a malloc o realloc (<code class="docutils literal notranslate"><span class="pre">p[i:j]</span></code> significa el segmento de bytes de <code class="docutils literal notranslate"><span class="pre">*(p+i)</span></code> inclusive hasta <code class="docutils literal notranslate"><span class="pre">*(p+j)</span></code> exclusivo; tenga en cuenta que el tratamiento de los índices negativos difiere de un segmento de Python):</p>
<dl>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">p[-2*S:-S]</span></code></dt><dd><p class="translated">Número de bytes solicitados originalmente. Este es un size_t, big-endian (más fácil de leer en un volcado de memoria).</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">p[-S]</span></code></dt><dd><p class="translated">Identificador de API (carácter ASCII):</p>
<ul class="simple">
<li><p class="untranslated"><code class="docutils literal notranslate"><span class="pre">'r'</span></code> for <a class="reference internal" href="#c.PYMEM_DOMAIN_RAW" title="PYMEM_DOMAIN_RAW"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_RAW</span></code></a>.</p></li>
<li><p class="untranslated"><code class="docutils literal notranslate"><span class="pre">'m'</span></code> for <a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_MEM</span></code></a>.</p></li>
<li><p class="untranslated"><code class="docutils literal notranslate"><span class="pre">'o'</span></code> for <a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_OBJ</span></code></a>.</p></li>
</ul>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">p[-S+1:0]</span></code></dt><dd><p class="translated">Copias de PYMEM_FORBIDDENBYTE. Se utiliza para detectar suscripciones y lecturas.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">p[0:N]</span></code></dt><dd><p class="translated">La memoria solicitada, llena de copias de PYMEM_CLEANBYTE, utilizada para capturar la referencia a la memoria no inicializada. Cuando se llama a una función similar a realloc solicitando un bloque de memoria más grande, los nuevos bytes en exceso también se llenan con PYMEM_CLEANBYTE. Cuando se llama a una función de tipo free, se sobrescriben con PYMEM_DEADBYTE, para captar la referencia a la memoria liberada. Cuando se llama a una función similar a la realloc solicitando un bloque de memoria más pequeño, los bytes antiguos sobrantes también se llenan con PYMEM_DEADBYTE.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">p[N:N+S]</span></code></dt><dd><p class="translated">Copias de PYMEM_FORBIDDENBYTE. Se utiliza para detectar sobrescrituras y lecturas.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">p[N+S:N+2*S]</span></code></dt><dd><p class="translated">Solo se utiliza si la macro <code class="docutils literal notranslate"><span class="pre">PYMEM_DEBUG_SERIALNO</span></code> está definida (no definida por defecto).</p>
<p class="untranslated">A serial number, incremented by 1 on each call to a malloc-like or
realloc-like function.  Big-endian <code class="xref c c-type docutils literal notranslate"><span class="pre">size_t</span></code>.  If «bad memory» is detected
later, the serial number gives an excellent way to set a breakpoint on the
next run, to capture the instant at which this block was passed out.  The
static function bumpserialno() in obmalloc.c is the only place the serial
number is incremented, and exists so you can set such a breakpoint easily.</p>
</dd>
</dl>
<p class="translated">Una función de tipo realloc o de tipo free primero verifica que los bytes PYMEM_FORBIDDENBYTE en cada extremo estén intactos. Si se han modificado, la salida de diagnóstico se escribe en stderr y el programa se aborta mediante Py_FatalError(). El otro modo de falla principal es provocar un error de memoria cuando un programa lee uno de los patrones de bits especiales e intenta usarlo como una dirección. Si ingresa a un depurador y observa el objeto, es probable que vea que está completamente lleno de PYMEM_DEADBYTE (lo que significa que se está usando la memoria liberada) o PYMEM_CLEANBYTE (que significa que se está usando la memoria no inicializada).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>The <a class="reference internal" href="#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetupDebugHooks()</span></code></a> function now also works on Python
compiled in release mode.  On error, the debug hooks now use
<a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a> to get the traceback where a memory block was allocated.
The debug hooks now also check if there is an <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> when
functions of <a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_OBJ</span></code></a> and <a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_MEM</span></code></a> domains are
called.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Los patrones de bytes <code class="docutils literal notranslate"><span class="pre">0xCB</span></code> (<code class="docutils literal notranslate"><span class="pre">PYMEM_CLEANBYTE</span></code>), <code class="docutils literal notranslate"><span class="pre">0xDB</span></code> (<code class="docutils literal notranslate"><span class="pre">PYMEM_DEADBYTE</span></code>) y <code class="docutils literal notranslate"><span class="pre">0xFB</span></code> (<code class="docutils literal notranslate"><span class="pre">PYMEM_FORBIDDENBYTE</span></code>) se han reemplazado por <code class="docutils literal notranslate"><span class="pre">0xCD</span></code>, <code class="docutils literal notranslate"><span class="pre">0xDD</span></code> y <code class="docutils literal notranslate"><span class="pre">0xFD</span></code> para usar los mismos valores que la depuración de Windows CRT <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> y <code class="docutils literal notranslate"><span class="pre">free()</span></code>.</p>
</div>
</section>
<section id="the-pymalloc-allocator">
<span id="pymalloc"></span><h2 class="translated">El asignador pymalloc<a class="headerlink" href="#the-pymalloc-allocator" title="Link to this heading">¶</a></h2>
<p class="untranslated">Python has a <em>pymalloc</em> allocator optimized for small objects (smaller or equal
to 512 bytes) with a short lifetime. It uses memory mappings called «arenas»
with a fixed size of either 256 KiB on 32-bit platforms or 1 MiB on 64-bit
platforms. It falls back to <a class="reference internal" href="#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a> and
<a class="reference internal" href="#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a> for allocations larger than 512 bytes.</p>
<p class="untranslated"><em>pymalloc</em> is the <a class="reference internal" href="#default-memory-allocators"><span class="std std-ref">default allocator</span></a> of the
<a class="reference internal" href="#c.PYMEM_DOMAIN_MEM" title="PYMEM_DOMAIN_MEM"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_MEM</span></code></a> (ex: <a class="reference internal" href="#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>) and
<a class="reference internal" href="#c.PYMEM_DOMAIN_OBJ" title="PYMEM_DOMAIN_OBJ"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PYMEM_DOMAIN_OBJ</span></code></a> (ex: <a class="reference internal" href="#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a>) domains.</p>
<p class="translated">El asignador de arena utiliza las siguientes funciones:</p>
<ul class="simple">
<li><p class="untranslated"><code class="xref c c-func docutils literal notranslate"><span class="pre">VirtualAlloc()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">VirtualFree()</span></code> on Windows,</p></li>
<li><p class="untranslated"><code class="xref c c-func docutils literal notranslate"><span class="pre">mmap()</span></code> and <code class="xref c c-func docutils literal notranslate"><span class="pre">munmap()</span></code> if available,</p></li>
<li><p class="translated"><code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> y <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> en caso contrario.</p></li>
</ul>
<p class="translated">Este asignador está deshabilitado si Python está configurado con la opción <a class="reference internal" href="../using/configure.html#cmdoption-without-pymalloc"><code class="xref std std-option docutils literal notranslate"><span class="pre">--without-pymalloc</span></code></a>. También se puede deshabilitar en tiempo de ejecución usando la variable de entorno <span class="target" id="index-15"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONMALLOC"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONMALLOC</span></code></a> (por ejemplo: <code class="docutils literal notranslate"><span class="pre">PYTHONMALLOC=malloc</span></code>).</p>
<p class="untranslated">Typically, it makes sense to disable the pymalloc allocator when building
Python with AddressSanitizer (<a class="reference internal" href="../using/configure.html#cmdoption-with-address-sanitizer"><code class="xref std std-option docutils literal notranslate"><span class="pre">--with-address-sanitizer</span></code></a>) which helps
uncover low level bugs within the C code.</p>
<section id="customize-pymalloc-arena-allocator">
<h3 class="translated">Personalizar asignador de arena de pymalloc<a class="headerlink" href="#customize-pymalloc-arena-allocator" title="Link to this heading">¶</a></h3>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyObjectArenaAllocator">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyObjectArenaAllocator</span></span></span><a class="headerlink" href="#c.PyObjectArenaAllocator" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">Estructura utilizada para describir un asignador de arena. La estructura tiene tres campos:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Campo</p></th>
<th class="head"><p class="translated">Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*ctx</span></code></p></td>
<td><p class="translated">contexto de usuario pasado como primer argumento</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">void*</span> <span class="pre">alloc(void</span> <span class="pre">*ctx,</span> <span class="pre">size_t</span> <span class="pre">size)</span></code></p></td>
<td><p class="translated">asignar una arena de bytes de tamaño</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">free(void</span> <span class="pre">*ctx,</span> <span class="pre">void</span> <span class="pre">*ptr,</span> <span class="pre">size_t</span> <span class="pre">size)</span></code></p></td>
<td><p class="translated">liberar la arena</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyObject_GetArenaAllocator">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyObject_GetArenaAllocator</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyObjectArenaAllocator" title="PyObjectArenaAllocator"><span class="n"><span class="pre">PyObjectArenaAllocator</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">allocator</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_GetArenaAllocator" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">Consigue el asignador de arena.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyObject_SetArenaAllocator">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyObject_SetArenaAllocator</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyObjectArenaAllocator" title="PyObjectArenaAllocator"><span class="n"><span class="pre">PyObjectArenaAllocator</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">allocator</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_SetArenaAllocator" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">Establecer el asignador de arena.</p>
</dd></dl>

</section>
</section>
<section id="the-mimalloc-allocator">
<span id="mimalloc"></span><h2 class="untranslated">The mimalloc allocator<a class="headerlink" href="#the-mimalloc-allocator" title="Link to this heading">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
<p class="untranslated">Python supports the mimalloc allocator when the underlying platform support is available.
mimalloc «is a general purpose allocator with excellent performance characteristics.
Initially developed by Daan Leijen for the runtime systems of the Koka and Lean languages.»</p>
</section>
<section id="tracemalloc-c-api">
<h2 class="translated">tracemalloc C API<a class="headerlink" href="#tracemalloc-c-api" title="Link to this heading">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyTraceMalloc_Track">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTraceMalloc_Track</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">domain</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">ptr</span></span>, <span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="n"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyTraceMalloc_Track" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">Rastree un bloque de memoria asignado en el módulo <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a>.</p>
<p class="translated">Retorna <code class="docutils literal notranslate"><span class="pre">0</span></code> en caso de éxito, retorna <code class="docutils literal notranslate"><span class="pre">-1</span></code> en caso de error (no se pudo asignar memoria para almacenar la traza). Retorna <code class="docutils literal notranslate"><span class="pre">-2</span></code> si tracemalloc está deshabilitado.</p>
<p class="translated">Si el bloque de memoria ya está rastreado, actualice el rastreo existente.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyTraceMalloc_Untrack">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTraceMalloc_Untrack</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">domain</span></span>, <span class="n"><span class="pre">uintptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyTraceMalloc_Untrack" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">Descomprima un bloque de memoria asignado en el módulo <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a>. No haga nada si el bloque no fue rastreado.</p>
<p class="translated">Retorna <code class="docutils literal notranslate"><span class="pre">-2</span></code> si tracemalloc está deshabilitado; de lo contrario, retorna <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</dd></dl>

</section>
<section id="examples">
<span id="memoryexamples"></span><h2 class="translated">Ejemplos<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h2>
<p class="translated">Aquí está el ejemplo de la sección <a class="reference internal" href="#memoryoverview"><span class="std std-ref">Visión general</span></a>, reescrito para que el búfer de E/S se asigne desde el montón de Python utilizando el primer conjunto de funciones:</p>
<div class="untranslated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">PyMem_Malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span><span class="w"> </span><span class="cm">/* for I/O */</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buf</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="cm">/* ...Do some I/O operation involving buf... */</span>
<span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyBytes_FromString</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="n">PyMem_Free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"> </span><span class="cm">/* allocated with PyMem_Malloc */</span>
<span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
</pre></div>
</div>
<p class="translated">El mismo código que utiliza el conjunto de funciones orientado a tipos:</p>
<div class="untranslated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyMem_New</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="n">BUFSIZ</span><span class="p">);</span><span class="w"> </span><span class="cm">/* for I/O */</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buf</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PyErr_NoMemory</span><span class="p">();</span>
<span class="cm">/* ...Do some I/O operation involving buf... */</span>
<span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyBytes_FromString</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="n">PyMem_Free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"> </span><span class="cm">/* allocated with PyMem_New */</span>
<span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
</pre></div>
</div>
<p class="translated">Tenga en cuenta que en los dos ejemplos anteriores, el búfer siempre se manipula a través de funciones que pertenecen al mismo conjunto. De hecho, es necesario usar la misma familia de API de memoria para un bloque de memoria dado, de modo que el riesgo de mezclar diferentes asignadores se reduzca al mínimo. La siguiente secuencia de código contiene dos errores, uno de los cuales está etiquetado como <em>fatal</em> porque mezcla dos asignadores diferentes que operan en montones diferentes.:</p>
<div class="untranslated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyMem_New</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="n">BUFSIZ</span><span class="p">);</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">PyMem_Malloc</span><span class="p">(</span><span class="n">BUFSIZ</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">PyMem_Del</span><span class="p">(</span><span class="n">buf3</span><span class="p">);</span><span class="w">  </span><span class="cm">/* Wrong -- should be PyMem_Free() */</span>
<span class="n">free</span><span class="p">(</span><span class="n">buf2</span><span class="p">);</span><span class="w">       </span><span class="cm">/* Right -- allocated via malloc() */</span>
<span class="n">free</span><span class="p">(</span><span class="n">buf1</span><span class="p">);</span><span class="w">       </span><span class="cm">/* Fatal -- should be PyMem_Free()  */</span>
</pre></div>
</div>
<p class="untranslated">In addition to the functions aimed at handling raw memory blocks from the Python
heap, objects in Python are allocated and released with <a class="reference internal" href="allocation.html#c.PyObject_New" title="PyObject_New"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_New</span></code></a>,
<a class="reference internal" href="allocation.html#c.PyObject_NewVar" title="PyObject_NewVar"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_NewVar</span></code></a> and <a class="reference internal" href="#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a>.</p>
<p class="translated">Esto se explicará en el próximo capítulo sobre cómo definir e implementar nuevos tipos de objetos en C.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Gestión de la memoria</a><ul>
<li><a class="reference internal" href="#overview">Visión general</a></li>
<li><a class="reference internal" href="#allocator-domains">Dominios del asignador</a></li>
<li><a class="reference internal" href="#raw-memory-interface">Interfaz de memoria sin procesar</a></li>
<li><a class="reference internal" href="#memory-interface">Interfaz de memoria</a></li>
<li><a class="reference internal" href="#object-allocators">Asignadores de objetos</a></li>
<li><a class="reference internal" href="#default-memory-allocators">Asignadores de memoria predeterminados</a></li>
<li><a class="reference internal" href="#customize-memory-allocators">Personalizar asignadores de memoria</a></li>
<li><a class="reference internal" href="#debug-hooks-on-the-python-memory-allocators">Configurar enlaces para detectar errores en las funciones del asignador de memoria de Python</a></li>
<li><a class="reference internal" href="#the-pymalloc-allocator">El asignador pymalloc</a><ul>
<li><a class="reference internal" href="#customize-pymalloc-arena-allocator">Personalizar asignador de arena de pymalloc</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-mimalloc-allocator">The mimalloc allocator</a></li>
<li><a class="reference internal" href="#tracemalloc-c-api">tracemalloc C API</a></li>
<li><a class="reference internal" href="#examples">Ejemplos</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="init_config.html"
                          title="capítulo anterior">Configuración de inicialización de Python</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="objimpl.html"
                          title="próximo capítulo">Soporte de implementación de objetos</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/c-api/memory.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Contraer barra lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="objimpl.html" title="Soporte de implementación de objetos"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="init_config.html" title="Configuración de inicialización de Python"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Manual de referencia de la API en C de Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Gestión de la memoria</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Derechos de autor</a> 2001 Python Software Foundation.
    <br>
    Ésta página tiene la licencia Python Software Foundation Versión 2.
    <br>
    Ejemplos, guías, y otro código en la documentación están bajo la licencia adicional Zero Clause BSD.
    <br>
    
      Ver <a href="/license.html">Historia y Licencia</a> para más información.<br>
    
    
    <br>

    La Python Software Foundation es una corporación sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor dona.</a>
<br>
    <br>
      Última actualización en oct 06, 2025 (04:51 UTC).
    
      <a href="/bugs.html">Encontraste un bug</a>?
    
    <br>

    Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a>8.2.3.
    </div>

  </body>
</html>