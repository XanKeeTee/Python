<!DOCTYPE html>

<html lang="es" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="ctypes — A foreign function library for Python" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/ctypes.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Source code: Lib/ctypes ctypes es una biblioteca de funciones foráneas para Python. Proporciona tipos de datos compatibles con C y permite llamar a funciones en archivos DLL o bibliotecas compartid..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.15/es/_images/social_previews/summary_library_ctypes_7ffe83f1.png" />
<meta property="og:image:alt" content="Source code: Lib/ctypes ctypes es una biblioteca de funciones foráneas para Python. Proporciona tipos de datos compatibles con C y permite llamar a funciones en archivos DLL o bibliotecas compartid..." />
<meta name="description" content="Source code: Lib/ctypes ctypes es una biblioteca de funciones foráneas para Python. Proporciona tipos de datos compatibles con C y permite llamar a funciones en archivos DLL o bibliotecas compartid..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>ctypes — A foreign function library for Python &#8212; documentación de Python - 3.15.0a0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=bf1f176d"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f85f4cfb"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.15.0a0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Derechos de autor" href="../copyright.html" />
    <link rel="next" title="Command-line interface libraries" href="cmdlinelibs.html" />
    <link rel="prev" title="errno — Standard errno system symbols" href="errno.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/library/ctypes.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menú">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> — A foreign function library for Python</a><ul>
<li><a class="reference internal" href="#ctypes-tutorial">tutorial de ctypes</a><ul>
<li><a class="reference internal" href="#loading-dynamic-link-libraries">Carga de bibliotecas de enlaces dinámicos</a></li>
<li><a class="reference internal" href="#accessing-functions-from-loaded-dlls">Acceder a las funciones de los dll cargados</a></li>
<li><a class="reference internal" href="#calling-functions">Funciones de llamada</a></li>
<li><a class="reference internal" href="#fundamental-data-types">Tipos de datos fundamentales</a></li>
<li><a class="reference internal" href="#calling-functions-continued">Funciones de llamada, continuación</a></li>
<li><a class="reference internal" href="#calling-variadic-functions">Calling variadic functions</a></li>
<li><a class="reference internal" href="#calling-functions-with-your-own-custom-data-types">Funciones de llamada con sus propios tipos de datos personalizados</a></li>
<li><a class="reference internal" href="#specifying-the-required-argument-types-function-prototypes">Especificar los tipos de argumentos requeridos (prototipos de funciones)</a></li>
<li><a class="reference internal" href="#return-types">Tipos de retorno</a></li>
<li><a class="reference internal" href="#passing-pointers-or-passing-parameters-by-reference">Pasar los punteros (o: pasar los parámetros por referencia)</a></li>
<li><a class="reference internal" href="#structures-and-unions">Estructuras y uniones</a></li>
<li><a class="reference internal" href="#structure-union-layout-alignment-and-byte-order">Structure/union layout, alignment and byte order</a></li>
<li><a class="reference internal" href="#bit-fields-in-structures-and-unions">Campos de bits en estructuras y uniones</a></li>
<li><a class="reference internal" href="#arrays">Arreglos</a></li>
<li><a class="reference internal" href="#pointers">Punteros</a></li>
<li><a class="reference internal" href="#thread-safety-without-the-gil">Thread safety without the GIL</a></li>
<li><a class="reference internal" href="#type-conversions">Conversiones de tipos</a></li>
<li><a class="reference internal" href="#incomplete-types">Tipos incompletos</a></li>
<li><a class="reference internal" href="#callback-functions">Funciones de retrollamadas (<em>callback</em>)</a></li>
<li><a class="reference internal" href="#accessing-values-exported-from-dlls">Acceder a los valores exportados de los dlls</a></li>
<li><a class="reference internal" href="#surprises">Sorpresas</a></li>
<li><a class="reference internal" href="#variable-sized-data-types">Tipos de datos de tamaño variable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ctypes-reference">referencia ctypes</a><ul>
<li><a class="reference internal" href="#finding-shared-libraries">Encontrar bibliotecas compartidas</a></li>
<li><a class="reference internal" href="#listing-loaded-shared-libraries">Listing loaded shared libraries</a></li>
<li><a class="reference internal" href="#loading-shared-libraries">Cargando bibliotecas compartidas</a></li>
<li><a class="reference internal" href="#foreign-functions">Funciones foráneas</a></li>
<li><a class="reference internal" href="#function-prototypes">Prototipos de funciones</a></li>
<li><a class="reference internal" href="#utility-functions">Funciones de utilidad</a></li>
<li><a class="reference internal" href="#data-types">Tipos de datos</a></li>
<li><a class="reference internal" href="#ctypes-fundamental-data-types-2">Tipos de datos fundamentales</a></li>
<li><a class="reference internal" href="#structured-data-types">Tipos de datos estructurados</a></li>
<li><a class="reference internal" href="#arrays-and-pointers">Arreglos y punteros</a></li>
<li><a class="reference internal" href="#exceptions">Exceptions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="errno.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">errno</span></code> — Standard errno system symbols</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="cmdlinelibs.html"
                          title="próximo capítulo">Command-line interface libraries</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/ctypes.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="cmdlinelibs.html" title="Command-line interface libraries"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="errno.html" title="errno — Standard errno system symbols"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">Servicios genéricos del sistema operativo</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> — A foreign function library for Python</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-ctypes">
<span id="ctypes-a-foreign-function-library-for-python"></span><h1 class="untranslated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> — A foreign function library for Python<a class="headerlink" href="#module-ctypes" title="Link to this heading">¶</a></h1>
<p class="untranslated"><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/main/Lib/ctypes">Lib/ctypes</a></p>
<hr class="docutils" />
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> es una biblioteca de funciones foráneas para Python. Proporciona tipos de datos compatibles con C y permite llamar a funciones en archivos DLL o bibliotecas compartidas. Se puede utilizar para envolver estas bibliotecas en Python puro.</p>
<section id="ctypes-tutorial">
<span id="ctypes-ctypes-tutorial"></span><h2 class="translated">tutorial de ctypes<a class="headerlink" href="#ctypes-tutorial" title="Link to this heading">¶</a></h2>
<p class="translated">Nota: Los ejemplos de código en este tutorial usan <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> para asegurarse de que realmente funcionen. Dado que algunos ejemplos de código se comportan de manera diferente en Linux, Windows o macOS, contienen directivas doctest en los comentarios.</p>
<p class="translated">Nota: Algunos ejemplos de código hacen referencia al tipo ctypes <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>. En las plataformas donde <code class="docutils literal notranslate"><span class="pre">sizeof(long)</span> <span class="pre">==</span> <span class="pre">sizeof(int)</span></code> es un alias de <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a>. Por lo tanto, no debe confundirse si <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a> se imprime si espera <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> — son en realidad del mismo tipo.</p>
<section id="loading-dynamic-link-libraries">
<span id="ctypes-loading-dynamic-link-libraries"></span><h3 class="translated">Carga de bibliotecas de enlaces dinámicos<a class="headerlink" href="#loading-dynamic-link-libraries" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> exporta los objetos <em>cdll</em> y en Windows <em>windll</em> y <em>oledll</em>, para cargar bibliotecas de enlaces dinámicos.</p>
<p class="untranslated">You load libraries by accessing them as attributes of these objects. <em>cdll</em>
loads libraries which export functions using the standard <code class="docutils literal notranslate"><span class="pre">cdecl</span></code> calling
convention, while <em>windll</em> libraries call functions using the <code class="docutils literal notranslate"><span class="pre">stdcall</span></code>
calling convention. <em>oledll</em> also uses the <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> calling convention, and
assumes the functions return a Windows <code class="xref c c-type docutils literal notranslate"><span class="pre">HRESULT</span></code> error code. The error
code is used to automatically raise an <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> exception when the
function call fails.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Los errores de Windows solían generar <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a>, que ahora es un alias de <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
</div>
<p class="untranslated">Here are some examples for Windows. Note that <code class="docutils literal notranslate"><span class="pre">msvcrt</span></code> is the MS standard C
library containing most standard C functions, and uses the <code class="docutils literal notranslate"><span class="pre">cdecl</span></code> calling
convention:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">)</span>
<span class="go">&lt;WinDLL &#39;kernel32&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">)</span>
<span class="go">&lt;CDLL &#39;msvcrt&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Windows agrega automáticamente la extensión común <code class="docutils literal notranslate"><span class="pre">.dll</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Acceder a la biblioteca estándar de C a través de <code class="docutils literal notranslate"><span class="pre">cdll.msvcrt</span></code> utilizará una versión obsoleta de la biblioteca que puede ser incompatible con la utilizada por Python. Cuando sea posible, use la funcionalidad nativa de Python, o bien importe y use el módulo <code class="docutils literal notranslate"><span class="pre">msvcrt</span></code>.</p>
</div>
<p class="untranslated">On Linux, it is required to specify the filename <em>including</em> the extension to
load a library, so attribute access can not be used to load libraries. Either the
<a class="reference internal" href="#ctypes.LibraryLoader.LoadLibrary" title="ctypes.LibraryLoader.LoadLibrary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadLibrary()</span></code></a> method of the dll loaders should be used,
or you should load the library by creating an instance of CDLL by calling
the constructor:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">CDLL</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span>
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="accessing-functions-from-loaded-dlls">
<span id="ctypes-accessing-functions-from-loaded-dlls"></span><h3 class="translated">Acceder a las funciones de los dll cargados<a class="headerlink" href="#accessing-functions-from-loaded-dlls" title="Link to this heading">¶</a></h3>
<p class="translated">Las funciones se acceden como atributos de los objetos dll:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">)</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">MyOwnFunction</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">239</span>, in <span class="n">__getattr__</span>
<span class="w">    </span><span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">function &#39;MyOwnFunction&#39; not found</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="untranslated">Note that win32 system dlls like <code class="docutils literal notranslate"><span class="pre">kernel32</span></code> and <code class="docutils literal notranslate"><span class="pre">user32</span></code> often export ANSI
as well as UNICODE versions of a function. The UNICODE version is exported with
a <code class="docutils literal notranslate"><span class="pre">W</span></code> appended to the name, while the ANSI version is exported with an <code class="docutils literal notranslate"><span class="pre">A</span></code>
appended to the name. The win32 <code class="docutils literal notranslate"><span class="pre">GetModuleHandle</span></code> function, which returns a
<em>module handle</em> for a given module name, has the following C prototype, and a
macro is used to expose one of them as <code class="docutils literal notranslate"><span class="pre">GetModuleHandle</span></code> depending on whether
UNICODE is defined or not:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">ANSI</span> <span class="n">version</span> <span class="o">*/</span>
<span class="n">HMODULE</span> <span class="n">GetModuleHandleA</span><span class="p">(</span><span class="n">LPCSTR</span> <span class="n">lpModuleName</span><span class="p">);</span>
<span class="o">/*</span> <span class="n">UNICODE</span> <span class="n">version</span> <span class="o">*/</span>
<span class="n">HMODULE</span> <span class="n">GetModuleHandleW</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpModuleName</span><span class="p">);</span>
</pre></div>
</div>
<p class="translated"><em>windll</em> no intenta seleccionar una de ellas por arte de magia, se debe acceder a la versión que se necesita especificando <code class="docutils literal notranslate"><span class="pre">GetModuleHandleA</span></code> o <code class="docutils literal notranslate"><span class="pre">GetModuleHandleW</span></code> explícitamente, y luego llamarlo con bytes u objetos de cadena respectivamente.</p>
<p class="translated">A veces, las dlls exportan funciones con nombres que no son identificadores válidos de Python, como <code class="docutils literal notranslate"><span class="pre">&quot;??2&#64;YAPAXI&#64;Z&quot;</span></code>. En este caso tienes que usar <a class="reference internal" href="functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> para recuperar la función:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">getattr</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">,</span> <span class="s2">&quot;??2@YAPAXI@Z&quot;</span><span class="p">)</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">En Windows, algunas dlls exportan funciones no por nombre sino por ordinal. Se pueden acceder a estas funciones indexando el objeto dll con el número ordinal:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">310</span>, in <span class="n">__getitem__</span>
<span class="w">    </span><span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">function ordinal 0 not found</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="calling-functions">
<span id="ctypes-calling-functions"></span><h3 class="translated">Funciones de llamada<a class="headerlink" href="#calling-functions" title="Link to this heading">¶</a></h3>
<p class="untranslated">You can call these functions like any other Python callable. This example uses
the <code class="docutils literal notranslate"><span class="pre">rand()</span></code> function, which takes no arguments and returns a pseudo-random integer:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">rand</span><span class="p">())</span>
<span class="go">1804289383</span>
</pre></div>
</div>
<p class="untranslated">On Windows, you can call the <code class="docutils literal notranslate"><span class="pre">GetModuleHandleA()</span></code> function, which returns a win32 module
handle (passing <code class="docutils literal notranslate"><span class="pre">None</span></code> as single argument to call it with a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer):</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="kc">None</span><span class="p">)))</span>
<span class="go">0x1d000000</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> es lanzado cuando se llama a una función <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> con la convención de llamada <code class="docutils literal notranslate"><span class="pre">cdecl</span></code>, o viceversa:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">Procedure probably called with not enough arguments (4 bytes missing)</span>
<span class="gp">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">msvcrt</span><span class="o">.</span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;spam&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">Procedure probably called with too many arguments (4 bytes in excess)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Para saber la convención de llamada correcta, hay que mirar en el archivo de encabezado C o en la documentación de la función que se quiere llamar.</p>
<p class="translated">En Windows, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> utiliza la gestión de excepciones estructurada de win32 para evitar que se produzcan fallos de protección general cuando se llaman funciones con valores de argumento inválidos:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">OSError</span>: <span class="n">exception: access violation reading 0x00000020</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Sin embargo, hay suficientes maneras de bloquear Python con <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>, así que debes tener cuidado de todos modos. El módulo <a class="reference internal" href="faulthandler.html#module-faulthandler" title="faulthandler: Dump the Python traceback."><code class="xref py py-mod docutils literal notranslate"><span class="pre">faulthandler</span></code></a> puede ser útil para depurar bloqueos (por ejemplo, provenientes de fallos de segmentación producidos por llamadas erróneas a la biblioteca C).</p>
<p class="untranslated"><code class="docutils literal notranslate"><span class="pre">None</span></code>, integers, bytes objects and (unicode) strings are the only native
Python objects that can directly be used as parameters in these function calls.
<code class="docutils literal notranslate"><span class="pre">None</span></code> is passed as a C <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer, bytes objects and strings are passed
as pointer to the memory block that contains their data (<span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">*</span></span> or
<span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span>).  Python integers are passed as the platform’s default C
<span class="c-expr sig sig-inline c"><span class="kt">int</span></span> type, their value is masked to fit into the C type.</p>
<p class="translated">Antes de pasar a llamar funciones con otros tipos de parámetros, tenemos que aprender más sobre los tipos de datos <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>.</p>
</section>
<section id="fundamental-data-types">
<span id="ctypes-fundamental-data-types"></span><h3 class="translated">Tipos de datos fundamentales<a class="headerlink" href="#fundamental-data-types" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> define un número de tipos de datos primitivos compatibles con C:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">tipo ctypes</p></th>
<th class="head"><p class="translated">Tipo C</p></th>
<th class="head"><p class="translated">Tipo Python</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_bool" title="ctypes.c_bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_bool</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">_Bool</span></span></p></td>
<td><p class="translated">bool (1)</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">char</span></span></p></td>
<td><p class="translated">Un objeto bytes de 1-caracter</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar</span></code></a></p></td>
<td><p class="untranslated"><code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code></p></td>
<td><p class="translated">Una cadena de 1-caracter</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_byte</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">char</span></span></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ubyte</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_short</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">short</span></span></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ushort</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span></span></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">int</span></span></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-even"><td><p class="untranslated"><a class="reference internal" href="#ctypes.c_int8" title="ctypes.c_int8"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int8</span></code></a></p></td>
<td><p class="untranslated"><code class="xref c c-type docutils literal notranslate"><span class="pre">int8_t</span></code></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-odd"><td><p class="untranslated"><a class="reference internal" href="#ctypes.c_int16" title="ctypes.c_int16"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int16</span></code></a></p></td>
<td><p class="untranslated"><code class="xref c c-type docutils literal notranslate"><span class="pre">int16_t</span></code></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-even"><td><p class="untranslated"><a class="reference internal" href="#ctypes.c_int32" title="ctypes.c_int32"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int32</span></code></a></p></td>
<td><p class="untranslated"><code class="xref c c-type docutils literal notranslate"><span class="pre">int32_t</span></code></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-odd"><td><p class="untranslated"><a class="reference internal" href="#ctypes.c_int64" title="ctypes.c_int64"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int64</span></code></a></p></td>
<td><p class="untranslated"><code class="xref c c-type docutils literal notranslate"><span class="pre">int64_t</span></code></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-odd"><td><p class="untranslated"><a class="reference internal" href="#ctypes.c_uint8" title="ctypes.c_uint8"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint8</span></code></a></p></td>
<td><p class="untranslated"><code class="xref c c-type docutils literal notranslate"><span class="pre">uint8_t</span></code></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-even"><td><p class="untranslated"><a class="reference internal" href="#ctypes.c_uint16" title="ctypes.c_uint16"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint16</span></code></a></p></td>
<td><p class="untranslated"><code class="xref c c-type docutils literal notranslate"><span class="pre">uint16_t</span></code></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-odd"><td><p class="untranslated"><a class="reference internal" href="#ctypes.c_uint32" title="ctypes.c_uint32"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint32</span></code></a></p></td>
<td><p class="untranslated"><code class="xref c c-type docutils literal notranslate"><span class="pre">uint32_t</span></code></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-even"><td><p class="untranslated"><a class="reference internal" href="#ctypes.c_uint64" title="ctypes.c_uint64"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint64</span></code></a></p></td>
<td><p class="untranslated"><code class="xref c c-type docutils literal notranslate"><span class="pre">uint64_t</span></code></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">long</span></span></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulong</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longlong</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="n">__int64</span></span> o <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulonglong</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">__int64</span></span> o <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_size_t" title="ctypes.c_size_t"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_size_t</span></code></a></p></td>
<td><p class="untranslated"><code class="xref c c-type docutils literal notranslate"><span class="pre">size_t</span></code></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_ssize_t" title="ctypes.c_ssize_t"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ssize_t</span></code></a></p></td>
<td><p class="untranslated"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssize_t</span></code> or
<span class="c-expr sig sig-inline c"><a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n">Py_ssize_t</span></a></span></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-odd"><td><p class="untranslated"><a class="reference internal" href="#ctypes.c_time_t" title="ctypes.c_time_t"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_time_t</span></code></a></p></td>
<td><p class="untranslated"><code class="xref c c-type docutils literal notranslate"><span class="pre">time_t</span></code></p></td>
<td><p class="translated">entero</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_float" title="ctypes.c_float"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_float</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">float</span></span></p></td>
<td><p class="translated">flotante</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_double</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">double</span></span></p></td>
<td><p class="translated">flotante</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_longdouble" title="ctypes.c_longdouble"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longdouble</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">double</span></span></p></td>
<td><p class="translated">flotante</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">*</span></span> (terminado en NUL)</p></td>
<td><p class="translated">objeto de bytes o <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar_p</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span> (terminado en NUL)</p></td>
<td><p class="translated">cadena o <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span></p></td>
<td><p class="translated">entero o <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
</tbody>
</table>
<ol class="arabic simple">
<li><p class="translated">El constructor acepta cualquier objeto con valor verdadero.</p></li>
</ol>
<p class="untranslated">Additionally, if IEC 60559 compatible complex arithmetic (Annex G) is supported
in both C and <code class="docutils literal notranslate"><span class="pre">libffi</span></code>, the following complex types are available:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">tipo ctypes</p></th>
<th class="head"><p class="translated">Tipo C</p></th>
<th class="head"><p class="translated">Tipo Python</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="untranslated"><a class="reference internal" href="#ctypes.c_float_complex" title="ctypes.c_float_complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_float_complex</span></code></a></p></td>
<td><p class="untranslated"><span class="c-expr sig sig-inline c"><span class="kt">float</span><span class="w"> </span><span class="kt">complex</span></span></p></td>
<td><p class="untranslated">complex</p></td>
</tr>
<tr class="row-odd"><td><p class="untranslated"><a class="reference internal" href="#ctypes.c_double_complex" title="ctypes.c_double_complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_double_complex</span></code></a></p></td>
<td><p class="untranslated"><span class="c-expr sig sig-inline c"><span class="kt">double</span><span class="w"> </span><span class="kt">complex</span></span></p></td>
<td><p class="untranslated">complex</p></td>
</tr>
<tr class="row-even"><td><p class="untranslated"><a class="reference internal" href="#ctypes.c_longdouble_complex" title="ctypes.c_longdouble_complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longdouble_complex</span></code></a></p></td>
<td><p class="untranslated"><span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="kt">complex</span></span></p></td>
<td><p class="untranslated">complex</p></td>
</tr>
</tbody>
</table>
<p class="translated">Todos estos tipos pueden ser creados llamándolos con un inicializador opcional del tipo y valor correctos:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c_int</span><span class="p">()</span>
<span class="go">c_long(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_wchar_p</span><span class="p">(</span><span class="s2">&quot;Hello, World&quot;</span><span class="p">)</span>
<span class="go">c_wchar_p(140018365411392)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_ushort</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">c_ushort(65533)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Dado que estos tipos son mutables, su valor también puede ser cambiado después:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(42)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">-99</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="untranslated">Assigning a new value to instances of the pointer types <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>,
<a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar_p</span></code></a>, and <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a> changes the <em>memory location</em> they
point to, <em>not the contents</em> of the memory block (of course not, because Python
string objects are immutable):</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Hello, World&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span> <span class="o">=</span> <span class="n">c_wchar_p</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="p">)</span>
<span class="go">c_wchar_p(139966785747344)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">Hello World</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;Hi, there&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="p">)</span>              <span class="c1"># the memory location has changed</span>
<span class="go">c_wchar_p(139966783348904)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">Hi, there</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>                <span class="c1"># first object is unchanged</span>
<span class="go">Hello, World</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Sin embargo, debe tener cuidado de no pasarlos a funciones que esperan punteros a la memoria mutable. Si necesitas bloques de memoria mutables, ctypes tiene una función <a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code></a> que los crea de varias maneras. El contenido actual del bloque de memoria puede ser accedido (o cambiado) con la propiedad <code class="docutils literal notranslate"><span class="pre">raw</span></code>; si quieres acceder a él como cadena terminada NUL, usa la propiedad <code class="docutils literal notranslate"><span class="pre">value</span></code>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>            <span class="c1"># create a 3 byte buffer, initialized to NUL bytes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">3 b&#39;\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>     <span class="c1"># create a buffer containing a NUL terminated string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">6 b&#39;Hello\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">b&#39;Hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="c1"># create a 10 byte buffer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">10 b&#39;Hello\x00\x00\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;Hi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">10 b&#39;Hi\x00lo\x00\x00\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="untranslated">The <a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code></a> function replaces the old <code class="xref py py-func docutils literal notranslate"><span class="pre">c_buffer()</span></code>
function (which is still available as an alias).  To create a mutable memory
block containing unicode characters of the C type <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code>, use the
<a class="reference internal" href="#ctypes.create_unicode_buffer" title="ctypes.create_unicode_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_unicode_buffer()</span></code></a> function.</p>
</section>
<section id="calling-functions-continued">
<span id="ctypes-calling-functions-continued"></span><h3 class="translated">Funciones de llamada, continuación<a class="headerlink" href="#calling-functions-continued" title="Link to this heading">¶</a></h3>
<p class="translated">Note que printf imprime al canal de salida estándar real, <em>no</em> a <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>, por lo que estos ejemplos sólo funcionarán en el prompt de la consola, no desde dentro de <em>IDLE</em> o <em>PythonWin</em>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello, </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello, %S</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mf">42.5</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ctypes.ArgumentError</span>: <span class="n">argument 2: TypeError: Don&#39;t know how to convert parameter 2</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Como se ha mencionado antes, todos los tipos de Python, excepto los enteros, cadenas y objetos bytes, tienen que ser envueltos en su correspondiente tipo <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>, para que puedan ser convertidos al tipo de datos C requerido:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;An int </span><span class="si">%d</span><span class="s2">, a double </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="mf">3.14</span><span class="p">))</span>
<span class="go">An int 1234, a double 3.140000</span>
<span class="go">31</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="calling-variadic-functions">
<span id="ctypes-calling-variadic-functions"></span><h3 class="untranslated">Calling variadic functions<a class="headerlink" href="#calling-variadic-functions" title="Link to this heading">¶</a></h3>
<p class="untranslated">On a lot of platforms calling variadic functions through ctypes is exactly the same
as calling functions with a fixed number of parameters. On some platforms, and in
particular ARM64 for Apple Platforms, the calling convention for variadic functions
is different than that for regular functions.</p>
<p class="untranslated">On those platforms it is required to specify the <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a>
attribute for the regular, non-variadic, function arguments:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">libc</span><span class="o">.</span><span class="n">printf</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">]</span>
</pre></div>
</div>
<p class="untranslated">Because specifying the attribute does not inhibit portability it is advised to always
specify <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> for all variadic functions.</p>
</section>
<section id="calling-functions-with-your-own-custom-data-types">
<span id="ctypes-calling-functions-with-own-custom-data-types"></span><h3 class="translated">Funciones de llamada con sus propios tipos de datos personalizados<a class="headerlink" href="#calling-functions-with-your-own-custom-data-types" title="Link to this heading">¶</a></h3>
<p class="untranslated">You can also customize <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> argument conversion to allow instances of
your own classes be used as function arguments. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> looks for an
<code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> attribute and uses this as the function argument. The
attribute must be an integer, string, bytes, a <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> instance, or an
object with an <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> attribute:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Bottles</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_as_parameter_</span> <span class="o">=</span> <span class="n">number</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bottles</span> <span class="o">=</span> <span class="n">Bottles</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bottles</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="untranslated">If you don’t want to store the instance’s data in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code>
instance variable, you could define a <a class="reference internal" href="functions.html#property" title="property"><code class="xref py py-class docutils literal notranslate"><span class="pre">property</span></code></a> which makes the
attribute available on request.</p>
</section>
<section id="specifying-the-required-argument-types-function-prototypes">
<span id="ctypes-specifying-required-argument-types"></span><h3 class="translated">Especificar los tipos de argumentos requeridos (prototipos de funciones)<a class="headerlink" href="#specifying-the-required-argument-types-function-prototypes" title="Link to this heading">¶</a></h3>
<p class="untranslated">It is possible to specify the required argument types of functions exported from
DLLs by setting the <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> attribute.</p>
<p class="untranslated"><a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> must be a sequence of C data types (the <code class="xref py py-func docutils literal notranslate"><span class="pre">printf()</span></code> function is
probably not a good example here, because it takes a variable number and
different types of parameters depending on the format string, on the other hand
this is quite handy to experiment with this feature):</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">c_double</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;String &#39;</span><span class="si">%s</span><span class="s2">&#39;, Int </span><span class="si">%d</span><span class="s2">, Double </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;Hi&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">)</span>
<span class="go">String &#39;Hi&#39;, Int 10, Double 2.200000</span>
<span class="go">37</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">La especificación de un formato protege contra los tipos de argumentos incompatibles (al igual que un prototipo para una función C), e intenta convertir los argumentos en tipos válidos:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ctypes.ArgumentError</span>: <span class="n">argument 2: TypeError: &#39;int&#39; object cannot be interpreted as ctypes.c_char_p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">X 2 3.000000</span>
<span class="go">13</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="untranslated">If you have defined your own classes which you pass to function calls, you have
to implement a <a class="reference internal" href="#ctypes._CData.from_param" title="ctypes._CData.from_param"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code></a> class method for them to be able to use them
in the <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> sequence. The <a class="reference internal" href="#ctypes._CData.from_param" title="ctypes._CData.from_param"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code></a> class method receives
the Python object passed to the function call, it should do a typecheck or
whatever is needed to make sure this object is acceptable, and then return the
object itself, its <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> attribute, or whatever you want to
pass as the C function argument in this case. Again, the result should be an
integer, string, bytes, a <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> instance, or an object with an
<code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> attribute.</p>
</section>
<section id="return-types">
<span id="ctypes-return-types"></span><h3 class="translated">Tipos de retorno<a class="headerlink" href="#return-types" title="Link to this heading">¶</a></h3>
<p class="untranslated">By default functions are assumed to return the C <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> type.  Other
return types can be specified by setting the <a class="reference internal" href="#ctypes._CFuncPtr.restype" title="ctypes._CFuncPtr.restype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code></a> attribute of the
function object.</p>
<p class="untranslated">The C prototype of <code class="xref c c-func docutils literal notranslate"><span class="pre">time()</span></code> is <code class="docutils literal notranslate"><span class="pre">time_t</span> <span class="pre">time(time_t</span> <span class="pre">*)</span></code>. Because <code class="xref c c-type docutils literal notranslate"><span class="pre">time_t</span></code>
might be of a different type than the default return type <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>, you should
specify the <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> attribute:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_time_t</span>
</pre></div>
</div>
<p class="untranslated">The argument types can be specified using <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">POINTER</span><span class="p">(</span><span class="n">c_time_t</span><span class="p">),)</span>
</pre></div>
</div>
<p class="untranslated">To call the function with a <code class="docutils literal notranslate"><span class="pre">NULL</span></code> pointer as first argument, use <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
<span class="go">1150640792</span>
</pre></div>
</div>
<p class="untranslated">Here is a more advanced example, it uses the <code class="xref py py-func docutils literal notranslate"><span class="pre">strchr()</span></code> function, which expects
a string pointer and a char, and returns a pointer to a string:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">strchr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))</span>
<span class="go">8059983</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>    <span class="c1"># c_char_p is a pointer to a string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))</span>
<span class="go">b&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="untranslated">If you want to avoid the <a class="reference internal" href="functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord(&quot;x&quot;)</span></code></a> calls above, you can set the
<a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> attribute, and the second argument will be converted from a
single character Python bytes object into a C char:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">b&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;def&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">ctypes.ArgumentError</span>: <span class="n">argument 2: TypeError: one character bytes, bytearray or integer expected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">b&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="untranslated">You can also use a callable Python object (a function or a class for example) as
the <a class="reference internal" href="#ctypes._CFuncPtr.restype" title="ctypes._CFuncPtr.restype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code></a> attribute, if the foreign function returns an integer.  The
callable will be called with the <em>integer</em> the C function returns, and the
result of this call will be used as the result of your function call. This is
useful to check for error return values and automatically raise an exception:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span> <span class="o">=</span> <span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">ValidHandle</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">value</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ValidHandle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="go">486539264</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="s2">&quot;something silly&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">3</span>, in <span class="n">ValidHandle</span>
<span class="gr">OSError</span>: <span class="n">[Errno 126] The specified module could not be found.</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">WinError</span></code> es una función que llamará a la api Windows <code class="docutils literal notranslate"><span class="pre">FormatMessage</span></code> para obtener la representación de la cadena de un código de error, y retornará una excepción. <code class="docutils literal notranslate"><span class="pre">WinError</span></code> toma un parámetro de código de error opcional, si no se usa ninguno, llama a <code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError`()</span></code> para recuperarlo.</p>
<p class="untranslated">Please note that a much more powerful error checking mechanism is available
through the <a class="reference internal" href="#ctypes._CFuncPtr.errcheck" title="ctypes._CFuncPtr.errcheck"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code></a> attribute;
see the reference manual for details.</p>
</section>
<section id="passing-pointers-or-passing-parameters-by-reference">
<span id="ctypes-passing-pointers"></span><h3 class="translated">Pasar los punteros (o: pasar los parámetros por referencia)<a class="headerlink" href="#passing-pointers-or-passing-parameters-by-reference" title="Link to this heading">¶</a></h3>
<p class="translated">A veces una función api C espera un <em>puntero</em> a un tipo de datos como parámetro, probablemente para escribir en el lugar correspondiente, o si los datos son demasiado grandes para ser pasados por valor. Esto también se conoce cómo <em>pasar parámetros por referencia</em>.</p>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> exporta la función <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> que se utiliza para pasar parámetros por referencia. El mismo efecto se puede conseguir con la función <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a>, aunque <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> hace mucho más trabajo ya que construye un objeto puntero real, por lo que es más rápido usar <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> si no se necesita el objeto puntero en el propio Python:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">c_float</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\000</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">0 0.0 b&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">sscanf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;1 3.14 Hello&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">byref</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">byref</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">s</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">1 3.1400001049 b&#39;Hello&#39;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="structures-and-unions">
<span id="ctypes-structures-unions"></span><h3 class="translated">Estructuras y uniones<a class="headerlink" href="#structures-and-unions" title="Link to this heading">¶</a></h3>
<p class="untranslated">Structures and unions must derive from the <a class="reference internal" href="#ctypes.Structure" title="ctypes.Structure"><code class="xref py py-class docutils literal notranslate"><span class="pre">Structure</span></code></a> and <a class="reference internal" href="#ctypes.Union" title="ctypes.Union"><code class="xref py py-class docutils literal notranslate"><span class="pre">Union</span></code></a>
base classes which are defined in the <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> module. Each subclass must
define a <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> attribute.  <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> must be a list of
<em>2-tuples</em>, containing a <em>field name</em> and a <em>field type</em>.</p>
<p class="translated">El tipo de campo debe ser un tipo <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> como <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>, o cualquier otro tipo <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> derivado: estructura, unión, matriz, puntero.</p>
<p class="translated">Aquí hay un ejemplo simple de una estructura POINT, que contiene dos enteros llamados <em>x</em> y <em>y</em>, y también muestra cómo inicializar una estructura en el constructor:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">10 20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">too many initializers</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Sin embargo, se pueden construir estructuras mucho más complicadas. Una estructura puede contener por sí misma otras estructuras usando una estructura como tipo de campo.</p>
<p class="translated">Aquí hay una estructura RECT que contiene dos POINTs llamados <em>upperleft</em> (superior izquierda)y <em>lowerright</em> (abajo a la derecha):</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;upperleft&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;lowerright&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 0</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Las estructuras anidadas también pueden ser inicializadas en el constructor de varias maneras:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p class="untranslated">Field <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>s can be retrieved from the <em>class</em>, they are useful
for debugging because they can provide useful information.
See <a class="reference internal" href="#ctypes.CField" title="ctypes.CField"><code class="xref py py-class docutils literal notranslate"><span class="pre">CField</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">POINT</span><span class="o">.</span><span class="n">x</span>
<span class="go">&lt;ctypes.CField &#39;x&#39; type=c_int, ofs=0, size=4&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POINT</span><span class="o">.</span><span class="n">y</span>
<span class="go">&lt;ctypes.CField &#39;y&#39; type=c_int, ofs=4, size=4&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition warning" id="ctypes-structureunion-alignment-byte-order">
<p class="admonition-title">Advertencia</p>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> no soporta el paso de uniones o estructuras con campos de bits a funciones por valor. Aunque esto puede funcionar en 32-bit x86, la biblioteca no garantiza que funcione en el caso general. Las uniones y estructuras con campos de bits siempre deben pasarse a las funciones por puntero.</p>
</div>
</section>
<section id="structure-union-layout-alignment-and-byte-order">
<h3 class="untranslated">Structure/union layout, alignment and byte order<a class="headerlink" href="#structure-union-layout-alignment-and-byte-order" title="Link to this heading">¶</a></h3>
<p class="untranslated">By default, Structure and Union fields are laid out in the same way the C
compiler does it.  It is possible to override this behavior entirely by specifying a
<a class="reference internal" href="#ctypes.Structure._layout_" title="ctypes.Structure._layout_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_layout_</span></code></a> class attribute in the subclass definition; see
the attribute documentation for details.</p>
<p class="untranslated">It is possible to specify the maximum alignment for the fields and/or for the
structure itself by setting the class attributes <a class="reference internal" href="#ctypes.Structure._pack_" title="ctypes.Structure._pack_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code></a>
and/or <a class="reference internal" href="#ctypes.Structure._align_" title="ctypes.Structure._align_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_align_</span></code></a>, respectively.
See the attribute documentation for details.</p>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> utiliza el orden de bytes nativos para las Estructuras y Uniones. Para construir estructuras con un orden de bytes no nativo, puedes usar una de las clases base <a class="reference internal" href="#ctypes.BigEndianStructure" title="ctypes.BigEndianStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">BigEndianStructure</span></code></a>, <a class="reference internal" href="#ctypes.LittleEndianStructure" title="ctypes.LittleEndianStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">LittleEndianStructure</span></code></a>, <a class="reference internal" href="#ctypes.BigEndianUnion" title="ctypes.BigEndianUnion"><code class="xref py py-class docutils literal notranslate"><span class="pre">BigEndianUnion</span></code></a>, y <a class="reference internal" href="#ctypes.LittleEndianUnion" title="ctypes.LittleEndianUnion"><code class="xref py py-class docutils literal notranslate"><span class="pre">LittleEndianUnion</span></code></a>. Estas clases no pueden contener campos puntero.</p>
</section>
<section id="bit-fields-in-structures-and-unions">
<span id="ctypes-bit-fields-in-structures-unions"></span><h3 class="translated">Campos de bits en estructuras y uniones<a class="headerlink" href="#bit-fields-in-structures-and-unions" title="Link to this heading">¶</a></h3>
<p class="untranslated">It is possible to create structures and unions containing bit fields. Bit fields
are only possible for integer fields, the bit width is specified as the third
item in the <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> tuples:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Int</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;first_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;second_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Int</span><span class="o">.</span><span class="n">first_16</span><span class="p">)</span>
<span class="go">&lt;ctypes.CField &#39;first_16&#39; type=c_int, ofs=0, bit_size=16, bit_offset=0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Int</span><span class="o">.</span><span class="n">second_16</span><span class="p">)</span>
<span class="go">&lt;ctypes.CField &#39;second_16&#39; type=c_int, ofs=0, bit_size=16, bit_offset=16&gt;</span>
</pre></div>
</div>
<p class="untranslated">It is important to note that bit field allocation and layout in memory are not
defined as a C standard; their implementation is compiler-specific.
By default, Python will attempt to match the behavior of a «native» compiler
for the current platform.
See the <a class="reference internal" href="#ctypes.Structure._layout_" title="ctypes.Structure._layout_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_layout_</span></code></a> attribute for details on the default
behavior and how to change it.</p>
</section>
<section id="arrays">
<span id="ctypes-arrays"></span><h3 class="translated">Arreglos<a class="headerlink" href="#arrays" title="Link to this heading">¶</a></h3>
<p class="translated">Los arreglos son secuencias, que contienen un número fijo de instancias del mismo tipo.</p>
<p class="translated">La forma recomendada de crear tipos de arreglos es multiplicando un tipo de dato por un entero positivo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">TenPointsArrayType</span> <span class="o">=</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">10</span>
</pre></div>
</div>
<p class="translated">Aquí hay un ejemplo de un tipo de datos algo artificial, una estructura que contiene 4 POINTs entre otras cosas:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">MyStruct</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">c_float</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;point_array&quot;</span><span class="p">,</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">()</span><span class="o">.</span><span class="n">point_array</span><span class="p">))</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Las instancias se crean de la manera habitual, llamando a la clase:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="n">TenPointsArrayType</span><span class="p">()</span>
<span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">El código anterior imprime una serie de líneas <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">0</span></code>, porque el contenido del arreglos se inicializa con ceros.</p>
<p class="translated">También se pueden especificar inicializadores del tipo correcto:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TenIntegers</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii</span> <span class="o">=</span> <span class="n">TenIntegers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
<span class="go">&lt;c_long_Array_10 object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ii</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 2 3 4 5 6 7 8 9 10</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="pointers">
<span id="ctypes-pointers"></span><h3 class="translated">Punteros<a class="headerlink" href="#pointers" title="Link to this heading">¶</a></h3>
<p class="translated">Las instancias de puntero se crean llamando a la función <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> en un tipo <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Las instancias del puntero tienen un atributo <a class="reference internal" href="#ctypes._Pointer.contents" title="ctypes._Pointer.contents"><code class="xref py py-attr docutils literal notranslate"><span class="pre">contents</span></code></a> que retorna el objeto al que apunta el puntero, el objeto <code class="docutils literal notranslate"><span class="pre">i</span></code> arriba:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(42)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Ten en cuenta que <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> no tiene OOR (original object return), construye un nuevo objeto equivalente cada vez que recuperas un atributo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">i</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Asignar otra instancia <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> al atributo de contenido del puntero causaría que el puntero apunte al lugar de memoria donde se almacena:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="o">=</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(99)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Las instancias de puntero también pueden ser indexadas con números enteros:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">99</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Asignando a un índice entero cambia el valor señalado:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(99)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">22</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(22)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">También es posible usar índices diferentes de 0, pero debes saber lo que estás haciendo, al igual que en C: Puedes acceder o cambiar arbitrariamente las ubicaciones de memoria. Generalmente sólo usas esta característica si recibes un puntero de una función C, y <em>sabes</em> que el puntero en realidad apunta a un arreglo en lugar de a un solo elemento.</p>
<p class="translated">Entre bastidores, la función <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> hace más que simplemente crear instancias de puntero, tiene que crear primero punteros <em>tipos</em>. Esto se hace con la función <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal notranslate"><span class="pre">POINTER()</span></code></a>, que acepta cualquier tipo de <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>, y retorna un nuevo tipo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span>
<span class="go">&lt;class &#39;ctypes.LP_c_long&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">expected c_long instead of int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Llamar al tipo de puntero sin un argumento crea un puntero <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. Los punteros <code class="docutils literal notranslate"><span class="pre">NULL</span></code> tienen un valor booleano falso..:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">null_ptr</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> comprueba si hay <code class="docutils literal notranslate"><span class="pre">NULL</span></code> cuando los punteros de referencia (pero los punteros no válidos de referencia no-<code class="docutils literal notranslate"><span class="pre">NULL</span></code> se romperán en Python):</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">    </span><span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">NULL pointer access</span>
<span class="gp">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">    </span><span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">NULL pointer access</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="thread-safety-without-the-gil">
<span id="ctypes-thread-safety"></span><h3 class="untranslated">Thread safety without the GIL<a class="headerlink" href="#thread-safety-without-the-gil" title="Link to this heading">¶</a></h3>
<p class="untranslated">From Python 3.13 onward, the <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> can be disabled on <a class="reference internal" href="../glossary.html#term-free-threading"><span class="xref std std-term">free threaded</span></a> builds.
In ctypes, reads and writes to a single object concurrently is safe, but not across multiple objects:</p>
<blockquote>
<div><div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">number</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pointer_a</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pointer_b</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p class="untranslated">In the above, it’s only safe for one object to read and write to the address at once if the GIL is disabled.
So, <code class="docutils literal notranslate"><span class="pre">pointer_a</span></code> can be shared and written to across multiple threads, but only if <code class="docutils literal notranslate"><span class="pre">pointer_b</span></code>
is not also attempting to do the same. If this is an issue, consider using a <a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a>
to synchronize access to memory:</p>
<blockquote>
<div><div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">threading</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Thread 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">pointer_a</span><span class="o">.</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Thread 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">pointer_b</span><span class="o">.</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">42</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="type-conversions">
<span id="ctypes-type-conversions"></span><h3 class="translated">Conversiones de tipos<a class="headerlink" href="#type-conversions" title="Link to this heading">¶</a></h3>
<p class="untranslated">Usually, ctypes does strict type checking.  This means, if you have
<code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> in the <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> list of a function or as the type of
a member field in a structure definition, only instances of exactly the same
type are accepted.  There are some exceptions to this rule, where ctypes accepts
other objects.  For example, you can pass compatible array instances instead of
pointer types.  So, for <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code>, ctypes accepts an array of c_int:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Bar</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_int</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="untranslated">In addition, if a function argument is explicitly declared to be a pointer type
(such as <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code>) in <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a>, an object of the pointed
type (<code class="docutils literal notranslate"><span class="pre">c_int</span></code> in this case) can be passed to the function.  ctypes will apply
the required <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> conversion in this case automatically.</p>
<p class="translated">Para poner un campo de tipo POINTER a <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, puedes asignar <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">A veces se tienen instancias de tipos incompatibles. En C, puedes cambiar un tipo por otro tipo. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> proporciona una función <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> qué puede ser usada de la misma manera. La estructura <code class="docutils literal notranslate"><span class="pre">Bar</span></code> definida arriba acepta punteros <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> o arreglos <code class="xref py py-class docutils literal notranslate"><span class="pre">c_int`</span></code> para su campo <code class="docutils literal notranslate"><span class="pre">values</span></code>, pero no instancias de otros tipos:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">incompatible types, c_byte_Array_4 instance instead of LP_c_long instance</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Para estos casos, la función <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> es muy útil.</p>
<p class="translated">La función <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> puede ser usada para lanzar una instancia ctypes en un puntero a un tipo de datos ctypes diferente. <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> toma dos parámetros, un objeto ctypes que es o puede ser convertido en un puntero de algún tipo, y un tipo de puntero ctypes. retorna una instancia del segundo argumento, que hace referencia al mismo bloque de memoria que el primer argumento:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cast</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at ...&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Así, <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> puede ser usado para asignar al campo <code class="docutils literal notranslate"><span class="pre">values</span></code> de <code class="docutils literal notranslate"><span class="pre">Bar</span></code> la estructura:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">((</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)(),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="incomplete-types">
<span id="ctypes-incomplete-types"></span><h3 class="translated">Tipos incompletos<a class="headerlink" href="#incomplete-types" title="Link to this heading">¶</a></h3>
<p class="translated"><em>Los Tipos Incompletos</em> son estructuras, uniones o matrices cuyos miembros aún no están especificados. En C, se especifican mediante declaraciones a futuro, que se definen más adelante:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">cell</span><span class="p">;</span> <span class="o">/*</span> <span class="n">forward</span> <span class="n">declaration</span> <span class="o">*/</span>

<span class="n">struct</span> <span class="n">cell</span> <span class="p">{</span>
    <span class="n">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="n">struct</span> <span class="n">cell</span> <span class="o">*</span><span class="nb">next</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="translated">La traducción directa al código de ctypes sería esta, pero no funciona:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">cell</span>
<span class="gr">NameError</span>: <span class="n">name &#39;cell&#39; is not defined</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="untranslated">because the new <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">cell</span></code> is not available in the class statement itself.
In <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>, we can define the <code class="docutils literal notranslate"><span class="pre">cell</span></code> class and set the
<a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> attribute later, after the class statement:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Vamos a intentarlo. Creamos dos instancias de <code class="docutils literal notranslate"><span class="pre">cell</span></code>, y dejamos que se apunten una a la otra, y finalmente seguimos la cadena de punteros unas cuantas veces:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;foo&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">c1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">foo bar foo bar foo bar foo bar</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="callback-functions">
<span id="ctypes-callback-functions"></span><h3 class="translated">Funciones de retrollamadas (<em>callback</em>)<a class="headerlink" href="#callback-functions" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> permite crear punteros de función invocables C a partir de los invocables de Python. A veces se llaman <em>funciones de retrollamada</em>.</p>
<p class="translated">Primero, debes crear una clase para la función de retrollamada. La clase conoce la convención de llamada, el tipo de retorno, y el número y tipos de argumentos que esta función recibirá.</p>
<p class="translated">La función de fábrica <code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE`()</span></code> crea tipos para las funciones de retrollamada usando la convención de llamada <code class="docutils literal notranslate"><span class="pre">cdecl</span></code>. En Windows, la función de fábrica <a class="reference internal" href="#ctypes.WINFUNCTYPE" title="ctypes.WINFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">WINFUNCTYPE()</span></code></a> crea tipos para funciones de retrollamadas usando la convención de llamadas <code class="docutils literal notranslate"><span class="pre">stdcall</span></code>.</p>
<p class="translated">Ambas funciones de fábrica se llaman con el tipo de resultado como primer argumento, y las funciones de llamada de retorno con los tipos de argumentos esperados como los argumentos restantes.</p>
<p class="untranslated">I will present an example here which uses the standard C library’s
<code class="xref c c-func docutils literal notranslate"><span class="pre">qsort()</span></code> function, that is used to sort items with the help of a callback
function.  <code class="xref c c-func docutils literal notranslate"><span class="pre">qsort()</span></code> will be used to sort an array of integers:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">IntArray5</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ia</span> <span class="o">=</span> <span class="n">IntArray5</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">qsort</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="untranslated"><code class="xref py py-func docutils literal notranslate"><span class="pre">qsort()</span></code> must be called with a pointer to the data to sort, the number of
items in the data array, the size of one item, and a pointer to the comparison
function, the callback. The callback will then be called with two pointers to
items, and it must return a negative integer if the first item is smaller than
the second, a zero if they are equal, and a positive integer otherwise.</p>
<p class="translated">Así que nuestra función de retrollamada recibe punteros a números enteros, y debe retornar un número entero. Primero creamos el <code class="docutils literal notranslate"><span class="pre">tipo</span></code> para la función de retrollamada:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CMPFUNC</span> <span class="o">=</span> <span class="n">CFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Para empezar, aquí hay una simple llamada que muestra los valores que se pasan:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mi">0</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmp_func</span> <span class="o">=</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">El resultado:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">cmp_func</span><span class="p">)</span>
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">py_cmp_func 1 7</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Ahora podemos comparar los dos artículos y obtener un resultado útil:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">))</span>
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 7</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Como podemos comprobar fácilmente, nuestro arreglo está ordenado ahora:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ia</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 5 7 33 99</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Las funciones de fabrica pueden ser usadas como decoradores de fabrica, así que podemos escribir:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@CFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">... </span><span class="k">def</span><span class="w"> </span><span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">py_cmp_func</span><span class="p">)</span>
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 7</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Asegúrate de mantener las referencias a los objetos <a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE()</span></code></a> mientras se usen desde el código C. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> no lo hace, y si no lo haces, pueden ser basura recolectada, colapsando tu programa cuando se hace una llamada.</p>
<p class="translated">Además, nótese que sí se llama a la función de retrollamada en un hilo creado fuera del control de Python (por ejemplo, por el código foráneo que llama a la retrollamada), ctypes crea un nuevo hilo Python tonto en cada invocación. Este comportamiento es correcto para la mayoría de los propósitos, pero significa que los valores almacenados con <a class="reference internal" href="threading.html#threading.local" title="threading.local"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.local</span></code></a> <em>no</em> sobreviven a través de diferentes llamadas de retorno, incluso cuando esas llamadas se hacen desde el mismo hilo C.</p>
</div>
</section>
<section id="accessing-values-exported-from-dlls">
<span id="ctypes-accessing-values-exported-from-dlls"></span><h3 class="translated">Acceder a los valores exportados de los dlls<a class="headerlink" href="#accessing-values-exported-from-dlls" title="Link to this heading">¶</a></h3>
<p class="untranslated">Some shared libraries not only export functions, they also export variables. An
example in the Python library itself is the <a class="reference internal" href="../c-api/apiabiversion.html#c.Py_Version" title="Py_Version"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_Version</span></code></a>, Python
runtime version number encoded in a single constant integer.</p>
<p class="untranslated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> can access values like this with the <a class="reference internal" href="#ctypes._CData.in_dll" title="ctypes._CData.in_dll"><code class="xref py py-meth docutils literal notranslate"><span class="pre">in_dll()</span></code></a> class methods of
the type.  <em>pythonapi</em> is a predefined symbol giving access to the Python C
api:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">version</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s2">&quot;Py_Version&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">version</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">0x30c00a0</span>
</pre></div>
</div>
<p class="translated">Un ejemplo extendido que también demuestra el uso de punteros accediendo al puntero <a class="reference internal" href="../c-api/import.html#c.PyImport_FrozenModules" title="PyImport_FrozenModules"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyImport_FrozenModules</span></code></a> exportado por Python.</p>
<p class="translated">Citando los documentos para ese valor:</p>
<blockquote>
<div><p class="translated">Este puntero se inicializa para apuntar a un arreglo de registros <a class="reference internal" href="../c-api/import.html#c._frozen" title="_frozen"><code class="xref c c-struct docutils literal notranslate"><span class="pre">_frozen</span></code></a>, terminados por uno cuyos miembros son todos <code class="docutils literal notranslate"><span class="pre">NULL</span></code> o cero. Cuando se importa un módulo congelado, se busca en esta tabla. El código de terceros podría jugar trucos con esto para proporcionar una colección de módulos congelados creada dinámicamente.</p>
</div></blockquote>
<p class="translated">Así que manipular este puntero podría incluso resultar útil. Para restringir el tamaño del ejemplo, sólo mostramos cómo esta tabla puede ser leída con <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">struct_frozen</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;code&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_ubyte</span><span class="p">)),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;size&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;get_code&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_ubyte</span><span class="p">)),</span>  <span class="c1"># Function pointer</span>
<span class="gp">... </span>               <span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Hemos definido el tipo de datos <a class="reference internal" href="../c-api/import.html#c._frozen" title="_frozen"><code class="xref c c-struct docutils literal notranslate"><span class="pre">_frozen</span></code></a>, por lo que podemos obtener el puntero a la tabla:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">FrozenTable</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">struct_frozen</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">FrozenTable</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s2">&quot;_PyImport_FrozenBootstrap&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Como <code class="docutils literal notranslate"><span class="pre">tabla</span></code> es un <code class="docutils literal notranslate"><span class="pre">puntero</span></code> al arreglo de registros <code class="docutils literal notranslate"><span class="pre">struct_frozen</span></code>, podemos iterar sobre ella, pero sólo tenemos que asegurarnos de que nuestro bucle termine, porque los punteros no tienen tamaño. Tarde o temprano, probablemente se caerá con una violación de acceso o lo que sea, así que es mejor salir del bucle cuando le demos a la entrada <code class="docutils literal notranslate"><span class="pre">NULL</span></code>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">break</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">),</span> <span class="n">item</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">_frozen_importlib 31764</span>
<span class="go">_frozen_importlib_external 41499</span>
<span class="go">zipimport 12345</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">El hecho de que la Python estándar tenga un módulo congelado y un paquete congelado (indicado por el miembro <code class="docutils literal notranslate"><span class="pre">tamaño</span></code> negativo) no se conoce bien, sólo se usa para hacer pruebas. Pruébalo con <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">__hello__</span></code> por ejemplo.</p>
</section>
<section id="surprises">
<span id="ctypes-surprises"></span><h3 class="translated">Sorpresas<a class="headerlink" href="#surprises" title="Link to this heading">¶</a></h3>
<p class="translated">Hay algunas aristas en <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> en las que podrías esperar algo distinto de lo que realmente sucede.</p>
<p class="translated">Considere el siguiente ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">1 2 3 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># now swap the two points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">3 4 3 4</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Hm. Ciertamente esperábamos que la última declaración imprimiera <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">1</span> <span class="pre">2</span></code>. ¿Qué ha pasado? Aquí están los pasos de la línea <code class="docutils literal notranslate"><span class="pre">rc.a,</span> <span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">rc.b,</span> <span class="pre">rc.a</span></code> arriba:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">temp0</span><span class="p">,</span> <span class="n">temp1</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">temp0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp1</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Note que <code class="docutils literal notranslate"><span class="pre">temp0</span></code> y <code class="docutils literal notranslate"><span class="pre">temp1</span></code> son objetos que todavía usan el buffer interno del objeto <code class="docutils literal notranslate"><span class="pre">rc</span></code> de arriba. Así que ejecutando <code class="docutils literal notranslate"><span class="pre">rc.a</span> <span class="pre">=</span> <span class="pre">temp0</span></code> copia el contenido del buffer de <code class="docutils literal notranslate"><span class="pre">temp0</span></code> en el buffer de <code class="docutils literal notranslate"><span class="pre">rc</span></code>. Esto, a su vez, cambia el contenido de <code class="docutils literal notranslate"><span class="pre">temp1</span></code>. Por lo tanto, la última asignación <code class="docutils literal notranslate"><span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">temp1</span></code>, no tiene el efecto esperado.</p>
<p class="translated">Tengan en cuenta que la recuperación de subobjetos de Estructuras, Uniones y Arreglos no <em>copia</em> el subobjeto, sino que recupera un objeto contenido que accede al búfer subyacente del objeto raíz.</p>
<p class="translated">Otro ejemplo que puede comportarse de manera diferente a lo que uno esperaría es este:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">c_char_p</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;abc def ghi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">b&#39;abc def ghi&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Los objetos instanciados desde <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a> sólo pueden tener su valor fijado en bytes o enteros.</p>
</div>
<p class="translated">¿Por qué está imprimiendo <code class="docutils literal notranslate"><span class="pre">False</span></code>? Las instancias ctypes son objetos que contienen un bloque de memoria más algunos <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>s que acceden al contenido de la memoria. Almacenar un objeto Python en el bloque de memoria no almacena el objeto en sí mismo, en su lugar se almacenan los <code class="docutils literal notranslate"><span class="pre">contenidos</span></code> del objeto. ¡Acceder a los contenidos de nuevo construye un nuevo objeto Python cada vez!</p>
</section>
<section id="variable-sized-data-types">
<span id="ctypes-variable-sized-data-types"></span><h3 class="translated">Tipos de datos de tamaño variable<a class="headerlink" href="#variable-sized-data-types" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> proporciona algo de soporte para matrices y estructuras de tamaño variable.</p>
<p class="translated">La función <a class="reference internal" href="#ctypes.resize" title="ctypes.resize"><code class="xref py py-func docutils literal notranslate"><span class="pre">resize()</span></code></a> puede ser usada para redimensionar el buffer de memoria de un objeto ctypes existente. La función toma el objeto como primer argumento, y el tamaño solicitado en bytes como segundo argumento. El bloque de memoria no puede hacerse más pequeño que el bloque de memoria natural especificado por el tipo de objeto, se lanza un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si se intenta:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_short</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">    </span><span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">minimum size is 8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Esto está bien, pero ¿cómo se puede acceder a los elementos adicionales contenidos en este arreglo?  Dado que el tipo todavía sabe sólo 4 elementos, obtenemos errores al acceder a otros elementos:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[:]</span>
<span class="go">[0, 0, 0, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">    </span><span class="o">...</span>
<span class="gr">IndexError</span>: <span class="n">invalid index</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Otra forma de utilizar tipos de datos de tamaño variable con <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> es utilizar la naturaleza dinámica de Python, y (re)definir el tipo de datos después de que se conozca el tamaño requerido, caso por caso.</p>
</section>
</section>
<section id="ctypes-reference">
<span id="ctypes-ctypes-reference"></span><h2 class="translated">referencia ctypes<a class="headerlink" href="#ctypes-reference" title="Link to this heading">¶</a></h2>
<section id="finding-shared-libraries">
<span id="ctypes-finding-shared-libraries"></span><h3 class="translated">Encontrar bibliotecas compartidas<a class="headerlink" href="#finding-shared-libraries" title="Link to this heading">¶</a></h3>
<p class="translated">Cuando se programa en un lenguaje compilado, se accede a las bibliotecas compartidas cuando se compila/enlaza un programa, y cuándo se ejecuta el programa.</p>
<p class="untranslated">The purpose of the <a class="reference internal" href="#ctypes.util.find_library" title="ctypes.util.find_library"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code></a> function is to locate a library in a way
similar to what the compiler or runtime loader does (on platforms with several
versions of a shared library the most recent should be loaded), while the ctypes
library loaders act like when a program is run, and call the runtime loader
directly.</p>
<p class="untranslated">The <code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes.util</span></code> module provides a function which can help to determine
the library to load.</p>
<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.util.</span></span><span class="sig-name descname"><span class="pre">find_library</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p class="translated">Intenta encontrar una biblioteca y retornar un nombre. <em>name</em> es el nombre de la biblioteca sin ningún prefijo como <em>lib</em>, sufijo como <code class="docutils literal notranslate"><span class="pre">.so</span></code>, <code class="docutils literal notranslate"><span class="pre">.dylib</span></code> o número de versión (esta es la forma usada para la opción del enlazador posix <code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code>). Si no se puede encontrar ninguna biblioteca, retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<p class="translated">La funcionalidad exacta depende del sistema.</p>
<p class="untranslated">On Linux, <a class="reference internal" href="#ctypes.util.find_library" title="ctypes.util.find_library"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code></a> tries to run external programs
(<code class="docutils literal notranslate"><span class="pre">/sbin/ldconfig</span></code>, <code class="docutils literal notranslate"><span class="pre">gcc</span></code>, <code class="docutils literal notranslate"><span class="pre">objdump</span></code> and <code class="docutils literal notranslate"><span class="pre">ld</span></code>) to find the library file.
It returns the filename of the library file.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>En Linux, el valor de la variable de entorno <code class="docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code> se utiliza cuando se buscan bibliotecas, si una biblioteca no puede ser encontrada por ningún otro medio.</p>
</div>
<p class="translated">Aquí hay algunos ejemplos:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;libm.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;libc.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;libbz2.so.1.0&#39;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="untranslated">On macOS and Android, <a class="reference internal" href="#ctypes.util.find_library" title="ctypes.util.find_library"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code></a> uses the system’s
standard naming schemes and paths to locate the library, and returns a full
pathname if successful:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libc.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libm.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libbz2.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;AGL&quot;</span><span class="p">)</span>
<span class="go">&#39;/System/Library/Frameworks/AGL.framework/AGL&#39;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="untranslated">On Windows, <a class="reference internal" href="#ctypes.util.find_library" title="ctypes.util.find_library"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code></a> searches along the system search path, and
returns the full pathname, but since there is no predefined naming scheme a call
like <code class="docutils literal notranslate"><span class="pre">find_library(&quot;c&quot;)</span></code> will fail and return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p class="untranslated">If wrapping a shared library with <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>, it <em>may</em> be better to determine
the shared library name at development time, and hardcode that into the wrapper
module instead of using <a class="reference internal" href="#ctypes.util.find_library" title="ctypes.util.find_library"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code></a> to locate the library at runtime.</p>
</section>
<section id="listing-loaded-shared-libraries">
<span id="ctypes-listing-loaded-shared-libraries"></span><h3 class="untranslated">Listing loaded shared libraries<a class="headerlink" href="#listing-loaded-shared-libraries" title="Link to this heading">¶</a></h3>
<p class="untranslated">When writing code that relies on code loaded from shared libraries, it can be
useful to know which shared libraries have already been loaded into the current
process.</p>
<p class="untranslated">The <code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes.util</span></code> module provides the <a class="reference internal" href="#ctypes.util.dllist" title="ctypes.util.dllist"><code class="xref py py-func docutils literal notranslate"><span class="pre">dllist()</span></code></a> function,
which calls the different APIs provided by the various platforms to help determine
which shared libraries have already been loaded into the current process.</p>
<p class="untranslated">The exact output of this function will be system dependent. On most platforms,
the first entry of this list represents the current process itself, which may
be an empty string.
For example, on glibc-based Linux, the return may look like:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">dllist</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dllist</span><span class="p">()</span>
<span class="go">[&#39;&#39;, &#39;linux-vdso.so.1&#39;, &#39;/lib/x86_64-linux-gnu/libm.so.6&#39;, &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;, ... ]</span>
</pre></div>
</div>
</section>
<section id="loading-shared-libraries">
<span id="ctypes-loading-shared-libraries"></span><h3 class="translated">Cargando bibliotecas compartidas<a class="headerlink" href="#loading-shared-libraries" title="Link to this heading">¶</a></h3>
<p class="translated">Hay varias maneras de cargar las bibliotecas compartidas en el proceso Python. Una forma es instanciar una de las siguientes clases:</p>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.CDLL">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">CDLL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">DEFAULT_MODE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_errno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_last_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winmode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CDLL" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Las instancias de esta clase representan bibliotecas compartidas cargadas. Las funciones en estas bibliotecas utilizan la convención de llamada estándar de C y se supone que retornan <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>.</p>
<p class="translated">En Windows, la creación de una instancia <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> puede fallar incluso si existe el nombre de la DLL. Cuando no se encuentra una DLL dependiente de la DLL cargada, se lanza un error <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> con el mensaje <em>«[WinError 126] No se pudo encontrar el módulo especificado».</em> Este mensaje de error no contiene el nombre de DLL que falta porque la API de Windows no retorna esta información, lo que dificulta el diagnóstico de este error. Para resolver este error y determinar qué DLL no se encuentra, debe buscar la lista de DLL dependientes y determinar cuál no se encuentra utilizando las herramientas de depuración y seguimiento de Windows.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>The <em>name</em> parameter can now be a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="translated"><a class="reference external" href="https://docs.microsoft.com/cpp/build/reference/dependents">Herramienta Microsoft DUMPBIN</a> – Una herramienta para encontrar dependientes de DLL.</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.OleDLL">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">OleDLL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">DEFAULT_MODE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_errno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_last_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winmode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.OleDLL" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Instances of this class represent loaded shared libraries,
functions in these libraries use the <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> calling convention, and are
assumed to return the windows specific <a class="reference internal" href="#ctypes.HRESULT" title="ctypes.HRESULT"><code class="xref py py-class docutils literal notranslate"><span class="pre">HRESULT</span></code></a> code.  <a class="reference internal" href="#ctypes.HRESULT" title="ctypes.HRESULT"><code class="xref py py-class docutils literal notranslate"><span class="pre">HRESULT</span></code></a>
values contain information specifying whether the function call failed or
succeeded, together with additional error code.  If the return value signals a
failure, an <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> is automatically raised.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span><a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a> used to be raised,
which is now an alias of <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>The <em>name</em> parameter can now be a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.WinDLL">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">WinDLL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">DEFAULT_MODE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_errno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_last_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winmode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WinDLL" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Instances of this class represent loaded shared libraries,
functions in these libraries use the <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> calling convention, and are
assumed to return <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> by default.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>The <em>name</em> parameter can now be a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<p class="translated">El termino Python <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a> es lanzado antes de llamar a cualquier función exportada por estas librerías, y se requiere después.</p>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.PyDLL">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">PyDLL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">DEFAULT_MODE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.PyDLL" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Las instancias de esta clase se comportan como instancias <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> , excepto que el GIL de Python es <em>no</em> liberado durante la llamada a la función, y después de la ejecución de la función se comprueba si esta activo el flag de error de Python. Si el flag de error esta activado, se lanza una excepción Python.</p>
<p class="translated">Por lo tanto, esto sólo es útil para llamar directamente a las funciones api C de Python.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>The <em>name</em> parameter can now be a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<p class="untranslated">All these classes can be instantiated by calling them with at least one
argument, the pathname of the shared library.  If you have an existing handle to
an already loaded shared library, it can be passed as the <code class="docutils literal notranslate"><span class="pre">handle</span></code> named
parameter, otherwise the underlying platform’s <code class="xref c c-func docutils literal notranslate"><span class="pre">dlopen()</span></code> or
<code class="xref c c-func docutils literal notranslate"><span class="pre">LoadLibrary()</span></code> function is used to load the library into
the process, and to get a handle to it.</p>
<p class="translated">El parámetro <em>mode</em> puede utilizarse para especificar cómo se carga la biblioteca. Para más detalles, consulte la página <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/dlopen(3)">dlopen(3)</a></em> del manual. En Windows, <em>mode</em> es ignorado. En los sistemas posix, RTLD_NOW siempre se agrega, y no es configurable.</p>
<p class="untranslated">The <em>use_errno</em> parameter, when set to true, enables a ctypes mechanism that
allows accessing the system <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> error number in a safe way.
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> maintains a thread-local copy of the system’s <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a>
variable; if you call foreign functions created with <code class="docutils literal notranslate"><span class="pre">use_errno=True</span></code> then the
<a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> value before the function call is swapped with the ctypes private
copy, the same happens immediately after the function call.</p>
<p class="translated">La función <a class="reference internal" href="#ctypes.get_errno" title="ctypes.get_errno"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.get_errno()</span></code></a> retorna el valor de la copia privada de ctypes, y la función <a class="reference internal" href="#ctypes.set_errno" title="ctypes.set_errno"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.set_errno()</span></code></a> cambia la copia privada de ctypes a un nuevo valor y retorna el valor anterior.</p>
<p class="untranslated">The <em>use_last_error</em> parameter, when set to true, enables the same mechanism for
the Windows error code which is managed by the <a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError()</span></code></a> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">SetLastError()</span></code> Windows API functions; <a class="reference internal" href="#ctypes.get_last_error" title="ctypes.get_last_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.get_last_error()</span></code></a> and
<a class="reference internal" href="#ctypes.set_last_error" title="ctypes.set_last_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.set_last_error()</span></code></a> are used to request and change the ctypes private
copy of the windows error code.</p>
<p class="untranslated">The <em>winmode</em> parameter is used on Windows to specify how the library is loaded
(since <em>mode</em> is ignored). It takes any value that is valid for the Win32 API
<code class="docutils literal notranslate"><span class="pre">LoadLibraryEx</span></code> flags parameter. When omitted, the default is to use the
flags that result in the most secure DLL load, which avoids issues such as DLL
hijacking. Passing the full path to the DLL is the safest way to ensure the
correct library and dependencies are loaded.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Añadido el parámetro <em>winmode</em>.</p>
</div>
<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">RTLD_GLOBAL</span></span></dt>
<dd><p class="translated">Flag para usar como parámetro <em>modo</em>. En las plataformas en las que esta bandera no está disponible, se define como el cero entero.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">RTLD_LOCAL</span></span></dt>
<dd><p class="translated">Flag para usar como parámetro <em>modo</em>. En las plataformas en las que esto no está disponible, es lo mismo que <em>RTLD_GLOBAL</em>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">DEFAULT_MODE</span></span></dt>
<dd><p class="translated">El modo por defecto que se utiliza para cargar las bibliotecas compartidas. En OSX 10.3, esto es <em>RTLD_GLOBAL</em>, de lo contrario es lo mismo que <em>RTLD_LOCAL</em>.</p>
</dd></dl>

<p class="translated">Las instancias de estas clases no tienen métodos públicos. Se puede acceder a las funciones exportadas por la biblioteca compartida como atributos o por índice. Tenga en cuenta que al acceder a la función a través de un atributo se almacena en caché el resultado y, por lo tanto, al acceder a él repetidamente se retorna el mismo objeto cada vez. Por otro lado, acceder a ella a través de un índice retorna un nuevo objeto cada vez:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="n">CDLL</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">CDLL</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>  <span class="c1"># On Linux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">libc</span><span class="o">.</span><span class="n">time</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">libc</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
<span class="go">False</span>
</pre></div>
</div>
<p class="translated">Los siguientes atributos públicos están disponibles, su nombre comienza con un guión bajo para no chocar con los nombres de las funciones exportadas:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.PyDLL._handle">
<span class="sig-prename descclassname"><span class="pre">PyDLL.</span></span><span class="sig-name descname"><span class="pre">_handle</span></span><a class="headerlink" href="#ctypes.PyDLL._handle" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El manejador del sistema usado para acceder a la biblioteca.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.PyDLL._name">
<span class="sig-prename descclassname"><span class="pre">PyDLL.</span></span><span class="sig-name descname"><span class="pre">_name</span></span><a class="headerlink" href="#ctypes.PyDLL._name" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El nombre de la biblioteca pasado en el constructor.</p>
</dd></dl>

<p class="untranslated">Shared libraries can also be loaded by using one of the prefabricated objects,
which are instances of the <a class="reference internal" href="#ctypes.LibraryLoader" title="ctypes.LibraryLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">LibraryLoader</span></code></a> class, either by calling the
<a class="reference internal" href="#ctypes.LibraryLoader.LoadLibrary" title="ctypes.LibraryLoader.LoadLibrary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadLibrary()</span></code></a> method, or by retrieving the library as
attribute of the loader instance.</p>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.LibraryLoader">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">LibraryLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dlltype</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LibraryLoader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Clase que carga bibliotecas compartidas. <em>dlltype</em> debe ser uno de los tipos <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a>, <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a>, <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a>, o <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a>.</p>
<p class="untranslated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code> has special behavior: It allows loading a shared library by
accessing it as attribute of a library loader instance.  The result is cached,
so repeated attribute accesses return the same library each time.</p>
<dl class="py method">
<dt class="sig sig-object py" id="ctypes.LibraryLoader.LoadLibrary">
<span class="sig-name descname"><span class="pre">LoadLibrary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LibraryLoader.LoadLibrary" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Carga una biblioteca compartida en el proceso y la retorna. Este método siempre retorna una nueva instancia de la biblioteca.</p>
</dd></dl>

</dd></dl>

<p class="translated">Estos cargadores prefabricados de bibliotecas están disponibles:</p>
<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">cdll</span></span></dt>
<dd><p class="translated">Crea instancias de <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">windll</span></span></dt>
<dd><p class="untranslated">Creates <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a> instances.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">oledll</span></span></dt>
<dd><p class="untranslated">Creates <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a> instances.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">pydll</span></span></dt>
<dd><p class="translated">Crea instancias de <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a>.</p>
</dd></dl>

<p class="translated">Para acceder directamente a la API C de Python, se dispone de un objeto de biblioteca compartida de Python listo-para-usar:</p>
<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">pythonapi</span></span></dt>
<dd><p class="untranslated">An instance of <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a> that exposes Python C API functions as
attributes.  Note that all these functions are assumed to return C
<span class="c-expr sig sig-inline c"><span class="kt">int</span></span>, which is of course not always the truth, so you have to assign
the correct <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> attribute to use these functions.</p>
</dd></dl>

<p class="audit-hook untranslated"><p class="untranslated">Loading a library through any of these objects raises an
<a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.dlopen</span></code> with string argument
<code class="docutils literal notranslate"><span class="pre">name</span></code>, the name used to load the library.</p>
</p>
<p class="audit-hook untranslated"><p class="untranslated">Accessing a function on a loaded library raises an auditing event
<code class="docutils literal notranslate"><span class="pre">ctypes.dlsym</span></code> with arguments <code class="docutils literal notranslate"><span class="pre">library</span></code> (the library object) and <code class="docutils literal notranslate"><span class="pre">name</span></code>
(the symbol’s name as a string or integer).</p>
</p>
<p class="audit-hook translated">En los casos en los que sólo está disponible el manejador de la biblioteca en lugar del objeto, al acceder a una función se produce un evento de auditoría <code class="docutils literal notranslate"><span class="pre">ctypes.dlsym/handle</span></code> con los argumentos <code class="docutils literal notranslate"><span class="pre">handle</span></code> (el manejador de la biblioteca en bruto) y <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
</section>
<section id="foreign-functions">
<span id="ctypes-foreign-functions"></span><h3 class="translated">Funciones foráneas<a class="headerlink" href="#foreign-functions" title="Link to this heading">¶</a></h3>
<p class="untranslated">As explained in the previous section, foreign functions can be accessed as
attributes of loaded shared libraries.  The function objects created in this way
by default accept any number of arguments, accept any ctypes data instances as
arguments, and return the default result type specified by the library loader.</p>
<p class="untranslated">They are instances of a private local class <code class="xref py py-class docutils literal notranslate"><span class="pre">_FuncPtr</span></code> (not exposed
in <code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code>) which inherits from the private <a class="reference internal" href="#ctypes._CFuncPtr" title="ctypes._CFuncPtr"><code class="xref py py-class docutils literal notranslate"><span class="pre">_CFuncPtr</span></code></a> class:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ctypes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CDLL</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">_FuncPtr</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">_CFuncPtr</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span><span class="o">.</span><span class="n">_FuncPtr</span> <span class="ow">is</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">_CFuncPtr</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes._CFuncPtr">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">_CFuncPtr</span></span><a class="headerlink" href="#ctypes._CFuncPtr" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Clase base para funciones foráneas C invocables.</p>
<p class="translated">Las instancias de funciones foráneas también son tipos de datos compatibles con C; representan punteros de funciones C.</p>
<p class="translated">Este comportamiento puede personalizarse asignando a los atributos especiales del objeto de la función foránea.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CFuncPtr.restype">
<span class="sig-name descname"><span class="pre">restype</span></span><a class="headerlink" href="#ctypes._CFuncPtr.restype" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Asigne un tipo ctypes para especificar el tipo de resultado de la función externa. Use <code class="docutils literal notranslate"><span class="pre">None</span></code> para <span class="c-expr sig sig-inline c"><span class="kt">void</span></span>, una función que no retorna nada.</p>
<p class="untranslated">It is possible to assign a callable Python object that is not a ctypes
type, in this case the function is assumed to return a C <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>, and
the callable will be called with this integer, allowing further
processing or error checking.  Using this is deprecated, for more flexible
post processing or error checking use a ctypes data type as
<code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> and assign a callable to the <a class="reference internal" href="#ctypes._CFuncPtr.errcheck" title="ctypes._CFuncPtr.errcheck"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code></a> attribute.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CFuncPtr.argtypes">
<span class="sig-name descname"><span class="pre">argtypes</span></span><a class="headerlink" href="#ctypes._CFuncPtr.argtypes" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Asigne una tupla de tipos ctypes para especificar los tipos de argumentos que acepta la función. Las funciones que utilizan la convención de llamada <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> sólo pueden ser llamadas con el mismo número de argumentos que la longitud de esta tupla; las funciones que utilizan la convención de llamada C aceptan también argumentos adicionales no especificados.</p>
<p class="untranslated">When a foreign function is called, each actual argument is passed to the
<a class="reference internal" href="#ctypes._CData.from_param" title="ctypes._CData.from_param"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code></a> class method of the items in the <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a>
tuple, this method allows adapting the actual argument to an object that
the foreign function accepts.  For example, a <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a> item in
the <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> tuple will convert a string passed as argument into
a bytes object using ctypes conversion rules.</p>
<p class="untranslated">New: It is now possible to put items in argtypes which are not ctypes
types, but each item must have a <a class="reference internal" href="#ctypes._CData.from_param" title="ctypes._CData.from_param"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code></a> method which returns a
value usable as argument (integer, string, ctypes instance).  This allows
defining adapters that can adapt custom objects as function parameters.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CFuncPtr.errcheck">
<span class="sig-name descname"><span class="pre">errcheck</span></span><a class="headerlink" href="#ctypes._CFuncPtr.errcheck" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Asigne una función Python u otra llamada a este atributo. El invocable será llamado con tres o más argumentos:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">callable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arguments</span></span></em><span class="sig-paren">)</span></dt>
<dd><p class="untranslated"><em>result</em> is what the foreign function returns, as specified by the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> attribute.</p>
<p class="translated"><em>func</em> es el propio objeto de la función foránea, lo que permite reutilizar el mismo objeto invocable para comprobar o postprocesar los resultados de varias funciones.</p>
<p class="translated"><em>arguments</em> es una tupla que contiene los parámetros originalmente pasados a la llamada de la función, esto permite especializar el comportamiento en los argumentos utilizados.</p>
</dd></dl>

<p class="translated">El objeto que retorna esta función será retornado por la llamada de la función foránea, pero también puede comprobar el valor del resultado y hacer una excepción si la llamada de la función foránea ha fallado.</p>
</dd></dl>

</dd></dl>

<p class="audit-hook translated">En Windows, cuando una llamada a una función foránea plantea una excepción de sistema (por ejemplo, debido a una violación de acceso), será capturada y sustituida por una excepción Python adecuada. Además, un evento de auditoría <code class="docutils literal notranslate"><span class="pre">ctypes.set_exception</span></code> con el argumento <code class="docutils literal notranslate"><span class="pre">code</span></code> será levantado, permitiendo que un gancho de auditoría reemplace la excepción con la suya propia.</p>
<p class="audit-hook untranslated"><p class="untranslated">Some ways to invoke foreign function calls as well as some of the
functions in this module may raise an auditing event
<code class="docutils literal notranslate"><span class="pre">ctypes.call_function</span></code> with arguments <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">pointer</span></code> and <code class="docutils literal notranslate"><span class="pre">arguments</span></code>.</p>
</p>
</section>
<section id="function-prototypes">
<span id="ctypes-function-prototypes"></span><h3 class="translated">Prototipos de funciones<a class="headerlink" href="#function-prototypes" title="Link to this heading">¶</a></h3>
<p class="translated">Las funciones foráneas también pueden crearse mediante la instanciación de prototipos de funciones. Los prototipos de funciones son similares a los prototipos de funciones en C; describen una función (tipo de retorno, tipos de argumentos, convención de llamada) sin definir una implementación. Las funciones de fábrica deben ser llamadas con el tipo de resultado deseado y los tipos de argumento de la función, y pueden ser usadas como fábricas de decoradores, y como tales, ser aplicadas a las funciones a través de la sintaxis <code class="docutils literal notranslate"><span class="pre">&#64;wrapper</span></code>. Ver <a class="reference internal" href="#ctypes-callback-functions"><span class="std std-ref">Funciones de retrollamadas (callback)</span></a> para ejemplos.</p>
<dl class="py function">
<dt class="sig sig-object py" id="ctypes.CFUNCTYPE">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">CFUNCTYPE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">restype</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">argtypes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_errno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_last_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CFUNCTYPE" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El prototipo de función retornado crea funciones que usan la convención de llamada C estándar. La función liberará el GIL durante la llamada. Si <em>use_errno</em> se configura a true, la copia privada de ctypes de la variable del sistema <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> se intercambia con el valor real <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> antes y después de la llamada; <em>use_last_error</em> hace lo mismo con el código de error de Windows.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.WINFUNCTYPE">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">WINFUNCTYPE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">restype</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">argtypes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_errno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_last_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WINFUNCTYPE" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The returned function prototype creates functions that use the
<code class="docutils literal notranslate"><span class="pre">stdcall</span></code> calling convention.  The function will
release the GIL during the call.  <em>use_errno</em> and <em>use_last_error</em> have the
same meaning as above.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.PYFUNCTYPE">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">PYFUNCTYPE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">restype</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">argtypes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.PYFUNCTYPE" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El prototipo de función retornado crea funciones que usan la convención de llamadas de Python. La función <em>no</em> liberará el GIL durante la llamada.</p>
</dd></dl>

<p class="translated">Los prototipos de funciones creados por estas funciones de fábrica pueden ser instanciados de diferentes maneras, dependiendo del tipo y el número de los parámetros en la llamada:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">prototype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span></dt>
<dd><p class="translated">Retorna una función foránea en la dirección especificada que debe ser un número entero.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">prototype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">callable</span></span></em><span class="sig-paren">)</span></dt>
<dd><p class="translated">Crear una función de llamada C (una función de retrollamada) a partir de un <em>callable</em> Python.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">prototype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_spec</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">paramflags</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p class="translated">Retorna una función foránea exportada por una biblioteca compartida. <em>func_spec</em> debe ser un 2-tupla <code class="docutils literal notranslate"><span class="pre">(name_or_ordinal,</span> <span class="pre">library)</span></code>. El primer elemento es el nombre de la función exportada como cadena, o el ordinal de la función exportada como entero pequeño. El segundo elemento es la instancia de la biblioteca compartida.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">prototype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vtbl_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">paramflags</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">iid</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p class="translated">Retorna una función foránea que llamará a un método COM. <em>vtbl_index</em> es el índice de la tabla de funciones virtuales, un pequeño entero no negativo. <em>name</em> es el nombre del método COM. <em>iid</em> es un puntero opcional para el identificador de la interfaz que se utiliza en el informe de errores extendido.</p>
<p class="untranslated">If <em>iid</em> is not specified, an <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> is raised if the COM method
call fails. If <em>iid</em> is specified, a <a class="reference internal" href="#ctypes.COMError" title="ctypes.COMError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">COMError</span></code></a> is raised
instead.</p>
<p class="untranslated">COM methods use a special calling convention: They require a pointer to
the COM interface as first argument, in addition to those parameters that
are specified in the <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> tuple.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<p class="translated">El parámetro opcional <em>paramflags</em> crea envoltorios de funciones foráneas con mucha más funcionalidad que las características descritas anteriormente.</p>
<p class="untranslated"><em>paramflags</em> must be a tuple of the same length as <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a>.</p>
<p class="translated">Cada elemento de esta tupla contiene más información sobre un parámetro, debe ser una tupla que contenga uno, dos o tres elementos.</p>
<p class="translated">El primer elemento es un entero que contiene una combinación de flags de dirección para el parámetro:</p>
<blockquote>
<div><dl class="simple">
<dt class="translated">1</dt><dd><p class="translated">Especifica un parámetro de entrada a la función.</p>
</dd>
<dt class="translated">2</dt><dd><p class="translated">Parámetro de salida. La función foránea rellena un valor.</p>
</dd>
<dt class="translated">4</dt><dd><p class="translated">Parámetro de entrada que por defecto es el cero entero.</p>
</dd>
</dl>
</div></blockquote>
<p class="translated">El segundo elemento opcional es el nombre del parámetro como cadena. Si se especifica esto, se puede llamar a la función foránea con parámetros con nombre.</p>
<p class="translated">El tercer elemento opcional es el valor por defecto de este parámetro.</p>
<p class="untranslated">The following example demonstrates how to wrap the Windows <code class="docutils literal notranslate"><span class="pre">MessageBoxW</span></code> function so
that it supports default parameters and named arguments. The C declaration from
the windows header file is this:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WINUSERAPI</span> <span class="nb">int</span> <span class="n">WINAPI</span>
<span class="n">MessageBoxW</span><span class="p">(</span>
    <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">lpText</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">lpCaption</span><span class="p">,</span>
    <span class="n">UINT</span> <span class="n">uType</span><span class="p">);</span>
</pre></div>
</div>
<p class="translated">Aquí está el envoltorio con <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes.wintypes</span><span class="w"> </span><span class="kn">import</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">UINT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">UINT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;hwnd&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;Hi&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;caption&quot;</span><span class="p">,</span> <span class="s2">&quot;Hello from ctypes&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;flags&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s2">&quot;MessageBoxW&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">La función foránea de <code class="docutils literal notranslate"><span class="pre">MessageBox</span></code> puede ser llamada de esta manera:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s2">&quot;Spam, spam, spam&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s2">&quot;foo bar&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Un segundo ejemplo demuestra los parámetros de salida. La función <code class="docutils literal notranslate"><span class="pre">GetWindowRect</span></code> de win32 retorna las dimensiones de una ventana especificada copiándolas en la estructura <code class="docutils literal notranslate"><span class="pre">RECT</span></code> que la persona que llama tiene que suministrar. Aquí está la declaración C:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WINUSERAPI</span> <span class="n">BOOL</span> <span class="n">WINAPI</span>
<span class="n">GetWindowRect</span><span class="p">(</span>
     <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
     <span class="n">LPRECT</span> <span class="n">lpRect</span><span class="p">);</span>
</pre></div>
</div>
<p class="translated">Aquí está el envoltorio con <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="n">POINTER</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span><span class="p">,</span> <span class="n">WinError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes.wintypes</span><span class="w"> </span><span class="kn">import</span> <span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">RECT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">RECT</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;hwnd&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;lprect&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s2">&quot;GetWindowRect&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Las funciones con parámetros de salida retornarán automáticamente el valor del parámetro de salida si hay uno solo, o una tupla que contiene los valores del parámetro de salida cuando hay más de uno, por lo que la función GetWindowRect retorna ahora una instancia RECT, cuando se llama.</p>
<p class="untranslated">Output parameters can be combined with the <a class="reference internal" href="#ctypes._CFuncPtr.errcheck" title="ctypes._CFuncPtr.errcheck"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code></a> protocol to do
further output processing and error checking.  The win32 <code class="docutils literal notranslate"><span class="pre">GetWindowRect</span></code> api
function returns a <code class="docutils literal notranslate"><span class="pre">BOOL</span></code> to signal success or failure, so this function could
do the error checking, and raises an exception when the api call failed:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">args</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="untranslated">If the <a class="reference internal" href="#ctypes._CFuncPtr.errcheck" title="ctypes._CFuncPtr.errcheck"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code></a> function returns the argument tuple it receives
unchanged, <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> continues the normal processing it does on the output
parameters.  If you want to return a tuple of window coordinates instead of a
<code class="docutils literal notranslate"><span class="pre">RECT</span></code> instance, you can retrieve the fields in the function and return them
instead, the normal processing will no longer take place:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">rc</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">right</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="utility-functions">
<span id="ctypes-utility-functions"></span><h3 class="translated">Funciones de utilidad<a class="headerlink" href="#utility-functions" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="ctypes.addressof">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">addressof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.addressof" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna la dirección del buffer de memoria como un entero. <em>obj</em> debe ser una instancia de tipo ctypes.</p>
<p class="audit-hook translated">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.addressof</span></code> con el argumento <code class="docutils literal notranslate"><span class="pre">obj</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.alignment">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj_or_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.alignment" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna los requerimientos de alineación de un tipo de ctypes. <em>obj_or_type</em> debe ser un tipo o instancia ctypes.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.byref">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">byref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.byref" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna un puntero ligero a <em>obj</em>, que debe ser un ejemplo de un tipo de ctypes. <em>offset</em> es por defecto cero, y debe ser un entero que se añadirá al valor del puntero interno.</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">byref(obj,</span> <span class="pre">offset)</span></code> corresponde a este código C:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">El objeto retornado sólo puede ser utilizado como un parámetro de llamada de función foránea. Se comporta de manera similar a <code class="docutils literal notranslate"><span class="pre">pointer(obj)</span></code>, pero la construcción es mucho más rápida.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.CopyComPointer">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">CopyComPointer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CopyComPointer" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Copies a COM pointer from <em>src</em> to <em>dst</em> and returns the Windows specific
<code class="xref c c-type docutils literal notranslate"><span class="pre">HRESULT</span></code> value.</p>
<p class="untranslated">If <em>src</em> is not <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, its <code class="docutils literal notranslate"><span class="pre">AddRef</span></code> method is called, incrementing the
reference count.</p>
<p class="untranslated">In contrast, the reference count of <em>dst</em> will not be decremented before
assigning the new value. Unless <em>dst</em> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the caller is responsible
for decrementing the reference count by calling its <code class="docutils literal notranslate"><span class="pre">Release</span></code> method when
necessary.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.cast">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.cast" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Esta función es similar a la del operador de reparto en C. retorna una nueva instancia de <em>type</em> que apunta al mismo bloque de memoria que <em>obj</em>. <em>type</em> debe ser un tipo de puntero, y <em>obj</em> debe ser un objeto que pueda ser interpretado como un puntero.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.create_string_buffer">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">create_string_buffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.create_string_buffer" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">create_string_buffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span></dt>
<dd><p class="translated">Esta función crea un búfer de caracteres mutables. El objeto retornado es un arreglo de ctypes de <a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char</span></code></a>.</p>
<p class="untranslated">If <em>size</em> is given (and not <code class="docutils literal notranslate"><span class="pre">None</span></code>), it must be an <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>.
It specifies the size of the returned array.</p>
<p class="untranslated">If the <em>init</em> argument is given, it must be <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. It is used
to initialize the array items. Bytes not initialized this way are
set to zero (NUL).</p>
<p class="untranslated">If <em>size</em> is not given (or if it is <code class="docutils literal notranslate"><span class="pre">None</span></code>), the buffer is made one element
larger than <em>init</em>, effectively adding a NUL terminator.</p>
<p class="untranslated">If both arguments are given, <em>size</em> must not be less than <code class="docutils literal notranslate"><span class="pre">len(init)</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p class="untranslated">If <em>size</em> is equal to <code class="docutils literal notranslate"><span class="pre">len(init)</span></code>, a NUL terminator is
not added. Do not treat such a buffer as a C string.</p>
</div>
<p class="untranslated">For example:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">b&#39;\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ab&#39;</span><span class="p">))</span>
<span class="go">b&#39;ab\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ab&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">b&#39;ab&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ab&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">b&#39;ab\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcdef&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">   </span><span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">byte string too long</span>
</pre></div>
</div>
<p class="audit-hook translated">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.create_string_buffer</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">init</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.create_unicode_buffer">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">create_unicode_buffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.create_unicode_buffer" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">create_unicode_buffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span></dt>
<dd><p class="translated">Esta función crea un búfer de caracteres unicode mutable. El objeto retornado es un arreglo de ctypes de <a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar</span></code></a>.</p>
<p class="untranslated">The function takes the same arguments as <a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code></a> except
<em>init</em> must be a string and <em>size</em> counts <a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar</span></code></a>.</p>
<p class="audit-hook translated">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.create_unicode_buffer</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">init</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.DllCanUnloadNow">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">DllCanUnloadNow</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.DllCanUnloadNow" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">This function is a hook which allows implementing in-process
COM servers with ctypes.  It is called from the DllCanUnloadNow function that
the _ctypes extension dll exports.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.DllGetClassObject">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">DllGetClassObject</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.DllGetClassObject" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">This function is a hook which allows implementing in-process
COM servers with ctypes.  It is called from the DllGetClassObject function
that the <code class="docutils literal notranslate"><span class="pre">_ctypes</span></code> extension dll exports.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.util.find_library">
<span class="sig-prename descclassname"><span class="pre">ctypes.util.</span></span><span class="sig-name descname"><span class="pre">find_library</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.find_library" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Intenta encontrar una biblioteca y retornar un nombre de ruta. <em>name</em> es el nombre de la biblioteca sin ningún prefijo como <code class="docutils literal notranslate"><span class="pre">lib</span></code>, sufijo como <code class="docutils literal notranslate"><span class="pre">.so</span></code>, <code class="docutils literal notranslate"><span class="pre">.dylib</span></code> o número de versión (esta es la forma usada para la opción del enlazador posix <code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code>). Si no se puede encontrar ninguna biblioteca, retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p class="translated">La funcionalidad exacta depende del sistema.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.util.find_msvcrt">
<span class="sig-prename descclassname"><span class="pre">ctypes.util.</span></span><span class="sig-name descname"><span class="pre">find_msvcrt</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.find_msvcrt" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Returns the filename of the VC runtime library used by Python,
and by the extension modules.  If the name of the library cannot be
determined, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
<p class="translated">Si necesita liberar memoria, por ejemplo, asignada por un módulo de extensión con una llamada al <code class="docutils literal notranslate"><span class="pre">free(void</span> <span class="pre">*)</span></code>, es importante que utilice la función en la misma biblioteca que asignó la memoria.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.util.dllist">
<span class="sig-prename descclassname"><span class="pre">ctypes.util.</span></span><span class="sig-name descname"><span class="pre">dllist</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.dllist" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Try to provide a list of paths of the shared libraries loaded into the current
process.  These paths are not normalized or processed in any way.  The function
can raise <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> if the underlying platform APIs fail.
The exact functionality is system dependent.</p>
<p class="untranslated">On most platforms, the first element of the list represents the current
executable file. It may be an empty string.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows, macOS, iOS, glibc, BSD libc, musl</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.FormatError">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">FormatError</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">code</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.FormatError" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Returns a textual description of the error code <em>code</em>.  If no error code is
specified, the last error code is used by calling the Windows API function
<a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError()</span></code></a>.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.GetLastError">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">GetLastError</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.GetLastError" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Returns the last error code set by Windows in the calling thread.
This function calls the Windows <code class="docutils literal notranslate"><span class="pre">GetLastError()</span></code> function directly,
it does not return the ctypes-private copy of the error code.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.get_errno">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">get_errno</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.get_errno" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna el valor actual de la copia ctypes-private de la variable de sistema <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> en el hilo de llamada.</p>
<p class="audit-hook translated">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.get_errno</span></code> sin argumentos.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.get_last_error">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">get_last_error</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.get_last_error" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Returns the current value of the ctypes-private copy of the system
<code class="xref py py-data docutils literal notranslate"><span class="pre">LastError</span></code> variable in the calling thread.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
<p class="audit-hook translated">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.get_last_error</span></code> sin argumentos.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.memmove">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">memmove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memmove" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Igual que la función de la biblioteca estándar  de C <em>memmove</em>: copia <em>count</em> bytes de <em>src</em> a <em>dst</em>. <em>dst</em> y <em>src</em> deben ser enteros o instancias ctypes que pueden ser convertidos en punteros.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.memset">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">memset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memset" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Igual que la función de la biblioteca estándar de C <em>memset</em> C: llena el bloque de memoria en la dirección <em>dst</em> con <em>count</em> bytes de valor <em>c</em>. <em>dst</em> debe ser un número entero que especifique una dirección, o una instancia ctypes.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.POINTER">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">POINTER</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.POINTER" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Create or return a ctypes pointer type. Pointer types are cached and
reused internally, so calling this function repeatedly is cheap.
<em>type</em> must be a ctypes type.</p>
<div class="impl-detail compound">
<p class="untranslated"><strong>Detalles de implementación de CPython:</strong> The resulting pointer type is cached in the <code class="docutils literal notranslate"><span class="pre">__pointer_type__</span></code>
attribute of <em>type</em>.
It is possible to set this attribute before the first call to
<code class="docutils literal notranslate"><span class="pre">POINTER</span></code> in order to set a custom pointer type.
However, doing this is discouraged: manually creating a suitable
pointer type is difficult without relying on implementation
details that may change in future Python versions.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.pointer">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">pointer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.pointer" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Create a new pointer instance, pointing to <em>obj</em>.
The returned object is of the type <code class="docutils literal notranslate"><span class="pre">POINTER(type(obj))</span></code>.</p>
<p class="translated">Nota: Si sólo quieres pasar un puntero a un objeto a una llamada de función foránea, deberías usar <code class="docutils literal notranslate"><span class="pre">byref(obj)</span></code> que es mucho más rápido.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.resize">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">resize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.resize" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Esta función redimensiona el búfer de memoria interna de <em>obj</em>, que debe ser una instancia de tipo ctypes. No es posible hacer el buffer más pequeño que el tamaño nativo del tipo de objetos, como lo indica <code class="docutils literal notranslate"><span class="pre">size</span> <span class="pre">of</span> <span class="pre">(type(obj))</span></code>, pero es posible agrandar el buffer.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.set_errno">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">set_errno</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.set_errno" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Poner el valor actual de la copia ctypes-private de la variable del sistema <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> en el hilo de llamada a <em>valor</em> y retornar el valor anterior.</p>
<p class="audit-hook translated">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.set_errno</span></code> con argumento <code class="docutils literal notranslate"><span class="pre">errno</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.set_last_error">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">set_last_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.set_last_error" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Sets the current value of the ctypes-private copy of the system
<code class="xref py py-data docutils literal notranslate"><span class="pre">LastError</span></code> variable in the calling thread to <em>value</em> and return the
previous value.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
<p class="audit-hook translated">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.set_last_error</span></code> con argumento <code class="docutils literal notranslate"><span class="pre">error</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.sizeof">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">sizeof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj_or_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.sizeof" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna el tamaño en bytes de un buffer de memoria tipo ctypes o instancia. Hace lo mismo que el operador C <code class="docutils literal notranslate"><span class="pre">sizeof</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.string_at">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">string_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ptr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.string_at" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return the byte string at <em>void *ptr</em>.
If <em>size</em> is specified, it is used as size, otherwise the string is assumed
to be zero-terminated.</p>
<p class="audit-hook untranslated">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.string_at</span></code> with arguments <code class="docutils literal notranslate"><span class="pre">ptr</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.WinError">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">WinError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WinError" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Creates an instance of <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.  If <em>code</em> is not specified,
<a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError()</span></code></a> is called to determine the error code. If <em>descr</em> is not
specified, <a class="reference internal" href="#ctypes.FormatError" title="ctypes.FormatError"><code class="xref py py-func docutils literal notranslate"><span class="pre">FormatError()</span></code></a> is called to get a textual description of the
error.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>An instance of <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a> used to be created, which is now an
alias of <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.wstring_at">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">wstring_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ptr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.wstring_at" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return the wide-character string at <em>void *ptr</em>.
If <em>size</em> is specified, it is used as the number of
characters of the string, otherwise the string is assumed to be
zero-terminated.</p>
<p class="audit-hook untranslated">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.wstring_at</span></code> with arguments <code class="docutils literal notranslate"><span class="pre">ptr</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.memoryview_at">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">memoryview_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ptr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">readonly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memoryview_at" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return a <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> object of length <em>size</em> that references memory
starting at <em>void *ptr</em>.</p>
<p class="untranslated">If <em>readonly</em> is true, the returned <code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code> object can
not be used to modify the underlying memory.
(Changes made by other means will still be reflected in the returned
object.)</p>
<p class="untranslated">This function is similar to <a class="reference internal" href="#ctypes.string_at" title="ctypes.string_at"><code class="xref py py-func docutils literal notranslate"><span class="pre">string_at()</span></code></a> with the key
difference of not making a copy of the specified memory.
It is a semantically equivalent (but more efficient) alternative to
<code class="docutils literal notranslate"><span class="pre">memoryview((c_byte</span> <span class="pre">*</span> <span class="pre">size).from_address(ptr))</span></code>.
(While <a class="reference internal" href="#ctypes._CData.from_address" title="ctypes._CData.from_address"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_address()</span></code></a> only takes integers, <em>ptr</em> can also
be given as a <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-class docutils literal notranslate"><span class="pre">ctypes.POINTER</span></code></a> or a <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> object.)</p>
<p class="audit-hook untranslated" id="audit_event_ctypes_memoryview_at_0">Raises an <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.memoryview_at</span></code> with arguments <code class="docutils literal notranslate"><span class="pre">address</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>, <code class="docutils literal notranslate"><span class="pre">readonly</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

</section>
<section id="data-types">
<span id="ctypes-data-types"></span><h3 class="translated">Tipos de datos<a class="headerlink" href="#data-types" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes._CData">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">_CData</span></span><a class="headerlink" href="#ctypes._CData" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Esta clase no pública es la clase de base común de todos los tipos de datos de los ctypes. Entre otras cosas, todas las instancias de tipo ctypes contienen un bloque de memoria que contiene datos compatibles con C; la dirección del bloque de memoria es retornada por la función de ayuda <a class="reference internal" href="#ctypes.addressof" title="ctypes.addressof"><code class="xref py py-func docutils literal notranslate"><span class="pre">addressof()</span></code></a>. Otra variable de instancia se expone como <code class="xref py py-attr docutils literal notranslate"><span class="pre">_objetos</span></code>; ésta contiene otros objetos de Python que deben mantenerse vivos en caso de que el bloque de memoria contenga punteros.</p>
<p class="translated">Métodos comunes de tipos de datos ctypes, estos son todos métodos de clase (para ser exactos, son métodos del <a class="reference internal" href="../glossary.html#term-metaclass"><span class="xref std std-term">metaclass</span></a>):</p>
<dl class="py method">
<dt class="sig sig-object py" id="ctypes._CData.from_buffer">
<span class="sig-name descname"><span class="pre">from_buffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_buffer" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Este método retorna una instancia ctypes que comparte el buffer del objeto <em>source</em>. El objeto <em>source</em> debe soportar la interfaz del buffer de escritura. El parámetro opcional <em>offset</em> especifica un offset en el buffer de la fuente en bytes; el valor por defecto es cero. Si el buffer de la fuente no es lo suficientemente grande se lanza un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<p class="audit-hook translated">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.cdata/buffer</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">pointer</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>, <code class="docutils literal notranslate"><span class="pre">offset</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ctypes._CData.from_buffer_copy">
<span class="sig-name descname"><span class="pre">from_buffer_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_buffer_copy" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Este método crea una instancia ctypes, copiando el buffer del buffer de objetos <em>source</em> que debe ser legible. El parámetro opcional <em>offset</em> especifica un offset en el buffer de origen en bytes; el valor por defecto es cero. Si el buffer de fuente no es lo suficientemente grande se lanza un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<p class="audit-hook translated">Lanza un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.cdata/buffer</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">pointer</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>, <code class="docutils literal notranslate"><span class="pre">offset</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ctypes._CData.from_address">
<span class="sig-name descname"><span class="pre">from_address</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_address" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Este método retorna una instancia de tipo ctypes utilizando la memoria especificada por <em>address</em> que debe ser un entero.</p>
<p class="audit-hook translated">Este método, y otros que indirectamente llaman a este método, lanzan un <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.cdata</span></code> con argumento <code class="docutils literal notranslate"><span class="pre">address</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ctypes._CData.from_param">
<span class="sig-name descname"><span class="pre">from_param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_param" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">This method adapts <em>obj</em> to a ctypes type.  It is called with the actual
object used in a foreign function call when the type is present in the
foreign function’s <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> tuple;
it must return an object that can be used as a function call parameter.</p>
<p class="translated">Todos los tipos de datos ctypes tienen una implementación por defecto de este método de clase que normalmente retorna <em>obj</em> si es una instancia del tipo. Algunos tipos aceptan también otros objetos.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ctypes._CData.in_dll">
<span class="sig-name descname"><span class="pre">in_dll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">library</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.in_dll" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Este método retorna una instancia de tipo ctypes exportada por una biblioteca compartida. <em>name</em> es el nombre del símbolo que exporta los datos, <em>library</em> es la biblioteca compartida cargada.</p>
</dd></dl>

<p class="untranslated">Common class variables of ctypes data types:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CData.__pointer_type__">
<span class="sig-name descname"><span class="pre">__pointer_type__</span></span><a class="headerlink" href="#ctypes._CData.__pointer_type__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The pointer type that was created by calling
<a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal notranslate"><span class="pre">POINTER()</span></code></a> for corresponding ctypes data type. If a pointer type
was not yet created, the attribute is missing.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<p class="translated">Variables de instancia común de los tipos de datos de ctypes:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CData._b_base_">
<span class="sig-name descname"><span class="pre">_b_base_</span></span><a class="headerlink" href="#ctypes._CData._b_base_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">A veces, las instancias de datos ctypes no poseen el bloque de memoria que contienen, sino que comparten parte del bloque de memoria de un objeto base. El miembro de sólo lectura <a class="reference internal" href="#ctypes._CData._b_base_" title="ctypes._CData._b_base_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_b_base_</span></code></a> es el objeto raíz ctypes que posee el bloque de memoria.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CData._b_needsfree_">
<span class="sig-name descname"><span class="pre">_b_needsfree_</span></span><a class="headerlink" href="#ctypes._CData._b_needsfree_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Esta variable de sólo lectura es verdadera cuando la instancia de datos ctypes ha sido asignada a el propio bloque de memoria, falsa en caso contrario.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CData._objects">
<span class="sig-name descname"><span class="pre">_objects</span></span><a class="headerlink" href="#ctypes._CData._objects" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Este miembro es <code class="docutils literal notranslate"><span class="pre">None</span></code> o un diccionario que contiene objetos de Python que deben mantenerse vivos para que el contenido del bloque de memoria sea válido. Este objeto sólo se expone para su depuración; nunca modifique el contenido de este diccionario.</p>
</dd></dl>

</dd></dl>

</section>
<section id="ctypes-fundamental-data-types-2">
<span id="id1"></span><h3 class="translated">Tipos de datos fundamentales<a class="headerlink" href="#ctypes-fundamental-data-types-2" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes._SimpleCData">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">_SimpleCData</span></span><a class="headerlink" href="#ctypes._SimpleCData" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Esta clase no pública es la clase base de todos los tipos de datos de ctypes fundamentales. Se menciona aquí porque contiene los atributos comunes de los tipos de datos de ctypes fundamentales. <a class="reference internal" href="#ctypes._SimpleCData" title="ctypes._SimpleCData"><code class="xref py py-class docutils literal notranslate"><span class="pre">_SimpleCData</span></code></a> es una subclase de <a class="reference internal" href="#ctypes._CData" title="ctypes._CData"><code class="xref py py-class docutils literal notranslate"><span class="pre">_CData</span></code></a>, por lo que hereda sus métodos y atributos. Los tipos de datos ctypes que no son y no contienen punteros ahora pueden ser archivados.</p>
<p class="translated">Los instancias tienen un solo atributo:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._SimpleCData.value">
<span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#ctypes._SimpleCData.value" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Este atributo contiene el valor real de la instancia. Para los tipos enteros y punteros, es un entero, para los tipos de caracteres, es un objeto o cadena de bytes de un solo carácter, para los tipos de punteros de caracteres es un objeto o cadena de bytes de Python.</p>
<p class="translated">Cuando el atributo <code class="docutils literal notranslate"><span class="pre">value</span></code> se recupera de una instancia ctypes, normalmente se retorna un nuevo objeto cada vez. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> <em>no</em> implementa el retorno del objeto original, siempre se construye un nuevo objeto. Lo mismo ocurre con todas las demás instancias de objetos ctypes.</p>
</dd></dl>

</dd></dl>

<p class="untranslated">Fundamental data types, when returned as foreign function call results, or, for
example, by retrieving structure field members or array items, are transparently
converted to native Python types.  In other words, if a foreign function has a
<a class="reference internal" href="#ctypes._CFuncPtr.restype" title="ctypes._CFuncPtr.restype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code></a> of <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>, you will always receive a Python bytes
object, <em>not</em> a <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a> instance.</p>
<p class="untranslated">Subclasses of fundamental data types do <em>not</em> inherit this behavior. So, if a
foreign functions <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> is a subclass of <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a>, you will
receive an instance of this subclass from the function call. Of course, you can
get the value of the pointer by accessing the <code class="docutils literal notranslate"><span class="pre">value</span></code> attribute.</p>
<p class="translated">Estos son los tipos de datos fundamentales de ctypes:</p>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_byte">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_byte</span></span><a class="headerlink" href="#ctypes.c_byte" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">char</span></span> e interpreta el valor como un entero pequeño. El constructor acepta un inicializador entero opcional; no se realiza ninguna comprobación de desbordamiento.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_char">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_char</span></span><a class="headerlink" href="#ctypes.c_char" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <span class="c-expr sig sig-inline c"><span class="kt">char</span></span> e interpreta el valor como un solo carácter. El constructor acepta un inicializador de cadena opcional, la longitud de la cadena debe ser exactamente un carácter.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_char_p">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_char_p</span></span><a class="headerlink" href="#ctypes.c_char_p" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">*</span></span> cuando apunta a una cadena terminada en cero. Para un puntero de carácter general que también puede apuntar a datos binarios, se debe usar <code class="docutils literal notranslate"><span class="pre">POINTER(c_char)</span></code>. El constructor acepta una dirección entera o un objeto de bytes.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_double">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_double</span></span><a class="headerlink" href="#ctypes.c_double" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span>. El constructor acepta un inicializador flotante opcional.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_longdouble">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_longdouble</span></span><a class="headerlink" href="#ctypes.c_longdouble" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">double</span></span>. El constructor acepta un inicializador flotante opcional. En plataformas donde <code class="docutils literal notranslate"><span class="pre">sizeof(long</span> <span class="pre">double)</span> <span class="pre">==</span> <span class="pre">sizeof(double)</span></code> es un alias de <a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_double</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_float">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_float</span></span><a class="headerlink" href="#ctypes.c_float" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <span class="c-expr sig sig-inline c"><span class="kt">float</span></span>. El constructor acepta un inicializador flotante opcional.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_double_complex">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_double_complex</span></span><a class="headerlink" href="#ctypes.c_double_complex" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Represents the C <span class="c-expr sig sig-inline c"><span class="kt">double</span><span class="w"> </span><span class="kt">complex</span></span> datatype, if available.  The
constructor accepts an optional <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a> initializer.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_float_complex">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_float_complex</span></span><a class="headerlink" href="#ctypes.c_float_complex" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Represents the C <span class="c-expr sig sig-inline c"><span class="kt">float</span><span class="w"> </span><span class="kt">complex</span></span> datatype, if available.  The
constructor accepts an optional <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a> initializer.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_longdouble_complex">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_longdouble_complex</span></span><a class="headerlink" href="#ctypes.c_longdouble_complex" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Represents the C <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="kt">complex</span></span> datatype, if available.  The
constructor accepts an optional <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a> initializer.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_int">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_int</span></span><a class="headerlink" href="#ctypes.c_int" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">int</span></span>. El constructor acepta un inicializador entero opcional; no se realiza ninguna comprobación de desbordamiento. En plataformas donde <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></code> es un alias de <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_int8">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_int8</span></span><a class="headerlink" href="#ctypes.c_int8" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Represents the C 8-bit <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">int</span></span> datatype.  It is an alias for
<a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_byte</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_int16">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_int16</span></span><a class="headerlink" href="#ctypes.c_int16" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">int</span></span> de C de 16 bits. Por lo general, un alias para <a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_short</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_int32">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_int32</span></span><a class="headerlink" href="#ctypes.c_int32" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">int</span></span> de C de 32 bits. Por lo general, un alias para <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_int64">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_int64</span></span><a class="headerlink" href="#ctypes.c_int64" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">int</span></span> de C de 64 bits. Por lo general, un alias para <a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longlong</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_long">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_long</span></span><a class="headerlink" href="#ctypes.c_long" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">long</span></span>. El constructor acepta un inicializador entero opcional; no se realiza ninguna comprobación de desbordamiento.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_longlong">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_longlong</span></span><a class="headerlink" href="#ctypes.c_longlong" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span>. El constructor acepta un inicializador entero opcional; no se realiza ninguna comprobación de desbordamiento.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_short">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_short</span></span><a class="headerlink" href="#ctypes.c_short" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">short</span></span>. El constructor acepta un inicializador entero opcional; no se realiza ninguna comprobación de desbordamiento.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_size_t">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_size_t</span></span><a class="headerlink" href="#ctypes.c_size_t" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <code class="xref c c-type docutils literal notranslate"><span class="pre">size_t</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_ssize_t">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_ssize_t</span></span><a class="headerlink" href="#ctypes.c_ssize_t" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <code class="xref c c-type docutils literal notranslate"><span class="pre">ssize_t</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_time_t">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_time_t</span></span><a class="headerlink" href="#ctypes.c_time_t" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">time_t</span></code> datatype.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_ubyte">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_ubyte</span></span><a class="headerlink" href="#ctypes.c_ubyte" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span>, interpreta el valor como un entero pequeño. El constructor acepta un inicializador entero opcional; no se realiza ninguna comprobación de desbordamiento.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_uint">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_uint</span></span><a class="headerlink" href="#ctypes.c_uint" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span>. El constructor acepta un inicializador entero opcional; no se realiza ninguna comprobación de desbordamiento. En plataformas donde <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></code> es un alias para <a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulong</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_uint8">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_uint8</span></span><a class="headerlink" href="#ctypes.c_uint8" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Represents the C 8-bit <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> datatype.  It is an alias for
<a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ubyte</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_uint16">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_uint16</span></span><a class="headerlink" href="#ctypes.c_uint16" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> de C de 16 bits. Por lo general, un alias para <a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ushort</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_uint32">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_uint32</span></span><a class="headerlink" href="#ctypes.c_uint32" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> de C de 32 bits. Por lo general, un alias para <a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_uint64">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_uint64</span></span><a class="headerlink" href="#ctypes.c_uint64" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> de C de 64 bits. Por lo general, un alias para <a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulonglong</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_ulong">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_ulong</span></span><a class="headerlink" href="#ctypes.c_ulong" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span>. El constructor acepta un inicializador entero opcional; no se realiza ninguna comprobación de desbordamiento.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_ulonglong">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_ulonglong</span></span><a class="headerlink" href="#ctypes.c_ulonglong" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span>. El constructor acepta un inicializador entero opcional; no se realiza ninguna comprobación de desbordamiento.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_ushort">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_ushort</span></span><a class="headerlink" href="#ctypes.c_ushort" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span></span>. El constructor acepta un inicializador entero opcional; no se realiza ninguna comprobación de desbordamiento.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_void_p">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_void_p</span></span><a class="headerlink" href="#ctypes.c_void_p" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo C <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span>. El valor se representa como un número entero. El constructor acepta un inicializador entero opcional.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_wchar">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_wchar</span></span><a class="headerlink" href="#ctypes.c_wchar" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Represents the C <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> datatype, and interprets the value as a
single character unicode string.  The constructor accepts an optional string
initializer, the length of the string must be exactly one character.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_wchar_p">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_wchar_p</span></span><a class="headerlink" href="#ctypes.c_wchar_p" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de datos C <span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span>, que debe ser un puntero a una cadena de caracteres anchos terminada en cero. El constructor acepta una dirección entera o una cadena.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_bool">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_bool</span></span><a class="headerlink" href="#ctypes.c_bool" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de dato C <span class="c-expr sig sig-inline c"><span class="kt">bool</span></span> (más precisamente, <span class="c-expr sig sig-inline c"><span class="kt">_Bool</span></span> de C99). Su valor puede ser <code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code>, y el constructor acepta cualquier objeto que tenga un valor de verdad.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.HRESULT">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">HRESULT</span></span><a class="headerlink" href="#ctypes.HRESULT" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Represents a <code class="xref c c-type docutils literal notranslate"><span class="pre">HRESULT</span></code> value, which contains success or
error information for a function or method call.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.py_object">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">py_object</span></span><a class="headerlink" href="#ctypes.py_object" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Representa el tipo de dato de C <span class="c-expr sig sig-inline c"><a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>.  Llamar esto sin un argumento crea un puntero <span class="c-expr sig sig-inline c"><a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.14: </span><code class="xref py py-class docutils literal notranslate"><span class="pre">py_object</span></code> is now a <a class="reference internal" href="../glossary.html#term-generic-type"><span class="xref std std-term">generic type</span></a>.</p>
</div>
</dd></dl>

<p class="untranslated">The <code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes.wintypes</span></code> module provides quite some other Windows specific
data types, for example <code class="xref c c-type docutils literal notranslate"><span class="pre">HWND</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">WPARAM</span></code>, or <code class="xref c c-type docutils literal notranslate"><span class="pre">DWORD</span></code>.
Some useful structures like <code class="xref c c-type docutils literal notranslate"><span class="pre">MSG</span></code> or <code class="xref c c-type docutils literal notranslate"><span class="pre">RECT</span></code> are also defined.</p>
</section>
<section id="structured-data-types">
<span id="ctypes-structured-data-types"></span><h3 class="translated">Tipos de datos estructurados<a class="headerlink" href="#structured-data-types" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.Union">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">Union</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Union" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Clase base abstracta para uniones en orden de bytes nativos.</p>
<p class="untranslated">Unions share common attributes and behavior with structures;
see <a class="reference internal" href="#ctypes.Structure" title="ctypes.Structure"><code class="xref py py-class docutils literal notranslate"><span class="pre">Structure</span></code></a> documentation for details.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.BigEndianUnion">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">BigEndianUnion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.BigEndianUnion" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Clase base abstracta para uniones en orden de bytes <em>big endian</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.LittleEndianUnion">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">LittleEndianUnion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LittleEndianUnion" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Clase base abstracta para uniones en orden de bytes <em>little endian</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.BigEndianStructure">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">BigEndianStructure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.BigEndianStructure" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Clase base abstracta para estructuras en orden de bytes <em>big endian</em>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.LittleEndianStructure">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">LittleEndianStructure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LittleEndianStructure" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Clase base abstracta para estructuras en orden de bytes <em>little endian</em>.</p>
</dd></dl>

<p class="translated">Las estructuras y uniones con un orden de bytes no nativo no pueden contener campos de tipo puntero ni ningún otro tipo de datos que contenga campos de tipo puntero.</p>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.Structure">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">Structure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Structure" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Clase base abstracta para estructuras en orden de bytes <em>native</em>.</p>
<p class="translated">La estructura concreta y los tipos de unión deben crearse subclasificando uno de estos tipos, y al menos definir una variable de clase <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> creará <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>s que permitan leer y escribir los campos por accesos directos de atributos. Estos son los</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Structure._fields_">
<span class="sig-name descname"><span class="pre">_fields_</span></span><a class="headerlink" href="#ctypes.Structure._fields_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una secuencia que define los campos de estructura. Los elementos deben ser de 2 o 3 tuplas. El primer ítem es el nombre del campo, el segundo ítem especifica el tipo de campo; puede ser cualquier tipo de datos ctypes.</p>
<p class="translated">Para los campos de tipo entero como <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>, se puede dar un tercer elemento opcional. Debe ser un pequeño entero positivo que defina el ancho de bit del campo.</p>
<p class="translated">Los nombres de los campos deben ser únicos dentro de una estructura o unión. Esto no se comprueba, sólo se puede acceder a un campo cuando los nombres se repiten.</p>
<p class="translated">Es posible definir la variable de clase <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> <em>después</em> de la sentencia de clase que define la subclase Estructura, esto permite crear tipos de datos que se refieren directa o indirectamente a sí mismos:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">List</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;pnext&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">List</span><span class="p">)),</span>
                 <span class="o">...</span>
                <span class="p">]</span>
</pre></div>
</div>
<p class="untranslated">The <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> class variable can only be set once.
Later assignments will raise an <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>.</p>
<p class="untranslated">Additionally, the <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> class variable must be defined before
the structure or union type is first used: an instance or subclass is
created, <a class="reference internal" href="#ctypes.sizeof" title="ctypes.sizeof"><code class="xref py py-func docutils literal notranslate"><span class="pre">sizeof()</span></code></a> is called on it, and so on.
Later assignments to <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> will raise an <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>.
If <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> has not been set before such use,
the structure or union will have no own fields, as if <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code>
was empty.</p>
<p class="untranslated">Sub-subclasses of structure types inherit the fields of the base class
plus the <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> defined in the sub-subclass, if any.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Structure._pack_">
<span class="sig-name descname"><span class="pre">_pack_</span></span><a class="headerlink" href="#ctypes.Structure._pack_" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">An optional small integer that allows overriding the alignment of
structure fields in the instance.</p>
<p class="untranslated">This is only implemented for the MSVC-compatible memory layout
(see <a class="reference internal" href="#ctypes.Structure._layout_" title="ctypes.Structure._layout_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_layout_</span></code></a>).</p>
<p class="untranslated">Setting <code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code> to 0 is the same as not setting it at all.
Otherwise, the value must be a positive power of two.
The effect is equivalent to <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">pack(N)</span></code> in C, except
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> may allow larger <em>n</em> than what the compiler accepts.</p>
<p class="untranslated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code> must already be defined
when <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> is assigned, otherwise it will have no effect.</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.14, will be removed in version 3.19: </span>For historical reasons, if <code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code> is non-zero,
the MSVC-compatible layout will be used by default.
On non-Windows platforms, this default is deprecated and is slated to
become an error in Python 3.19.
If it is intended, set <a class="reference internal" href="#ctypes.Structure._layout_" title="ctypes.Structure._layout_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_layout_</span></code></a> to <code class="docutils literal notranslate"><span class="pre">'ms'</span></code>
explicitly.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Structure._align_">
<span class="sig-name descname"><span class="pre">_align_</span></span><a class="headerlink" href="#ctypes.Structure._align_" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">An optional small integer that allows increasing the alignment of
the structure when being packed or unpacked to/from memory.</p>
<p class="untranslated">The value must not be negative.
The effect is equivalent to <code class="docutils literal notranslate"><span class="pre">__attribute__((aligned(N)))</span></code> on GCC
or <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">align(N)</span></code> on MSVC, except <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> may allow
values that the compiler would reject.</p>
<p class="untranslated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_align_</span></code> can only <em>increase</em> a structure’s alignment
requirements. Setting it to 0 or 1 has no effect.</p>
<p class="untranslated">Using values that are not powers of two is discouraged and may lead to
surprising behavior.</p>
<p class="untranslated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_align_</span></code> must already be defined
when <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> is assigned, otherwise it will have no effect.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Structure._layout_">
<span class="sig-name descname"><span class="pre">_layout_</span></span><a class="headerlink" href="#ctypes.Structure._layout_" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">An optional string naming the struct/union layout. It can currently
be set to:</p>
<ul class="simple">
<li><p class="untranslated"><code class="docutils literal notranslate"><span class="pre">&quot;ms&quot;</span></code>: the layout used by the Microsoft compiler (MSVC).
On GCC and Clang, this layout can be selected with
<code class="docutils literal notranslate"><span class="pre">__attribute__((ms_struct))</span></code>.</p></li>
<li><p class="untranslated"><code class="docutils literal notranslate"><span class="pre">&quot;gcc-sysv&quot;</span></code>: the layout used by GCC with the System V or “SysV-like”
data model, as used on Linux and macOS.
With this layout, <a class="reference internal" href="#ctypes.Structure._pack_" title="ctypes.Structure._pack_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code></a> must be unset or zero.</p></li>
</ul>
<p class="untranslated">If not set explicitly, <code class="docutils literal notranslate"><span class="pre">ctypes</span></code> will use a default that
matches the platform conventions. This default may change in future
Python releases (for example, when a new platform gains official support,
or when a difference between similar platforms is found).
Currently the default will be:</p>
<ul class="simple">
<li><p class="untranslated">On Windows: <code class="docutils literal notranslate"><span class="pre">&quot;ms&quot;</span></code></p></li>
<li><p class="untranslated">When <a class="reference internal" href="#ctypes.Structure._pack_" title="ctypes.Structure._pack_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code></a> is specified: <code class="docutils literal notranslate"><span class="pre">&quot;ms&quot;</span></code>.
(This is deprecated; see <a class="reference internal" href="#ctypes.Structure._pack_" title="ctypes.Structure._pack_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code></a> documentation.)</p></li>
<li><p class="untranslated">Otherwise: <code class="docutils literal notranslate"><span class="pre">&quot;gcc-sysv&quot;</span></code></p></li>
</ul>
<p class="untranslated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_layout_</span></code> must already be defined when
<a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> is assigned, otherwise it will have no effect.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Structure._anonymous_">
<span class="sig-name descname"><span class="pre">_anonymous_</span></span><a class="headerlink" href="#ctypes.Structure._anonymous_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una secuencia opcional que enumera los nombres de los campos sin nombre (anónimos). <a class="reference internal" href="#ctypes.Structure._anonymous_" title="ctypes.Structure._anonymous_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_anonymous_</span></code></a> debe estar ya definida cuando se asigna <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>, de lo contrario no tendrá ningún efecto.</p>
<p class="translated">Los campos listados en esta variable deben ser campos de tipo estructura o unión. <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> creará descriptores en el tipo de estructura que permitan acceder a los campos anidados directamente, sin necesidad de crear el campo de estructura o unión.</p>
<p class="translated">Aquí hay un tipo de ejemplo (Windows):</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">_U</span><span class="p">(</span><span class="n">Union</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;lptdesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">TYPEDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;lpadesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">ARRAYDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;hreftype&quot;</span><span class="p">,</span> <span class="n">HREFTYPE</span><span class="p">)]</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TYPEDESC</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_anonymous_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">,)</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="n">_U</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;vt&quot;</span><span class="p">,</span> <span class="n">VARTYPE</span><span class="p">)]</span>
</pre></div>
</div>
<p class="translated">La estructura <code class="docutils literal notranslate"><span class="pre">TYPEDESC</span></code> describe un tipo de datos COM, el campo <code class="docutils literal notranslate"><span class="pre">vt</span></code> especifica cuál de los campos de unión es válido. Como el campo <code class="docutils literal notranslate"><span class="pre">u</span></code> está definido como campo anónimo, ahora es posible acceder a los miembros directamente desde la instancia TYPEDESC. <code class="docutils literal notranslate"><span class="pre">td.lptdesc</span></code> y <code class="docutils literal notranslate"><span class="pre">td.u.lptdesc</span></code> son equivalentes, pero el primero es más rápido ya que no necesita crear una instancia de unión temporal:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">td</span> <span class="o">=</span> <span class="n">TYPEDESC</span><span class="p">()</span>
<span class="n">td</span><span class="o">.</span><span class="n">vt</span> <span class="o">=</span> <span class="n">VT_PTR</span>
<span class="n">td</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
<span class="n">td</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<p class="translated">Es posible definir subclases de estructuras, que heredan los campos de la clase base. Si la definición de la subclase tiene una variable <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> separada, los campos especificados en ella se añaden a los campos de la clase base.</p>
<p class="translated">Los constructores de estructuras y uniones aceptan tanto argumentos posicionales como de palabras clave. Los argumentos posicionales se usan para inicializar los campos de los miembros en el mismo orden en que aparecen en <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>. Los argumentos de palabras clave en el constructor se interpretan como asignaciones de atributos, por lo que inicializarán <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> con el mismo nombre, o crearán nuevos atributos para nombres no presentes en <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.CField">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">CField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CField" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Descriptor for fields of a <a class="reference internal" href="#ctypes.Structure" title="ctypes.Structure"><code class="xref py py-class docutils literal notranslate"><span class="pre">Structure</span></code></a> and <a class="reference internal" href="#ctypes.Union" title="ctypes.Union"><code class="xref py py-class docutils literal notranslate"><span class="pre">Union</span></code></a>.
For example:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Color</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>        <span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">c_uint8</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">(</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">c_uint8</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">(</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">c_uint8</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">(</span><span class="s1">&#39;intense&#39;</span><span class="p">,</span> <span class="n">c_bool</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">(</span><span class="s1">&#39;blinking&#39;</span><span class="p">,</span> <span class="n">c_bool</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>   <span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">red</span>
<span class="go">&lt;ctypes.CField &#39;red&#39; type=c_ubyte, ofs=0, size=1&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">green</span><span class="o">.</span><span class="n">type</span>
<span class="go">&lt;class &#39;ctypes.c_ubyte&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">blue</span><span class="o">.</span><span class="n">byte_offset</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">intense</span>
<span class="go">&lt;ctypes.CField &#39;intense&#39; type=c_bool, ofs=3, bit_size=1, bit_offset=0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">blinking</span><span class="o">.</span><span class="n">bit_offset</span>
<span class="go">1</span>
</pre></div>
</div>
<p class="untranslated">All attributes are read-only.</p>
<p class="untranslated"><code class="xref py py-class docutils literal notranslate"><span class="pre">CField</span></code> objects are created via <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>;
do not instantiate the class directly.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14: </span>Previously, descriptors only had <code class="docutils literal notranslate"><span class="pre">offset</span></code> and <code class="docutils literal notranslate"><span class="pre">size</span></code> attributes
and a readable string representation; the <code class="xref py py-class docutils literal notranslate"><span class="pre">CField</span></code> class was not
available directly.</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.CField.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#ctypes.CField.name" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Name of the field, as a string.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.CField.type">
<span class="sig-name descname"><span class="pre">type</span></span><a class="headerlink" href="#ctypes.CField.type" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Type of the field, as a <a class="reference internal" href="#ctypes-data-types"><span class="std std-ref">ctypes class</span></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.CField.offset">
<span class="sig-name descname"><span class="pre">offset</span></span><a class="headerlink" href="#ctypes.CField.offset" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="ctypes.CField.byte_offset">
<span class="sig-name descname"><span class="pre">byte_offset</span></span><a class="headerlink" href="#ctypes.CField.byte_offset" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Offset of the field, in bytes.</p>
<p class="untranslated">For bitfields, this is the offset of the underlying byte-aligned
<em>storage unit</em>; see <a class="reference internal" href="#ctypes.CField.bit_offset" title="ctypes.CField.bit_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bit_offset</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.CField.byte_size">
<span class="sig-name descname"><span class="pre">byte_size</span></span><a class="headerlink" href="#ctypes.CField.byte_size" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Size of the field, in bytes.</p>
<p class="untranslated">For bitfields, this is the size of the underlying <em>storage unit</em>.
Typically, it has the same size as the bitfield’s type.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.CField.size">
<span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#ctypes.CField.size" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">For non-bitfields, equivalent to <a class="reference internal" href="#ctypes.CField.byte_size" title="ctypes.CField.byte_size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">byte_size</span></code></a>.</p>
<p class="untranslated">For bitfields, this contains a backwards-compatible bit-packed
value that combines <a class="reference internal" href="#ctypes.CField.bit_size" title="ctypes.CField.bit_size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bit_size</span></code></a> and
<a class="reference internal" href="#ctypes.CField.bit_offset" title="ctypes.CField.bit_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bit_offset</span></code></a>.
Prefer using the explicit attributes instead.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.CField.is_bitfield">
<span class="sig-name descname"><span class="pre">is_bitfield</span></span><a class="headerlink" href="#ctypes.CField.is_bitfield" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">True if this is a bitfield.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.CField.bit_offset">
<span class="sig-name descname"><span class="pre">bit_offset</span></span><a class="headerlink" href="#ctypes.CField.bit_offset" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="ctypes.CField.bit_size">
<span class="sig-name descname"><span class="pre">bit_size</span></span><a class="headerlink" href="#ctypes.CField.bit_size" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The location of a bitfield within its <em>storage unit</em>, that is, within
<a class="reference internal" href="#ctypes.CField.byte_size" title="ctypes.CField.byte_size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">byte_size</span></code></a> bytes of memory starting at
<a class="reference internal" href="#ctypes.CField.byte_offset" title="ctypes.CField.byte_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">byte_offset</span></code></a>.</p>
<p class="untranslated">To get the field’s value, read the storage unit as an integer,
<a class="reference internal" href="../reference/expressions.html#shifting"><span class="std std-ref">shift left</span></a> by <code class="xref py py-attr docutils literal notranslate"><span class="pre">bit_offset</span></code> and
take the <code class="xref py py-attr docutils literal notranslate"><span class="pre">bit_size</span></code> least significant bits.</p>
<p class="untranslated">For non-bitfields, <code class="xref py py-attr docutils literal notranslate"><span class="pre">bit_offset</span></code> is zero
and <code class="xref py py-attr docutils literal notranslate"><span class="pre">bit_size</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">byte_size</span> <span class="pre">*</span> <span class="pre">8</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.CField.is_anonymous">
<span class="sig-name descname"><span class="pre">is_anonymous</span></span><a class="headerlink" href="#ctypes.CField.is_anonymous" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">True if this field is anonymous, that is, it contains nested sub-fields
that should be merged into a containing structure or union.</p>
</dd></dl>

</dd></dl>

</section>
<section id="arrays-and-pointers">
<span id="ctypes-arrays-pointers"></span><h3 class="translated">Arreglos y punteros<a class="headerlink" href="#arrays-and-pointers" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.Array">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">Array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Array" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Clase base abstracta para arreglos.</p>
<p class="translated">La forma recomendada de crear tipos de arreglos concretos es multiplicando cualquier tipo de datos <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> con un número entero no negativo. Como alternativa, puede subclasificar este tipo y definir variables de clase <a class="reference internal" href="#ctypes.Array._length_" title="ctypes.Array._length_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_length_</span></code></a> y <a class="reference internal" href="#ctypes.Array._type_" title="ctypes.Array._type_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_type_</span></code></a>. Los elementos del arreglo se pueden leer y escribir utilizando subíndices estándar y accesos de segmento; para lecturas de segmentos, el objeto resultante <em>no es</em> en sí mismo, un <a class="reference internal" href="#ctypes.Array" title="ctypes.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Array._length_">
<span class="sig-name descname"><span class="pre">_length_</span></span><a class="headerlink" href="#ctypes.Array._length_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Un número entero positivo que especifica el número de elementos del conjunto. Los subíndices fuera de rango dan como resultado un <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>. Será retornado por <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Array._type_">
<span class="sig-name descname"><span class="pre">_type_</span></span><a class="headerlink" href="#ctypes.Array._type_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Especifica el tipo de cada elemento del arreglo.</p>
</dd></dl>

<p class="translated">Los constructores de subclases de arreglos aceptan argumentos posicionales, usados para inicializar los elementos en orden.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.ARRAY">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">ARRAY</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.ARRAY" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Create an array.
Equivalent to <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">*</span> <span class="pre">length</span></code>, where <em>type</em> is a
<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> data type and <em>length</em> an integer.</p>
<p class="untranslated">This function is <a class="reference internal" href="../glossary.html#term-soft-deprecated"><span class="xref std std-term">soft deprecated</span></a> in favor of multiplication.
There are no plans to remove it.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes._Pointer">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">_Pointer</span></span><a class="headerlink" href="#ctypes._Pointer" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Clase base, privada y abstracta para punteros.</p>
<p class="translated">Los tipos de punteros concretos se crean llamando a <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal notranslate"><span class="pre">POINTER()</span></code></a> con el tipo que será apuntado; esto se hace automáticamente por <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a>.</p>
<p class="translated">Si un puntero apunta a un arreglo, sus elementos pueden ser leídos y escritos usando accesos de subíndices y cortes estándar. Los objetos punteros no tienen tamaño, así que <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> lanzará un <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. Los subíndices negativos se leerán de la memoria <em>antes</em> que el puntero (como en C), y los subíndices fuera de rango probablemente se bloqueen con una violación de acceso (si tienes suerte).</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._Pointer._type_">
<span class="sig-name descname"><span class="pre">_type_</span></span><a class="headerlink" href="#ctypes._Pointer._type_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Especifica el tipo apuntado.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._Pointer.contents">
<span class="sig-name descname"><span class="pre">contents</span></span><a class="headerlink" href="#ctypes._Pointer.contents" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna el objeto al que el puntero apunta. Asignando a este atributo cambia el puntero para que apunte al objeto asignado.</p>
</dd></dl>

</dd></dl>

</section>
<section id="exceptions">
<span id="ctypes-exceptions"></span><h3 class="untranslated">Exceptions<a class="headerlink" href="#exceptions" title="Link to this heading">¶</a></h3>
<dl class="py exception">
<dt class="sig sig-object py" id="ctypes.ArgumentError">
<em class="property"><span class="k"><span class="pre">exception</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">ArgumentError</span></span><a class="headerlink" href="#ctypes.ArgumentError" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Esta excepción se lanza cuando una llamada a una función foránea no puede convertir uno de los argumentos pasados.</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ctypes.COMError">
<em class="property"><span class="k"><span class="pre">exception</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">COMError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hresult</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">details</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.COMError" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">This exception is raised when a COM method call failed.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.COMError.hresult">
<span class="sig-name descname"><span class="pre">hresult</span></span><a class="headerlink" href="#ctypes.COMError.hresult" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The integer value representing the error code.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.COMError.text">
<span class="sig-name descname"><span class="pre">text</span></span><a class="headerlink" href="#ctypes.COMError.text" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The error message.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.COMError.details">
<span class="sig-name descname"><span class="pre">details</span></span><a class="headerlink" href="#ctypes.COMError.details" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The 5-tuple <code class="docutils literal notranslate"><span class="pre">(descr,</span> <span class="pre">source,</span> <span class="pre">helpfile,</span> <span class="pre">helpcontext,</span> <span class="pre">progid)</span></code>.</p>
<p class="untranslated"><em>descr</em> is the textual description.  <em>source</em> is the language-dependent
<code class="docutils literal notranslate"><span class="pre">ProgID</span></code> for the class or application that raised the error.  <em>helpfile</em>
is the path of the help file.  <em>helpcontext</em> is the help context
identifier.  <em>progid</em> is the <code class="docutils literal notranslate"><span class="pre">ProgID</span></code> of the interface that defined the
error.</p>
</dd></dl>

<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> — A foreign function library for Python</a><ul>
<li><a class="reference internal" href="#ctypes-tutorial">tutorial de ctypes</a><ul>
<li><a class="reference internal" href="#loading-dynamic-link-libraries">Carga de bibliotecas de enlaces dinámicos</a></li>
<li><a class="reference internal" href="#accessing-functions-from-loaded-dlls">Acceder a las funciones de los dll cargados</a></li>
<li><a class="reference internal" href="#calling-functions">Funciones de llamada</a></li>
<li><a class="reference internal" href="#fundamental-data-types">Tipos de datos fundamentales</a></li>
<li><a class="reference internal" href="#calling-functions-continued">Funciones de llamada, continuación</a></li>
<li><a class="reference internal" href="#calling-variadic-functions">Calling variadic functions</a></li>
<li><a class="reference internal" href="#calling-functions-with-your-own-custom-data-types">Funciones de llamada con sus propios tipos de datos personalizados</a></li>
<li><a class="reference internal" href="#specifying-the-required-argument-types-function-prototypes">Especificar los tipos de argumentos requeridos (prototipos de funciones)</a></li>
<li><a class="reference internal" href="#return-types">Tipos de retorno</a></li>
<li><a class="reference internal" href="#passing-pointers-or-passing-parameters-by-reference">Pasar los punteros (o: pasar los parámetros por referencia)</a></li>
<li><a class="reference internal" href="#structures-and-unions">Estructuras y uniones</a></li>
<li><a class="reference internal" href="#structure-union-layout-alignment-and-byte-order">Structure/union layout, alignment and byte order</a></li>
<li><a class="reference internal" href="#bit-fields-in-structures-and-unions">Campos de bits en estructuras y uniones</a></li>
<li><a class="reference internal" href="#arrays">Arreglos</a></li>
<li><a class="reference internal" href="#pointers">Punteros</a></li>
<li><a class="reference internal" href="#thread-safety-without-the-gil">Thread safety without the GIL</a></li>
<li><a class="reference internal" href="#type-conversions">Conversiones de tipos</a></li>
<li><a class="reference internal" href="#incomplete-types">Tipos incompletos</a></li>
<li><a class="reference internal" href="#callback-functions">Funciones de retrollamadas (<em>callback</em>)</a></li>
<li><a class="reference internal" href="#accessing-values-exported-from-dlls">Acceder a los valores exportados de los dlls</a></li>
<li><a class="reference internal" href="#surprises">Sorpresas</a></li>
<li><a class="reference internal" href="#variable-sized-data-types">Tipos de datos de tamaño variable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ctypes-reference">referencia ctypes</a><ul>
<li><a class="reference internal" href="#finding-shared-libraries">Encontrar bibliotecas compartidas</a></li>
<li><a class="reference internal" href="#listing-loaded-shared-libraries">Listing loaded shared libraries</a></li>
<li><a class="reference internal" href="#loading-shared-libraries">Cargando bibliotecas compartidas</a></li>
<li><a class="reference internal" href="#foreign-functions">Funciones foráneas</a></li>
<li><a class="reference internal" href="#function-prototypes">Prototipos de funciones</a></li>
<li><a class="reference internal" href="#utility-functions">Funciones de utilidad</a></li>
<li><a class="reference internal" href="#data-types">Tipos de datos</a></li>
<li><a class="reference internal" href="#ctypes-fundamental-data-types-2">Tipos de datos fundamentales</a></li>
<li><a class="reference internal" href="#structured-data-types">Tipos de datos estructurados</a></li>
<li><a class="reference internal" href="#arrays-and-pointers">Arreglos y punteros</a></li>
<li><a class="reference internal" href="#exceptions">Exceptions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="errno.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">errno</span></code> — Standard errno system symbols</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="cmdlinelibs.html"
                          title="próximo capítulo">Command-line interface libraries</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/ctypes.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Contraer barra lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="cmdlinelibs.html" title="Command-line interface libraries"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="errno.html" title="errno — Standard errno system symbols"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >Servicios genéricos del sistema operativo</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> — A foreign function library for Python</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Derechos de autor</a> 2001 Python Software Foundation.
    <br>
    Ésta página tiene la licencia Python Software Foundation Versión 2.
    <br>
    Ejemplos, guías, y otro código en la documentación están bajo la licencia adicional Zero Clause BSD.
    <br>
    
      Ver <a href="/license.html">Historia y Licencia</a> para más información.<br>
    
    
    <br>

    La Python Software Foundation es una corporación sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor dona.</a>
<br>
    <br>
      Última actualización en oct 06, 2025 (04:51 UTC).
    
      <a href="/bugs.html">Encontraste un bug</a>?
    
    <br>

    Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a>8.2.3.
    </div>

  </body>
</html>