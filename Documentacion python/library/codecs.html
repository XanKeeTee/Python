<!DOCTYPE html>

<html lang="es" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="codecs — Codec registry and base classes" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/codecs.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Código fuente: Lib/codecs.py Este módulo define las clases base para los códecs estándar de Python (codificadores y decodificadores) y proporciona acceso al registro interno de códecs de Python, qu..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.15/es/_images/social_previews/summary_library_codecs_d6a5fa54.png" />
<meta property="og:image:alt" content="Código fuente: Lib/codecs.py Este módulo define las clases base para los códecs estándar de Python (codificadores y decodificadores) y proporciona acceso al registro interno de códecs de Python, qu..." />
<meta name="description" content="Código fuente: Lib/codecs.py Este módulo define las clases base para los códecs estándar de Python (codificadores y decodificadores) y proporciona acceso al registro interno de códecs de Python, qu..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>codecs — Codec registry and base classes &#8212; documentación de Python - 3.15.0a0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=bf1f176d"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f85f4cfb"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.15.0a0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Derechos de autor" href="../copyright.html" />
    <link rel="next" title="Tipos de datos" href="datatypes.html" />
    <link rel="prev" title="struct — Interpret bytes as packed binary data" href="struct.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/library/codecs.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menú">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code> — Codec registry and base classes</a><ul>
<li><a class="reference internal" href="#codec-base-classes">Clases Base de Códec</a><ul>
<li><a class="reference internal" href="#error-handlers">Manejadores de errores</a></li>
<li><a class="reference internal" href="#stateless-encoding-and-decoding">Codificación y decodificación sin estado</a></li>
<li><a class="reference internal" href="#incremental-encoding-and-decoding">Codificación y decodificación incrementales</a><ul>
<li><a class="reference internal" href="#incrementalencoder-objects">Objetos IncrementalEncoder</a></li>
<li><a class="reference internal" href="#incrementaldecoder-objects">Objetos IncrementalDecoder</a></li>
</ul>
</li>
<li><a class="reference internal" href="#stream-encoding-and-decoding">Codificación y decodificación de flujos</a><ul>
<li><a class="reference internal" href="#streamwriter-objects">Objetos StreamWriter</a></li>
<li><a class="reference internal" href="#streamreader-objects">Objetos StreamReader</a></li>
<li><a class="reference internal" href="#streamreaderwriter-objects">Objetos StreamReaderWriter</a></li>
<li><a class="reference internal" href="#streamrecoder-objects">Objetos StreamRecoder</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#encodings-and-unicode">Codificaciones y Unicode</a></li>
<li><a class="reference internal" href="#standard-encodings">Codificaciones estándar</a></li>
<li><a class="reference internal" href="#python-specific-encodings">Codificaciones específicas de Python</a><ul>
<li><a class="reference internal" href="#text-encodings">Codificaciones de texto</a></li>
<li><a class="reference internal" href="#binary-transforms">Transformaciones Binarias</a></li>
<li><a class="reference internal" href="#standalone-codec-functions">Standalone Codec Functions</a></li>
<li><a class="reference internal" href="#text-transforms">Transformaciones de texto</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-encodings"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings</span></code> — Encodings package</a></li>
<li><a class="reference internal" href="#module-encodings.idna"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.idna</span></code> — Nombres de dominio internacionalizados en aplicaciones</a></li>
<li><a class="reference internal" href="#module-encodings.mbcs"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.mbcs</span></code> — Página de códigos ANSI de Windows</a></li>
<li><a class="reference internal" href="#module-encodings.utf_8_sig"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.utf_8_sig</span></code> — Códec UTF-8 con firma BOM</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="struct.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code> — Interpret bytes as packed binary data</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="datatypes.html"
                          title="próximo capítulo">Tipos de datos</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/codecs.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="datatypes.html" title="Tipos de datos"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="struct.html" title="struct — Interpret bytes as packed binary data"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="binary.html" accesskey="U">Servicios de datos binarios</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code> — Codec registry and base classes</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-codecs">
<span id="codecs-codec-registry-and-base-classes"></span><h1 class="untranslated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code> — Codec registry and base classes<a class="headerlink" href="#module-codecs" title="Link to this heading">¶</a></h1>
<p class="translated"><strong>Código fuente:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/main/Lib/codecs.py">Lib/codecs.py</a></p>
<hr class="docutils" id="index-0" />
<p class="translated">Este módulo define las clases base para los códecs estándar de Python (codificadores y decodificadores) y proporciona acceso al registro interno de códecs de Python, que administra el códec y el proceso de búsqueda del manejo de errores. La mayoría de los códecs estándar son <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>, que codifican texto a bytes (y decodifican bytes a texto), pero también se proporcionan códecs que codifican texto a texto y bytes a bytes. Los códecs personalizados pueden codificar y decodificar entre tipos arbitrarios, pero algunas características del módulo están restringidas para usarse específicamente con <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a> o con códecs que codifican a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
<p class="translated">El módulo define las siguientes funciones para codificar y decodificar con cualquier códec:</p>
<dl class="py function">
<dt class="sig sig-object py" id="codecs.encode">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.encode" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Codifica <em>obj</em> utilizando el códec registrado para <em>encoding</em>.</p>
<p class="translated">Se pueden dar <em>errors</em> para establecer el esquema de manejo de errores deseado. El manejador de errores predeterminado es <code class="docutils literal notranslate"><span class="pre">'estricto'</span></code>, lo que significa que los errores de codificación provocan <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> (o una subclase más específica del códec, como <a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a>). Consulte <a class="reference internal" href="#codec-base-classes"><span class="std std-ref">Clases Base de Códec</span></a> para obtener más información sobre el manejo de errores de códec.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.decode">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'utf-8'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.decode" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Decodifica <em>obj</em> utilizando el códec registrado para <em>encoding</em>.</p>
<p class="translated">Se pueden dar <em>errors</em> para establecer el esquema de manejo de errores deseado. El manejador de errores predeterminado es <code class="docutils literal notranslate"><span class="pre">'estricto'</span></code>, lo que significa que los errores de decodificación generan <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> (o una subclase más específica de códec, como <a class="reference internal" href="exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a>). Consulte <a class="reference internal" href="#codec-base-classes"><span class="std std-ref">Clases Base de Códec</span></a> para obtener más información sobre el manejo de errores de códec.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.charmap_build">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">charmap_build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.charmap_build" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return a mapping suitable for encoding with a custom single-byte encoding.
Given a <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> <em>string</em> of up to 256 characters representing a
decoding table, returns either a compact internal mapping object
<code class="docutils literal notranslate"><span class="pre">EncodingMap</span></code> or a <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a> mapping character ordinals
to byte values. Raises a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> on invalid input.</p>
</dd></dl>

<p class="translated">Los detalles completos de cada códec también se pueden consultar directamente:</p>
<dl class="py function">
<dt class="sig sig-object py" id="codecs.lookup">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">lookup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.lookup" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Busca la información de códec en el registro de códec de Python y retorna un objeto <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code></a> como se define a continuación.</p>
<p class="untranslated">This function first normalizes the <em>encoding</em>: all ASCII letters are
converted to lower case, spaces are replaced with hyphens.
Then encoding is looked up in the registry’s cache. If not found, the list of
registered search functions is scanned. If no <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code></a> object is
found, a <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> is raised. Otherwise, the <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code></a> object
is stored in the cache and returned to the caller.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>Any characters except ASCII letters and digits and a dot are converted to underscore.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.15.0a0 (unreleased): </span>No characters are converted to underscore anymore.
Spaces are converted to hyphens.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="codecs.CodecInfo">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">CodecInfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">streamreader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">streamwriter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incrementalencoder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incrementaldecoder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.CodecInfo" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Detalles de códec al buscar el registro de códec. Los argumentos del constructor se almacenan en atributos del mismo nombre:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="codecs.CodecInfo.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#codecs.CodecInfo.name" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El nombre de la codificación.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="codecs.CodecInfo.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><a class="headerlink" href="#codecs.CodecInfo.encode" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="codecs.CodecInfo.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><a class="headerlink" href="#codecs.CodecInfo.decode" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Las funciones de codificación y decodificación sin estado. Deben ser funciones o métodos que tengan la misma interfaz que los métodos <a class="reference internal" href="#codecs.Codec.encode" title="codecs.Codec.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a> y <a class="reference internal" href="#codecs.Codec.decode" title="codecs.Codec.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> de instancias de <em>Codec</em> (ver <a class="reference internal" href="#codec-objects"><span class="std std-ref">Codec Interface</span></a>). Se espera que las funciones o métodos funcionen en modo sin estado.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="codecs.CodecInfo.incrementalencoder">
<span class="sig-name descname"><span class="pre">incrementalencoder</span></span><a class="headerlink" href="#codecs.CodecInfo.incrementalencoder" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="codecs.CodecInfo.incrementaldecoder">
<span class="sig-name descname"><span class="pre">incrementaldecoder</span></span><a class="headerlink" href="#codecs.CodecInfo.incrementaldecoder" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Clases de codificación y decodificación incremental o funciones de fábrica. Deben proporcionar la interfaz definida por las clases base <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a> y <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a>, respectivamente. Los códecs incrementales pueden mantener el estado.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="codecs.CodecInfo.streamwriter">
<span class="sig-name descname"><span class="pre">streamwriter</span></span><a class="headerlink" href="#codecs.CodecInfo.streamwriter" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="codecs.CodecInfo.streamreader">
<span class="sig-name descname"><span class="pre">streamreader</span></span><a class="headerlink" href="#codecs.CodecInfo.streamreader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Las clases <em>stream</em>, tanto <em>writer</em> como <em>reader</em> o funciones de fábrica. Estos tienen que proporcionar la interfaz definida por las clases base <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> y <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>, respectivamente. Los códecs de flujo pueden mantener el estado.</p>
</dd></dl>

</dd></dl>

<p class="translated">Para simplificar el acceso a los diversos componentes de códec, el módulo proporciona estas funciones adicionales que utilizan <a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal notranslate"><span class="pre">lookup()</span></code></a> para la búsqueda de códec:</p>
<dl class="py function">
<dt class="sig sig-object py" id="codecs.getencoder">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">getencoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getencoder" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Busca el códec para la codificación dada y retorna su función de codificador.</p>
<p class="translated">Lanza un <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> en caso de que no se encuentre la codificación.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.getdecoder">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">getdecoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getdecoder" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Busca el códec para la codificación dada y retorna su función de decodificador.</p>
<p class="translated">Lanza un <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> en caso de que no se encuentre la codificación.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.getincrementalencoder">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">getincrementalencoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getincrementalencoder" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Busca el códec para la codificación dada y retorna su clase de codificador incremental o función de fábrica.</p>
<p class="translated">Lanza un <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> en caso de que no se encuentre la codificación o el códec no admita un codificador incremental.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.getincrementaldecoder">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">getincrementaldecoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getincrementaldecoder" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Busca el códec para la codificación dada y retorna su clase de decodificador incremental o función de fábrica.</p>
<p class="translated">Lanza un <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> en caso de que no se encuentre la codificación o el códec no admita un decodificador incremental.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.getreader">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">getreader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getreader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Busca el códec para la codificación dada y retorna su clase <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> o función de fábrica.</p>
<p class="translated">Lanza un <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> en caso de que no se encuentre la codificación.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.getwriter">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">getwriter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getwriter" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Busca el códec para la codificación dada y retorna su clase <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> o función de fábrica.</p>
<p class="translated">Lanza un <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> en caso de que no se encuentre la codificación.</p>
</dd></dl>

<p class="translated">Los códecs personalizados se ponen a disposición registrando una función de búsqueda de códecs adecuada:</p>
<dl class="py function">
<dt class="sig sig-object py" id="codecs.register">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">register</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">search_function</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.register" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Register a codec search function. Search functions are expected to take one
argument, being the encoding name in all lower case letters with spaces
converted to hyphens, and return a <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code></a> object.
In case a search function cannot find a given encoding, it should return
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.unregister">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">unregister</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">search_function</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.unregister" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Anula el registro de una función de búsqueda de códecs y elimina el caché del registro. Si la función de búsqueda no está registrada, no hace nada.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<p class="translated">Mientras que la función incorporada <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> y el módulo asociado <a class="reference internal" href="io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> son el enfoque recomendado para trabajar con archivos de texto codificados, este módulo proporciona funciones y clases de utilidad adicionales que permiten el uso de una gama más amplia de códecs cuando se trabaja con archivos binarios:</p>
<dl class="py function">
<dt class="sig sig-object py" id="codecs.open">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffering</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.open" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Abre un archivo codificado utilizando el modo dado y retorna una instancia de <a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReaderWriter</span></code></a>, proporcionando codificación/decodificación transparente. El modo de archivo predeterminado es <code class="docutils literal notranslate"><span class="pre">'r'</span></code>, que significa abrir el archivo en modo de lectura.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Si el valor de <em>encoding</em> no es <code class="docutils literal notranslate"><span class="pre">None</span></code>, entonces, los archivos codificados subyacentes siempre se abren en modo binario. No se realiza ninguna conversión automática de <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> al leer y escribir. El argumento <em>mode</em> puede ser cualquier modo binario aceptable para la función integrada <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>; la <code class="docutils literal notranslate"><span class="pre">'b'</span></code> se añade automáticamente.</p>
</div>
<p class="translated"><em>encoding</em> especifica la codificación que se utilizará para el archivo. Se permite cualquier codificación que codifique y decodifique desde bytes, y los tipos de datos admitidos por los métodos de archivo dependen del códec utilizado.</p>
<p class="translated">pueden proporcionarse <em>errors</em> para definir el manejo de errores. El valor predeterminado es <code class="docutils literal notranslate"><span class="pre">'estricto'</span></code>, lo que hace que se genere un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> en caso de que ocurra un error de codificación.</p>
<p class="translated"><em>buffering</em> tiene el mismo significado que para la función incorporada <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>. Su valor predeterminado es -1, lo que significa que se utilizará el tamaño predeterminado del búfer.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>El modo <code class="docutils literal notranslate"><span class="pre">'U'</span></code> ha sido eliminado.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.14: </span><a class="reference internal" href="#codecs.open" title="codecs.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.open()</span></code></a> has been superseded by <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.EncodedFile">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">EncodedFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_encoding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.EncodedFile" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna una instancia de <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamRecoder</span></code></a>, una versión envuelta de <em>file</em> que proporciona transcodificación transparente. El archivo original se cierra cuando se cierra la versión empaquetada.</p>
<p class="translated">Los datos escritos en el archivo empaquetado se decodifican de acuerdo con la <em>data_encoding</em> dada y luego se escriben en el archivo original como bytes usando <em>file_encoding</em>. Los bytes leídos del archivo original se decodifican según <em>file_encoding</em>, y el resultado se codifica utilizando <em>data_encoding</em>.</p>
<p class="translated">Si no se proporciona <em>file_encoding</em>, el valor predeterminado es <em>data_encoding</em>.</p>
<p class="translated">Pueden proporcionarse <em>errors</em> para definir el manejo de errores. Su valor predeterminado es <code class="docutils literal notranslate"><span class="pre">'estricto'</span></code>, lo que hace que se genere <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> en caso de que ocurra un error de codificación.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.iterencode">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">iterencode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.iterencode" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Uses an incremental encoder to iteratively encode the input provided by
<em>iterator</em>. <em>iterator</em> must yield <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> objects.
This function is a <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>. The <em>errors</em> argument (as well as any
other keyword argument) is passed through to the incremental encoder.</p>
<p class="translated">Esta función requiere que el códec acepte texto en objetos <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> para codificar. Por lo tanto, no admite codificadores de bytes a bytes, como <code class="docutils literal notranslate"><span class="pre">base64_codec</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.iterdecode">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">iterdecode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.iterdecode" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Uses an incremental decoder to iteratively decode the input provided by
<em>iterator</em>. <em>iterator</em> must yield <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> objects.
This function is a <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>. The <em>errors</em> argument (as well as any
other keyword argument) is passed through to the incremental decoder.</p>
<p class="translated">Esta función requiere que el códec acepte objetos <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> para decodificar. Por lo tanto, no admite codificadores de texto a texto como <code class="docutils literal notranslate"><span class="pre">rot_13</span></code>, aunque <code class="docutils literal notranslate"><span class="pre">rot_13</span></code> puede usarse de manera equivalente con <a class="reference internal" href="#codecs.iterencode" title="codecs.iterencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">iterencode()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.readbuffer_encode">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">readbuffer_encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.readbuffer_encode" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return a <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the raw bytes of <em>buffer</em>, a
<a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">buffer-compatible object</span></a> or <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>
(encoded to UTF-8 before processing), and their length in bytes.</p>
<p class="untranslated">The <em>errors</em> argument is ignored.</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">codecs</span><span class="o">.</span><span class="n">readbuffer_encode</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Zito&quot;</span><span class="p">)</span>
<span class="go">(b&#39;Zito&#39;, 4)</span>
</pre></div>
</div>
</dd></dl>

<p class="translated">El módulo también proporciona las siguientes constantes que son útiles para leer y escribir en archivos dependientes de la plataforma:</p>
<dl class="py data">
<dt class="sig sig-object py" id="codecs.BOM">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">BOM</span></span><a class="headerlink" href="#codecs.BOM" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="codecs.BOM_BE">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">BOM_BE</span></span><a class="headerlink" href="#codecs.BOM_BE" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="codecs.BOM_LE">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">BOM_LE</span></span><a class="headerlink" href="#codecs.BOM_LE" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="codecs.BOM_UTF8">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">BOM_UTF8</span></span><a class="headerlink" href="#codecs.BOM_UTF8" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="codecs.BOM_UTF16">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">BOM_UTF16</span></span><a class="headerlink" href="#codecs.BOM_UTF16" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="codecs.BOM_UTF16_BE">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">BOM_UTF16_BE</span></span><a class="headerlink" href="#codecs.BOM_UTF16_BE" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="codecs.BOM_UTF16_LE">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">BOM_UTF16_LE</span></span><a class="headerlink" href="#codecs.BOM_UTF16_LE" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="codecs.BOM_UTF32">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">BOM_UTF32</span></span><a class="headerlink" href="#codecs.BOM_UTF32" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="codecs.BOM_UTF32_BE">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">BOM_UTF32_BE</span></span><a class="headerlink" href="#codecs.BOM_UTF32_BE" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="codecs.BOM_UTF32_LE">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">BOM_UTF32_LE</span></span><a class="headerlink" href="#codecs.BOM_UTF32_LE" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Estas constantes definen varias secuencias de bytes, que son marcas de orden de bytes Unicode (BOM) para varias codificaciones. Se utilizan en flujos de datos UTF-16 y UTF-32 para indicar el orden de bytes utilizado, y en UTF-8 como firma Unicode. <a class="reference internal" href="#codecs.BOM_UTF16" title="codecs.BOM_UTF16"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16</span></code></a> es <a class="reference internal" href="#codecs.BOM_UTF16_BE" title="codecs.BOM_UTF16_BE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16_BE</span></code></a> o <a class="reference internal" href="#codecs.BOM_UTF16_LE" title="codecs.BOM_UTF16_LE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16_LE</span></code></a> dependiendo del orden de bytes nativo de la plataforma, <a class="reference internal" href="#codecs.BOM" title="codecs.BOM"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM</span></code></a> es un alias para <a class="reference internal" href="#codecs.BOM_UTF16" title="codecs.BOM_UTF16"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16</span></code></a>, <a class="reference internal" href="#codecs.BOM_LE" title="codecs.BOM_LE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_LE</span></code></a> para <a class="reference internal" href="#codecs.BOM_UTF16_LE" title="codecs.BOM_UTF16_LE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16_LE</span></code></a> y <a class="reference internal" href="#codecs.BOM_BE" title="codecs.BOM_BE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_BE</span></code></a> para <a class="reference internal" href="#codecs.BOM_UTF16_BE" title="codecs.BOM_UTF16_BE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16_BE</span></code></a>. Los otros representan la lista de materiales en las codificaciones UTF-8 y UTF-32.</p>
</dd></dl>

<section id="codec-base-classes">
<span id="id1"></span><h2 class="translated">Clases Base de Códec<a class="headerlink" href="#codec-base-classes" title="Link to this heading">¶</a></h2>
<p class="translated">El módulo <a class="reference internal" href="#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> define un conjunto de clases base que definen las interfaces para trabajar con objetos de códec, y también puede usarse como base para implementaciones de códec personalizadas.</p>
<p class="translated">Cada códec tiene que definir cuatro interfaces para que pueda usarse como códec en Python: codificador sin estado, decodificador sin estado, lector de flujo y escritor de flujo. El lector de flujo y los escritores suelen reutilizar el codificador/decodificador sin estado para implementar los protocolos de archivo. Los autores de códecs también necesitan definir cómo manejará los errores de codificación y decodificación.</p>
<section id="error-handlers">
<span id="surrogateescape"></span><span id="id2"></span><h3 class="translated">Manejadores de errores<a class="headerlink" href="#error-handlers" title="Link to this heading">¶</a></h3>
<p class="translated">Para simplificar y estandarizar el manejo de errores, los códecs pueden implementar diferentes esquemas de manejo de errores aceptando el argumento de cadena <em>errors</em>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;German ß, ♬&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;backslashreplace&#39;</span><span class="p">)</span>
<span class="go">b&#39;German \\xdf, \\u266c&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;German ß, ♬&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;xmlcharrefreplace&#39;</span><span class="p">)</span>
<span class="go">b&#39;German &amp;#223;, &amp;#9836;&#39;</span>
</pre></div>
</div>
<p class="translated" id="index-1">Los siguientes manejadores de errores se pueden emplear con todos los códecs Python <a class="reference internal" href="#standard-encodings"><span class="std std-ref">Codificaciones estándar</span></a>:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Valor</p></th>
<th class="head"><p class="translated">Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">'strict'</span></code></p></td>
<td><p class="translated">Lanza <a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a> (o una subclase), este es el valor predeterminado. Implementado en <code class="xref py py-func docutils literal notranslate"><span class="pre">strictly_errors()</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">'ignore'</span></code></p></td>
<td><p class="translated">Ignore los datos mal formados y continúe sin previo aviso. Implementado en <a class="reference internal" href="#codecs.ignore_errors" title="codecs.ignore_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">ignore_errors()</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">'replace'</span></code></p></td>
<td><p class="translated">Sustituir con un marcador de reemplazo. Al codificar, emplear <code class="docutils literal notranslate"><span class="pre">?</span></code> (carácter ASCII). Al decodificar, usar <code class="docutils literal notranslate"><span class="pre">�</span></code> (U+FFFD, el CARÁCTER DE REEMPLAZO oficial). Implementado en <a class="reference internal" href="#codecs.replace_errors" title="codecs.replace_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">replace_errors()</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code></p></td>
<td><p class="translated">Reemplazar con secuencias de escape mediante barra invertida. Al codificar, emplear la forma hexadecimal del punto de código Unicode con los formatos <code class="samp docutils literal notranslate"><span class="pre">\x</span><em><span class="pre">hh</span></em></code> <code class="samp docutils literal notranslate"><span class="pre">\u</span><em><span class="pre">xxxx</span></em></code> <code class="samp docutils literal notranslate"><span class="pre">\U</span><em><span class="pre">xxxxxxxx</span></em></code>. Al decodificar, usa la forma hexadecimal del valor del byte con el formato <code class="samp docutils literal notranslate"><span class="pre">\x</span><em><span class="pre">hh</span></em></code>. Implementado en <a class="reference internal" href="#codecs.backslashreplace_errors" title="codecs.backslashreplace_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">backslashreplace_errors()</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code></p></td>
<td><p class="translated">En la decodificación, reemplace el byte con código sustituto individual que va desde <code class="docutils literal notranslate"><span class="pre">U+DC80</span></code> a <code class="docutils literal notranslate"><span class="pre">U+DCFF</span></code>. Este código se volverá a convertir en el mismo byte cuando se use el manejador de errores <code class="docutils literal notranslate"><span class="pre">'sustituto</span> <span class="pre">de</span> <span class="pre">paisaje'</span></code> al codificar los datos. (Ver <span class="target" id="index-24"></span><a class="pep reference external" href="https://peps.python.org/pep-0383/"><strong>PEP 383</strong></a> para más información).</p></td>
</tr>
</tbody>
</table>
<p class="translated" id="index-3">Los siguientes manejadores de errores solo son aplicables a <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">codificaciones de texto</span></a>:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Valor</p></th>
<th class="head"><p class="translated">Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code></p></td>
<td><p class="translated">Reemplazar con una referencia de carácter numérico XML/HTML, que es una forma decimal del punto de código Unicode con formato <code class="samp docutils literal notranslate"><span class="pre">&amp;#</span><em><span class="pre">num</span></em><span class="pre">;</span></code>. Implementado en <a class="reference internal" href="#codecs.xmlcharrefreplace_errors" title="codecs.xmlcharrefreplace_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">xmlcharrefreplace_errors()</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code></p></td>
<td><p class="translated">Reemplazar con secuencias de escape <code class="docutils literal notranslate"><span class="pre">\N{...}</span></code>, lo que aparece entre llaves, es la propiedad Nombre de la Base de datos de Caracteres Unicode. Implementado en <a class="reference internal" href="#codecs.namereplace_errors" title="codecs.namereplace_errors"><code class="xref py py-func docutils literal notranslate"><span class="pre">namereplace_errors()</span></code></a>.</p></td>
</tr>
</tbody>
</table>
<p class="translated" id="index-4">Además, el siguiente manejador de errores es específico de los códecs dados:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Valor</p></th>
<th class="head"><p class="translated">Códecs</p></th>
<th class="head"><p class="translated">Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">'surrogatepass'</span></code></p></td>
<td><p class="translated">utf-8, utf-16, utf-32,
utf-16-be, utf-16-le,
utf-32-be, utf-32-le</p></td>
<td><p class="translated">Permite la codificación y decodificación del punto de código sustituto (<code class="docutils literal notranslate"><span class="pre">U+D800</span></code> - <code class="docutils literal notranslate"><span class="pre">U+DFFF</span></code>) como punto de código normal. De lo contrario, estos códecs tratan la presencia de un punto de código sustituto en <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> como un error.</p></td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.1: </span>Los manejadores de errores <code class="docutils literal notranslate"><span class="pre">'surrogateescape'</span></code> y <code class="docutils literal notranslate"><span class="pre">'surrogatepass'</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Los manejadores de errores <code class="docutils literal notranslate"><span class="pre">'surrogatepass'</span></code> ahora funcionan con los códecs utf-16* y utf-32*.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5: </span>El manejador de errores <code class="docutils literal notranslate"><span class="pre">'namereplace'</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>El manejador de errores <code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code> ahora funciona con decodificación y traducción.</p>
</div>
<p class="translated">El conjunto de valores permitidos puede ampliarse registrando un nuevo manejador de errores con nombre:</p>
<dl class="py function">
<dt class="sig sig-object py" id="codecs.register_error">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">register_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_handler</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.register_error" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Registre la función de manejo de errores <em>error_handler</em> bajo el nombre <em>name</em>. Se invocará el argumento <em>error_handler</em> durante la codificación y decodificación en caso de error, cuando <em>name</em> se especifica como el parámetro de errores.</p>
<p class="translated">Para la codificación, se llamará a <em>error_handler</em> con una instancia <a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a>, que contiene información sobre la ubicación del error. El manejador de errores debe generar esta o una excepción diferente, o retornar una tupla con un reemplazo para la parte no codificable de la entrada y una posición donde la codificación debe continuar. El reemplazo puede ser <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> o <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Si el reemplazo son bytes, el codificador simplemente los copiará en el búfer de salida. Si el reemplazo es una cadena de caracteres, el codificador codificará el reemplazo. La codificación continúa en la entrada original en la posición especificada. Los valores de posición negativos se tratarán como relativos al final de la cadena de entrada. Si la posición resultante está fuera del límite, se lanzará <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>.</p>
<p class="translated">La decodificación y la traducción funcionan de manera similar, excepto que <a class="reference internal" href="exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a> o <a class="reference internal" href="exceptions.html#UnicodeTranslateError" title="UnicodeTranslateError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeTranslateError</span></code></a> se pasarán al manejador y el sustituto del manejador de errores se colocará directamente en la salida.</p>
</dd></dl>

<p class="translated">Los manejadores de errores registrados previamente (incluidos los manejadores de error estándar) se pueden buscar por nombre:</p>
<dl class="py function">
<dt class="sig sig-object py" id="codecs.lookup_error">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">lookup_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.lookup_error" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna el manejador de errores previamente registrado con el nombre <em>name</em>.</p>
<p class="translated">Lanza un <a class="reference internal" href="exceptions.html#LookupError" title="LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> en caso de que no se pueda encontrar el controlador.</p>
</dd></dl>

<p class="translated">Los siguientes manejadores de errores estándar también están disponibles como funciones de nivel de módulo:</p>
<dl class="py function">
<dt class="sig sig-object py" id="codecs.strict_errors">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">strict_errors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.strict_errors" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Implementa el manejo de errores <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>.</p>
<p class="translated">Cada error de codificación o decodificación genera un <a class="reference internal" href="exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.ignore_errors">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">ignore_errors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.ignore_errors" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Implementa el manejo de errores <code class="docutils literal notranslate"><span class="pre">'ignore'</span></code>.</p>
<p class="translated">Los datos con formato incorrecto se ignoran; la codificación o decodificación continúa sin previo aviso.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.replace_errors">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">replace_errors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.replace_errors" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Implementa el manejo de errores <code class="docutils literal notranslate"><span class="pre">'replace'</span></code> .</p>
<p class="translated">Sustituye <code class="docutils literal notranslate"><span class="pre">?</span></code> (carácter ASCII) por errores de codificación o <code class="docutils literal notranslate"><span class="pre">�</span></code> (U+FFFD, el CARÁCTER DE REEMPLAZO oficial) por errores de decodificación.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.backslashreplace_errors">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">backslashreplace_errors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.backslashreplace_errors" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Implementa el manejador de errores <code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code>.</p>
<p class="translated">Los datos con formato incorrecto se reemplazan por una secuencia de escape con barra invertida. Al codificar, emplea la forma hexadecimal del punto de código Unicode con los formatos <code class="samp docutils literal notranslate"><span class="pre">\x</span><em><span class="pre">hh</span></em></code> <code class="samp docutils literal notranslate"><span class="pre">\u</span><em><span class="pre">xxxx</span></em></code> <code class="samp docutils literal notranslate"><span class="pre">\U</span><em><span class="pre">xxxxxxxx</span></em></code>. Al decodificar, usa la forma hexadecimal del valor del byte con el formato <code class="samp docutils literal notranslate"><span class="pre">\x</span><em><span class="pre">hh</span></em></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Funciona con la decodificación y traducción.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.xmlcharrefreplace_errors">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">xmlcharrefreplace_errors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.xmlcharrefreplace_errors" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Implementa el manejador de errores <code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code> (solo para codificar dentro de <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encoding</span></a>).</p>
<p class="translated">El carácter no codificable se reemplaza por una referencia de carácter numérico XML/HTML adecuada, que es una forma decimal del punto de código Unicode con formato <code class="samp docutils literal notranslate"><span class="pre">&amp;#</span><em><span class="pre">num</span></em><span class="pre">;</span></code> .</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.namereplace_errors">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">namereplace_errors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exception</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.namereplace_errors" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Implementa el manejo de errores <code class="docutils literal notranslate"><span class="pre">'namereplace</span></code> (solo para codificar dentro de <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encoding</span></a>).</p>
<p class="translated">El carácter no codificable se reemplaza por una secuencia de escape <code class="docutils literal notranslate"><span class="pre">\N{...}</span></code>. El conjunto de caracteres que aparecen entre llaves es la propiedad Nombre de la Base de datos de Caracteres Unicode. Por ejemplo, la letra minúscula alemana <code class="docutils literal notranslate"><span class="pre">'ß'</span></code> se convertirá en la secuencia de bytes <code class="docutils literal notranslate"><span class="pre">\N{LATIN</span> <span class="pre">SMALL</span> <span class="pre">LETTER</span> <span class="pre">SHARP</span> <span class="pre">S}</span></code> .</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

</section>
<section id="stateless-encoding-and-decoding">
<span id="codec-objects"></span><h3 class="translated">Codificación y decodificación sin estado<a class="headerlink" href="#stateless-encoding-and-decoding" title="Link to this heading">¶</a></h3>
<p class="translated">La clase base <a class="reference internal" href="#codecs.Codec" title="codecs.Codec"><code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code></a> define estos métodos que también definen las interfaces de función del codificador y decodificador sin estado:</p>
<dl class="py class">
<dt class="sig sig-object py" id="codecs.Codec">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">Codec</span></span><a class="headerlink" href="#codecs.Codec" title="Link to this definition">¶</a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="codecs.Codec.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.Codec.encode" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Codifica el objeto <em>input</em> y retorna una tupla (objeto de salida, longitud consumida). Por ejemplo <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encoding</span></a> convierte un objeto de cadena de caracteres en un objeto de bytes utilizando una codificación de juego de caracteres particular (por ejemplo,``cp1252`` o <code class="docutils literal notranslate"><span class="pre">iso-8859-1</span></code>).</p>
<p class="translated">El argumento <em>errors</em> define el manejo de errores a aplicar. El valor predeterminado es el manejo <code class="docutils literal notranslate"><span class="pre">estricto</span></code>.</p>
<p class="translated">Es posible que el método no almacene estado en la instancia <a class="reference internal" href="#codecs.Codec" title="codecs.Codec"><code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code></a>. Use <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> para códecs que deben mantener el estado para que la codificación sea eficiente.</p>
<p class="translated">El codificador debe poder manejar la entrada de longitud cero y retornar un objeto vacío del tipo de objeto de salida en esta situación.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codecs.Codec.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.Codec.decode" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Decodifica el objeto <em>input</em> y retorna una tupla (objeto de salida, longitud consumida). Por ejemplo, para un <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">codificación de texto</span></a>, la decodificación convierte un objeto de bytes codificado usando una codificación de juego de caracteres particular en un objeto de cadena de caracteres.</p>
<p class="translated">Para codificaciones de texto y códecs de bytes a bytes, <em>input</em> debe ser un objeto de bytes o uno que proporcione la interfaz de búfer de solo lectura, por ejemplo, objetos de búfer y archivos mapeados en memoria.</p>
<p class="translated">El argumento <em>errors</em> define el manejo de errores a aplicar. El valor predeterminado es el manejo <code class="docutils literal notranslate"><span class="pre">estricto</span></code>.</p>
<p class="translated">Es posible que el método no almacene estado en la instancia de <a class="reference internal" href="#codecs.Codec" title="codecs.Codec"><code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code></a>. Use <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> para códecs que deben mantener el estado para que la decodificación sea eficiente.</p>
<p class="translated">El decodificador debe poder manejar la entrada de longitud cero y retornar un objeto vacío del tipo de objeto de salida en esta situación.</p>
</dd></dl>

</dd></dl>

</section>
<section id="incremental-encoding-and-decoding">
<h3 class="translated">Codificación y decodificación incrementales<a class="headerlink" href="#incremental-encoding-and-decoding" title="Link to this heading">¶</a></h3>
<p class="translated">Las clases <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a> y <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a> proporcionan la interfaz básica para la codificación y decodificación incrementales. La codificación/decodificación de la entrada no se realiza con una llamada a la función de codificador/decodificador sin estado, sino con varias llamadas al método <a class="reference internal" href="#codecs.IncrementalEncoder.encode" title="codecs.IncrementalEncoder.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a>/<a class="reference internal" href="#codecs.IncrementalDecoder.decode" title="codecs.IncrementalDecoder.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> del codificador incremental /decodificador. El codificador/decodificador incremental realiza un seguimiento del proceso de codificación/decodificación durante las llamadas a métodos.</p>
<p class="translated">La salida combinada de las llamadas al método <a class="reference internal" href="#codecs.IncrementalEncoder.encode" title="codecs.IncrementalEncoder.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a>/<a class="reference internal" href="#codecs.IncrementalDecoder.decode" title="codecs.IncrementalDecoder.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> es el mismo que si todas las entradas individuales se unieran en una, y esta entrada se codificara/decodificara con codificador/decodificador sin estado.</p>
<section id="incrementalencoder-objects">
<span id="incremental-encoder-objects"></span><h4 class="translated">Objetos IncrementalEncoder<a class="headerlink" href="#incrementalencoder-objects" title="Link to this heading">¶</a></h4>
<p class="translated">La clase <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a> se usa para codificar una entrada en varios pasos. Define los siguientes métodos que cada codificador incremental debe definir para ser compatible con el registro de códec Python.</p>
<dl class="py class">
<dt class="sig sig-object py" id="codecs.IncrementalEncoder">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">IncrementalEncoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Constructor para una clase instancia de <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a>.</p>
<p class="translated">Todos los codificadores incrementales deben proporcionar esta interfaz de constructor. Son libres de agregar argumentos de palabras clave adicionales, pero el registro de códecs de Python solo utiliza los definidos aquí.</p>
<p class="translated">La clase <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a> puede implementar diferentes esquemas de manejo de errores al proporcionar el argumento de palabra clave <em>errors</em>. Ver <a class="reference internal" href="#error-handlers"><span class="std std-ref">Manejadores de errores</span></a> para posibles valores.</p>
<p class="translated">El argumento <em>errors</em> se asignará a un atributo del mismo nombre. La asignación a este atributo hace posible cambiar entre diferentes estrategias de manejo de errores durante la vida útil del objeto <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="codecs.IncrementalEncoder.encode">
<span class="sig-name descname"><span class="pre">encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.encode" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Codifica <em>object</em> (teniendo en cuenta el estado actual del codificador) y retorna el objeto codificado resultante. Si esta es la última llamada a <a class="reference internal" href="#codecs.encode" title="codecs.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a> <em>final</em> debe ser verdadero (el valor predeterminado es falso).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codecs.IncrementalEncoder.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.reset" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Restablece el codificador al estado inicial. La salida se descarta: llama a <code class="docutils literal notranslate"><span class="pre">.encode(object,</span> <span class="pre">final=True)</span></code>, pasando un byte vacío o una cadena de texto si es necesario, para restablecer el codificador y obtener la salida.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codecs.IncrementalEncoder.getstate">
<span class="sig-name descname"><span class="pre">getstate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.getstate" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna el estado actual del codificador que debe ser un número entero. La implementación debe asegurarse de que <code class="docutils literal notranslate"><span class="pre">0</span></code> sea el estado más común. (Los estados que son más complicados que los enteros se pueden convertir en un entero al empaquetar/serializar el estado y codificar los bytes de la cadena resultante en un entero).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codecs.IncrementalEncoder.setstate">
<span class="sig-name descname"><span class="pre">setstate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.setstate" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Establece el estado del codificador en <em>state</em>. <em>state</em> debe ser un estado de codificador retornado por <a class="reference internal" href="#codecs.IncrementalEncoder.getstate" title="codecs.IncrementalEncoder.getstate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getstate()</span></code></a>.</p>
</dd></dl>

</dd></dl>

</section>
<section id="incrementaldecoder-objects">
<span id="incremental-decoder-objects"></span><h4 class="translated">Objetos IncrementalDecoder<a class="headerlink" href="#incrementaldecoder-objects" title="Link to this heading">¶</a></h4>
<p class="translated">La clase <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a> se usa para decodificar una entrada en varios pasos. Define los siguientes métodos que cada decodificador incremental debe definir para ser compatible con el registro de códec Python.</p>
<dl class="py class">
<dt class="sig sig-object py" id="codecs.IncrementalDecoder">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">IncrementalDecoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Constructor para una instancia de <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a>.</p>
<p class="translated">Todos los decodificadores incrementales deben proporcionar esta interfaz de constructor. Son libres de agregar argumentos de palabras clave adicionales, pero el registro de códecs de Python solo utiliza los definidos aquí.</p>
<p class="translated">La clase <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a> puede implementar diferentes esquemas de manejo de errores al proporcionar el argumento de palabra clave <em>errors</em>. Ver <a class="reference internal" href="#error-handlers"><span class="std std-ref">Manejadores de errores</span></a> para posibles valores.</p>
<p class="translated">El argumento <em>errors</em> se asignará a un atributo del mismo nombre. La asignación a este atributo hace posible cambiar entre diferentes estrategias de manejo de errores durante la vida útil del objeto <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="codecs.IncrementalDecoder.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.decode" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Decodifica <em>object</em> (teniendo en cuenta el estado actual del decodificador) y retorna el objeto decodificado resultante. Si esta es la última llamada a <a class="reference internal" href="#codecs.decode" title="codecs.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> <em>final</em> debe ser verdadero (el valor predeterminado es falso). Si <em>final</em> es verdadero, el decodificador debe decodificar la entrada por completo y debe vaciar todos los búferes. Si esto no es posible (por ejemplo, debido a secuencias de bytes incompletas al final de la entrada), debe iniciar el manejo de errores al igual que en el caso sin estado (lo que podría generar una excepción).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codecs.IncrementalDecoder.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.reset" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Restablece el decodificador al estado inicial.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codecs.IncrementalDecoder.getstate">
<span class="sig-name descname"><span class="pre">getstate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.getstate" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna el estado actual del decodificador. Debe ser una tupla con dos elementos, el primero debe ser el búfer que contiene la entrada aún sin codificar. El segundo debe ser un número entero y puede ser información de estado adicional. (La implementación debe asegurarse de que <code class="docutils literal notranslate"><span class="pre">0</span></code> sea la información de estado adicional más común). Si esta información de estado adicional es <code class="docutils literal notranslate"><span class="pre">0</span></code>, debe ser posible establecer el decodificador en el estado que no tiene entrada almacenada y <code class="docutils literal notranslate"><span class="pre">0</span></code> como información de estado adicional, de modo que alimentar la entrada previamente almacenada en el búfer al decodificador la retorna al estado anterior sin producir ninguna salida. (La información de estado adicional que es más complicada que los enteros se puede convertir en un entero al empaquetar/serializar la información y codificar los bytes de la cadena resultante en un entero).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codecs.IncrementalDecoder.setstate">
<span class="sig-name descname"><span class="pre">setstate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.setstate" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Establezca el estado del decodificador en <em>state</em>. <em>state</em> debe ser un estado de decodificador retornado por <a class="reference internal" href="#codecs.IncrementalDecoder.getstate" title="codecs.IncrementalDecoder.getstate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getstate()</span></code></a>.</p>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="stream-encoding-and-decoding">
<h3 class="translated">Codificación y decodificación de flujos<a class="headerlink" href="#stream-encoding-and-decoding" title="Link to this heading">¶</a></h3>
<p class="untranslated">The <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> and <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> classes provide generic
working interfaces which can be used to implement new encoding submodules very
easily. See <code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.utf_8</span></code> for an example of how this is done.</p>
<section id="streamwriter-objects">
<span id="stream-writer-objects"></span><h4 class="translated">Objetos StreamWriter<a class="headerlink" href="#streamwriter-objects" title="Link to this heading">¶</a></h4>
<p class="translated">La clase <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> es una subclase de <a class="reference internal" href="#codecs.Codec" title="codecs.Codec"><code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code></a> y define los siguientes métodos que cada escritor del flujo debe definir para ser compatible con el registro de códecs Python.</p>
<dl class="py class">
<dt class="sig sig-object py" id="codecs.StreamWriter">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">StreamWriter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stream</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Constructor para una instancia de <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>.</p>
<p class="translated">Todos los escritores de flujos deben proporcionar esta interfaz de constructor. Son libres de agregar argumentos de palabras clave adicionales, pero el registro de códecs de Python solo utiliza los definidos aquí.</p>
<p class="translated">El argumento <em>stream</em> debe ser un objeto tipo archivo abierto para escribir texto o datos binarios, según corresponda para el códec específico.</p>
<p class="translated">La clase <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> puede implementar diferentes esquemas de manejo de errores al proporcionar el argumento de palabra clave <em>errors</em>. Consulte <a class="reference internal" href="#error-handlers"><span class="std std-ref">Manejadores de errores</span></a> para ver los manejadores de errores estándar que puede admitir el códec de flujo subyacente.</p>
<p class="translated">El argumento <em>errors</em> se asignará a un atributo del mismo nombre. La asignación a este atributo hace posible cambiar entre diferentes estrategias de manejo de errores durante la vida útil del objeto <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="codecs.StreamWriter.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter.write" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Escribe el contenido del objeto codificado en el flujo.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codecs.StreamWriter.writelines">
<span class="sig-name descname"><span class="pre">writelines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter.writelines" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Escribe una lista concatenada de cadenas en el flujo (posiblemente reutilizando el método <a class="reference internal" href="#codecs.StreamWriter.write" title="codecs.StreamWriter.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a>). No se admiten iterables infinitos o muy grandes. Los códecs estándar de bytes a bytes no admiten este método.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codecs.StreamWriter.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter.reset" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Restablece los búfers de códec utilizados para mantener el estado interno.</p>
<p class="translated">Llamar a este método debería garantizar que los datos en la salida se pongan en un estado limpio que permita agregar datos nuevos sin tener que volver a escanear todo el flujo para recuperar el estado.</p>
</dd></dl>

</dd></dl>

<p class="translated">Además de los métodos anteriores, la clase <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> también debe heredar todos los demás métodos y atributos del flujo subyacente.</p>
</section>
<section id="streamreader-objects">
<span id="stream-reader-objects"></span><h4 class="translated">Objetos StreamReader<a class="headerlink" href="#streamreader-objects" title="Link to this heading">¶</a></h4>
<p class="translated">La clase <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> es una subclase de <a class="reference internal" href="#codecs.Codec" title="codecs.Codec"><code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code></a> y define los siguientes métodos que cada lector de flujo debe definir para ser compatible con el registro de códecs de Python.</p>
<dl class="py class">
<dt class="sig sig-object py" id="codecs.StreamReader">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">StreamReader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stream</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Constructor para una instancia de <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>.</p>
<p class="translated">Todos los lectores de flujo deben proporcionar esta interfaz de constructor. Son libres de agregar argumentos de palabras clave adicionales, pero el registro de códecs de Python solo utiliza los definidos aquí.</p>
<p class="translated">El argumento <em>stream</em> debe ser un objeto tipo archivo abierto para leer texto o datos binarios, según corresponda para el códec específico.</p>
<p class="translated">La clase <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> puede implementar diferentes esquemas de manejo de errores al proporcionar el argumento de palabra clave <em>errors</em>. Consulte <a class="reference internal" href="#error-handlers"><span class="std std-ref">Manejadores de errores</span></a> para ver los manejadores de errores estándar que puede admitir el códec de flujo subyacente.</p>
<p class="translated">El argumento <em>errors</em> se asignará a un atributo del mismo nombre. La asignación a este atributo hace posible cambiar entre diferentes estrategias de manejo de errores durante la vida útil del objeto <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>.</p>
<p class="translated">El conjunto de valores permitidos para el argumento <em>errors</em> se puede ampliar con <a class="reference internal" href="#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_error()</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="codecs.StreamReader.read">
<span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chars</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">firstline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.read" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Decodifica datos del flujo y retorna el objeto resultante.</p>
<p class="translated">El argumento <em>chars</em> indica el número de puntos de código decodificados o bytes a retornar. El método <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-func docutils literal notranslate"><span class="pre">read()</span></code></a> nunca retornará más datos de los solicitados, pero podría retornar menos, si no hay suficientes disponibles.</p>
<p class="translated">El argumento <em>size</em> indica el número máximo aproximado de bytes codificados o puntos de código para leer para la decodificación. El decodificador puede modificar esta configuración según corresponda. El valor predeterminado -1 indica leer y decodificar tanto como sea posible. Este parámetro está diseñado para evitar tener que decodificar archivos grandes en un solo paso.</p>
<p class="translated">La bandera <em>firstline</em> indica que sería suficiente retornar solo la primera línea, si hay errores de decodificación en las líneas posteriores.</p>
<p class="translated">El método debe usar una estrategia de lectura codiciosa, lo que significa que debe leer la mayor cantidad de datos permitidos dentro de la definición de la codificación y el tamaño dado, por ejemplo si las terminaciones de codificación opcionales o los marcadores de estado están disponibles en la transmisión, también deben leerse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codecs.StreamReader.readline">
<span class="sig-name descname"><span class="pre">readline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepends</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.readline" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Lee una línea del flujo de entrada y retorna los datos decodificados.</p>
<p class="translated"><em>size</em>, si se da, se pasa como argumento de tamaño al método <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> del <em>stream</em>.</p>
<p class="translated">Si <em>keepends</em> es falso, las terminaciones de línea se eliminarán de las líneas retornadas.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codecs.StreamReader.readlines">
<span class="sig-name descname"><span class="pre">readlines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sizehint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepends</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.readlines" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Lee todas las líneas disponibles en el flujo de entrada y las retorna como una lista de líneas.</p>
<p class="translated">Los finales de línea se implementan utilizando el método <a class="reference internal" href="#codecs.decode" title="codecs.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> del códec y se incluyen en las entradas de la lista si <em>keepends</em> es verdadero.</p>
<p class="translated"><em>sizehint</em>, si se proporciona, se pasa como argumento <em>size</em> al método <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> del <em>stream</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codecs.StreamReader.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.reset" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Restablece los búfers de códec utilizados para mantener el estado interno.</p>
<p class="translated">Tenga en cuenta que ningún reposicionamiento de flujo debe suceder. Este método está destinado principalmente a poder recuperarse de errores de decodificación.</p>
</dd></dl>

</dd></dl>

<p class="translated">Además de los métodos anteriores, la clase <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> también debe heredar todos los demás métodos y atributos del flujo subyacente.</p>
</section>
<section id="streamreaderwriter-objects">
<span id="stream-reader-writer"></span><h4 class="translated">Objetos StreamReaderWriter<a class="headerlink" href="#streamreaderwriter-objects" title="Link to this heading">¶</a></h4>
<p class="translated">La clase <a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReaderWriter</span></code></a> es una clase de conveniencia que permite envolver flujos que funcionan tanto en modo de lectura como de escritura.</p>
<p class="translated">El diseño es tal que uno puede usar las funciones de fábrica retornadas por la función <a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal notranslate"><span class="pre">lookup()</span></code></a> para construir la instancia.</p>
<dl class="py class">
<dt class="sig sig-object py" id="codecs.StreamReaderWriter">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">StreamReaderWriter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stream</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Reader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Writer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReaderWriter" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Crea una instancia de <a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReaderWriter</span></code></a>. <em>stream</em> debe ser un objeto similar a un archivo. <em>Reader</em> y <em>Writer</em> deben ser funciones o clases de fábrica que proporcionen la interfaz <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> y <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> respectivamente. El manejo de errores se realiza de la misma manera que se define para los lectores y escritores de flujos.</p>
</dd></dl>

<p class="translated">Las instancias <a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReaderWriter</span></code></a> definen las interfaces combinadas de <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> y clases <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>. Heredan todos los demás métodos y atributos del flujo subyacente.</p>
</section>
<section id="streamrecoder-objects">
<span id="stream-recoder-objects"></span><h4 class="translated">Objetos StreamRecoder<a class="headerlink" href="#streamrecoder-objects" title="Link to this heading">¶</a></h4>
<p class="translated">La clase <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamRecoder</span></code></a> traduce datos de una codificación a otra, lo que a veces es útil cuando se trata de diferentes entornos de codificación.</p>
<p class="translated">El diseño es tal que uno puede usar las funciones de fábrica retornadas por la función <a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal notranslate"><span class="pre">lookup()</span></code></a> para construir la instancia.</p>
<dl class="py class">
<dt class="sig sig-object py" id="codecs.StreamRecoder">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">StreamRecoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stream</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Reader</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Writer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamRecoder" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Creates a <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamRecoder</span></code></a> instance which implements a two-way conversion:
<em>encode</em> and <em>decode</em> work on the frontend — the data visible to
code calling <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> and <a class="reference internal" href="#codecs.StreamWriter.write" title="codecs.StreamWriter.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a>,
while <em>Reader</em> and <em>Writer</em>
work on the backend — the data in <em>stream</em>.</p>
<p class="translated">Puede usar estos objetos para realizar transcodificaciones transparentes, por ejemplo, de Latin-1 a UTF-8 y viceversa.</p>
<p class="translated">El argumento <em>stream</em> debe ser un objeto similar a un archivo.</p>
<p class="translated">Los argumentos <em>encode</em> y <em>decode</em> deben cumplir con la interfaz de <a class="reference internal" href="#codecs.Codec" title="codecs.Codec"><code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code></a>. <em>Reader</em> y <em>Writer</em> deben ser funciones o clases de fábrica que proporcionen objetos de la interfaz <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> y <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> respectivamente.</p>
<p class="translated">El manejo de errores se realiza de la misma manera que se define para los lectores y escritores de flujos.</p>
</dd></dl>

<p class="translated">las instancias <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamRecoder</span></code></a> definen las interfaces combinadas de las clases <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> y <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>. Heredan todos los demás métodos y atributos del flujo subyacente.</p>
</section>
</section>
</section>
<section id="encodings-and-unicode">
<span id="encodings-overview"></span><h2 class="translated">Codificaciones y Unicode<a class="headerlink" href="#encodings-and-unicode" title="Link to this heading">¶</a></h2>
<p class="translated">Las cadenas de caracteres se almacenan internamente como secuencias de puntos de código en el rango <code class="docutils literal notranslate"><span class="pre">U+0000</span></code>–<code class="docutils literal notranslate"><span class="pre">U+10FFFF</span></code>. (Consultar <span class="target" id="index-25"></span><a class="pep reference external" href="https://peps.python.org/pep-0393/"><strong>PEP 393</strong></a> para obtener más detalles sobre la implementación). Una vez utilizado un objeto de cadena de caracteres fuera de la CPU y de la memoria, la <em>endianness</em> y cómo se almacenan estas matrices como bytes se convierte en un problema. Al igual que con otros códecs, la serialización de una cadena en una secuencia de bytes se conoce como codificación, y la recreación de la cadena a partir de los bytes se conoce como decodificación. Hay múltiples códecs para la serialización de texto, a los que se puede consultar colectivamente mediante <a class="reference internal" href="../glossary.html#term-text-encoding"><span class="xref std std-term">text encodings</span></a>.</p>
<p class="translated">La codificación de texto más simple (llamada <code class="docutils literal notranslate"><span class="pre">'latin-1'</span></code> o <code class="docutils literal notranslate"><span class="pre">'iso-8859-1'</span></code>) asigna los puntos de código 0–255 a los bytes <code class="docutils literal notranslate"><span class="pre">0x0</span></code> – <code class="docutils literal notranslate"><span class="pre">0xff</span></code>, lo que significa que un objeto de cadena de caracteres que contiene puntos de código encima de <code class="docutils literal notranslate"><span class="pre">U+00FF</span></code> no se puede codificar con este códec. Al hacerlo, lanzará un <a class="reference internal" href="exceptions.html#UnicodeEncodeError" title="UnicodeEncodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a> que se parece a lo siguiente (aunque los detalles del mensaje de error pueden diferir): <code class="docutils literal notranslate"><span class="pre">UnicodeEncodeError:</span> <span class="pre">'latin-1'</span> <span class="pre">codec</span> <span class="pre">can't</span> <span class="pre">encode</span> <span class="pre">character</span> <span class="pre">'\u1234'</span> <span class="pre">'in</span> <span class="pre">position</span> <span class="pre">3:</span> <span class="pre">ordinal</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">range(256)</span></code>.</p>
<p class="translated">Hay otro grupo de codificaciones (las llamadas codificaciones de mapa de caracteres) que eligen un subconjunto diferente de todos los puntos de código Unicode y cómo estos puntos de código se asignan a los bytes <code class="docutils literal notranslate"><span class="pre">0x0</span></code> – <code class="docutils literal notranslate"><span class="pre">0xff</span></code>. Para ver cómo se hace esto, simplemente abra, por ejemplo <code class="file docutils literal notranslate"><span class="pre">encodings/cp1252.py</span></code> (que es una codificación que se usa principalmente en Windows). Hay una cadena constante con 256 caracteres que le muestra qué carácter está asignado a qué valor de byte.</p>
<p class="translated">Todas estas codificaciones solo pueden codificar 256 de los 1114112 puntos de código definidos en Unicode. Una manera simple y directa que permita almacenar cada punto de código Unicode, es almacenar cada punto de código como cuatro bytes consecutivos. Hay dos posibilidades: almacenar los bytes en orden <em>big endian</em> o <em>little endian</em>. Estas dos codificaciones se denominan <code class="docutils literal notranslate"><span class="pre">UTF-32-BE</span></code> y <code class="docutils literal notranslate"><span class="pre">UTF-32-LE</span></code> respectivamente. Su desventaja es que, si por ejemplo, usa <code class="docutils literal notranslate"><span class="pre">UTF-32-BE</span></code> en una pequeña máquina <em>endian</em>, siempre tendrá que intercambiar bytes en la codificación y decodificación. <code class="docutils literal notranslate"><span class="pre">UTF-32</span></code> evita este problema: los bytes siempre estarán en <em>endianness</em> natural. Cuando estos bytes son leídos por una CPU con una <em>endianness</em> diferente, entonces los bytes deben intercambiarse. Para poder detectar el <em>endian</em> de una secuencia de bytes <code class="docutils literal notranslate"><span class="pre">UTF-16</span></code> o <code class="docutils literal notranslate"><span class="pre">UTF-32</span></code>, existe la llamada BOM («Marca de orden de bytes», o en inglés <em>Byte Order Mark</em>). Este es el carácter Unicode <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code>. Este carácter puede anteponerse a cada secuencia de bytes <code class="docutils literal notranslate"><span class="pre">UTF-16</span></code> o <code class="docutils literal notranslate"><span class="pre">UTF-32</span></code>. La versión intercambiada de bytes de este carácter (<code class="docutils literal notranslate"><span class="pre">0xFFFE</span></code>) es un carácter ilegal que puede no aparecer en un texto Unicode. Entonces, cuando el primer carácter en una secuencia de bytes <code class="docutils literal notranslate"><span class="pre">UTF-16</span></code> o <code class="docutils literal notranslate"><span class="pre">UTF-32</span></code> parece ser un <code class="docutils literal notranslate"><span class="pre">U+FFFE</span></code>, los bytes deben intercambiarse en la decodificación. Desafortunadamente, el carácter <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code> tenía un segundo propósito como <code class="docutils literal notranslate"><span class="pre">ESPACIO</span> <span class="pre">DE</span> <span class="pre">ANCHO</span> <span class="pre">CERO</span> <span class="pre">SIN</span> <span class="pre">QUIEBRA</span></code>: un carácter que no tiene ancho y no permite dividir una palabra. Por ejemplo, puede ser usado para dar pistas a un algoritmo de ligadura. Con Unicode 4.0, el uso de <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code> como <code class="docutils literal notranslate"><span class="pre">ESPACIO</span> <span class="pre">DE</span> <span class="pre">ANCHO</span> <span class="pre">CERO</span> <span class="pre">SIN</span> <span class="pre">QUIEBRA</span></code> ha quedado obsoleto (con <code class="docutils literal notranslate"><span class="pre">U+2060</span></code> (<code class="docutils literal notranslate"><span class="pre">WORD</span> <span class="pre">JOINER</span></code>) asumiendo este rol). Sin embargo, el software Unicode aún debe ser capaz de manejar <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code> en ambos roles: como BOM, es un dispositivo para determinar el diseño de almacenamiento de los bytes codificados, y desaparece una vez que la secuencia de bytes ha sido decodificada en una cadena; como un <code class="docutils literal notranslate"><span class="pre">ESPACIO</span> <span class="pre">DE</span> <span class="pre">ANCHO</span> <span class="pre">CERO</span> <span class="pre">SIN</span> <span class="pre">QUIEBRA</span></code> es un carácter normal que se decodificará como cualquier otro.</p>
<p class="translated">Hay otra codificación que puede codificar el rango completo de caracteres Unicode: UTF-8. UTF-8 es una codificación de 8 bits, lo que significa que no hay problemas con el orden de bytes en UTF-8. Cada byte en una secuencia de bytes UTF-8 consta de dos partes: bits marcadores (los bits más significativos) y bits de carga útil. Los bits marcadores son una secuencia de cero a cuatro bits <code class="docutils literal notranslate"><span class="pre">1</span></code> seguidos de un bit <code class="docutils literal notranslate"><span class="pre">0</span></code>. Los caracteres Unicode se codifican de esta manera (con x siendo bits de carga útil, que cuando se concatenan dan el carácter Unicode):</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Rango</p></th>
<th class="head"><p class="translated">Codificación</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">U-00000000</span></code> … <code class="docutils literal notranslate"><span class="pre">U-0000007F</span></code></p></td>
<td><p class="translated">0xxxxxxx</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">U-00000080</span></code> … <code class="docutils literal notranslate"><span class="pre">U-000007FF</span></code></p></td>
<td><p class="translated">110xxxxx 10xxxxxx</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">U-00000800</span></code> … <code class="docutils literal notranslate"><span class="pre">U-0000FFFF</span></code></p></td>
<td><p class="translated">1110xxxx 10xxxxxx 10xxxxxx</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">U-00010000</span></code> … <code class="docutils literal notranslate"><span class="pre">U-0010FFFF</span></code></p></td>
<td><p class="translated">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p></td>
</tr>
</tbody>
</table>
<p class="translated">El bit menos significativo del carácter Unicode es el bit x más a la derecha.</p>
<p class="translated">Como UTF-8 es una codificación de 8 bits, no se requiere una lista de materiales y cualquier carácter <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code> en la cadena decodificada (incluso si es el primer carácter) se trata como un <code class="docutils literal notranslate"><span class="pre">ESPACIO</span> <span class="pre">SIN</span> <span class="pre">QUIEBRE</span> <span class="pre">DE</span> <span class="pre">ANCHO</span> <span class="pre">CERO</span></code> (<em>``ZERO WIDTH NO-BREAK SPACE``</em>).</p>
<p class="translated">Sin información externa, es imposible determinar de manera fidedigna qué codificación se utilizó para codificar una cadena de caracteres. Cada codificación de mapa de caracteres puede decodificar cualquier secuencia de bytes aleatoria. Sin embargo, eso no es posible con UTF-8, ya que las secuencias de bytes UTF-8 tienen una estructura que no permite secuencias de bytes arbitrarias. Para aumentar la confiabilidad con la que se puede detectar una codificación UTF-8, Microsoft inventó una variante de UTF-8 (que Python 2.5 llama <code class="docutils literal notranslate"><span class="pre">&quot;utf-8-sig&quot;</span></code>) para su programa Bloc de notas: Antes de que cualquier carácter Unicode sea escrito en un archivo, se escribe un BOM codificado en UTF-8 (que se muestra como una secuencia de bytes: <code class="docutils literal notranslate"><span class="pre">0xef</span></code>, <code class="docutils literal notranslate"><span class="pre">0xbb</span></code>, <code class="docutils literal notranslate"><span class="pre">0xbf</span></code>). Como es bastante improbable que cualquier archivo codificado del mapa de caracteres comience con estos valores de bytes (que, por ejemplo, se asignarían a</p>
<blockquote>
<div><div class="line-block">
<div class="translated line">LETRA LATINA PEQUEÑA I CON DIAERESIS</div>
<div class="translated line">SEÑALADO A LA DERECHA DE DOBLE ÁNGULO MARCA DE CITA</div>
<div class="translated line">SIGNO DE PREGUNTA INVERTIDO</div>
</div>
</div></blockquote>
<p class="translated">en iso-8859-1), esto aumenta la probabilidad de que una codificación <code class="docutils literal notranslate"><span class="pre">utf-8-sig</span></code> pueda adivinarse correctamente a partir de la secuencia de bytes. Por lo tanto, aquí la lista de materiales no se utiliza para poder determinar el orden de bytes utilizado para generar la secuencia de bytes, sino como una firma que ayuda a adivinar la codificación. Al codificar, el códec utf-8-sig escribirá <code class="docutils literal notranslate"><span class="pre">0xef</span></code>, <code class="docutils literal notranslate"><span class="pre">0xbb</span></code>, <code class="docutils literal notranslate"><span class="pre">0xbf</span></code> como los primeros tres bytes del archivo. Al decodificar, <code class="docutils literal notranslate"><span class="pre">utf-8-sig</span></code> omitirá esos tres bytes si aparecen como los primeros tres bytes en el archivo. En UTF-8, se desaconseja el uso de la lista de materiales y, en general, debe evitarse.</p>
</section>
<section id="standard-encodings">
<span id="id3"></span><h2 class="translated">Codificaciones estándar<a class="headerlink" href="#standard-encodings" title="Link to this heading">¶</a></h2>
<p class="untranslated">Python comes with a number of codecs built-in, either implemented as C functions
or with dictionaries as mapping tables. The following table lists the codecs by
name, together with a few common aliases, and the languages for which the
encoding is likely used. Neither the list of aliases nor the list of languages
is meant to be exhaustive. Notice that spelling alternatives that only differ in
case or use a space or a hyphen instead of an underscore are also valid aliases
because they are equivalent when normalized by
<a class="reference internal" href="#encodings.normalize_encoding" title="encodings.normalize_encoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">normalize_encoding()</span></code></a>. For example, <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> is a valid
alias for the <code class="docutils literal notranslate"><span class="pre">'utf_8'</span></code> codec.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">The below table lists the most common aliases, for a complete list
refer to the source <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/main/Lib/encodings/aliases.py">aliases.py</a> file.</p>
</div>
<p class="untranslated">On Windows, <code class="docutils literal notranslate"><span class="pre">cpXXX</span></code> codecs are available for all code pages.
But only codecs listed in the following table are guarantead to exist on
other platforms.</p>
<div class="impl-detail compound">
<p class="translated">Algunas codificaciones comunes pueden omitir la maquinaria de búsqueda de códecs para mejorar el rendimiento. CPython solo reconoce estas oportunidades de optimización para un conjunto limitado de alias (sin distinción entre mayúsculas y minúsculas): utf-8, utf8, latin-1, latin1, iso-8859-1, iso8859-1, mbcs (solo Windows), ascii, us-ascii, utf-16, utf16, utf-32, utf32, y lo mismo usando guiones bajos en lugar de guiones. El uso de alias alternativos para estas codificaciones puede resultar en una ejecución más lenta.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Oportunidad de optimización reconocida para us-ascii.</p>
</div>
</div>
<p class="translated">Muchos de los juegos de caracteres admiten los mismos idiomas. Varían en caracteres individuales (por ejemplo, si el SIGNO EURO es compatible o no), y en la asignación de caracteres para codificar posiciones. Para los idiomas europeos en particular, generalmente existen las siguientes variantes:</p>
<ul class="simple">
<li><p class="translated">un conjunto de códigos ISO 8859</p></li>
<li><p class="translated">una página de códigos de Microsoft Windows, que generalmente se deriva de un conjunto de códigos 8859, pero reemplaza los caracteres de control con caracteres gráficos adicionales</p></li>
<li><p class="translated">una página de códigos EBCDIC de IBM</p></li>
<li><p class="translated">una página de códigos de IBM PC, que es compatible con ASCII</p></li>
</ul>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Códec</p></th>
<th class="head"><p class="translated">Aliases</p></th>
<th class="head"><p class="translated">Lenguajes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated">ascii</p></td>
<td><p class="translated">646, us-ascii</p></td>
<td><p class="translated">Inglés</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">big5</p></td>
<td><p class="translated">big5-tw, csbig5</p></td>
<td><p class="translated">Chino Tradicional</p></td>
</tr>
<tr class="row-even"><td><p class="translated">big5hkscs</p></td>
<td><p class="translated">big5-hkscs, hkscs</p></td>
<td><p class="translated">Chino Tradicional</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp037</p></td>
<td><p class="translated">IBM037, IBM039</p></td>
<td><p class="translated">Inglés</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp273</p></td>
<td><p class="translated">273, IBM273, csIBM273</p></td>
<td><p class="translated">Alemán</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p class="translated">cp424</p></td>
<td><p class="translated">EBCDIC-CP-HE, IBM424</p></td>
<td><p class="translated">Hebreo</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp437</p></td>
<td><p class="translated">437, IBM437</p></td>
<td><p class="translated">Inglés</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp500</p></td>
<td><p class="translated">EBCDIC-CP-BE, EBCDIC-CP-CH,
IBM500</p></td>
<td><p class="translated">Europa Occidental</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp720</p></td>
<td></td>
<td><p class="translated">Árabe</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp737</p></td>
<td></td>
<td><p class="translated">Griego</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp775</p></td>
<td><p class="translated">IBM775</p></td>
<td><p class="translated">Lenguajes bálticos</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp850</p></td>
<td><p class="translated">850, IBM850</p></td>
<td><p class="translated">Europa Occidental</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp852</p></td>
<td><p class="translated">852, IBM852</p></td>
<td><p class="translated">Europa central y del este</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp855</p></td>
<td><p class="translated">855, IBM855</p></td>
<td><p class="untranslated">Belarusian, Bulgarian,
Macedonian, Russian, Serbian</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp856</p></td>
<td></td>
<td><p class="translated">Hebreo</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp857</p></td>
<td><p class="translated">857, IBM857</p></td>
<td><p class="translated">Turco</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp858</p></td>
<td><p class="translated">858, IBM858</p></td>
<td><p class="translated">Europa Occidental</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp860</p></td>
<td><p class="translated">860, IBM860</p></td>
<td><p class="translated">Portugués</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp861</p></td>
<td><p class="translated">861, CP-IS, IBM861</p></td>
<td><p class="translated">Islandés</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp862</p></td>
<td><p class="translated">862, IBM862</p></td>
<td><p class="translated">Hebreo</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp863</p></td>
<td><p class="translated">863, IBM863</p></td>
<td><p class="translated">Canadiense</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp864</p></td>
<td><p class="translated">IBM864</p></td>
<td><p class="translated">Árabe</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp865</p></td>
<td><p class="translated">865, IBM865</p></td>
<td><p class="translated">Danés, Noruego</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp866</p></td>
<td><p class="translated">866, IBM866</p></td>
<td><p class="translated">Ruso</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp869</p></td>
<td><p class="translated">869, CP-GR, IBM869</p></td>
<td><p class="translated">Griego</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp874</p></td>
<td></td>
<td><p class="translated">Tailandés</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp875</p></td>
<td></td>
<td><p class="translated">Griego</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp932</p></td>
<td><p class="untranslated">932, ms932, mskanji, ms-kanji,
windows-31j</p></td>
<td><p class="translated">Japonés</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp949</p></td>
<td><p class="translated">949, ms949, uhc</p></td>
<td><p class="translated">Coreano</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp950</p></td>
<td><p class="translated">950, ms950</p></td>
<td><p class="translated">Chino Tradicional</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp1006</p></td>
<td></td>
<td><p class="translated">Urdu</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp1026</p></td>
<td><p class="translated">ibm1026</p></td>
<td><p class="translated">Turco</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp1125</p></td>
<td><p class="translated">1125, ibm1125, cp866u, ruscii</p></td>
<td><p class="translated">Ucraniano</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p class="translated">cp1140</p></td>
<td><p class="translated">ibm1140</p></td>
<td><p class="translated">Europa Occidental</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp1250</p></td>
<td><p class="translated">windows-1250</p></td>
<td><p class="translated">Europa central y del este</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp1251</p></td>
<td><p class="translated">windows-1251</p></td>
<td><p class="untranslated">Belarusian, Bulgarian,
Macedonian, Russian, Serbian</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp1252</p></td>
<td><p class="translated">windows-1252</p></td>
<td><p class="translated">Europa Occidental</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp1253</p></td>
<td><p class="translated">windows-1253</p></td>
<td><p class="translated">Griego</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp1254</p></td>
<td><p class="translated">windows-1254</p></td>
<td><p class="translated">Turco</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp1255</p></td>
<td><p class="translated">windows-1255</p></td>
<td><p class="translated">Hebreo</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp1256</p></td>
<td><p class="translated">windows-1256</p></td>
<td><p class="translated">Árabe</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">cp1257</p></td>
<td><p class="translated">windows-1257</p></td>
<td><p class="translated">Lenguajes bálticos</p></td>
</tr>
<tr class="row-even"><td><p class="translated">cp1258</p></td>
<td><p class="translated">windows-1258</p></td>
<td><p class="translated">Vietnamita</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">euc_jp</p></td>
<td><p class="translated">eucjp, ujis, u-jis</p></td>
<td><p class="translated">Japonés</p></td>
</tr>
<tr class="row-even"><td><p class="translated">euc_jis_2004</p></td>
<td><p class="translated">jisx0213, eucjis2004</p></td>
<td><p class="translated">Japonés</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">euc_jisx0213</p></td>
<td><p class="translated">eucjisx0213</p></td>
<td><p class="translated">Japonés</p></td>
</tr>
<tr class="row-even"><td><p class="translated">euc_kr</p></td>
<td><p class="translated">euckr, korean, ksc5601,
ks_c-5601, ks_c-5601-1987,
ksx1001, ks_x-1001</p></td>
<td><p class="translated">Coreano</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">gb2312</p></td>
<td><p class="translated">chinese, csiso58gb231280,
euc-cn, euccn, eucgb2312-cn,
gb2312-1980, gb2312-80,
iso-ir-58</p></td>
<td><p class="translated">Chino simplificado</p></td>
</tr>
<tr class="row-even"><td><p class="translated">gbk</p></td>
<td><p class="translated">936, cp936, ms936</p></td>
<td><p class="translated">Chino Unificado</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">gb18030</p></td>
<td><p class="translated">gb18030-2000</p></td>
<td><p class="translated">Chino Unificado</p></td>
</tr>
<tr class="row-even"><td><p class="translated">hz</p></td>
<td><p class="translated">hzgb, hz-gb, hz-gb-2312</p></td>
<td><p class="translated">Chino simplificado</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">iso2022_jp</p></td>
<td><p class="translated">csiso2022jp, iso2022jp,
iso-2022-jp</p></td>
<td><p class="translated">Japonés</p></td>
</tr>
<tr class="row-even"><td><p class="translated">iso2022_jp_1</p></td>
<td><p class="translated">iso2022jp-1, iso-2022-jp-1</p></td>
<td><p class="translated">Japonés</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">iso2022_jp_2</p></td>
<td><p class="translated">iso2022jp-2, iso-2022-jp-2</p></td>
<td><p class="translated">Japonés, Coreano, Chino simplificado, Europa occidental, Griego</p></td>
</tr>
<tr class="row-even"><td><p class="translated">iso2022_jp_2004</p></td>
<td><p class="translated">iso2022jp-2004,
iso-2022-jp-2004</p></td>
<td><p class="translated">Japonés</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">iso2022_jp_3</p></td>
<td><p class="translated">iso2022jp-3, iso-2022-jp-3</p></td>
<td><p class="translated">Japonés</p></td>
</tr>
<tr class="row-even"><td><p class="translated">iso2022_jp_ext</p></td>
<td><p class="translated">iso2022jp-ext, iso-2022-jp-ext</p></td>
<td><p class="translated">Japonés</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">iso2022_kr</p></td>
<td><p class="translated">csiso2022kr, iso2022kr,
iso-2022-kr</p></td>
<td><p class="translated">Coreano</p></td>
</tr>
<tr class="row-even"><td><p class="translated">latin_1</p></td>
<td><p class="translated">iso-8859-1, iso8859-1, 8859,
cp819, latin, latin1, L1</p></td>
<td><p class="translated">Europa Occidental</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">iso8859_2</p></td>
<td><p class="translated">iso-8859-2, latin2, L2</p></td>
<td><p class="translated">Europa central y del este</p></td>
</tr>
<tr class="row-even"><td><p class="translated">iso8859_3</p></td>
<td><p class="translated">iso-8859-3, latin3, L3</p></td>
<td><p class="translated">Esperanto, Maltés</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">iso8859_4</p></td>
<td><p class="translated">iso-8859-4, latin4, L4</p></td>
<td><p class="untranslated">Northern Europe</p></td>
</tr>
<tr class="row-even"><td><p class="translated">iso8859_5</p></td>
<td><p class="translated">iso-8859-5, cyrillic</p></td>
<td><p class="untranslated">Belarusian, Bulgarian,
Macedonian, Russian, Serbian</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">iso8859_6</p></td>
<td><p class="translated">iso-8859-6, arabic</p></td>
<td><p class="translated">Árabe</p></td>
</tr>
<tr class="row-even"><td><p class="translated">iso8859_7</p></td>
<td><p class="translated">iso-8859-7, greek, greek8</p></td>
<td><p class="translated">Griego</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">iso8859_8</p></td>
<td><p class="translated">iso-8859-8, hebrew</p></td>
<td><p class="translated">Hebreo</p></td>
</tr>
<tr class="row-even"><td><p class="translated">iso8859_9</p></td>
<td><p class="translated">iso-8859-9, latin5, L5</p></td>
<td><p class="translated">Turco</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">iso8859_10</p></td>
<td><p class="translated">iso-8859-10, latin6, L6</p></td>
<td><p class="translated">Lenguajes nórdicos</p></td>
</tr>
<tr class="row-even"><td><p class="translated">iso8859_11</p></td>
<td><p class="translated">iso-8859-11, thai</p></td>
<td><p class="translated">Lenguajes tailandeses</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">iso8859_13</p></td>
<td><p class="translated">iso-8859-13, latin7, L7</p></td>
<td><p class="translated">Lenguajes bálticos</p></td>
</tr>
<tr class="row-even"><td><p class="translated">iso8859_14</p></td>
<td><p class="translated">iso-8859-14, latin8, L8</p></td>
<td><p class="translated">Lenguajes Celtas</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">iso8859_15</p></td>
<td><p class="translated">iso-8859-15, latin9, L9</p></td>
<td><p class="translated">Europa Occidental</p></td>
</tr>
<tr class="row-even"><td><p class="translated">iso8859_16</p></td>
<td><p class="translated">iso-8859-16, latin10, L10</p></td>
<td><p class="translated">Europa sudoriental</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">johab</p></td>
<td><p class="translated">cp1361, ms1361</p></td>
<td><p class="translated">Coreano</p></td>
</tr>
<tr class="row-even"><td><p class="translated">koi8_r</p></td>
<td></td>
<td><p class="translated">Ruso</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">koi8_t</p></td>
<td></td>
<td><p class="translated">Tayiko</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</td>
</tr>
<tr class="row-even"><td><p class="translated">koi8_u</p></td>
<td></td>
<td><p class="translated">Ucraniano</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">kz1048</p></td>
<td><p class="translated">kz_1048, strk1048_2002, rk1048</p></td>
<td><p class="translated">Kazajo</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</td>
</tr>
<tr class="row-even"><td><p class="translated">mac_cyrillic</p></td>
<td><p class="translated">maccyrillic</p></td>
<td><p class="untranslated">Belarusian, Bulgarian,
Macedonian, Russian, Serbian</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">mac_greek</p></td>
<td><p class="translated">macgreek</p></td>
<td><p class="translated">Griego</p></td>
</tr>
<tr class="row-even"><td><p class="translated">mac_iceland</p></td>
<td><p class="translated">maciceland</p></td>
<td><p class="translated">Islandés</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">mac_latin2</p></td>
<td><p class="translated">maclatin2, maccentraleurope,
mac_centeuro</p></td>
<td><p class="translated">Europa central y del este</p></td>
</tr>
<tr class="row-even"><td><p class="translated">mac_roman</p></td>
<td><p class="translated">macroman, macintosh</p></td>
<td><p class="translated">Europa Occidental</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">mac_turkish</p></td>
<td><p class="translated">macturkish</p></td>
<td><p class="translated">Turco</p></td>
</tr>
<tr class="row-even"><td><p class="translated">ptcp154</p></td>
<td><p class="translated">csptcp154, pt154, cp154,
cyrillic-asian</p></td>
<td><p class="translated">Kazajo</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">shift_jis</p></td>
<td><p class="translated">csshiftjis, shiftjis, sjis,
s_jis</p></td>
<td><p class="translated">Japonés</p></td>
</tr>
<tr class="row-even"><td><p class="translated">shift_jis_2004</p></td>
<td><p class="translated">shiftjis2004, sjis_2004,
sjis2004</p></td>
<td><p class="translated">Japonés</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">shift_jisx0213</p></td>
<td><p class="translated">shiftjisx0213, sjisx0213,
s_jisx0213</p></td>
<td><p class="translated">Japonés</p></td>
</tr>
<tr class="row-even"><td><p class="translated">utf_32</p></td>
<td><p class="translated">U32, utf32</p></td>
<td><p class="translated">todos los lenguajes</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">utf_32_be</p></td>
<td><p class="translated">UTF-32BE</p></td>
<td><p class="translated">todos los lenguajes</p></td>
</tr>
<tr class="row-even"><td><p class="translated">utf_32_le</p></td>
<td><p class="translated">UTF-32LE</p></td>
<td><p class="translated">todos los lenguajes</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">utf_16</p></td>
<td><p class="translated">U16, utf16</p></td>
<td><p class="translated">todos los lenguajes</p></td>
</tr>
<tr class="row-even"><td><p class="translated">utf_16_be</p></td>
<td><p class="translated">UTF-16BE</p></td>
<td><p class="translated">todos los lenguajes</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">utf_16_le</p></td>
<td><p class="translated">UTF-16LE</p></td>
<td><p class="translated">todos los lenguajes</p></td>
</tr>
<tr class="row-even"><td><p class="translated">utf_7</p></td>
<td><p class="translated">U7, unicode-1-1-utf-7</p></td>
<td><p class="translated">todos los lenguajes</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">utf_8</p></td>
<td><p class="translated">U8, UTF, utf8, cp65001</p></td>
<td><p class="translated">todos los lenguajes</p></td>
</tr>
<tr class="row-even"><td><p class="translated">utf_8_sig</p></td>
<td><p class="untranslated">utf8-sig</p></td>
<td><p class="translated">todos los lenguajes</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Los codificadores utf-16* y utf-32* ya no permiten codificar puntos de código sustitutos (<code class="docutils literal notranslate"><span class="pre">U+D800</span></code> – <code class="docutils literal notranslate"><span class="pre">U+DFFF</span></code>). Los decodificadores utf-32* ya no decodifican secuencias de bytes que corresponden a puntos de código sustituto.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span><code class="docutils literal notranslate"><span class="pre">cp65001</span></code> ahora es un alias de <code class="docutils literal notranslate"><span class="pre">utf_8</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.14: </span>On Windows, <code class="docutils literal notranslate"><span class="pre">cpXXX</span></code> codecs are now available for all code pages.</p>
</div>
</section>
<section id="python-specific-encodings">
<h2 class="translated">Codificaciones específicas de Python<a class="headerlink" href="#python-specific-encodings" title="Link to this heading">¶</a></h2>
<p class="translated">Varios códecs predefinidos son específicos de Python, por lo que sus nombres de códec no tienen significado fuera de Python. Estos se enumeran en las tablas a continuación según los tipos de entrada y salida esperados (tenga en cuenta que si bien las codificaciones de texto son el caso de uso más común para los códecs, la infraestructura de códecs subyacente admite transformaciones de datos arbitrarias en lugar de solo codificaciones de texto). Para los códecs asimétricos, el significado indicado describe la dirección de codificación.</p>
<section id="text-encodings">
<h3 class="translated">Codificaciones de texto<a class="headerlink" href="#text-encodings" title="Link to this heading">¶</a></h3>
<p class="translated">Los siguientes códecs proporcionan codificación de <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> y decodificación de <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> a <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, similar a las codificaciones de texto Unicode.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Códec</p></th>
<th class="head"><p class="translated">Aliases</p></th>
<th class="head"><p class="translated">Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated">idna</p></td>
<td></td>
<td><p class="translated">Implementar <span class="target" id="index-26"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3490.html"><strong>RFC 3490</strong></a>, ver también <a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.idna</span></code></a>. Solo se admite <code class="docutils literal notranslate"><span class="pre">errors='strict'</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">mbcs</p></td>
<td><p class="translated">ansi,
dbcs</p></td>
<td><p class="translated">Solo Windows: codifique el operando de acuerdo con la página de códigos ANSI (CP_ACP).</p></td>
</tr>
<tr class="row-even"><td><p class="translated">oem</p></td>
<td></td>
<td><p class="translated">Solo Windows: codifique el operando de acuerdo con la página de códigos OEM (CP_OEMCP).</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><p class="translated">palmos</p></td>
<td></td>
<td><p class="translated">Codificación de PalmOS 3.5.</p></td>
</tr>
<tr class="row-even"><td><p class="translated">punycode</p></td>
<td></td>
<td><p class="translated">Implementar <span class="target" id="index-27"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3492.html"><strong>RFC 3492</strong></a>. Los códecs con estado no son compatibles.</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">raw_unicode_escape</p></td>
<td></td>
<td><p class="translated">Codificación Latin-1 con <code class="samp docutils literal notranslate"><span class="pre">\u</span><em><span class="pre">XXXX</span></em></code> y <code class="samp docutils literal notranslate"><span class="pre">\U</span><em><span class="pre">XXXXXXXX</span></em></code> para otros puntos de código. Las barras invertidas existentes no se escapan de ninguna manera. Se usa en el protocolo Python <em>pickle</em>.</p></td>
</tr>
<tr class="row-even"><td><p class="translated">indefinido</p></td>
<td></td>
<td><p class="untranslated">This Codec should only
be used for testing
purposes.</p>
<p class="translated">Lanza una excepción para todas las conversiones, incluso cadenas vacías. El manejador de errores se ignora.</p>
</td>
</tr>
<tr class="row-odd"><td><p class="translated">unicode_escape</p></td>
<td></td>
<td><p class="translated">Codificación adecuada como contenido de un literal Unicode en código fuente Python codificado en ASCII, excepto que no se escapan las comillas. Decodificar desde el código fuente Latin-1. Tenga en cuenta que el código fuente de Python realmente usa UTF-8 por defecto.</p></td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Se elimina el códec «unicode_internal».</p>
</div>
</section>
<section id="binary-transforms">
<span id="id4"></span><h3 class="translated">Transformaciones Binarias<a class="headerlink" href="#binary-transforms" title="Link to this heading">¶</a></h3>
<p class="translated">Los siguientes códecs proporcionan transformaciones binarias: mapeos de <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. No son compatibles con <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> (que solo produce <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> de salida).</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Códec</p></th>
<th class="head"><p class="translated">Aliases</p></th>
<th class="head"><p class="translated">Significado</p></th>
<th class="head"><p class="translated">Codificador / decodificador</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated">base64_codec <a class="footnote-reference brackets" href="#b64" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td>
<td><p class="translated">base64, base_64</p></td>
<td><p class="translated">Convierta el operando a MIME base64 multilínea (el resultado siempre incluye un <code class="docutils literal notranslate"><span class="pre">'\n'</span></code> final).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>acepta cualquier <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> como entrada para codificar y decodificar</p>
</div>
</td>
<td><p class="translated"><a class="reference internal" href="base64.html#base64.encodebytes" title="base64.encodebytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base64.encodebytes()</span></code></a> /
<a class="reference internal" href="base64.html#base64.decodebytes" title="base64.decodebytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">base64.decodebytes()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p class="translated">bz2_codec</p></td>
<td><p class="translated">bz2</p></td>
<td><p class="translated">Comprime el operando usando bz2.</p></td>
<td><p class="translated"><a class="reference internal" href="bz2.html#bz2.compress" title="bz2.compress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bz2.compress()</span></code></a> /
<a class="reference internal" href="bz2.html#bz2.decompress" title="bz2.decompress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bz2.decompress()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p class="translated">hex_codec</p></td>
<td><p class="translated">hex</p></td>
<td><p class="translated">Convierte el operando en representación hexadecimal, con dos dígitos por byte.</p></td>
<td><p class="translated"><a class="reference internal" href="binascii.html#binascii.b2a_hex" title="binascii.b2a_hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">binascii.b2a_hex()</span></code></a> /
<a class="reference internal" href="binascii.html#binascii.a2b_hex" title="binascii.a2b_hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">binascii.a2b_hex()</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p class="translated">quopri_codec</p></td>
<td><p class="translated">quopri,
quotedprintable,
quoted_printable</p></td>
<td><p class="translated">Convierte el operando a MIME citado imprimible.</p></td>
<td><p class="translated"><a class="reference internal" href="quopri.html#quopri.encode" title="quopri.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quopri.encode()</span></code></a> con <code class="docutils literal notranslate"><span class="pre">quotetabs=True</span></code> / <a class="reference internal" href="quopri.html#quopri.decode" title="quopri.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">quopri.decode()</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p class="translated">uu_codec</p></td>
<td><p class="translated">uu</p></td>
<td><p class="translated">Convierte el operando usando uuencode.</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p class="translated">zlib_codec</p></td>
<td><p class="translated">zip, zlib</p></td>
<td><p class="translated">Comprime el operando usando gzip.</p></td>
<td><p class="translated"><a class="reference internal" href="zlib.html#zlib.compress" title="zlib.compress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zlib.compress()</span></code></a> /
<a class="reference internal" href="zlib.html#zlib.decompress" title="zlib.decompress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zlib.decompress()</span></code></a></p></td>
</tr>
</tbody>
</table>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="b64" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">1</a><span class="fn-bracket">]</span></span>
<p class="translated">Además de <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">objetos similares a bytes</span></a>, <code class="docutils literal notranslate"><span class="pre">'base64_codec'</span></code> también acepta instancias solo ASCII de <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> para decodificación</p>
</aside>
</aside>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2: </span>Restauración de las transformaciones binarias.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Restauración de los alias para las transformaciones binarias.</p>
</div>
</section>
<section id="standalone-codec-functions">
<span id="id6"></span><h3 class="untranslated">Standalone Codec Functions<a class="headerlink" href="#standalone-codec-functions" title="Link to this heading">¶</a></h3>
<p class="untranslated">The following functions provide encoding and decoding functionality similar to codecs,
but are not available as named codecs through <a class="reference internal" href="#codecs.encode" title="codecs.encode"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.encode()</span></code></a> or <a class="reference internal" href="#codecs.decode" title="codecs.decode"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.decode()</span></code></a>.
They are used internally (for example, by <a class="reference internal" href="pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a>) and behave similarly to the
<code class="docutils literal notranslate"><span class="pre">string_escape</span></code> codec that was removed in Python 3.</p>
<dl class="py function">
<dt class="sig sig-object py" id="codecs.codecs.escape_encode">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">escape_encode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.codecs.escape_encode" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Encode <em>input</em> using escape sequences. Similar to how <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> on bytes
produces escaped byte values.</p>
<p class="untranslated"><em>input</em> must be a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> object.</p>
<p class="untranslated">Returns a tuple <code class="docutils literal notranslate"><span class="pre">(output,</span> <span class="pre">length)</span></code> where <em>output</em> is a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>
object and <em>length</em> is the number of bytes consumed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="codecs.codecs.escape_decode">
<span class="sig-prename descclassname"><span class="pre">codecs.</span></span><span class="sig-name descname"><span class="pre">escape_decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.codecs.escape_decode" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Decode <em>input</em> from escape sequences back to the original bytes.</p>
<p class="untranslated"><em>input</em> must be a <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>.</p>
<p class="untranslated">Returns a tuple <code class="docutils literal notranslate"><span class="pre">(output,</span> <span class="pre">length)</span></code> where <em>output</em> is a <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>
object and <em>length</em> is the number of bytes consumed.</p>
</dd></dl>

</section>
<section id="text-transforms">
<span id="id7"></span><h3 class="translated">Transformaciones de texto<a class="headerlink" href="#text-transforms" title="Link to this heading">¶</a></h3>
<p class="translated">El siguiente códec proporciona una transformación de texto: un mapeo de <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> a <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>. No es compatible con <a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> (que solo produce <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> de salida).</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Códec</p></th>
<th class="head"><p class="translated">Aliases</p></th>
<th class="head"><p class="translated">Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated">rot_13</p></td>
<td><p class="translated">rot13</p></td>
<td><p class="translated">Retorna el cifrado César (<em>Caesar-cypher</em>) del operando.</p></td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2: </span>Restauración de la transformación de texto <code class="docutils literal notranslate"><span class="pre">rot_13</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Restauración del alias <code class="docutils literal notranslate"><span class="pre">rot13</span></code>.</p>
</div>
</section>
</section>
<section id="module-encodings">
<span id="encodings-encodings-package"></span><h2 class="untranslated"><a class="reference internal" href="#module-encodings" title="encodings: Encodings package"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings</span></code></a> — Encodings package<a class="headerlink" href="#module-encodings" title="Link to this heading">¶</a></h2>
<p class="untranslated">This module implements the following functions:</p>
<dl class="py function">
<dt class="sig sig-object py" id="encodings.normalize_encoding">
<span class="sig-prename descclassname"><span class="pre">encodings.</span></span><span class="sig-name descname"><span class="pre">normalize_encoding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.normalize_encoding" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Normalize encoding name <em>encoding</em>.</p>
<p class="untranslated">Normalization works as follows: all non-alphanumeric characters except the
dot used for Python package names are collapsed and replaced with a single
underscore, leading and trailing underscores are removed.
For example, <code class="docutils literal notranslate"><span class="pre">'</span>&#160; <span class="pre">-;#'</span></code> becomes <code class="docutils literal notranslate"><span class="pre">'_'</span></code>.</p>
<p class="untranslated">Note that <em>encoding</em> should be ASCII only.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">The following functions should not be used directly, except for testing
purposes; <a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.lookup()</span></code></a> should be used instead.</p>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="encodings.search_function">
<span class="sig-prename descclassname"><span class="pre">encodings.</span></span><span class="sig-name descname"><span class="pre">search_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.search_function" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Search for the codec module corresponding to the given encoding name
<em>encoding</em>.</p>
<p class="untranslated">This function first normalizes the <em>encoding</em> using
<a class="reference internal" href="#encodings.normalize_encoding" title="encodings.normalize_encoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">normalize_encoding()</span></code></a>, then looks for a corresponding alias.
It attempts to import a codec module from the encodings package using either
the alias or the normalized name. If the module is found and defines a valid
<code class="docutils literal notranslate"><span class="pre">getregentry()</span></code> function that returns a <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">codecs.CodecInfo</span></code></a> object,
the codec is cached and returned.</p>
<p class="untranslated">If the codec module defines a <code class="docutils literal notranslate"><span class="pre">getaliases()</span></code> function any returned aliases
are registered for future use.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="encodings.win32_code_page_search_function">
<span class="sig-prename descclassname"><span class="pre">encodings.</span></span><span class="sig-name descname"><span class="pre">win32_code_page_search_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.win32_code_page_search_function" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Search for a Windows code page encoding <em>encoding</em> of the form <code class="docutils literal notranslate"><span class="pre">cpXXXX</span></code>.</p>
<p class="untranslated">If the code page is valid and supported, return a <a class="reference internal" href="#codecs.CodecInfo" title="codecs.CodecInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">codecs.CodecInfo</span></code></a>
object for it.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<p class="untranslated">This module implements the following exception:</p>
<dl class="py exception">
<dt class="sig sig-object py" id="encodings.CodecRegistryError">
<em class="property"><span class="k"><span class="pre">exception</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">encodings.</span></span><span class="sig-name descname"><span class="pre">CodecRegistryError</span></span><a class="headerlink" href="#encodings.CodecRegistryError" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Raised when a codec is invalid or incompatible.</p>
</dd></dl>

</section>
<section id="module-encodings.idna">
<span id="encodings-idna-internationalized-domain-names-in-applications"></span><h2 class="translated"><a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.idna</span></code></a> — Nombres de dominio internacionalizados en aplicaciones<a class="headerlink" href="#module-encodings.idna" title="Link to this heading">¶</a></h2>
<p class="translated">Este módulo implementa <span class="target" id="index-28"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3490.html"><strong>RFC 3490</strong></a> (nombres de dominio internacionalizados en aplicaciones) y <span class="target" id="index-29"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3492.html"><strong>RFC 3492</strong></a> (<em>Nameprep</em>: un perfil de <em>Stringprep</em> para nombres de dominio internacionalizados (IDN)). Se basa en la codificación <code class="docutils literal notranslate"><span class="pre">punycode</span></code> y <a class="reference internal" href="stringprep.html#module-stringprep" title="stringprep: String preparation, as per RFC 3453"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stringprep</span></code></a>.</p>
<p class="untranslated">If you need the IDNA 2008 standard from <span class="target" id="index-10"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5891.html"><strong>RFC 5891</strong></a> and <span class="target" id="index-11"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc5895.html"><strong>RFC 5895</strong></a>, use the
third-party <a class="extlink-pypi reference external" href="https://pypi.org/project/idna/">idna</a> module.</p>
<p class="translated">Estas RFC juntas definen un protocolo para admitir caracteres no ASCII en los nombres de dominio. Un nombre de dominio que contiene caracteres no ASCII (como <code class="docutils literal notranslate"><span class="pre">www.Alliancefrançaise.nu</span></code>) se convierte en una codificación compatible con ASCII (ACE, como <code class="docutils literal notranslate"><span class="pre">www.xn--alliancefranaise-npb.nu</span></code>). La forma ACE del nombre de dominio se utiliza en todos los lugares donde el protocolo no permite caracteres arbitrarios, como consultas DNS, campos HTTP <em class="mailheader">Host</em>, etc. Esta conversión se lleva a cabo en la aplicación; si es posible invisible para el usuario: la aplicación debe convertir de forma transparente las etiquetas de dominio Unicode a IDNA en el cable, y volver a convertir las etiquetas ACE a Unicode antes de presentarlas al usuario.</p>
<p class="translated">Python admite esta conversión de varias maneras: el códec <code class="docutils literal notranslate"><span class="pre">idna</span></code> realiza la conversión entre Unicode y ACE, separando una cadena de entrada en etiquetas basadas en los caracteres separadores definidos en la sección 3.1 de RFC 3490 <span class="target" id="index-30"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3490.html#section-3.1"><strong>RFC 3490 Section 3.1</strong></a> y convertir cada etiqueta a ACE según sea necesario, y por el contrario, separar una cadena de bytes de entrada en etiquetas basadas en el separador <code class="docutils literal notranslate"><span class="pre">.</span></code> y convertir cualquier etiqueta ACE encontrada en unicode. Además, el módulo <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> convierte de forma transparente los nombres de host Unicode a ACE, por lo que las aplicaciones no necesitan preocuparse por convertir los nombres de host ellos mismos cuando los pasan al módulo de socket. Además de eso, los módulos que tienen nombres de host como parámetros de función, como <a class="reference internal" href="http.client.html#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">http.client</span></code></a> y <a class="reference internal" href="ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a>, aceptan nombres de host Unicode (<a class="reference internal" href="http.client.html#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">http.client</span></code></a> y luego también envían un mensaje transparente IDNA <em>hostname</em> en el campo <em class="mailheader">Host</em> si envía ese campo).</p>
<p class="translated">Al recibir nombres de host desde el cable (como en la búsqueda inversa de nombres), no se realiza una conversión automática a Unicode: las aplicaciones que deseen presentar dichos nombres de host al usuario deben decodificarlos en Unicode.</p>
<p class="translated">El módulo <a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.idna</span></code></a> también implementa el procedimiento <em>nameprep</em>, que realiza ciertas normalizaciones en los nombres de host, para lograr la insensibilidad a mayúsculas y minúsculas de los nombres de dominio internacionales y unificar caracteres similares. Las funciones <em>nameprep</em> se pueden usar directamente si lo desea.</p>
<dl class="py function">
<dt class="sig sig-object py" id="encodings.idna.nameprep">
<span class="sig-prename descclassname"><span class="pre">encodings.idna.</span></span><span class="sig-name descname"><span class="pre">nameprep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.idna.nameprep" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna la versión pasada por <em>nameprep</em> (o versión <em>nameprepped</em>) de <em>label</em>. La implementación actualmente asume cadenas de caracteres de consulta, por lo que <code class="docutils literal notranslate"><span class="pre">AllowUnassigned</span></code> es verdadero.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="encodings.idna.ToASCII">
<span class="sig-prename descclassname"><span class="pre">encodings.idna.</span></span><span class="sig-name descname"><span class="pre">ToASCII</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.idna.ToASCII" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Convierte una etiqueta a ASCII, como se especifica en <span class="target" id="index-31"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3490.html"><strong>RFC 3490</strong></a>. Se supone que <code class="docutils literal notranslate"><span class="pre">UseSTD3ASCIIRules</span></code> es falso.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="encodings.idna.ToUnicode">
<span class="sig-prename descclassname"><span class="pre">encodings.idna.</span></span><span class="sig-name descname"><span class="pre">ToUnicode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.idna.ToUnicode" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Convierte una etiqueta a Unicode, como se especifica en <span class="target" id="index-32"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3490.html"><strong>RFC 3490</strong></a>.</p>
</dd></dl>

</section>
<section id="module-encodings.mbcs">
<span id="encodings-mbcs-windows-ansi-codepage"></span><h2 class="translated"><a class="reference internal" href="#module-encodings.mbcs" title="encodings.mbcs: Windows ANSI codepage"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.mbcs</span></code></a> — Página de códigos ANSI de Windows<a class="headerlink" href="#module-encodings.mbcs" title="Link to this heading">¶</a></h2>
<p class="translated">Este módulo implementa la página de códigos ANSI (CP_ACP).</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.2: </span>Antes de 3.2, se ignoraba el argumento <em>errors</em>; <code class="docutils literal notranslate"><span class="pre">'replace'</span></code> siempre se usó para codificar e <code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> para decodificar.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Admite cualquier manejador de errores.</p>
</div>
</section>
<section id="module-encodings.utf_8_sig">
<span id="encodings-utf-8-sig-utf-8-codec-with-bom-signature"></span><h2 class="translated"><a class="reference internal" href="#module-encodings.utf_8_sig" title="encodings.utf_8_sig: UTF-8 codec with BOM signature"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.utf_8_sig</span></code></a> — Códec UTF-8 con firma BOM<a class="headerlink" href="#module-encodings.utf_8_sig" title="Link to this heading">¶</a></h2>
<p class="translated">Este módulo implementa una variante del códec UTF-8. Al codificar, una lista de materiales codificada en UTF-8 se antepondrá a los bytes codificados en UTF-8. Para el codificador con estado esto solo se hace una vez (en la primera escritura en el flujo de bytes). En la decodificación, se omitirá una lista de materiales opcional codificada en UTF-8 al comienzo de los datos.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code> — Codec registry and base classes</a><ul>
<li><a class="reference internal" href="#codec-base-classes">Clases Base de Códec</a><ul>
<li><a class="reference internal" href="#error-handlers">Manejadores de errores</a></li>
<li><a class="reference internal" href="#stateless-encoding-and-decoding">Codificación y decodificación sin estado</a></li>
<li><a class="reference internal" href="#incremental-encoding-and-decoding">Codificación y decodificación incrementales</a><ul>
<li><a class="reference internal" href="#incrementalencoder-objects">Objetos IncrementalEncoder</a></li>
<li><a class="reference internal" href="#incrementaldecoder-objects">Objetos IncrementalDecoder</a></li>
</ul>
</li>
<li><a class="reference internal" href="#stream-encoding-and-decoding">Codificación y decodificación de flujos</a><ul>
<li><a class="reference internal" href="#streamwriter-objects">Objetos StreamWriter</a></li>
<li><a class="reference internal" href="#streamreader-objects">Objetos StreamReader</a></li>
<li><a class="reference internal" href="#streamreaderwriter-objects">Objetos StreamReaderWriter</a></li>
<li><a class="reference internal" href="#streamrecoder-objects">Objetos StreamRecoder</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#encodings-and-unicode">Codificaciones y Unicode</a></li>
<li><a class="reference internal" href="#standard-encodings">Codificaciones estándar</a></li>
<li><a class="reference internal" href="#python-specific-encodings">Codificaciones específicas de Python</a><ul>
<li><a class="reference internal" href="#text-encodings">Codificaciones de texto</a></li>
<li><a class="reference internal" href="#binary-transforms">Transformaciones Binarias</a></li>
<li><a class="reference internal" href="#standalone-codec-functions">Standalone Codec Functions</a></li>
<li><a class="reference internal" href="#text-transforms">Transformaciones de texto</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-encodings"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings</span></code> — Encodings package</a></li>
<li><a class="reference internal" href="#module-encodings.idna"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.idna</span></code> — Nombres de dominio internacionalizados en aplicaciones</a></li>
<li><a class="reference internal" href="#module-encodings.mbcs"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.mbcs</span></code> — Página de códigos ANSI de Windows</a></li>
<li><a class="reference internal" href="#module-encodings.utf_8_sig"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.utf_8_sig</span></code> — Códec UTF-8 con firma BOM</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="struct.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code> — Interpret bytes as packed binary data</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="datatypes.html"
                          title="próximo capítulo">Tipos de datos</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/codecs.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Contraer barra lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="datatypes.html" title="Tipos de datos"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="struct.html" title="struct — Interpret bytes as packed binary data"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="binary.html" >Servicios de datos binarios</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code> — Codec registry and base classes</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Derechos de autor</a> 2001 Python Software Foundation.
    <br>
    Ésta página tiene la licencia Python Software Foundation Versión 2.
    <br>
    Ejemplos, guías, y otro código en la documentación están bajo la licencia adicional Zero Clause BSD.
    <br>
    
      Ver <a href="/license.html">Historia y Licencia</a> para más información.<br>
    
    
    <br>

    La Python Software Foundation es una corporación sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor dona.</a>
<br>
    <br>
      Última actualización en oct 06, 2025 (04:51 UTC).
    
      <a href="/bugs.html">Encontraste un bug</a>?
    
    <br>

    Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a>8.2.3.
    </div>

  </body>
</html>