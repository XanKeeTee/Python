<!DOCTYPE html>

<html lang="es" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="re — Regular expression operations" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/re.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Código fuente: Lib/re/ Este módulo proporciona operaciones de coincidencia de expresiones regulares similares a las encontradas en Perl. Both patterns and strings to be searched can be Unicode stri..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.15/es/_images/social_previews/summary_library_re_8b17a018.png" />
<meta property="og:image:alt" content="Código fuente: Lib/re/ Este módulo proporciona operaciones de coincidencia de expresiones regulares similares a las encontradas en Perl. Both patterns and strings to be searched can be Unicode stri..." />
<meta name="description" content="Código fuente: Lib/re/ Este módulo proporciona operaciones de coincidencia de expresiones regulares similares a las encontradas en Perl. Both patterns and strings to be searched can be Unicode stri..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>re — Regular expression operations &#8212; documentación de Python - 3.15.0a0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=bf1f176d"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f85f4cfb"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.15.0a0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Derechos de autor" href="../copyright.html" />
    <link rel="next" title="difflib — Helpers for computing deltas" href="difflib.html" />
    <link rel="prev" title="string.templatelib — Support for template string literals" href="string.templatelib.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/library/re.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menú">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Regular expression operations</a><ul>
<li><a class="reference internal" href="#regular-expression-syntax">Sintaxis de expresiones regulares</a></li>
<li><a class="reference internal" href="#module-contents">Contenidos del módulo</a><ul>
<li><a class="reference internal" href="#flags">Indicadores</a></li>
<li><a class="reference internal" href="#functions">Funciones</a></li>
<li><a class="reference internal" href="#exceptions">Excepciones</a></li>
</ul>
</li>
<li><a class="reference internal" href="#regular-expression-objects">Objetos expresión regular</a></li>
<li><a class="reference internal" href="#match-objects">Objetos de coincidencia</a></li>
<li><a class="reference internal" href="#regular-expression-examples">Ejemplos de expresiones regulares</a><ul>
<li><a class="reference internal" href="#checking-for-a-pair">Buscando un par</a></li>
<li><a class="reference internal" href="#simulating-scanf">Simular scanf()</a></li>
<li><a class="reference internal" href="#search-vs-match">search() vs. match()</a></li>
<li><a class="reference internal" href="#making-a-phonebook">Haciendo una guía telefónica</a></li>
<li><a class="reference internal" href="#text-munging">Mungear texto</a></li>
<li><a class="reference internal" href="#finding-all-adverbs">Encontrar todos los adverbios</a></li>
<li><a class="reference internal" href="#finding-all-adverbs-and-their-positions">Encontrar todos los adverbios y sus posiciones</a></li>
<li><a class="reference internal" href="#raw-string-notation">Notación de cadena <em>raw</em></a></li>
<li><a class="reference internal" href="#writing-a-tokenizer">Escribir un Tokenizador</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="string.templatelib.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">string.templatelib</span></code> — Support for template string literals</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="difflib.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code> — Helpers for computing deltas</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/re.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="difflib.html" title="difflib — Helpers for computing deltas"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="string.templatelib.html" title="string.templatelib — Support for template string literals"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="text.html" accesskey="U">Servicios de procesamiento de texto</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Regular expression operations</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-re">
<span id="re-regular-expression-operations"></span><h1 class="untranslated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Regular expression operations<a class="headerlink" href="#module-re" title="Link to this heading">¶</a></h1>
<p class="translated"><strong>Código fuente:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/main/Lib/re/">Lib/re/</a></p>
<hr class="docutils" />
<p class="translated">Este módulo proporciona operaciones de coincidencia de expresiones regulares similares a las encontradas en Perl.</p>
<p class="untranslated">Both patterns and strings to be searched can be Unicode strings (<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>)
as well as 8-bit strings (<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>).
However, Unicode strings and 8-bit strings cannot be mixed:
that is, you cannot match a Unicode string with a bytes pattern or
vice-versa; similarly, when asking for a substitution, the replacement
string must be of the same type as both the pattern and the search string.</p>
<p class="translated">Las expresiones regulares usan el carácter de barra inversa (<code class="docutils literal notranslate"><span class="pre">'\'</span></code>) para indicar formas especiales o para permitir el uso de caracteres especiales sin invocar su significado especial.  Esto choca con el uso de Python de este carácter para el mismo propósito con los literales de cadena; por ejemplo, para hacer coincidir una barra inversa literal, se podría escribir <code class="docutils literal notranslate"><span class="pre">'\\\\'</span></code> como patrón, porque la expresión regular debe ser <code class="docutils literal notranslate"><span class="pre">\\</span></code>, y cada barra inversa debe ser expresada como <code class="docutils literal notranslate"><span class="pre">\\</span></code> dentro de un literal de cadena regular de Python.  También, notar que cualquier secuencia de escape inválida mientras se use la barra inversa de Python en los literales de cadena ahora genera un <a class="reference internal" href="exceptions.html#SyntaxWarning" title="SyntaxWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxWarning</span></code></a> y en el futuro esto se convertirá en un <a class="reference internal" href="exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>.  Este comportamiento ocurrirá incluso si es una secuencia de escape válida para una expresión regular.</p>
<p class="translated">La solución es usar la notación de cadena <em>raw</em> de Python para los patrones de expresiones regulares; las barras inversas no se manejan de ninguna manera especial en un literal de cadena prefijado con <code class="docutils literal notranslate"><span class="pre">'r'</span></code>.  Así que <code class="docutils literal notranslate"><span class="pre">r&quot;\n&quot;</span></code> es una cadena de dos caracteres que contiene <code class="docutils literal notranslate"><span class="pre">'\'</span></code> y <code class="docutils literal notranslate"><span class="pre">'n'</span></code>, mientras que <code class="docutils literal notranslate"><span class="pre">&quot;\n&quot;</span></code> es una cadena de un carácter que contiene una nueva línea.  Normalmente los patrones se expresan en código Python usando esta notación de cadena <em>raw</em>.</p>
<p class="translated">Es importante señalar que la mayoría de las operaciones de expresiones regulares están disponibles como funciones y métodos a nivel de módulo en <a class="reference internal" href="#re-objects"><span class="std std-ref">expresiones regulares compiladas</span></a> (expresiones regulares compiladas).  Las funciones son atajos que no requieren de compilar un objeto regex primero, aunque pasan por alto algunos parámetros de ajuste.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="untranslated">The third-party <a class="extlink-pypi reference external" href="https://pypi.org/project/regex/">regex</a> module,
which has an API compatible with the standard library <a class="reference internal" href="#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> module,
but offers additional functionality and a more thorough Unicode support.</p>
</div>
<section id="regular-expression-syntax">
<span id="re-syntax"></span><h2 class="translated">Sintaxis de expresiones regulares<a class="headerlink" href="#regular-expression-syntax" title="Link to this heading">¶</a></h2>
<p class="translated">Una expresión regular (o RE, por sus siglas en inglés) especifica un conjunto de cadenas que coinciden con ella; las funciones de este módulo permiten comprobar si una determinada cadena coincide con una expresión regular dada (o si una expresión regular dada coincide con una determinada cadena, que se reduce a lo mismo).</p>
<p class="translated">Las expresiones regulares pueden ser concatenadas para formar nuevas expresiones regulares; si <em>A</em> y <em>B</em> son ambas expresiones regulares, entonces <em>AB</em> es también una expresión regular. En general, si una cadena <em>p</em> coincide con <em>A</em> y otra cadena <em>q</em> coincide con <em>B</em>, la cadena <em>porque</em> coincidirá con AB.  Esto se mantiene a menos que <em>A</em> o <em>B</em> contengan operaciones de baja precedencia; condiciones límite entre <em>A</em> y <em>B</em>; o tengan referencias de grupo numeradas.  Así, las expresiones complejas pueden construirse fácilmente a partir de expresiones primitivas más simples como las que se describen aquí.  Para detalles de la teoría e implementación de las expresiones regulares, consulte el libro de Friedl <a class="reference internal" href="#frie09" id="id1"><span>[Frie09]</span></a>, o casi cualquier libro de texto sobre la construcción de compiladores.</p>
<p class="translated">A continuación se explica brevemente el formato de las expresiones regulares.  Para más información y una presentación más amena, consultar la <a class="reference internal" href="../howto/regex.html#regex-howto"><span class="std std-ref">Expresiones regulares COMOS (HOWTO)</span></a>.</p>
<p class="translated">Las expresiones regulares pueden contener tanto caracteres especiales como ordinarios. La mayoría de los caracteres ordinarios, como <code class="docutils literal notranslate"><span class="pre">'A'</span></code>, <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, o <code class="docutils literal notranslate"><span class="pre">'0'</span></code> son las expresiones regulares más sencillas; simplemente se ajustan a sí mismas.  Se pueden concatenar caracteres ordinarios, así que <code class="docutils literal notranslate"><span class="pre">last</span></code> coincide con la cadena <code class="docutils literal notranslate"><span class="pre">'last'</span></code>.  (En el resto de esta sección, se escribirán los RE en <code class="docutils literal notranslate"><span class="pre">este</span> <span class="pre">estilo</span> <span class="pre">especial</span></code>, normalmente sin comillas, y las cadenas que deban coincidir <code class="docutils literal notranslate"><span class="pre">'entre</span> <span class="pre">comillas</span> <span class="pre">simples'</span></code>.)</p>
<p class="translated">Algunos caracteres, como <code class="docutils literal notranslate"><span class="pre">'|'</span></code> o <code class="docutils literal notranslate"><span class="pre">'('</span></code>, son especiales. Los caracteres especiales representan clases de caracteres ordinarios, o afectan a la forma en que se interpretan las expresiones regulares que los rodean.</p>
<p class="translated">Los operadores de repetición o cuantificadores (<code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">{m,n}</span></code>, etc.) no pueden ser anidados directamente. Esto evita la ambigüedad con el sufijo modificador no codicioso <code class="docutils literal notranslate"><span class="pre">?</span></code>, y con otros modificadores en otras implementaciones. Para aplicar una segunda repetición a una repetición interna, se pueden usar paréntesis. Por ejemplo, la expresión <code class="docutils literal notranslate"><span class="pre">(?:a{6})*</span></code> coincide con cualquier múltiplo de seis caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code>.</p>
<p class="translated">Los caracteres especiales son:</p>
<dl class="simple" id="index-0">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">.</span></code></dt><dd><p class="untranslated">(Dot.)  In the default mode, this matches any character except a newline.  If
the <a class="reference internal" href="#re.DOTALL" title="re.DOTALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">DOTALL</span></code></a> flag has been specified, this matches any character
including a newline.  <code class="docutils literal notranslate"><span class="pre">(?s:.)</span></code> matches any character regardless of flags.</p>
</dd>
</dl>
<dl class="simple" id="index-1">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">^</span></code></dt><dd><p class="translated">(Circunflejo.)  Coincide con el comienzo de la cadena, y en modo <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> también coincide inmediatamente después de cada nueva línea.</p>
</dd>
</dl>
<dl class="simple" id="index-2">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">$</span></code></dt><dd><p class="translated">Coincide con el final de la cadena o justo antes de la nueva línea al final de la cadena, y en modo <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> también coincide antes de una nueva línea.  <code class="docutils literal notranslate"><span class="pre">foo</span></code> coincide con “foo” y “foobar”, mientras que la expresión regular <code class="docutils literal notranslate"><span class="pre">foo$</span></code> sólo coincide con “foo”.  Más interesante aún, al buscar <code class="docutils literal notranslate"><span class="pre">foo.$</span></code> en <code class="docutils literal notranslate"><span class="pre">'foo1\nfoo2\n'</span></code> coincide con “foo2” normalmente, pero solo “foo1” en <code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE`</span></code>; si busca un solo <code class="docutils literal notranslate"><span class="pre">$</span></code> en <code class="docutils literal notranslate"><span class="pre">'foo\n'</span></code> encontrará dos coincidencias (vacías): una justo antes de una nueva línea, y otra al final de la cadena.</p>
</dd>
</dl>
<dl class="simple" id="index-3">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">*</span></code></dt><dd><p class="translated">Hace que el RE resultante coincida con 0 o más repeticiones del RE precedente, tantas repeticiones como sean posibles.  <code class="docutils literal notranslate"><span class="pre">ab*</span></code> coincidirá con “a”, “ab” o “a” seguido de cualquier número de “b”.</p>
</dd>
</dl>
<dl class="simple" id="index-4">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">+</span></code></dt><dd><p class="translated">Hace que la RE resultante coincida con 1 o más repeticiones de la RE precedente. <code class="docutils literal notranslate"><span class="pre">ab+</span></code> coincidirá con “a” seguido de cualquier número distinto de cero de “b”; no coincidirá solo con “a”.</p>
</dd>
</dl>
<dl class="simple" id="index-5">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">?</span></code></dt><dd><p class="translated">Hace que la RE resultante coincida con 0 o 1 repeticiones de la RE precedente. <code class="docutils literal notranslate"><span class="pre">ab?</span></code> coincidirá con “a” o “ab”.</p>
</dd>
</dl>
<dl class="simple" id="index-6">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">+?</span></code>, <code class="docutils literal notranslate"><span class="pre">??</span></code></dt><dd><p class="translated">Los delimitadores <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code>, y <code class="docutils literal notranslate"><span class="pre">'?'</span></code> son todos <em class="dfn">greedy</em>; coinciden con la mayor cantidad de texto posible.  A veces este comportamiento no es deseado; si el RE <code class="docutils literal notranslate"><span class="pre">&lt;.*&gt;</span></code> se utiliza para coincidir con <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;</span> <span class="pre">b</span> <span class="pre">&lt;c&gt;'</span></code>, coincidirá con toda la cadena, y no sólo con <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;'</span></code>.  Añadiendo <code class="docutils literal notranslate"><span class="pre">?</span></code> después del delimitador hace que se realice la coincidencia de manera <em class="dfn">non-greedy</em> o <em class="dfn">minimal</em>; coincidirá la <em>mínima</em> cantidad de caracteres como sea posible.  Usando el RE <code class="docutils literal notranslate"><span class="pre">&lt;.*?&gt;</span></code> sólo coincidirá con <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;'</span></code>.</p>
</dd>
</dl>
<dl id="index-7">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">*+</span></code>, <code class="docutils literal notranslate"><span class="pre">++</span></code>, <code class="docutils literal notranslate"><span class="pre">?+</span></code></dt><dd><p class="translated">Como los cuantificadores <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code>, y <code class="docutils literal notranslate"><span class="pre">'?'</span></code> , aquellos en los que se agrega <code class="docutils literal notranslate"><span class="pre">'+'</span></code> también coinciden tantas veces como sea posible. Sin embargo, a diferencia de los verdaderos cuantificadores codiciosos, estos no permiten retroceder cuando la expresión que le sigue no coincide. Estos se conocen como cuantificadores <em class="dfn">possessive</em>. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">a*a</span></code> coincidirá con <code class="docutils literal notranslate"><span class="pre">'aaaa'</span></code> porque la <code class="docutils literal notranslate"><span class="pre">a*</span></code> coincidirá con los 4 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>s, pero, cuando se encuentra la <code class="docutils literal notranslate"><span class="pre">'a'</span></code> final, la expresión retrocede de modo que al final la <code class="docutils literal notranslate"><span class="pre">a*</span></code> termina coincidiendo con 3 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>s total, y la cuarta <code class="docutils literal notranslate"><span class="pre">'a'</span></code> coincide con la final <code class="docutils literal notranslate"><span class="pre">'a'</span></code>. Sin embargo, cuando <code class="docutils literal notranslate"><span class="pre">a*+a</span></code> se usa para que coincida con <code class="docutils literal notranslate"><span class="pre">'aaaa'</span></code>, el <code class="docutils literal notranslate"><span class="pre">a*+</span></code> coincidirá con los 4 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, pero cuando el <code class="docutils literal notranslate"><span class="pre">'a'</span></code> final no encuentra más caracteres para coincidir, la expresión no puede retroceder y, por lo tanto, no coincidirá. <code class="docutils literal notranslate"><span class="pre">x*+</span></code>, <code class="docutils literal notranslate"><span class="pre">x++</span></code> and <code class="docutils literal notranslate"><span class="pre">x?+</span></code> son equivalentes a <code class="docutils literal notranslate"><span class="pre">(?&gt;x*)</span></code>, <code class="docutils literal notranslate"><span class="pre">(?&gt;x+)</span></code> and <code class="docutils literal notranslate"><span class="pre">(?&gt;x?)</span></code> correspondientemente.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd>
</dl>
<dl id="index-8">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">{m}</span></code></dt><dd><p class="translated">Especifica que exactamente <em>m</em> copias de la RE anterior deben coincidir; menos coincidencias hacen que la RE entera no coincida.  Por ejemplo, <code class="docutils literal notranslate"><span class="pre">a{6}</span></code> coincidirá exactamente con seis caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, pero no con cinco.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">{m,n}</span></code></dt><dd><p class="translated">Hace que el RE resultante coincida de <em>m</em> a <em>n</em> repeticiones del RE precedente, tratando de coincidir con el mayor número de repeticiones posible.  Por ejemplo, <code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code> coincidirá de 3 a 5 caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code>.  Omitiendo <em>m</em> se especifica un límite inferior de cero, y omitiendo <em>n</em> se especifica un límite superior infinito.  Por ejemplo, <code class="docutils literal notranslate"><span class="pre">a{4,}b</span></code> coincidirá con <code class="docutils literal notranslate"><span class="pre">'aaaab'</span></code> o mil caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code> seguidos de una <code class="docutils literal notranslate"><span class="pre">'b'</span></code>, pero no <code class="docutils literal notranslate"><span class="pre">'aaab'</span></code>. La coma no puede ser omitida o el modificador se confundiría con la forma descrita anteriormente.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">{m,n}?</span></code></dt><dd><p class="translated">Hace que el RE resultante coincida de <em>m</em> a <em>n</em> repeticiones del RE precedente, tratando de coincidir con el <em>mínimo de</em> repeticiones posible.  Esta es la versión <em>non-greedy</em> (no codiciosa) del delimitador anterior.  Por ejemplo, en la cadena de 6 caracteres <code class="docutils literal notranslate"><span class="pre">'aaaaaa'</span></code>, <code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code> coincidirá con 5 caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, mientras que <code class="docutils literal notranslate"><span class="pre">a{3,5}?</span></code> solo coincidirá con 3 caracteres.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">{m,n}+</span></code></dt><dd><p class="translated">Hace que el RE resultante coincida de <em>m</em> a <em>n</em> repeticiones del RE anterior, intentando hacer coincidir tantas repeticiones como sea posible <em>sin</em> establecer ningún punto de retroceso. Esta es la versión posesiva del cuantificador anterior. Por ejemplo, en la cadena de 6 caracteres <code class="docutils literal notranslate"><span class="pre">'aaaaaa'</span></code>, <code class="docutils literal notranslate"><span class="pre">a{3,5}+aa</span></code> intenta hacer coincidir 5 caracteres <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, entonces, al requerir 2 más <code class="docutils literal notranslate"><span class="pre">'a'</span></code>s, necesitará más caracteres de los disponibles y, por lo tanto, fallará, mientras que <code class="docutils literal notranslate"><span class="pre">a{3,5}aa</span></code> coincidirá con <code class="docutils literal notranslate"><span class="pre">a{3,5}</span></code> capturando 5, luego 4 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>s por retroceso y luego los últimos 2 <code class="docutils literal notranslate"><span class="pre">'a'</span></code>s son emparejados por el <code class="docutils literal notranslate"><span class="pre">aa</span></code> final en el patrón. <code class="docutils literal notranslate"><span class="pre">x{m,n}+</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">(?&gt;x{m,n})</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd>
</dl>
<dl id="index-9">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">\</span></code></dt><dd><p class="translated">O bien se escapan a los caracteres especiales (lo que le permite hacer coincidir caracteres como <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'?'</span></code>, y así sucesivamente), o se señala una secuencia especial; las secuencias especiales se explican más adelante.</p>
<p class="translated">Si no se utiliza una cadena <em>raw</em> para expresar el patrón, recuerde que Python también utiliza la barra inversa como secuencia de escape en los literales de la cadena; si el analizador sintáctico de Python no reconoce la secuencia de escape, la barra inversa y el carácter subsiguiente se incluyen en la cadena resultante.  Sin embargo, si Python quisiera reconocer la secuencia resultante, la barra inversa debería repetirse dos veces.  Esto es complicado y difícil de entender, por lo que se recomienda encarecidamente utilizar cadenas <em>raw</em> para todas las expresiones salvo las más simples.</p>
</dd>
</dl>
<dl id="index-10">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">[]</span></code></dt><dd><p class="translated">Se utiliza para indicar un conjunto de caracteres.  En un conjunto:</p>
<ul class="simple">
<li><p class="translated">Los caracteres pueden ser listados individualmente, ej. <code class="docutils literal notranslate"><span class="pre">[amk]</span></code> coincidirá con <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, o <code class="docutils literal notranslate"><span class="pre">'k'</span></code>.</p></li>
</ul>
<ul class="simple" id="index-11">
<li><p class="translated">Los rangos de caracteres se pueden indicar mediante dos caracteres y separándolos con un <code class="docutils literal notranslate"><span class="pre">'-'</span></code>. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code> coincidirá con cualquier letra ASCII en minúscula, <code class="docutils literal notranslate"><span class="pre">[0-5][0-9]</span></code> coincidirá con todos los números de dos dígitos desde el <code class="docutils literal notranslate"><span class="pre">00</span></code> hasta el <code class="docutils literal notranslate"><span class="pre">59</span></code>, y <code class="docutils literal notranslate"><span class="pre">[0-9A-Fa-f]</span></code> coincidirá con cualquier dígito hexadecimal.  Si se escapa <code class="docutils literal notranslate"><span class="pre">-</span></code> (por ejemplo, <code class="docutils literal notranslate"><span class="pre">[a\-z]</span></code>) o si se coloca como el primer o el último carácter (por ejemplo, <code class="docutils literal notranslate"><span class="pre">[-a]</span></code> o <code class="docutils literal notranslate"><span class="pre">[a-]</span></code>), coincidirá con un literal <code class="docutils literal notranslate"><span class="pre">'-'</span></code>.</p></li>
<li><p class="untranslated">Special characters except backslash lose their special meaning inside sets.
For example,
<code class="docutils literal notranslate"><span class="pre">[(+*)]</span></code> will match any of the literal characters <code class="docutils literal notranslate"><span class="pre">'('</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'*'</span></code>, or <code class="docutils literal notranslate"><span class="pre">')'</span></code>.</p></li>
</ul>
<ul class="simple" id="index-12">
<li><p class="untranslated">Backslash either escapes characters which have special meaning in a set
such as <code class="docutils literal notranslate"><span class="pre">'-'</span></code>, <code class="docutils literal notranslate"><span class="pre">']'</span></code>, <code class="docutils literal notranslate"><span class="pre">'^'</span></code> and <code class="docutils literal notranslate"><span class="pre">'\\'</span></code> itself or signals
a special sequence which represents a single character such as
<code class="docutils literal notranslate"><span class="pre">\xa0</span></code> or <code class="docutils literal notranslate"><span class="pre">\n</span></code> or a character class such as <code class="docutils literal notranslate"><span class="pre">\w</span></code> or <code class="docutils literal notranslate"><span class="pre">\S</span></code>
(defined below).
Note that <code class="docutils literal notranslate"><span class="pre">\b</span></code> represents a single «backspace» character,
not a word boundary as outside a set, and numeric escapes
such as <code class="docutils literal notranslate"><span class="pre">\1</span></code> are always octal escapes, not group references.
Special sequences which do not match a single character such as <code class="docutils literal notranslate"><span class="pre">\A</span></code>
and <code class="docutils literal notranslate"><span class="pre">\z</span></code> are not allowed.</p></li>
</ul>
<ul class="simple" id="index-13">
<li><p class="translated">Los caracteres que no están dentro de un rango pueden ser coincidentes con <em class="dfn">complementing</em> el conjunto. Si el primer carácter del conjunto es <code class="docutils literal notranslate"><span class="pre">'^'</span></code>, todos los caracteres que <em>no</em> están en el conjunto coincidirán. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">[^5]</span></code> coincidirá con cualquier carácter excepto con <code class="docutils literal notranslate"><span class="pre">'5'</span></code>, y <code class="docutils literal notranslate"><span class="pre">[^^]</span></code> coincidirá con cualquier carácter excepto con <code class="docutils literal notranslate"><span class="pre">'^'</span></code>. <code class="docutils literal notranslate"><span class="pre">^</span></code> no tiene un significado especial si no es el primer carácter del conjunto.</p></li>
<li><p class="translated">Para coincidir con un <code class="docutils literal notranslate"><span class="pre">']'</span></code> literal dentro de un set, se debe preceder con una barra inversa, o colocarlo al principio del set. Por ejemplo, tanto <code class="docutils literal notranslate"><span class="pre">[()[\]{}]</span></code> como <code class="docutils literal notranslate"><span class="pre">[]()[{}]</span></code> coincidirá con los paréntesis, corchetes y llaves.</p></li>
</ul>
<ul class="simple">
<li><p class="translated">El soporte de conjuntos anidados y operaciones de conjuntos como en <a class="reference external" href="https://unicode.org/reports/tr18/">Unicode Technical Standard #18</a> podría ser añadido en el futuro. Esto cambiaría la sintaxis, así que por el momento se planteará un <a class="reference internal" href="exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a> en casos ambiguos para facilitar este cambio. Ello incluye conjuntos que empiecen con un literal <code class="docutils literal notranslate"><span class="pre">'['</span></code> o que contengan secuencias de caracteres literales <code class="docutils literal notranslate"><span class="pre">'—'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&amp;&amp;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'~~'</span></code> y <code class="docutils literal notranslate"><span class="pre">'||'</span></code>. Para evitar una advertencia, utilizar el código de escape con una barra inversa.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span><a class="reference internal" href="exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a> se genera si un conjunto de caracteres contiene construcciones que cambiarán semánticamente en el futuro.</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-14">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">|</span></code></dt><dd><p class="translated"><code class="docutils literal notranslate"><span class="pre">A|B</span></code>, donde <em>A</em> y <em>B</em> pueden ser RE arbitrarias, crea una expresión regular que coincidirá con <em>A</em> or <em>B</em>. Un número arbitrario de RE puede ser separado por <code class="docutils literal notranslate"><span class="pre">'|'</span></code> de esta manera. Esto puede también ser usado dentro de grupos (ver más adelante). Cuando la cadena de destino es procesada, los RE separados por <code class="docutils literal notranslate"><span class="pre">'|'</span></code> son probados de izquierda a derecha. Cuando un patrón coincide completamente, esa rama es aceptada. Esto significa que una vez que <em>A</em> coincida, <em>B</em> no se comprobará más, incluso si se produce una coincidencia general más larga. En otras palabras, el operador de <code class="docutils literal notranslate"><span class="pre">'|'</span></code> nunca es codicioso. Para emparejar un literal <code class="docutils literal notranslate"><span class="pre">'|'</span></code>, se usa <code class="docutils literal notranslate"><span class="pre">\|</span></code>, o se envuelve dentro de una clase de caracteres, como en <code class="docutils literal notranslate"><span class="pre">[|]</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-15">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">(...)</span></code></dt><dd><p class="translated">Coincide con cualquier expresión regular que esté dentro de los paréntesis, e indica el comienzo y el final de un grupo; el contenido de un grupo puede ser recuperado después de que se haya realizado una coincidencia, y puede coincidir más adelante en la cadena con la secuencia especial <code class="docutils literal notranslate"><span class="pre">\number</span></code>, que se describe más adelante. Para hacer coincidir los literales <code class="docutils literal notranslate"><span class="pre">`'('</span></code> o <code class="docutils literal notranslate"><span class="pre">')'</span></code>, se usa <code class="docutils literal notranslate"><span class="pre">\(</span></code> o <code class="docutils literal notranslate"><span class="pre">\)</span></code>, o se envuelve dentro de una clase de caracteres: <code class="docutils literal notranslate"><span class="pre">[(]</span></code>, <code class="docutils literal notranslate"><span class="pre">[)]</span></code>.</p>
</dd>
</dl>
<dl id="index-16">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">(?...)</span></code></dt><dd><p class="translated">Esta es una notación de extensión (un <code class="docutils literal notranslate"><span class="pre">'?'</span></code> después de un <code class="docutils literal notranslate"><span class="pre">'('</span></code> no tiene ningún otro significado). El primer carácter después de <code class="docutils literal notranslate"><span class="pre">'?'</span></code> determina el significado y la sintaxis de la construcción. Las extensiones normalmente no crean un nuevo grupo; <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;…)</span></code> es la única excepción a esta regla. A continuación se muestran las extensiones actualmente soportadas.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">(?aiLmsux)</span></code></dt><dd><p class="untranslated">(One or more letters from the set
<code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>.)
The group matches the empty string;
the letters set the corresponding flags for the entire regular expression:</p>
<ul class="simple">
<li><p class="untranslated"><a class="reference internal" href="#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.A</span></code></a> (ASCII-only matching)</p></li>
<li><p class="untranslated"><a class="reference internal" href="#re.I" title="re.I"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.I</span></code></a> (ignore case)</p></li>
<li><p class="untranslated"><a class="reference internal" href="#re.L" title="re.L"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.L</span></code></a> (locale dependent)</p></li>
<li><p class="untranslated"><a class="reference internal" href="#re.M" title="re.M"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.M</span></code></a> (multi-line)</p></li>
<li><p class="untranslated"><a class="reference internal" href="#re.S" title="re.S"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.S</span></code></a> (dot matches all)</p></li>
<li><p class="untranslated"><a class="reference internal" href="#re.U" title="re.U"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code></a> (Unicode matching)</p></li>
<li><p class="untranslated"><a class="reference internal" href="#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a> (verbose)</p></li>
</ul>
<p class="untranslated">(The flags are described in <a class="reference internal" href="#contents-of-module-re"><span class="std std-ref">Contenidos del módulo</span></a>.)
This is useful if you wish to include the flags as part of the
regular expression, instead of passing a <em>flag</em> argument to the
<a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> function.
Flags should be used first in the expression string.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Esta construcción solo se puede usar al comienzo de la expresión.</p>
</div>
</dd>
</dl>
<dl id="index-17">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">(?:...)</span></code></dt><dd><p class="translated">Una versión no capturable de los paréntesis regulares. Hace coincidir cualquier expresión regular que esté dentro de los paréntesis, pero la subcadena coincidente con el grupo <em>no puede</em> ser recuperada después de realizar una coincidencia o referenciada más adelante en el patrón.</p>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">(?aiLmsux-imsx:...)</span></code></dt><dd><p class="untranslated">(Zero or more letters from the set
<code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>,
optionally followed by <code class="docutils literal notranslate"><span class="pre">'-'</span></code> followed by
one or more letters from the <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>.)
The letters set or remove the corresponding flags for the part of the expression:</p>
<ul class="simple">
<li><p class="untranslated"><a class="reference internal" href="#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.A</span></code></a> (ASCII-only matching)</p></li>
<li><p class="untranslated"><a class="reference internal" href="#re.I" title="re.I"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.I</span></code></a> (ignore case)</p></li>
<li><p class="untranslated"><a class="reference internal" href="#re.L" title="re.L"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.L</span></code></a> (locale dependent)</p></li>
<li><p class="untranslated"><a class="reference internal" href="#re.M" title="re.M"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.M</span></code></a> (multi-line)</p></li>
<li><p class="untranslated"><a class="reference internal" href="#re.S" title="re.S"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.S</span></code></a> (dot matches all)</p></li>
<li><p class="untranslated"><a class="reference internal" href="#re.U" title="re.U"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code></a> (Unicode matching)</p></li>
<li><p class="untranslated"><a class="reference internal" href="#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a> (verbose)</p></li>
</ul>
<p class="untranslated">(The flags are described in <a class="reference internal" href="#contents-of-module-re"><span class="std std-ref">Contenidos del módulo</span></a>.)</p>
<p class="untranslated">The letters <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code> and <code class="docutils literal notranslate"><span class="pre">'u'</span></code> are mutually exclusive when used
as inline flags, so they can’t be combined or follow <code class="docutils literal notranslate"><span class="pre">'-'</span></code>.  Instead,
when one of them appears in an inline group, it overrides the matching mode
in the enclosing group.  In Unicode patterns <code class="docutils literal notranslate"><span class="pre">(?a:...)</span></code> switches to
ASCII-only matching, and <code class="docutils literal notranslate"><span class="pre">(?u:...)</span></code> switches to Unicode matching
(default).  In bytes patterns <code class="docutils literal notranslate"><span class="pre">(?L:...)</span></code> switches to locale dependent
matching, and <code class="docutils literal notranslate"><span class="pre">(?a:...)</span></code> switches to ASCII-only matching (default).
This override is only in effect for the narrow inline group, and the
original matching mode is restored outside of the group.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Las letras <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code> y <code class="docutils literal notranslate"><span class="pre">'u'</span></code> también pueden ser usadas en un grupo.</p>
</div>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">(?&gt;...)</span></code></dt><dd><p class="translated">Intenta hacer coincidir <code class="docutils literal notranslate"><span class="pre">...</span></code> como si fuera una expresión regular separada, y si tiene éxito, continúa coincidiendo con el resto del patrón que la sigue. Si el patrón posterior no coincide, la pila solo se puede desenrollar a un punto <em>antes</em> del <code class="docutils literal notranslate"><span class="pre">(?&gt;...)</span></code> Porque una vez que salió, la expresión, conocida como <em class="dfn">grupo atomico &lt;atomic group&gt;</em>, ha desechado todos los puntos de pila dentro de sí misma. Por lo tanto, <code class="docutils literal notranslate"><span class="pre">(?&gt;.*).</span></code> nunca coincidiría con nada porque primero el <code class="docutils literal notranslate"><span class="pre">.*</span></code> coincidiría con todos los caracteres posibles, luego, al no tener nada que igualar, el <code class="docutils literal notranslate"><span class="pre">.</span></code> final no coincidiría. Dado que no hay puntos de pila guardados en el Grupo Atómico, y no hay ningún punto de pila antes de él, toda la expresión no coincidiría.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd>
</dl>
<dl id="index-18">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code></dt><dd><p class="translated">Similar a los paréntesis regulares, pero la subcadena coincidente con el grupo es accesible a través del nombre simbólico del grupo, <em>name</em>. Los nombres de grupo deben ser identificadores válidos de Python, y en los patrones de <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> solo pueden contener bytes en el rango ASCII.  Cada nombre de grupo debe ser definido sólo una vez dentro de una expresión regular.  Un grupo simbólico es también un grupo numerado, del mismo modo que si el grupo no tuviera nombre.</p>
<p class="translated">Los grupos con nombre pueden ser referenciados en tres contextos. Si el patrón es <code class="docutils literal notranslate"><span class="pre">(?P&lt;quote&gt;['&quot;]).*?(?P=quote)</span></code> (es decir, hacer coincidir una cadena citada con comillas simples o dobles):</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Contexto de la referencia al grupo <em>quote</em> (cita)</p></th>
<th class="head"><p class="translated">Formas de hacer referencia</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated">en el mismo patrón en sí mismo</p></td>
<td><ul class="simple">
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">(?P=quote)</span></code> (como se muestra)</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">\1</span></code></p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p class="translated">cuando se procesa el objeto de la coincidencia <em>m</em></p></td>
<td><ul class="simple">
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">m.group('quote')</span></code></p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">m.end('quote')</span></code> (etc.)</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p class="translated">en una cadena pasada al argumento <em>repl</em> de <code class="docutils literal notranslate"><span class="pre">re.sub()</span></code></p></td>
<td><ul class="simple">
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">\g&lt;quote&gt;</span></code></p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">\g&lt;1&gt;</span></code></p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">\1</span></code></p></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>En patrones de tipo <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, el nombre del grupo <em>name</em> solo puede contener bytes en el rango ASCII (<code class="docutils literal notranslate"><span class="pre">b'\x00'</span></code>-<code class="docutils literal notranslate"><span class="pre">b'\x7f'</span></code>).</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-19">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">(?P=name)</span></code></dt><dd><p class="translated">Una referencia inversa a un grupo nombrado; coincide con cualquier texto correspondido por el grupo anterior llamado <em>name</em>.</p>
</dd>
</dl>
<dl class="simple" id="index-20">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">(?#...)</span></code></dt><dd><p class="translated">Un comentario; el contenido de los paréntesis es simplemente ignorado.</p>
</dd>
</dl>
<dl class="simple" id="index-21">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">(?=...)</span></code></dt><dd><p class="translated">Coincide si <code class="docutils literal notranslate"><span class="pre">…</span></code> coincide con el siguiente patrón, pero no procesa nada de la cadena. Esto se llama una <em class="dfn">lookahead assertion</em> (aserción de búsqueda anticipada). Por ejemplo, <code class="docutils literal notranslate"><span class="pre">Isaac</span> <span class="pre">(?=Asimov)</span></code> coincidirá con <code class="docutils literal notranslate"><span class="pre">'Isaac</span> <span class="pre">'</span></code> sólo si va seguido de <code class="docutils literal notranslate"><span class="pre">'Asimov'</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-22">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">(?!...)</span></code></dt><dd><p class="translated">Coincide si <code class="docutils literal notranslate"><span class="pre">…</span></code> no coincide con el siguiente. Esta es una <em class="dfn">negative lookahead assertion</em> (aserción negativa de búsqueda anticipada). Por ejemplo, <code class="docutils literal notranslate"><span class="pre">Isaac</span> <span class="pre">(?!Asimov)</span></code> coincidirá con <code class="docutils literal notranslate"><span class="pre">'Isaac</span> <span class="pre">'</span></code> sólo si <em>no</em> es seguido por <code class="docutils literal notranslate"><span class="pre">'Asimov'</span></code>.</p>
</dd>
</dl>
<dl id="index-23">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">(?&lt;=...)</span></code></dt><dd><p class="translated">Coincide si la posición actual en la cadena es precedida por una coincidencia para <code class="docutils literal notranslate"><span class="pre">…</span></code> que termina en la posición actual.  Esto se llama una <em class="dfn">positive lookbehind assertion</em> (aserciones positivas de búsqueda tardía). <code class="docutils literal notranslate"><span class="pre">(?&lt;=abc)def</span></code> encontrará una coincidencia en <code class="docutils literal notranslate"><span class="pre">'abcdef'</span></code>, ya que la búsqueda tardía hará una copia de seguridad de 3 caracteres y comprobará si el patrón contenido coincide. El patrón contenido sólo debe coincidir con cadenas de alguna longitud fija, lo que significa que <code class="docutils literal notranslate"><span class="pre">abc</span></code> o <code class="docutils literal notranslate"><span class="pre">a|b</span></code> están permitidas, pero <code class="docutils literal notranslate"><span class="pre">a*</span></code> y <code class="docutils literal notranslate"><span class="pre">a{3,4}</span></code> no lo están.  Hay que tener en cuenta que los patrones que empiezan con aserciones positivas de búsqueda tardía no coincidirán con el principio de la cadena que se está buscando; lo más probable es que se quiera usar la función <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> en lugar de la función <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;(?&lt;=abc)def&#39;</span><span class="p">,</span> <span class="s1">&#39;abcdef&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;def&#39;</span>
</pre></div>
</div>
<p class="translated">Este ejemplo busca una palabra seguida de un guión:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?&lt;=-)\w+&#39;</span><span class="p">,</span> <span class="s1">&#39;spam-egg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;egg&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Se añadió soporte a las referencias de grupo de longitud fija.</p>
</div>
</dd>
</dl>
<dl class="simple" id="index-24">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">(?&lt;!...)</span></code></dt><dd><p class="translated">Coincide si la posición actual en la cadena no está precedida por una coincidencia de «…».  Esto se llama una <em class="dfn">negative lookbehind assertion</em> (Aserciones negativas de búsqueda tardía).  Similar a las aserciones positivas de búsqueda tardía, el patrón contenido sólo debe coincidir con cadenas de alguna longitud fija.  Los patrones que empiezan con aserciones negativas pueden coincidir al principio de la cadena que se busca.</p>
</dd>
</dl>
<span id="re-conditional-expression"></span><dl id="index-25">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">(?(id/name)yes-pattern|no-pattern)</span></code></dt><dd><p class="translated">Tratará de coincidir con el <code class="docutils literal notranslate"><span class="pre">yes-pattern</span></code> (con patrón) si el grupo con un <em>id</em> o  <em>nombre</em> existe, y con el <code class="docutils literal notranslate"><span class="pre">no-pattern</span></code> (sin patrón) si no existe. El <code class="docutils literal notranslate"><span class="pre">no-pattern</span></code> es opcional y puede ser omitido. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">(&lt;)?(\w+&#64;\w+(?:\.\w+)+)(?(1)&gt;||$)</span></code> es un patrón de coincidencia de correo electrónico deficiente, ya que coincidirá con <code class="docutils literal notranslate"><span class="pre">'&lt;user&#64;host.com&gt;'</span></code> así como con <code class="docutils literal notranslate"><span class="pre">'user&#64;host.com'</span></code>, pero no con <code class="docutils literal notranslate"><span class="pre">'&lt;user&#64;host.com'</span></code> ni con <code class="docutils literal notranslate"><span class="pre">'user&#64;host.com&gt;'</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>El <em>id</em> del grupo solo puede contener dígitos ASCII. En patrones de tipo <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, el <em>name</em> del grupo solo puede contener bytes en el rango ASCII (<code class="docutils literal notranslate"><span class="pre">b'\x00'</span></code>-<code class="docutils literal notranslate"><span class="pre">b'\x7f'</span></code>).</p>
</div>
</dd>
</dl>
<p class="translated" id="re-special-sequences">Las secuencias especiales consisten en <code class="docutils literal notranslate"><span class="pre">'\'</span></code> y un carácter de la lista que aparece más adelante. Si el carácter ordinario no es un dígito ASCII o una letra ASCII, entonces el RE resultante coincidirá con el segundo carácter.  Por ejemplo, <code class="docutils literal notranslate"><span class="pre">\$</span></code> coincide con el carácter <code class="docutils literal notranslate"><span class="pre">'$'</span></code>.</p>
<dl class="simple" id="index-26">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">\number</span></code></dt><dd><p class="translated">Coincide con el contenido del grupo del mismo número.  Los grupos se numeran empezando por el 1. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">(.+)</span> <span class="pre">\1</span></code> coincide con <code class="docutils literal notranslate"><span class="pre">'el</span> <span class="pre">el'</span></code> o <code class="docutils literal notranslate"><span class="pre">'55</span> <span class="pre">55'</span></code>, pero no con <code class="docutils literal notranslate"><span class="pre">'elel'</span></code> (notar el espacio después del grupo).  Esta secuencia especial sólo puede ser usada para hacer coincidir uno de los primeros 99 grupos.  Si el primer dígito del <em>número</em> es 0, o el <em>número</em> tiene 3 dígitos octales, no se interpretará como una coincidencia de grupo, sino como el carácter con valor octal <em>número</em>. Dentro de los <code class="docutils literal notranslate"><span class="pre">'['</span></code> y <code class="docutils literal notranslate"><span class="pre">']'</span></code> de una clase de caracteres, todos los escapes numéricos son tratados como caracteres.</p>
</dd>
</dl>
<dl class="simple" id="index-27">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">\A</span></code></dt><dd><p class="translated">Coincide sólo al principio de la cadena.</p>
</dd>
</dl>
<dl id="index-28">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">\b</span></code></dt><dd><p class="untranslated">Matches the empty string, but only at the beginning or end of a word.
A word is defined as a sequence of word characters.
Note that formally, <code class="docutils literal notranslate"><span class="pre">\b</span></code> is defined as the boundary
between a <code class="docutils literal notranslate"><span class="pre">\w</span></code> and a <code class="docutils literal notranslate"><span class="pre">\W</span></code> character (or vice versa),
or between <code class="docutils literal notranslate"><span class="pre">\w</span></code> and the beginning or end of the string.
This means that <code class="docutils literal notranslate"><span class="pre">r'\bat\b'</span></code> matches <code class="docutils literal notranslate"><span class="pre">'at'</span></code>, <code class="docutils literal notranslate"><span class="pre">'at.'</span></code>, <code class="docutils literal notranslate"><span class="pre">'(at)'</span></code>,
and <code class="docutils literal notranslate"><span class="pre">'as</span> <span class="pre">at</span> <span class="pre">ay'</span></code> but not <code class="docutils literal notranslate"><span class="pre">'attempt'</span></code> or <code class="docutils literal notranslate"><span class="pre">'atlas'</span></code>.</p>
<p class="untranslated">The default word characters in Unicode (str) patterns
are Unicode alphanumerics and the underscore,
but this can be changed by using the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag.
Word boundaries are determined by the current locale
if the <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> flag is used.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">Inside a character range, <code class="docutils literal notranslate"><span class="pre">\b</span></code> represents the backspace character,
for compatibility with Python’s string literals.</p>
</div>
</dd>
</dl>
<dl id="index-29">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">\B</span></code></dt><dd><p class="untranslated">Matches the empty string,
but only when it is <em>not</em> at the beginning or end of a word.
This means that <code class="docutils literal notranslate"><span class="pre">r'at\B'</span></code> matches <code class="docutils literal notranslate"><span class="pre">'athens'</span></code>, <code class="docutils literal notranslate"><span class="pre">'atom'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'attorney'</span></code>, but not <code class="docutils literal notranslate"><span class="pre">'at'</span></code>, <code class="docutils literal notranslate"><span class="pre">'at.'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'at!'</span></code>.
<code class="docutils literal notranslate"><span class="pre">\B</span></code> is the opposite of <code class="docutils literal notranslate"><span class="pre">\b</span></code>,
so word characters in Unicode (str) patterns
are Unicode alphanumerics or the underscore,
although this can be changed by using the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag.
Word boundaries are determined by the current locale
if the <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> flag is used.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.14: </span><code class="docutils literal notranslate"><span class="pre">\B</span></code> now matches empty input string.</p>
</div>
</dd>
</dl>
<dl id="index-30">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">\d</span></code></dt><dd><dl>
<dt class="translated">Para los patrones de Unicode (str):</dt><dd><p class="untranslated">Matches any Unicode decimal digit
(that is, any character in Unicode character category <a class="reference external" href="https://www.unicode.org/versions/Unicode15.0.0/ch04.pdf#G134153">[Nd]</a>).
This includes <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>, and also many other digit characters.</p>
<p class="untranslated">Matches <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code> if the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used.</p>
</dd>
<dt class="translated">Para patrones de 8 bits (bytes):</dt><dd><p class="untranslated">Matches any decimal digit in the ASCII character set;
this is equivalent to <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<dl id="index-31">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">\D</span></code></dt><dd><p class="untranslated">Matches any character which is not a decimal digit.
This is the opposite of <code class="docutils literal notranslate"><span class="pre">\d</span></code>.</p>
<p class="untranslated">Matches <code class="docutils literal notranslate"><span class="pre">[^0-9]</span></code> if the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used.</p>
</dd>
</dl>
<dl id="index-32">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">\s</span></code></dt><dd><dl>
<dt class="translated">Para los patrones de Unicode (str):</dt><dd><p class="untranslated">Matches Unicode whitespace characters (as defined by <a class="reference internal" href="stdtypes.html#str.isspace" title="str.isspace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.isspace()</span></code></a>).
This includes <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>, and also many other characters, for example the
non-breaking spaces mandated by typography rules in many languages.</p>
<p class="untranslated">Matches <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code> if the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used.</p>
</dd>
<dt class="translated">Para patrones de 8 bits (bytes):</dt><dd><p class="translated">Coincide con los caracteres considerados como espacios en blanco en el conjunto de caracteres ASCII, lo que equivale a <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<dl id="index-33">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">\S</span></code></dt><dd><p class="untranslated">Matches any character which is not a whitespace character. This is
the opposite of <code class="docutils literal notranslate"><span class="pre">\s</span></code>.</p>
<p class="untranslated">Matches <code class="docutils literal notranslate"><span class="pre">[^</span> <span class="pre">\t\n\r\f\v]</span></code> if the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used.</p>
</dd>
</dl>
<dl id="index-34">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">\w</span></code></dt><dd><dl>
<dt class="translated">Para los patrones de Unicode (str):</dt><dd><p class="untranslated">Matches Unicode word characters;
this includes all Unicode alphanumeric characters
(as defined by <a class="reference internal" href="stdtypes.html#str.isalnum" title="str.isalnum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.isalnum()</span></code></a>),
as well as the underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>).</p>
<p class="untranslated">Matches <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code> if the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used.</p>
</dd>
<dt class="translated">Para patrones de 8 bits (bytes):</dt><dd><p class="untranslated">Matches characters considered alphanumeric in the ASCII character set;
this is equivalent to <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code>.
If the <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> flag is used,
matches characters considered alphanumeric in the current locale and the underscore.</p>
</dd>
</dl>
</dd>
</dl>
<dl id="index-35">
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">\W</span></code></dt><dd><p class="untranslated">Matches any character which is not a word character.
This is the opposite of <code class="docutils literal notranslate"><span class="pre">\w</span></code>.
By default, matches non-underscore (<code class="docutils literal notranslate"><span class="pre">_</span></code>) characters
for which <a class="reference internal" href="stdtypes.html#str.isalnum" title="str.isalnum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.isalnum()</span></code></a> returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p class="untranslated">Matches <code class="docutils literal notranslate"><span class="pre">[^a-zA-Z0-9_]</span></code> if the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used.</p>
<p class="untranslated">If the <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> flag is used,
matches characters which are neither alphanumeric in the current locale
nor the underscore.</p>
</dd>
</dl>
<dl id="index-36">
<dt class="untranslated"><code class="docutils literal notranslate"><span class="pre">\z</span></code></dt><dd><p class="translated">Coincide sólo el final de la cadena.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd>
<dt class="translated"><code class="docutils literal notranslate"><span class="pre">\Z</span></code></dt><dd><p class="untranslated">The same as <code class="docutils literal notranslate"><span class="pre">\z</span></code>.  For compatibility with old Python versions.</p>
</dd>
</dl>
<p class="translated" id="index-37">La mayoría de las <a class="reference internal" href="../reference/lexical_analysis.html#escape-sequences"><span class="std std-ref">secuencias de escape</span></a> soportadas por los literales de cadena de Python también son aceptadas por el analizador de expresiones regulares:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span>\<span class="n">a</span>      \<span class="n">b</span>      \<span class="n">f</span>      \<span class="n">n</span>
\<span class="n">N</span>      \<span class="n">r</span>      \<span class="n">t</span>      \<span class="n">u</span>
\<span class="n">U</span>      \<span class="n">v</span>      \<span class="n">x</span>      \\
</pre></div>
</div>
<p class="translated">(Notar que <code class="docutils literal notranslate"><span class="pre">\b</span></code> se usa para representar los límites de las palabras, y significa «retroceso» (<em>backspace</em>) sólo dentro de las clases de caracteres.)</p>
<p class="untranslated"><code class="docutils literal notranslate"><span class="pre">'\u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'\U'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'\N'</span></code> escape sequences are
only recognized in Unicode (str) patterns.
In bytes patterns they are errors.
Unknown escapes of ASCII letters are reserved
for future use and treated as errors.</p>
<p class="translated">Los escapes octales se incluyen en una forma limitada.  Si el primer dígito es un 0, o si hay tres dígitos octales, se considera un escape octal. De lo contrario, es una referencia de grupo.  En cuanto a los literales de cadena, los escapes octales siempre tienen como máximo tres dígitos de longitud.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Se han añadido las secuencias de escape <code class="docutils literal notranslate"><span class="pre">'\u'</span></code> y <code class="docutils literal notranslate"><span class="pre">'\U'</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Los escapes desconocidos que consisten en <code class="docutils literal notranslate"><span class="pre">'\'</span></code> y una letra ASCII ahora son errores.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Se añadió la secuencia de escape <code class="samp docutils literal notranslate"><span class="pre">'\N{</span><em><span class="pre">name</span></em><span class="pre">}'</span></code>. Como en los literales de cadena, se expande al carácter Unicode nombrado (p. ej. <code class="docutils literal notranslate"><span class="pre">'\N{EM</span> <span class="pre">DASH}'</span></code>).</p>
</div>
</section>
<section id="module-contents">
<span id="contents-of-module-re"></span><h2 class="translated">Contenidos del módulo<a class="headerlink" href="#module-contents" title="Link to this heading">¶</a></h2>
<p class="translated">El módulo define varias funciones, constantes y una excepción. Algunas de las funciones son versiones simplificadas de los métodos completos de las expresiones regulares compiladas.  La mayoría de las aplicaciones no triviales utilizan siempre la forma compilada.</p>
<section id="flags">
<h3 class="translated">Indicadores<a class="headerlink" href="#flags" title="Link to this heading">¶</a></h3>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Ahora las constantes de indicadores son instancias de <a class="reference internal" href="#re.RegexFlag" title="re.RegexFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegexFlag</span></code></a>, que es una subclase de <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a>.</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="re.RegexFlag">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">RegexFlag</span></span><a class="headerlink" href="#re.RegexFlag" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una clase <a class="reference internal" href="enum.html#enum.IntFlag" title="enum.IntFlag"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntFlag</span></code></a> contiene las opciones regex que se enumeran a continuación.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11: </span>- added to <code class="docutils literal notranslate"><span class="pre">__all__</span></code></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.A">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">A</span></span><a class="headerlink" href="#re.A" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="re.ASCII">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">ASCII</span></span><a class="headerlink" href="#re.ASCII" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Make <code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code>, <code class="docutils literal notranslate"><span class="pre">\d</span></code>, <code class="docutils literal notranslate"><span class="pre">\D</span></code>, <code class="docutils literal notranslate"><span class="pre">\s</span></code> and <code class="docutils literal notranslate"><span class="pre">\S</span></code>
perform ASCII-only matching instead of full Unicode matching.  This is only
meaningful for Unicode (str) patterns, and is ignored for bytes patterns.</p>
<p class="untranslated">Corresponds to the inline flag <code class="docutils literal notranslate"><span class="pre">(?a)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">The <a class="reference internal" href="#re.U" title="re.U"><code class="xref py py-const docutils literal notranslate"><span class="pre">U</span></code></a> flag still exists for backward compatibility,
but is redundant in Python 3 since
matches are Unicode by default for <code class="docutils literal notranslate"><span class="pre">str</span></code> patterns,
and Unicode matching isn’t allowed for bytes patterns.
<a class="reference internal" href="#re.UNICODE" title="re.UNICODE"><code class="xref py py-const docutils literal notranslate"><span class="pre">UNICODE</span></code></a> and the inline flag <code class="docutils literal notranslate"><span class="pre">(?u)</span></code> are similarly redundant.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.DEBUG">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">DEBUG</span></span><a class="headerlink" href="#re.DEBUG" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Display debug information about compiled expression.</p>
<p class="untranslated">No corresponding inline flag.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.I">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">I</span></span><a class="headerlink" href="#re.I" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="re.IGNORECASE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">IGNORECASE</span></span><a class="headerlink" href="#re.IGNORECASE" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Perform case-insensitive matching;
expressions like <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code> will also  match lowercase letters.
Full Unicode matching (such as <code class="docutils literal notranslate"><span class="pre">Ü</span></code> matching <code class="docutils literal notranslate"><span class="pre">ü</span></code>)
also works unless the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag
is used to disable non-ASCII matches.
The current locale does not change the effect of this flag
unless the <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> flag is also used.</p>
<p class="untranslated">Corresponds to the inline flag <code class="docutils literal notranslate"><span class="pre">(?i)</span></code>.</p>
<p class="untranslated">Note that when the Unicode patterns <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code> or <code class="docutils literal notranslate"><span class="pre">[A-Z]</span></code> are used in
combination with the <a class="reference internal" href="#re.IGNORECASE" title="re.IGNORECASE"><code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORECASE</span></code></a> flag, they will match the 52 ASCII
letters and 4 additional non-ASCII letters: “İ” (U+0130, Latin capital
letter I with dot above), “ı” (U+0131, Latin small letter dotless i),
“ſ” (U+017F, Latin small letter long s) and “K” (U+212A, Kelvin sign).
If the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used, only letters “a” to “z”
and “A” to “Z” are matched.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.L">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#re.L" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="re.LOCALE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">LOCALE</span></span><a class="headerlink" href="#re.LOCALE" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Make <code class="docutils literal notranslate"><span class="pre">\w</span></code>, <code class="docutils literal notranslate"><span class="pre">\W</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\B</span></code> and case-insensitive matching
dependent on the current locale.
This flag can be used only with bytes patterns.</p>
<p class="untranslated">Corresponds to the inline flag <code class="docutils literal notranslate"><span class="pre">(?L)</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p class="untranslated">This flag is discouraged; consider Unicode matching instead.
The locale mechanism is very unreliable
as it only handles one «culture» at a time
and only works with 8-bit locales.
Unicode matching is enabled by default for Unicode (str) patterns
and it is able to handle different locales and languages.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span><a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> can be used only with bytes patterns
and is not compatible with <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Compiled regular expression objects with the <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> flag
no longer depend on the locale at compile time.
Only the locale at matching time affects the result of matching.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.M">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">M</span></span><a class="headerlink" href="#re.M" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="re.MULTILINE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">MULTILINE</span></span><a class="headerlink" href="#re.MULTILINE" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">When specified, the pattern character <code class="docutils literal notranslate"><span class="pre">'^'</span></code> matches at the beginning of the
string and at the beginning of each line (immediately following each newline);
and the pattern character <code class="docutils literal notranslate"><span class="pre">'$'</span></code> matches at the end of the string and at the
end of each line (immediately preceding each newline).  By default, <code class="docutils literal notranslate"><span class="pre">'^'</span></code>
matches only at the beginning of the string, and <code class="docutils literal notranslate"><span class="pre">'$'</span></code> only at the end of the
string and immediately before the newline (if any) at the end of the string.</p>
<p class="untranslated">Corresponds to the inline flag <code class="docutils literal notranslate"><span class="pre">(?m)</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.NOFLAG">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">NOFLAG</span></span><a class="headerlink" href="#re.NOFLAG" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Indica que no se aplica ninguna bandera, el valor es <code class="docutils literal notranslate"><span class="pre">0</span></code>. Esta bandera puede ser utilizada como valor predeterminado para un argumento de palabra clave de función o como un valor que será condicionalmente combinado con otras banderas usando el operador binario OR. Ejemplo de uso como valor predeterminado:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">myfunc</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">NOFLAG</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.S">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">S</span></span><a class="headerlink" href="#re.S" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="re.DOTALL">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">DOTALL</span></span><a class="headerlink" href="#re.DOTALL" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Make the <code class="docutils literal notranslate"><span class="pre">'.'</span></code> special character match any character at all, including a
newline; without this flag, <code class="docutils literal notranslate"><span class="pre">'.'</span></code> will match anything <em>except</em> a newline.</p>
<p class="untranslated">Corresponds to the inline flag <code class="docutils literal notranslate"><span class="pre">(?s)</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.U">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">U</span></span><a class="headerlink" href="#re.U" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="re.UNICODE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">UNICODE</span></span><a class="headerlink" href="#re.UNICODE" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">In Python 3, Unicode characters are matched by default
for <code class="docutils literal notranslate"><span class="pre">str</span></code> patterns.
This flag is therefore redundant with <strong>no effect</strong>
and is only kept for backward compatibility.</p>
<p class="untranslated">See <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> to restrict matching to ASCII characters instead.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="re.X">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">X</span></span><a class="headerlink" href="#re.X" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="re.VERBOSE">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">VERBOSE</span></span><a class="headerlink" href="#re.VERBOSE" title="Link to this definition">¶</a></dt>
<dd><p class="translated" id="index-38">Esta bandera permite escribir expresiones regulares que se ven mejor y son más legibles, facilitando la separación visual de las secciones lógicas del patrón y la adición de comentarios. Los espacios en blanco dentro del patrón se ignoran, excepto cuando están en una clase de caracteres, o cuando están precedidos por una barra inversa sin escapar, o dentro de tokens como <code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">(?:</span></code> o <code class="docutils literal notranslate"><span class="pre">(?P&lt;...&gt;</span></code>. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">(?</span> <span class="pre">:</span></code> y <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">?</span></code> no están permitidos. Cuando una línea contiene un <code class="docutils literal notranslate"><span class="pre">#</span></code> que no está en una clase de caracteres y no está precedida por una barra inversa sin escapar, todos los caracteres desde el <code class="docutils literal notranslate"><span class="pre">#</span></code> más a la izquierda hasta el final de la línea son ignorados.</p>
<p class="translated">Esto significa que los dos siguientes objetos expresión regular que coinciden con un número decimal son funcionalmente iguales:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;\d +  # the integral part</span>
<span class="s2">                   \.    # the decimal point</span>
<span class="s2">                   \d *  # some fractional digits&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+\.\d*&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Corresponde al indicador en línea <code class="docutils literal notranslate"><span class="pre">(?x)</span></code>.</p>
</dd></dl>

</section>
<section id="functions">
<h3 class="translated">Funciones<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="re.compile">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">compile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.compile" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Compila un patrón de expresión regular en un <a class="reference internal" href="#re-objects"><span class="std std-ref">objeto de expresión regular</span></a>, que puede ser usado para las coincidencias usando <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a>, <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> y otros métodos, descritos más adelante.</p>
<p class="untranslated">The expression’s behaviour can be modified by specifying a <em>flags</em> value.
Values can be any of the <a class="reference internal" href="#flags">flags</a> variables, combined using bitwise OR
(the <code class="docutils literal notranslate"><span class="pre">|</span></code> operator).</p>
<p class="translated">La secuencia</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">prog</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">es equivalente a</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">pero usando <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> y guardando el objeto resultante de la expresión regular para su reutilización es más eficiente cuando la expresión será usada varias veces en un solo programa.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Las versiones compiladas de los patrones más recientes pasaron a <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> y las funciones de coincidencia a nivel de módulo están en caché, así que los programas que usan sólo unas pocas expresiones regulares a la vez no tienen que preocuparse de compilar expresiones regulares.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.search">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.search" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Explora la cadena de caracteres <em>string</em> en busca de la primera ubicación donde el patrón <em>pattern</em> de la expresión regular produce una coincidencia, y retorna un <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> correspondiente. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si ninguna posición en la cadena coincide con el patrón; nota que esto es diferente a encontrar una coincidencia de longitud cero en algún punto de la cadena.</p>
<p class="untranslated">The expression’s behaviour can be modified by specifying a <em>flags</em> value.
Values can be any of the <a class="reference internal" href="#flags">flags</a> variables, combined using bitwise OR
(the <code class="docutils literal notranslate"><span class="pre">|</span></code> operator).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.match">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.match" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Si cero o más caracteres al principio de la cadena <em>string</em> coinciden con el patrón <em>pattern</em> de la expresión regular, retorna un <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> correspondiente. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si la cadena no coincide con el patrón; notar que esto es diferente de una coincidencia de longitud cero.</p>
<p class="translated">Notar que incluso en el modo <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a>, <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a> sólo coincidirá al principio de la cadena y no al principio de cada línea.</p>
<p class="translated">Si se quiere localizar una coincidencia en cualquier lugar de la <em>string</em> («cadena»), se utiliza <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> en su lugar (ver también <a class="reference internal" href="#search-vs-match"><span class="std std-ref">search() vs. match()</span></a>).</p>
<p class="untranslated">The expression’s behaviour can be modified by specifying a <em>flags</em> value.
Values can be any of the <a class="reference internal" href="#flags">flags</a> variables, combined using bitwise OR
(the <code class="docutils literal notranslate"><span class="pre">|</span></code> operator).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.fullmatch">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">fullmatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.fullmatch" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Si toda la cadena <em>string</em> coincide con el patrón <em>pattern</em> de la expresión regular, retorna un <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> correspondiente. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si la cadena no coincide con el patrón; notar que esto es diferente de una coincidencia de longitud cero.</p>
<p class="untranslated">The expression’s behaviour can be modified by specifying a <em>flags</em> value.
Values can be any of the <a class="reference internal" href="#flags">flags</a> variables, combined using bitwise OR
(the <code class="docutils literal notranslate"><span class="pre">|</span></code> operator).</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.split">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.split" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Divide la <em>string</em> («cadena») por el número de ocurrencias del <em>pattern</em> («patrón»).  Si se utilizan paréntesis de captura en <em>pattern</em>, entonces el texto de todos los grupos en el patrón también se retornan como parte de la lista resultante. Si <em>maxsplit</em> (máxima divisibilidad) es distinta de cero, como mucho se producen <em>maxsplit</em> divisiones, y el resto de la cadena se retorna como elemento final de la lista.</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words&#39;, &#39;words&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W+&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;Words&#39;, &#39;words, words.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[a-f]+&#39;</span><span class="p">,</span> <span class="s1">&#39;0a3B9&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">[&#39;0&#39;, &#39;3&#39;, &#39;9&#39;]</span>
</pre></div>
</div>
<p class="translated">Si hay grupos de captura en el separador y coincide al principio de la cadena, el resultado comenzará con una cadena vacía.  Lo mismo ocurre con el final de la cadena:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W+)&#39;</span><span class="p">,</span> <span class="s1">&#39;...words, words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;...&#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;...&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p class="translated">De esa manera, los componentes de los separadores se encuentran siempre en los mismos índices relativos dentro de la lista de resultados.</p>
<p class="untranslated">Adjacent empty matches are not possible, but an empty match can occur
immediately after a non-empty match.</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\b&#39;</span><span class="p">,</span> <span class="s1">&#39;Words, words, words.&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;Words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;, &#39;, &#39;words&#39;, &#39;.&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W*&#39;</span><span class="p">,</span> <span class="s1">&#39;...words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;&#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;d&#39;, &#39;s&#39;, &#39;&#39;, &#39;&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\W*)&#39;</span><span class="p">,</span> <span class="s1">&#39;...words...&#39;</span><span class="p">)</span>
<span class="go">[&#39;&#39;, &#39;...&#39;, &#39;&#39;, &#39;&#39;, &#39;w&#39;, &#39;&#39;, &#39;o&#39;, &#39;&#39;, &#39;r&#39;, &#39;&#39;, &#39;d&#39;, &#39;&#39;, &#39;s&#39;, &#39;...&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]</span>
</pre></div>
</div>
<p class="untranslated">The expression’s behaviour can be modified by specifying a <em>flags</em> value.
Values can be any of the <a class="reference internal" href="#flags">flags</a> variables, combined using bitwise OR
(the <code class="docutils literal notranslate"><span class="pre">|</span></code> operator).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.1: </span>Se añadió el argumento de los indicadores opcionales.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Se añadió el soporte de la división en un patrón que podría coincidir con una cadena vacía.</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.13: </span>Passing <em>maxsplit</em> and <em>flags</em> as positional arguments is deprecated.
In future Python versions they will be
<a class="reference internal" href="../glossary.html#keyword-only-parameter"><span class="std std-ref">keyword-only parameters</span></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.findall">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">findall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.findall" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna todas las coincidencias no superpuestas de <em>pattern</em> en <em>string</em>, como una lista de strings o tuplas. El <em>string</em> se escanea de izquierda a derecha y las coincidencias se retornan en el orden en que se encuentran. Las coincidencias vacías se incluyen en el resultado.</p>
<p class="translated">El resultado depende del número de grupos detectados en el patrón. Si no hay grupos, retorna una lista de strings que coincidan con el patrón completo. Si existe exactamente un grupo, retorna una lista de strings que coincidan con ese grupo. Si hay varios grupos presentes, retorna una lista de tuplas de strings que coinciden con los grupos. Los grupos que no son detectados no afectan la forma del resultado.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\bf[a-z]*&#39;</span><span class="p">,</span> <span class="s1">&#39;which foot or hand fell fastest&#39;</span><span class="p">)</span>
<span class="go">[&#39;foot&#39;, &#39;fell&#39;, &#39;fastest&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\w+)=(\d+)&#39;</span><span class="p">,</span> <span class="s1">&#39;set width=20 and height=10&#39;</span><span class="p">)</span>
<span class="go">[(&#39;width&#39;, &#39;20&#39;), (&#39;height&#39;, &#39;10&#39;)]</span>
</pre></div>
</div>
<p class="untranslated">The expression’s behaviour can be modified by specifying a <em>flags</em> value.
Values can be any of the <a class="reference internal" href="#flags">flags</a> variables, combined using bitwise OR
(the <code class="docutils literal notranslate"><span class="pre">|</span></code> operator).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Las coincidencias no vacías ahora pueden empezar justo después de una coincidencia vacía anterior.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.finditer">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">finditer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.finditer" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna un <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterador</span></a> que produce objetos <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> sobre todas las coincidencias no superpuestas para el patrón de RE <em>pattern</em> en la <em>string</em>. La <em>string</em> es examinada de izquierda a derecha, y las coincidencias son retornadas en el orden en que se encuentran. Las coincidencias vacías se incluyen en el resultado.</p>
<p class="untranslated">The expression’s behaviour can be modified by specifying a <em>flags</em> value.
Values can be any of the <a class="reference internal" href="#flags">flags</a> variables, combined using bitwise OR
(the <code class="docutils literal notranslate"><span class="pre">|</span></code> operator).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Las coincidencias no vacías ahora pueden empezar justo después de una coincidencia vacía anterior.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.sub">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.sub" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna la cadena obtenida reemplazando las ocurrencias no superpuestas del <em>pattern</em> («patrón») en la <em>string</em> («cadena») por el reemplazo de <em>repl</em>.  Si el patrón no se encuentra, se retorna <em>string</em> sin cambios.  <em>repl</em> puede ser una cadena o una función; si es una cadena, cualquier barra inversa escapada en ella es procesada.  Es decir, <code class="docutils literal notranslate"><span class="pre">\n</span></code> se convierte en un carácter de una sola línea nueva, <code class="docutils literal notranslate"><span class="pre">\r</span></code> se convierte en un retorno de carro, y así sucesivamente.  Los escapes desconocidos de las letras ASCII se reservan para un uso futuro y se tratan como errores.  Otros escapes desconocidos como <code class="docutils literal notranslate"><span class="pre">\&amp;</span></code> no se utilizan. Las referencias inversas, como <code class="docutils literal notranslate"><span class="pre">\6</span></code>, se reemplazan por la subcadena que corresponde al grupo 6 del patrón. Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="sa">r</span><span class="s1">&#39;static PyObject*\npy_\1(void)\n{&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="s1">&#39;def myfunc():&#39;</span><span class="p">)</span>
<span class="go">&#39;static PyObject*\npy_myfunc(void)\n{&#39;</span>
</pre></div>
</div>
<p class="translated">Si <em>repl</em> es una función, se llama para cada ocurrencia no superpuesta de <em>pattern</em>.  La función toma un solo argumento <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a>, y retorna la cadena de sustitución.  Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">dashrepl</span><span class="p">(</span><span class="n">matchobj</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">matchobj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39; &#39;</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;-&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;-{1,2}&#39;</span><span class="p">,</span> <span class="n">dashrepl</span><span class="p">,</span> <span class="s1">&#39;pro----gram-files&#39;</span><span class="p">)</span>
<span class="go">&#39;pro--gram files&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\sAND\s&#39;</span><span class="p">,</span> <span class="s1">&#39; &amp; &#39;</span><span class="p">,</span> <span class="s1">&#39;Baked Beans And Spam&#39;</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
<span class="go">&#39;Baked Beans &amp; Spam&#39;</span>
</pre></div>
</div>
<p class="translated">El patrón puede ser una cadena o un <a class="reference internal" href="#re.Pattern" title="re.Pattern"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pattern</span></code></a>.</p>
<p class="untranslated">The optional argument <em>count</em> is the maximum number of pattern occurrences to be
replaced; <em>count</em> must be a non-negative integer.  If omitted or zero, all
occurrences will be replaced.</p>
<p class="untranslated">Adjacent empty matches are not possible, but an empty match can occur
immediately after a non-empty match.
As a result, <code class="docutils literal notranslate"><span class="pre">sub('x*',</span> <span class="pre">'-',</span> <span class="pre">'abxd')</span></code> returns <code class="docutils literal notranslate"><span class="pre">'-a-b--d-'</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">'-a-b-d-'</span></code>.</p>
<p class="translated" id="index-39">En los argumentos <em>repl</em> de tipo cadena, además de los escapes de caracteres y las referencias inversas descritas anteriormente, <code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code> usará la subcadena coincidente con el grupo llamado <code class="docutils literal notranslate"><span class="pre">name</span></code>, como se define en la sintaxis <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code>. <code class="docutils literal notranslate"><span class="pre">\g&lt;number&gt;</span></code> utiliza el número de grupo correspondiente; <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;</span></code> es por lo tanto equivalente a <code class="docutils literal notranslate"><span class="pre">\2</span></code>, pero no es ambiguo en un reemplazo como sucede con <code class="docutils literal notranslate"><span class="pre">\g&lt;2&gt;0</span></code>.  <code class="docutils literal notranslate"><span class="pre">\20</span></code> se interpretaría como una referencia al grupo 20, no como una referencia al grupo 2 seguido del carácter literal <code class="docutils literal notranslate"><span class="pre">'0'</span></code>.  La referencia inversa <code class="docutils literal notranslate"><span class="pre">\g&lt;0&gt;</span></code> sustituye en toda la subcadena coincidente con la RE.</p>
<p class="untranslated">The expression’s behaviour can be modified by specifying a <em>flags</em> value.
Values can be any of the <a class="reference internal" href="#flags">flags</a> variables, combined using bitwise OR
(the <code class="docutils literal notranslate"><span class="pre">|</span></code> operator).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.1: </span>Se añadió el argumento de los indicadores opcionales.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Los grupos no coincidentes son reemplazados por una cadena vacía.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Los escapes desconocidos en el <em>pattern</em> que consisten en <code class="docutils literal notranslate"><span class="pre">'\'</span></code> y una letra ASCII ahora son errores.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Unknown escapes in <em>repl</em> consisting of <code class="docutils literal notranslate"><span class="pre">'\'</span></code> and an ASCII letter
now are errors.
An empty match can occur immediately after a non-empty match.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>El <em>id</em> del grupo solo puede contener dígitos ASCII. En las cadenas de reemplazo <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, el nombre del grupo <em>name</em> solo puede contener bytes en el rango ASCII (<code class="docutils literal notranslate"><span class="pre">b'\x00'</span></code>-<code class="docutils literal notranslate"><span class="pre">b'\x7f'</span></code>).</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.13: </span>Passing <em>count</em> and <em>flags</em> as positional arguments is deprecated.
In future Python versions they will be
<a class="reference internal" href="../glossary.html#keyword-only-parameter"><span class="std std-ref">keyword-only parameters</span></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.subn">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">subn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.subn" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Realiza la misma operación que <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>, pero retorna una tupla <code class="docutils literal notranslate"><span class="pre">(new_string,</span> <span class="pre">number_of_subs_made)</span></code>.</p>
<p class="untranslated">The expression’s behaviour can be modified by specifying a <em>flags</em> value.
Values can be any of the <a class="reference internal" href="#flags">flags</a> variables, combined using bitwise OR
(the <code class="docutils literal notranslate"><span class="pre">|</span></code> operator).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.escape">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">escape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.escape" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Caracteres de escape especiales en <em>pattern</em> (» patrón»). Esto es útil si quieres hacer coincidir una cadena literal arbitraria que puede tener metacaracteres de expresión regular en ella.  Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;https://www.python.org&#39;</span><span class="p">))</span>
<span class="go">https://www\.python\.org</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">legal_chars</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span> <span class="o">+</span> <span class="s2">&quot;!#$%&amp;&#39;*+-.^_`|~:&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]+&#39;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">legal_chars</span><span class="p">))</span>
<span class="go">[abcdefghijklmnopqrstuvwxyz0123456789!\#\$%\&amp;&#39;\*\+\-\.\^_`\|\~:]+</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">operators</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;**&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))))</span>
<span class="go">/|\-|\+|\*\*|\*</span>
</pre></div>
</div>
<p class="translated">Esta función no debe usarse para la cadena de reemplazo en <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> y <a class="reference internal" href="#re.subn" title="re.subn"><code class="xref py py-func docutils literal notranslate"><span class="pre">subn()</span></code></a>, sólo deben escaparse las barras inversas.  Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">digits_re</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\d+&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span> <span class="o">=</span> <span class="s1">&#39;/usr/sbin/sendmail - 0 errors, 12 warnings&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">digits_re</span><span class="p">,</span> <span class="n">digits_re</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">),</span> <span class="n">sample</span><span class="p">))</span>
<span class="go">/usr/sbin/sendmail - \d+ errors, \d+ warnings</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>El carácter de <code class="docutils literal notranslate"><span class="pre">'_'</span></code> ya no se escapa.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Sólo se escapan los caracteres que pueden tener un significado especial en una expresión regular. Como resultado, <code class="docutils literal notranslate"><span class="pre">'!'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&quot;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'%'</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;'&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">','</span></code>, <code class="docutils literal notranslate"><span class="pre">'/'</span></code>, <code class="docutils literal notranslate"><span class="pre">':'</span></code>, <code class="docutils literal notranslate"><span class="pre">';'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'='</span></code>, <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> y <code class="docutils literal notranslate"><span class="pre">&quot;`&quot;</span></code> ya no se escapan.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="re.purge">
<span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">purge</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#re.purge" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Despeja la caché de expresión regular.</p>
</dd></dl>

</section>
<section id="exceptions">
<h3 class="translated">Excepciones<a class="headerlink" href="#exceptions" title="Link to this heading">¶</a></h3>
<dl class="py exception">
<dt class="sig sig-object py" id="re.PatternError">
<em class="property"><span class="k"><span class="pre">exception</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">PatternError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pattern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.PatternError" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Exception raised when a string passed to one of the functions here is not a
valid regular expression (for example, it might contain unmatched parentheses)
or when some other error occurs during compilation or matching.  It is never an
error if a string contains no match for a pattern.  The <code class="docutils literal notranslate"><span class="pre">PatternError</span></code> instance has
the following additional attributes:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="re.PatternError.msg">
<span class="sig-name descname"><span class="pre">msg</span></span><a class="headerlink" href="#re.PatternError.msg" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El mensaje de error sin formato.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.PatternError.pattern">
<span class="sig-name descname"><span class="pre">pattern</span></span><a class="headerlink" href="#re.PatternError.pattern" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El patrón de expresión regular.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.PatternError.pos">
<span class="sig-name descname"><span class="pre">pos</span></span><a class="headerlink" href="#re.PatternError.pos" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El índice en <em>pattern</em> («patrón») donde la compilación falló (puede ser <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.PatternError.lineno">
<span class="sig-name descname"><span class="pre">lineno</span></span><a class="headerlink" href="#re.PatternError.lineno" title="Link to this definition">¶</a></dt>
<dd><p class="translated">La línea correspondiente a <em>pos</em> (puede ser <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.PatternError.colno">
<span class="sig-name descname"><span class="pre">colno</span></span><a class="headerlink" href="#re.PatternError.colno" title="Link to this definition">¶</a></dt>
<dd><p class="translated">La columna correspondiente a <em>pos</em> (puede ser <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Se añadieron atributos adicionales.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13: </span><code class="docutils literal notranslate"><span class="pre">PatternError</span></code> was originally named <code class="docutils literal notranslate"><span class="pre">error</span></code>; the latter is kept as an alias for
backward compatibility.</p>
</div>
</dd></dl>

</section>
</section>
<section id="regular-expression-objects">
<span id="re-objects"></span><h2 class="translated">Objetos expresión regular<a class="headerlink" href="#regular-expression-objects" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="re.Pattern">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">Pattern</span></span><a class="headerlink" href="#re.Pattern" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Objeto de expresión regular compilada devuelto por <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span><a class="reference internal" href="#re.Pattern" title="re.Pattern"><code class="xref py py-class docutils literal notranslate"><span class="pre">re.Pattern</span></code></a> soporta <code class="docutils literal notranslate"><span class="pre">[]</span></code> para indicar un patrón Unicode (str) o de bytes. Ver <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.search">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.search" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Escanea a través de la cadena <em>string</em> buscando la primera ubicación donde esta expresión regular produce una coincidencia, y retorna un <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> correspondiente.  Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si ninguna posición en la cadena coincide con el patrón; notar que esto es diferente a encontrar una coincidencia de longitud cero en algún punto de la cadena.</p>
<p class="translated">El segundo parámetro opcional <em>pos</em> proporciona un índice en la cadena donde la búsqueda debe comenzar; por defecto es <code class="docutils literal notranslate"><span class="pre">0</span></code>.  Esto no es completamente equivalente a dividir la cadena; el patrón de carácter <code class="docutils literal notranslate"><span class="pre">'^'</span></code> coincide en el inicio real de la cadena y en las posiciones justo después de una nueva línea, pero no necesariamente en el índice donde la búsqueda va a comenzar.</p>
<p class="translated">El parámetro opcional <em>endpos</em> limita hasta dónde se buscará la cadena; será como si la cadena fuera de <em>endpos</em> caracteres de largo, por lo que sólo se buscará una coincidencia entre los caracteres de <em>pos</em> a <code class="docutils literal notranslate"><span class="pre">endpos</span> <span class="pre">-</span> <span class="pre">1</span></code>.  Si <em>endpos</em> es menor que <em>pos</em>, no se encontrará ninguna coincidencia; de lo contrario, si <em>rx</em> es un objeto de expresión regular compilado, <code class="docutils literal notranslate"><span class="pre">rx.search(string,</span> <span class="pre">0,</span> <span class="pre">50)</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">rx.search(string[:50],</span> <span class="pre">0)</span></code>.</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>     <span class="c1"># Match at index 0</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;d&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># No match; search doesn&#39;t include the &quot;d&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.match">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.match" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Si cero o más caracteres en el comienzo <em>beginning</em> de la cadena <em>string</em> coinciden con esta expresión regular, retorna un <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> correspondiente. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si la cadena no coincide con el patrón; notar que esto es diferente de una coincidencia de longitud cero.</p>
<p class="translated">Los parámetros opcionales <em>pos</em> y <em>endpos</em> tienen el mismo significado que para el método <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;o&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>      <span class="c1"># No match as &quot;o&quot; is not at the start of &quot;dog&quot;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># Match as &quot;o&quot; is the 2nd character of &quot;dog&quot;.</span>
<span class="go">&lt;re.Match object; span=(1, 2), match=&#39;o&#39;&gt;</span>
</pre></div>
</div>
<p class="translated">Si se quiere encontrar una coincidencia en cualquier lugar de <em>string</em>, utilizar <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> en su lugar (ver también <a class="reference internal" href="#search-vs-match"><span class="std std-ref">search() vs. match()</span></a>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.fullmatch">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">fullmatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.fullmatch" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Si toda la cadena <em>string</em> coincide con esta expresión regular, retorna un <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> correspondiente.  Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si la cadena no coincide con el patrón; notar que esto es diferente de una coincidencia de longitud cero.</p>
<p class="translated">Los parámetros opcionales <em>pos</em> y <em>endpos</em> tienen el mismo significado que para el método <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;o[gh]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;dog&quot;</span><span class="p">)</span>      <span class="c1"># No match as &quot;o&quot; is not at the start of &quot;dog&quot;.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;ogre&quot;</span><span class="p">)</span>     <span class="c1"># No match as not the full string matches.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;doggie&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>   <span class="c1"># Matches within given limits.</span>
<span class="go">&lt;re.Match object; span=(1, 3), match=&#39;og&#39;&gt;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.split">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsplit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.split" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Idéntico a la función <a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a>, usando el patrón compilado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.findall">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">findall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.findall" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Similar a la función <a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a>, usando el patrón compilado, pero también acepta parámetros opcionales <em>pos</em> y <em>endpos</em> que limitan la región de búsqueda como para <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.finditer">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">finditer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">endpos</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.finditer" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Similar a la función <a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a>, usando el patrón compilado, pero también acepta parámetros opcionales <em>pos</em> y <em>endpos</em> que limitan la región de búsqueda como para <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.sub">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.sub" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Idéntico a la función <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a>, usando el patrón compilado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Pattern.subn">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">subn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Pattern.subn" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Idéntico a la función <a class="reference internal" href="#re.subn" title="re.subn"><code class="xref py py-func docutils literal notranslate"><span class="pre">subn()</span></code></a>, usando el patrón compilado.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Pattern.flags">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">flags</span></span><a class="headerlink" href="#re.Pattern.flags" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The regex matching flags.  This is a combination of the flags given to
<a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>, any <code class="docutils literal notranslate"><span class="pre">(?...)</span></code> inline flags in the pattern, and implicit
flags such as <a class="reference internal" href="#re.UNICODE" title="re.UNICODE"><code class="xref py py-const docutils literal notranslate"><span class="pre">UNICODE</span></code></a> if the pattern is a Unicode string.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Pattern.groups">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">groups</span></span><a class="headerlink" href="#re.Pattern.groups" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El número de grupos de captura en el patrón.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Pattern.groupindex">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">groupindex</span></span><a class="headerlink" href="#re.Pattern.groupindex" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Un diccionario que mapea cualquier nombre de grupo simbólico definido por <code class="docutils literal notranslate"><span class="pre">(?P&lt;id&gt;)</span></code> para agrupar números.  El diccionario está vacío si no se utilizaron grupos simbólicos en el patrón.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Pattern.pattern">
<span class="sig-prename descclassname"><span class="pre">Pattern.</span></span><span class="sig-name descname"><span class="pre">pattern</span></span><a class="headerlink" href="#re.Pattern.pattern" title="Link to this definition">¶</a></dt>
<dd><p class="translated">La cadena de patrones a partir de la cual el objeto de patrón fue compilado.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Se añadió el soporte de <a class="reference internal" href="copy.html#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a> y <a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a>.  Los objetos expresión regular compilados se consideran atómicos.</p>
</div>
</section>
<section id="match-objects">
<span id="id3"></span><h2 class="translated">Objetos de coincidencia<a class="headerlink" href="#match-objects" title="Link to this heading">¶</a></h2>
<p class="translated">Los objetos de coincidencia siempre tienen un valor booleano de <code class="docutils literal notranslate"><span class="pre">True</span></code> («Verdadero»). Ya que <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> y <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> retornan <code class="docutils literal notranslate"><span class="pre">None</span></code> cuando no hay coincidencia. Se puede probar si hubo una coincidencia con una simple declaración <code class="docutils literal notranslate"><span class="pre">if</span></code>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
<span class="k">if</span> <span class="n">match</span><span class="p">:</span>
    <span class="n">process</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="re.Match">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">re.</span></span><span class="sig-name descname"><span class="pre">Match</span></span><a class="headerlink" href="#re.Match" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Objeto Match devuelto por llamadas exitosas a <code class="docutils literal notranslate"><span class="pre">match</span></code> y <code class="docutils literal notranslate"><span class="pre">search</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span><a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">re.Match</span></code></a> soporta <code class="docutils literal notranslate"><span class="pre">[]</span></code> para indicar una coincidencia Unicode (str) o de bytes. Ver <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.expand">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">template</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.expand" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return the string obtained by doing backslash substitution on the template
string <em>template</em>, as done by the <a class="reference internal" href="#re.Pattern.sub" title="re.Pattern.sub"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sub()</span></code></a> method.
Escapes such as <code class="docutils literal notranslate"><span class="pre">\n</span></code> are converted to the appropriate characters,
and numeric backreferences (<code class="docutils literal notranslate"><span class="pre">\1</span></code>, <code class="docutils literal notranslate"><span class="pre">\2</span></code>) and named backreferences
(<code class="docutils literal notranslate"><span class="pre">\g&lt;1&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">\g&lt;name&gt;</span></code>) are replaced by the contents of the
corresponding group. The backreference <code class="docutils literal notranslate"><span class="pre">\g&lt;0&gt;</span></code> will be
replaced by the entire match.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Los grupos no coincidentes son reemplazados por una cadena vacía.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.group">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">group</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">group1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.group" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna uno o más subgrupos de la coincidencia.  Si hay un solo argumento, el resultado es una sola cadena; si hay múltiples argumentos, el resultado es una tupla con un elemento por argumento. Sin argumentos, <em>group1</em> tiene un valor por defecto de cero (se retorna la coincidencia completa). Si un argumento <em>groupN</em> es cero, el valor de retorno correspondiente es toda la cadena coincidente; si está en el rango inclusivo [1..99], es la cadena coincidente con el grupo correspondiente entre paréntesis.  Si un número de grupo es negativo o mayor que el número de grupos definidos en el patrón, se produce una excepción <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>. Si un grupo está contenido en una parte del patrón que no coincidió, el resultado correspondiente es <code class="docutils literal notranslate"><span class="pre">None</span></code>. Si un grupo está contenido en una parte del patrón que coincidió varias veces, se retorna la última coincidencia.</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+) (\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton, physicist&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>       <span class="c1"># The entire match</span>
<span class="go">&#39;Isaac Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>       <span class="c1"># The first parenthesized subgroup.</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>       <span class="c1"># The second parenthesized subgroup.</span>
<span class="go">&#39;Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    <span class="c1"># Multiple arguments give us a tuple.</span>
<span class="go">(&#39;Isaac&#39;, &#39;Newton&#39;)</span>
</pre></div>
</div>
<p class="translated">Si la expresión regular usa la sintaxis <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code>, los argumentos <em>groupN</em> también pueden ser cadenas que identifican a los grupos por su nombre de grupo.  Si un argumento de cadena no se usa como nombre de grupo en el patrón, se produce una excepción <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>.</p>
<p class="translated">Un ejemplo moderadamente complicado:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Malcolm Reynolds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;first_name&#39;</span><span class="p">)</span>
<span class="go">&#39;Malcolm&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;last_name&#39;</span><span class="p">)</span>
<span class="go">&#39;Reynolds&#39;</span>
</pre></div>
</div>
<p class="translated">Los grupos nombrados también pueden ser referidos por su índice:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;Malcolm&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;Reynolds&#39;</span>
</pre></div>
</div>
<p class="translated">Si un grupo coincide varias veces, sólo se puede acceder a la última coincidencia:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(..)+&quot;</span><span class="p">,</span> <span class="s2">&quot;a1b2c3&quot;</span><span class="p">)</span>  <span class="c1"># Matches 3 times.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                        <span class="c1"># Returns only the last match.</span>
<span class="go">&#39;c3&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.__getitem__">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.__getitem__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Esto es idéntico a <code class="docutils literal notranslate"><span class="pre">m.group(g)</span></code>.  Esto permite un acceso más fácil a un grupo individual de una coincidencia:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+) (\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton, physicist&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>       <span class="c1"># The entire match</span>
<span class="go">&#39;Isaac Newton&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>       <span class="c1"># The first parenthesized subgroup.</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>       <span class="c1"># The second parenthesized subgroup.</span>
<span class="go">&#39;Newton&#39;</span>
</pre></div>
</div>
<p class="translated">Los grupos con nombre también son compatibles:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Isaac Newton&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s1">&#39;first_name&#39;</span><span class="p">]</span>
<span class="go">&#39;Isaac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="s1">&#39;last_name&#39;</span><span class="p">]</span>
<span class="go">&#39;Newton&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.groups">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">groups</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.groups" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna una tupla que contenga todos los subgrupos de la coincidencia, desde 1 hasta tantos grupos como haya en el patrón.  El argumento <em>default</em> («por defecto») se utiliza para los grupos que no participaron en la coincidencia; por defecto es <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\d+)\.(\d+)&quot;</span><span class="p">,</span> <span class="s2">&quot;24.1632&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
<span class="go">(&#39;24&#39;, &#39;1632&#39;)</span>
</pre></div>
</div>
<p class="translated">Si hacemos que el decimal y todo lo que sigue sea opcional, no todos los grupos podrían participar en la coincidencia.  Estos grupos serán por defecto <code class="docutils literal notranslate"><span class="pre">None</span></code> a menos que se utilice el argumento <em>default</em>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\d+)\.?(\d+)?&quot;</span><span class="p">,</span> <span class="s2">&quot;24&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>      <span class="c1"># Second group defaults to None.</span>
<span class="go">(&#39;24&#39;, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>   <span class="c1"># Now, the second group defaults to &#39;0&#39;.</span>
<span class="go">(&#39;24&#39;, &#39;0&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.groupdict">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">groupdict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.groupdict" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna un diccionario que contiene todos los subgrupos <em>nombrados</em> de la coincidencia, tecleado por el nombre del subgrupo.  El argumento <em>por defecto</em> se usa para los grupos que no participaron en la coincidencia; por defecto es <code class="docutils literal notranslate"><span class="pre">None</span></code>.  Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)&quot;</span><span class="p">,</span> <span class="s2">&quot;Malcolm Reynolds&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
<span class="go">{&#39;first_name&#39;: &#39;Malcolm&#39;, &#39;last_name&#39;: &#39;Reynolds&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.start">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.start" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="re.Match.end">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">end</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.end" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna los índices del comienzo y el final de la subcadena coincidiendo con el <em>group</em>; el <em>group</em> por defecto es cero (es decir, toda la subcadena coincidente). Retorna <code class="docutils literal notranslate"><span class="pre">-1</span></code> si <em>grupo</em> existe pero no ha contribuido a la coincidencia.  Para un objeto coincidente <em>m</em>, y un grupo <em>g</em> que sí contribuyó a la coincidencia, la subcadena coincidente con el grupo <em>g</em> (equivalente a <code class="docutils literal notranslate"><span class="pre">m.group(g)</span></code>) es</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="o">.</span><span class="n">string</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">g</span><span class="p">):</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">g</span><span class="p">)]</span>
</pre></div>
</div>
<p class="translated">Notar que <code class="docutils literal notranslate"><span class="pre">m.start(group)</span></code> será igual a <code class="docutils literal notranslate"><span class="pre">m.end(group)</span></code> si <em>group</em> coincidió con una cadena nula.  Por ejemplo, después de <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">=</span> <span class="pre">re.search('b(c?)',</span> <span class="pre">'cba')</span></code>, <code class="docutils literal notranslate"><span class="pre">m.start(0)</span></code> es 1, <code class="docutils literal notranslate"><span class="pre">m.end(0)</span></code> es 2, <code class="docutils literal notranslate"><span class="pre">m.start(1)</span></code> y <code class="docutils literal notranslate"><span class="pre">m.end(1)</span></code> son ambos 2, y <code class="docutils literal notranslate"><span class="pre">m.start(2)</span></code> produce una excepción <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>.</p>
<p class="translated">Un ejemplo que eliminará <em>remove_this</em> («quita esto») de las direcciones de correo electrónico:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">email</span> <span class="o">=</span> <span class="s2">&quot;tony@tiremove_thisger.net&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;remove_this&quot;</span><span class="p">,</span> <span class="n">email</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="p">[:</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">()]</span> <span class="o">+</span> <span class="n">email</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">():]</span>
<span class="go">&#39;tony@tiger.net&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="re.Match.span">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">span</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#re.Match.span" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Para una coincidencia <em>m</em>, retorna la tupla-2 <code class="docutils literal notranslate"><span class="pre">(m.inicio(grupo),</span> <span class="pre">m.fin(grupo))</span></code>. Notar que si <em>group</em> no contribuyó a la coincidencia, esto es <code class="docutils literal notranslate"><span class="pre">(-1,</span> <span class="pre">-1)</span></code>. <em>group</em> por se convierte a cero para toda la coincidencia.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.pos">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">pos</span></span><a class="headerlink" href="#re.Match.pos" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El valor de <em>pos</em> que fue pasado al método <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> o <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> de un <a class="reference internal" href="#re-objects"><span class="std std-ref">objeto regex</span></a>.  Este es el índice de la cadena en la que el motor RE comenzó a buscar una coincidencia.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.endpos">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">endpos</span></span><a class="headerlink" href="#re.Match.endpos" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El valor de <em>endpos</em> que se pasó al método <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> o <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> de un <a class="reference internal" href="#re-objects"><span class="std std-ref">objeto regex</span></a>.  Este es el índice de la cadena más allá de la cual el motor RE no irá.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.lastindex">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">lastindex</span></span><a class="headerlink" href="#re.Match.lastindex" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El índice entero del último grupo de captura coincidente, o``None`` si no hay ningún grupo coincidente. Por ejemplo, las expresiones <code class="docutils literal notranslate"><span class="pre">(a)b</span></code>, <code class="docutils literal notranslate"><span class="pre">((a)(b))</span></code> y <code class="docutils literal notranslate"><span class="pre">((ab))</span></code> tendrán <code class="docutils literal notranslate"><span class="pre">lastindex</span> <span class="pre">==</span> <span class="pre">1</span></code> si se aplican a la cadena <code class="docutils literal notranslate"><span class="pre">'ab'</span></code>, mientras que la expresión <code class="docutils literal notranslate"><span class="pre">(a)(b)</span></code> tendrá <code class="docutils literal notranslate"><span class="pre">lastindex</span> <span class="pre">==</span> <span class="pre">2</span></code>, si se aplica a la misma cadena.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.lastgroup">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">lastgroup</span></span><a class="headerlink" href="#re.Match.lastgroup" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El nombre del último grupo capturador coincidente, o``None`` si el grupo no tenía nombre, o si no había ningún grupo coincidente.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.re">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">re</span></span><a class="headerlink" href="#re.Match.re" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El <a class="reference internal" href="#re-objects"><span class="std std-ref">objeto de expresión regular</span></a> cuyo método <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> o <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a> produce esta instancia de coincidencia.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="re.Match.string">
<span class="sig-prename descclassname"><span class="pre">Match.</span></span><span class="sig-name descname"><span class="pre">string</span></span><a class="headerlink" href="#re.Match.string" title="Link to this definition">¶</a></dt>
<dd><p class="translated">La cadena pasada a <a class="reference internal" href="#re.Pattern.match" title="re.Pattern.match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">match()</span></code></a> o <a class="reference internal" href="#re.Pattern.search" title="re.Pattern.search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">search()</span></code></a>.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Se añadió el soporte de <a class="reference internal" href="copy.html#copy.copy" title="copy.copy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.copy()</span></code></a> y <a class="reference internal" href="copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code></a>.  Los objetos de coincidencia se consideran atómicos.</p>
</div>
</section>
<section id="regular-expression-examples">
<span id="re-examples"></span><h2 class="translated">Ejemplos de expresiones regulares<a class="headerlink" href="#regular-expression-examples" title="Link to this heading">¶</a></h2>
<section id="checking-for-a-pair">
<h3 class="translated">Buscando un par<a class="headerlink" href="#checking-for-a-pair" title="Link to this heading">¶</a></h3>
<p class="translated">En este ejemplo, se utilizará la siguiente función de ayuda para mostrar los objetos de coincidencia con un poco más de elegancia:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">displaymatch</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="s1">&#39;&lt;Match: </span><span class="si">%r</span><span class="s1">, groups=</span><span class="si">%r</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(),</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>
</pre></div>
</div>
<p class="translated">Supongamos que se está escribiendo un programa de póquer en el que la mano de un jugador se representa como una cadena de 5 caracteres en la que cada carácter representa una carta, «a» para el as, «k» para el rey, «q» para la reina, «j» para la jota, «t» para el 10, y del « 2» al «9» representando la carta con ese valor.</p>
<p class="translated">Para ver si una cadena dada es una mano válida, se podría hacer lo siguiente:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">valid</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^[a2-9tjqk]</span><span class="si">{5}</span><span class="s2">$&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt5q&quot;</span><span class="p">))</span>  <span class="c1"># Valid.</span>
<span class="go">&quot;&lt;Match: &#39;akt5q&#39;, groups=()&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt5e&quot;</span><span class="p">))</span>  <span class="c1"># Invalid.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;akt&quot;</span><span class="p">))</span>    <span class="c1"># Invalid.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;727ak&quot;</span><span class="p">))</span>  <span class="c1"># Valid.</span>
<span class="go">&quot;&lt;Match: &#39;727ak&#39;, groups=()&gt;&quot;</span>
</pre></div>
</div>
<p class="translated">Esa última mano, <code class="docutils literal notranslate"><span class="pre">&quot;727ak&quot;</span></code>, contenía un par, o dos de las mismas cartas de valor. Para igualar esto con una expresión regular, se podrían usar referencias inversas como tales:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;717ak&quot;</span><span class="p">))</span>     <span class="c1"># Pair of 7s.</span>
<span class="go">&quot;&lt;Match: &#39;717&#39;, groups=(&#39;7&#39;,)&gt;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;718ak&quot;</span><span class="p">))</span>     <span class="c1"># No pairs.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">displaymatch</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;354aa&quot;</span><span class="p">))</span>     <span class="c1"># Pair of aces.</span>
<span class="go">&quot;&lt;Match: &#39;354aa&#39;, groups=(&#39;a&#39;,)&gt;&quot;</span>
</pre></div>
</div>
<p class="translated">Para averiguar en qué carta consiste el par, se podría utilizar el método <a class="reference internal" href="#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a> del objeto de coincidencia de la siguiente manera:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;717ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;7&#39;</span>

<span class="go"># Error because re.match() returns None, which doesn&#39;t have a group() method:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;718ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;pyshell#23&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="w">    </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*(.).*\1&quot;</span><span class="p">,</span> <span class="s2">&quot;718ak&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;NoneType&#39; object has no attribute &#39;group&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pair</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;354aa&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;a&#39;</span>
</pre></div>
</div>
</section>
<section id="simulating-scanf">
<h3 class="translated">Simular scanf()<a class="headerlink" href="#simulating-scanf" title="Link to this heading">¶</a></h3>
<p class="translated" id="index-40">Actualmente, Python no tiene un equivalente a <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code>. Las expresiones regulares son generalmente más poderosas, aunque también más detalladas, que las cadenas de formato de <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code>. La tabla siguiente ofrece algunas correspondencias más o menos equivalentes entre los tokens de formato de <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> y expresiones regulares.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Token <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code></p></th>
<th class="head"><p class="translated">Expresión regular</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">%c</span></code></p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">.</span></code></p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">%5c</span></code></p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">.{5}</span></code></p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">%d</span></code></p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">[-+]?\d+</span></code></p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">%e</span></code>, <code class="docutils literal notranslate"><span class="pre">%E</span></code>, <code class="docutils literal notranslate"><span class="pre">%f</span></code>, <code class="docutils literal notranslate"><span class="pre">%g</span></code></p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">[-+]?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?</span></code></p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">%i</span></code></p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">[-+]?(0[xX][\dA-Fa-f]+|0[0-7]*|\d+)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">%o</span></code></p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">[-+]?[0-7]+</span></code></p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">%s</span></code></p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">\S+</span></code></p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">%u</span></code></p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">\d+</span></code></p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">%x</span></code>, <code class="docutils literal notranslate"><span class="pre">%X</span></code></p></td>
<td><p class="translated"><code class="docutils literal notranslate"><span class="pre">[-+]?(0[xX])?[\dA-Fa-f]+</span></code></p></td>
</tr>
</tbody>
</table>
<p class="translated">Para extraer el nombre de archivo y los números de una cadena como</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">sendmail</span> <span class="o">-</span> <span class="mi">0</span> <span class="n">errors</span><span class="p">,</span> <span class="mi">4</span> <span class="n">warnings</span>
</pre></div>
</div>
<p class="translated">utilizaría un formato <code class="xref c c-func docutils literal notranslate"><span class="pre">scanf()</span></code> como</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">s</span> <span class="o">-</span> <span class="o">%</span><span class="n">d</span> <span class="n">errors</span><span class="p">,</span> <span class="o">%</span><span class="n">d</span> <span class="n">warnings</span>
</pre></div>
</div>
<p class="translated">La expresión regular equivalente sería</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span>\<span class="n">S</span><span class="o">+</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span>\<span class="n">d</span><span class="o">+</span><span class="p">)</span> <span class="n">errors</span><span class="p">,</span> <span class="p">(</span>\<span class="n">d</span><span class="o">+</span><span class="p">)</span> <span class="n">warnings</span>
</pre></div>
</div>
</section>
<section id="search-vs-match">
<span id="id4"></span><h3 class="translated">search() vs. match()<a class="headerlink" href="#search-vs-match" title="Link to this heading">¶</a></h3>
<p class="translated">Python ofrece diferentes operaciones primitivas basadas en expresiones regulares:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a> verifica una coincidencia solo al principio de la cadena</p></li>
<li><p class="translated"><a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.search()</span></code></a> busca una coincidencia en cualquier parte de la cadena (esto es lo que Perl hace por defecto)</p></li>
<li><p class="translated"><a class="reference internal" href="#re.fullmatch" title="re.fullmatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.fullmatch()</span></code></a> verifica si la cadena completa es una coincidencia</p></li>
</ul>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>    <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>   <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(2, 3), match=&#39;c&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;p.*n&quot;</span><span class="p">,</span> <span class="s2">&quot;python&quot;</span><span class="p">)</span> <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(0, 6), match=&#39;python&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s2">&quot;r.*n&quot;</span><span class="p">,</span> <span class="s2">&quot;python&quot;</span><span class="p">)</span> <span class="c1"># No match</span>
</pre></div>
</div>
<p class="translated">Las expresiones regulares que comienzan con <code class="docutils literal notranslate"><span class="pre">'^'</span></code> pueden ser usadas con <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> para restringir la coincidencia al principio de la cadena:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>    <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^c&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>  <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^a&quot;</span><span class="p">,</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>  <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;a&#39;&gt;</span>
</pre></div>
</div>
<p class="translated">Notar, sin embargo, que en el modo <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a> sólo coincide al principio de la cadena, mientras que usando <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> con una expresión regular que comienza con <code class="docutils literal notranslate"><span class="pre">'^'</span></code> coincidirá al principio de cada línea.</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;A</span><span class="se">\n</span><span class="s2">B</span><span class="se">\n</span><span class="s2">X&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>  <span class="c1"># No match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;^X&quot;</span><span class="p">,</span> <span class="s2">&quot;A</span><span class="se">\n</span><span class="s2">B</span><span class="se">\n</span><span class="s2">X&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>  <span class="c1"># Match</span>
<span class="go">&lt;re.Match object; span=(4, 5), match=&#39;X&#39;&gt;</span>
</pre></div>
</div>
</section>
<section id="making-a-phonebook">
<h3 class="translated">Haciendo una guía telefónica<a class="headerlink" href="#making-a-phonebook" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a> divide una cadena en una lista delimitada por el patrón recibido.  El método es muy útil para convertir datos textuales en estructuras de datos que pueden ser fácilmente leídas y modificadas por Python, como se demuestra en el siguiente ejemplo en el que se crea una guía telefónica.</p>
<p class="translated">Primero, aquí está la información.  Normalmente puede venir de un archivo, aquí se usa la sintaxis de cadena de triple comilla</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Ross McFluff: 834.345.1254 155 Elm Street</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="s2">Ronald Heathmore: 892.345.3428 436 Finley Avenue</span>
<span class="gp">... </span><span class="s2">Frank Burger: 925.541.7625 662 South Dogwood Way</span>
<span class="gp">...</span>
<span class="gp">...</span>
<span class="gp">... </span><span class="s2">Heather Albrecht: 548.326.4584 919 Park Place&quot;&quot;&quot;</span>
</pre></div>
</div>
<p class="translated">Las entradas (<em>entries</em>) están separadas por una o más líneas nuevas. Ahora se convierte la cadena en una lista en la que cada línea no vacía tiene su propia entrada:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">entries</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">+&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entries</span>
<span class="go">[&#39;Ross McFluff: 834.345.1254 155 Elm Street&#39;,</span>
<span class="go">&#39;Ronald Heathmore: 892.345.3428 436 Finley Avenue&#39;,</span>
<span class="go">&#39;Frank Burger: 925.541.7625 662 South Dogwood Way&#39;,</span>
<span class="go">&#39;Heather Albrecht: 548.326.4584 919 Park Place&#39;]</span>
</pre></div>
</div>
<p class="translated">Finalmente, se divide cada entrada en una lista con nombre, apellido, número de teléfono y dirección.  Se utiliza el parámetro <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code> (división máxima) de <a class="reference internal" href="#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a> porque la dirección tiene espacios dentro del patrón de división:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:? &quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span>
<span class="go">[[&#39;Ross&#39;, &#39;McFluff&#39;, &#39;834.345.1254&#39;, &#39;155 Elm Street&#39;],</span>
<span class="go">[&#39;Ronald&#39;, &#39;Heathmore&#39;, &#39;892.345.3428&#39;, &#39;436 Finley Avenue&#39;],</span>
<span class="go">[&#39;Frank&#39;, &#39;Burger&#39;, &#39;925.541.7625&#39;, &#39;662 South Dogwood Way&#39;],</span>
<span class="go">[&#39;Heather&#39;, &#39;Albrecht&#39;, &#39;548.326.4584&#39;, &#39;919 Park Place&#39;]]</span>
</pre></div>
</div>
<p class="translated">El patrón <code class="docutils literal notranslate"><span class="pre">:?</span></code> coincide con los dos puntos después del apellido, de manera que no aparezca en la lista de resultados.  Con <code class="docutils literal notranslate"><span class="pre">maxsplit</span></code> de <code class="docutils literal notranslate"><span class="pre">4</span></code>, se podría separar el número de casa del nombre de la calle:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:? &quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">]</span>
<span class="go">[[&#39;Ross&#39;, &#39;McFluff&#39;, &#39;834.345.1254&#39;, &#39;155&#39;, &#39;Elm Street&#39;],</span>
<span class="go">[&#39;Ronald&#39;, &#39;Heathmore&#39;, &#39;892.345.3428&#39;, &#39;436&#39;, &#39;Finley Avenue&#39;],</span>
<span class="go">[&#39;Frank&#39;, &#39;Burger&#39;, &#39;925.541.7625&#39;, &#39;662&#39;, &#39;South Dogwood Way&#39;],</span>
<span class="go">[&#39;Heather&#39;, &#39;Albrecht&#39;, &#39;548.326.4584&#39;, &#39;919&#39;, &#39;Park Place&#39;]]</span>
</pre></div>
</div>
</section>
<section id="text-munging">
<h3 class="translated">Mungear texto<a class="headerlink" href="#text-munging" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> reemplaza cada ocurrencia de un patrón con una cadena o el resultado de una función.  Este ejemplo demuestra el uso de <a class="reference internal" href="#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> con una función para «mungear» (<em>munge</em>) el texto, o aleatorizar el orden de todos los caracteres en cada palabra de una frase excepto el primer y último carácter:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">repl</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">inner_word</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">inner_word</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inner_word</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Professor Abdolmalek, please report your absences promptly.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w)(\w+)(\w)&quot;</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w)(\w+)(\w)&quot;</span><span class="p">,</span> <span class="n">repl</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">&#39;Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.&#39;</span>
</pre></div>
</div>
</section>
<section id="finding-all-adverbs">
<h3 class="translated">Encontrar todos los adverbios<a class="headerlink" href="#finding-all-adverbs" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a> coincide con <em>todas</em> las ocurrencias de un patrón, no sólo con la primera, como lo hace <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a>.  Por ejemplo, si un escritor quisiera encontrar todos los adverbios en algún texto, podría usar <a class="reference internal" href="#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">findall()</span></code></a> de la siguiente manera:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;He was carefully disguised but captured quickly by police.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\w+ly\b&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="go">[&#39;carefully&#39;, &#39;quickly&#39;]</span>
</pre></div>
</div>
</section>
<section id="finding-all-adverbs-and-their-positions">
<h3 class="translated">Encontrar todos los adverbios y sus posiciones<a class="headerlink" href="#finding-all-adverbs-and-their-positions" title="Link to this heading">¶</a></h3>
<p class="translated">Si se desea obtener más información sobre todas las coincidencias de un patrón en lugar del texto coincidente, <a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a> es útil ya que proporciona <a class="reference internal" href="#re.Match" title="re.Match"><code class="xref py py-class docutils literal notranslate"><span class="pre">Match</span></code></a> objetos en lugar de cadenas. Continuando con el ejemplo anterior, si un escritor quisiera encontrar todos los adverbios <em>y sus posiciones</em> en algún texto, usaría <a class="reference internal" href="#re.finditer" title="re.finditer"><code class="xref py py-func docutils literal notranslate"><span class="pre">finditer()</span></code></a> de la siguiente manera:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;He was carefully disguised but captured quickly by police.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\w+ly\b&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%02d</span><span class="s1">-</span><span class="si">%02d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
<span class="go">07-16: carefully</span>
<span class="go">40-47: quickly</span>
</pre></div>
</div>
</section>
<section id="raw-string-notation">
<h3 class="translated">Notación de cadena <em>raw</em><a class="headerlink" href="#raw-string-notation" title="Link to this heading">¶</a></h3>
<p class="translated">La notación de cadena <em>raw</em> (<code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">&quot;text&quot;</span></code>) permite escribir expresiones regulares razonables.  Sin ella, para «escapar» cada barra inversa (<code class="docutils literal notranslate"><span class="pre">'\'</span></code>) en una expresión regular tendría que ser precedida por otra.  Por ejemplo, las dos siguientes líneas de código son funcionalmente idénticas:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\W(.)\1\W&quot;</span><span class="p">,</span> <span class="s2">&quot; ff &quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39; ff &#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">W(.)</span><span class="se">\\</span><span class="s2">1</span><span class="se">\\</span><span class="s2">W&quot;</span><span class="p">,</span> <span class="s2">&quot; ff &quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 4), match=&#39; ff &#39;&gt;</span>
</pre></div>
</div>
<p class="translated">Cuando uno quiere igualar una barra inversa literal, debe escaparse en la expresión regular.  Con la notación de cadena <em>raw</em>, esto significa <code class="docutils literal notranslate"><span class="pre">r&quot;\\&quot;</span></code>.  Sin la notación de cadena, uno debe usar <code class="docutils literal notranslate"><span class="pre">&quot;\\\\&quot;</span></code>, haciendo que las siguientes líneas de código sean funcionalmente idénticas:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;\\&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">&lt;re.Match object; span=(0, 1), match=&#39;\\&#39;&gt;</span>
</pre></div>
</div>
</section>
<section id="writing-a-tokenizer">
<h3 class="translated">Escribir un Tokenizador<a class="headerlink" href="#writing-a-tokenizer" title="Link to this heading">¶</a></h3>
<p class="translated">Un <a class="reference external" href="https://es.wikipedia.org/wiki/Analizador_léxico">tokenizador o analizador léxico</a> analiza una cadena para categorizar grupos de caracteres.  Este es un primer paso útil para escribir un compilador o intérprete.</p>
<p class="translated">Las categorías de texto se especifican con expresiones regulares.  La técnica consiste en combinarlas en una única expresión regular maestra y en hacer un bucle sobre las sucesivas coincidencias:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NamedTuple</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Token</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">line</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">column</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">def</span><span class="w"> </span><span class="nf">tokenize</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
    <span class="n">keywords</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="s1">&#39;FOR&#39;</span><span class="p">,</span> <span class="s1">&#39;NEXT&#39;</span><span class="p">,</span> <span class="s1">&#39;GOSUB&#39;</span><span class="p">,</span> <span class="s1">&#39;RETURN&#39;</span><span class="p">}</span>
    <span class="n">token_specification</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;NUMBER&#39;</span><span class="p">,</span>   <span class="sa">r</span><span class="s1">&#39;\d+(\.\d*)?&#39;</span><span class="p">),</span>  <span class="c1"># Integer or decimal number</span>
        <span class="p">(</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span>   <span class="sa">r</span><span class="s1">&#39;:=&#39;</span><span class="p">),</span>           <span class="c1"># Assignment operator</span>
        <span class="p">(</span><span class="s1">&#39;END&#39;</span><span class="p">,</span>      <span class="sa">r</span><span class="s1">&#39;;&#39;</span><span class="p">),</span>            <span class="c1"># Statement terminator</span>
        <span class="p">(</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span>       <span class="sa">r</span><span class="s1">&#39;[A-Za-z]+&#39;</span><span class="p">),</span>    <span class="c1"># Identifiers</span>
        <span class="p">(</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span>       <span class="sa">r</span><span class="s1">&#39;[+\-*/]&#39;</span><span class="p">),</span>      <span class="c1"># Arithmetic operators</span>
        <span class="p">(</span><span class="s1">&#39;NEWLINE&#39;</span><span class="p">,</span>  <span class="sa">r</span><span class="s1">&#39;\n&#39;</span><span class="p">),</span>           <span class="c1"># Line endings</span>
        <span class="p">(</span><span class="s1">&#39;SKIP&#39;</span><span class="p">,</span>     <span class="sa">r</span><span class="s1">&#39;[ \t]+&#39;</span><span class="p">),</span>       <span class="c1"># Skip over spaces and tabs</span>
        <span class="p">(</span><span class="s1">&#39;MISMATCH&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;.&#39;</span><span class="p">),</span>            <span class="c1"># Any other character</span>
    <span class="p">]</span>
    <span class="n">tok_regex</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;(?P&lt;</span><span class="si">%s</span><span class="s1">&gt;</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">token_specification</span><span class="p">)</span>
    <span class="n">line_num</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">line_start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">mo</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">tok_regex</span><span class="p">,</span> <span class="n">code</span><span class="p">):</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">lastgroup</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">-</span> <span class="n">line_start</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;NUMBER&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">value</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;ID&#39;</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;NEWLINE&#39;</span><span class="p">:</span>
            <span class="n">line_start</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="n">line_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;SKIP&#39;</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;MISMATCH&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s1"> unexpected on line </span><span class="si">{</span><span class="n">line_num</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">Token</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">line_num</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>

<span class="n">statements</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    IF quantity THEN</span>
<span class="s1">        total := total + price * quantity;</span>
<span class="s1">        tax := price * 0.05;</span>
<span class="s1">    ENDIF;</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">statements</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">El tokenizador produce el siguiente resultado:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;IF&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;quantity&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;THEN&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;:=&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">17</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;quantity&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">33</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">41</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;tax&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;:=&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OP&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;NUMBER&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">27</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;ENDIF&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Token</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;END&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<div role="list" class="citation-list">
<div class="citation" id="frie09" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">Frie09</a><span class="fn-bracket">]</span></span>
<p class="translated">Friedl, Jeffrey. <em>Mastering Regular Expressions</em>. 3a ed., O’Reilly Media, 2009. La tercera edición del libro ya no abarca a Python en absoluto, pero la primera edición cubría la escritura de buenos patrones de expresiones regulares con gran detalle.</p>
</div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Regular expression operations</a><ul>
<li><a class="reference internal" href="#regular-expression-syntax">Sintaxis de expresiones regulares</a></li>
<li><a class="reference internal" href="#module-contents">Contenidos del módulo</a><ul>
<li><a class="reference internal" href="#flags">Indicadores</a></li>
<li><a class="reference internal" href="#functions">Funciones</a></li>
<li><a class="reference internal" href="#exceptions">Excepciones</a></li>
</ul>
</li>
<li><a class="reference internal" href="#regular-expression-objects">Objetos expresión regular</a></li>
<li><a class="reference internal" href="#match-objects">Objetos de coincidencia</a></li>
<li><a class="reference internal" href="#regular-expression-examples">Ejemplos de expresiones regulares</a><ul>
<li><a class="reference internal" href="#checking-for-a-pair">Buscando un par</a></li>
<li><a class="reference internal" href="#simulating-scanf">Simular scanf()</a></li>
<li><a class="reference internal" href="#search-vs-match">search() vs. match()</a></li>
<li><a class="reference internal" href="#making-a-phonebook">Haciendo una guía telefónica</a></li>
<li><a class="reference internal" href="#text-munging">Mungear texto</a></li>
<li><a class="reference internal" href="#finding-all-adverbs">Encontrar todos los adverbios</a></li>
<li><a class="reference internal" href="#finding-all-adverbs-and-their-positions">Encontrar todos los adverbios y sus posiciones</a></li>
<li><a class="reference internal" href="#raw-string-notation">Notación de cadena <em>raw</em></a></li>
<li><a class="reference internal" href="#writing-a-tokenizer">Escribir un Tokenizador</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="string.templatelib.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">string.templatelib</span></code> — Support for template string literals</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="difflib.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code> — Helpers for computing deltas</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/re.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Contraer barra lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="difflib.html" title="difflib — Helpers for computing deltas"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="string.templatelib.html" title="string.templatelib — Support for template string literals"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="text.html" >Servicios de procesamiento de texto</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code> — Regular expression operations</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Derechos de autor</a> 2001 Python Software Foundation.
    <br>
    Ésta página tiene la licencia Python Software Foundation Versión 2.
    <br>
    Ejemplos, guías, y otro código en la documentación están bajo la licencia adicional Zero Clause BSD.
    <br>
    
      Ver <a href="/license.html">Historia y Licencia</a> para más información.<br>
    
    
    <br>

    La Python Software Foundation es una corporación sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor dona.</a>
<br>
    <br>
      Última actualización en oct 06, 2025 (04:51 UTC).
    
      <a href="/bugs.html">Encontraste un bug</a>?
    
    <br>

    Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a>8.2.3.
    </div>

  </body>
</html>