<!DOCTYPE html>

<html lang="es" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Bucle de eventos" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/asyncio-eventloop.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Código fuente: Lib/asyncio/events.py, Lib/asyncio/base_events.py Prólogo El bucle de eventos es el núcleo de cada aplicación asyncio. Los bucles de eventos ejecutan tareas asíncronas y llamadas de ..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.15/es/_images/social_previews/summary_library_asyncio-eventloop_9d687cdc.png" />
<meta property="og:image:alt" content="Código fuente: Lib/asyncio/events.py, Lib/asyncio/base_events.py Prólogo El bucle de eventos es el núcleo de cada aplicación asyncio. Los bucles de eventos ejecutan tareas asíncronas y llamadas de ..." />
<meta name="description" content="Código fuente: Lib/asyncio/events.py, Lib/asyncio/base_events.py Prólogo El bucle de eventos es el núcleo de cada aplicación asyncio. Los bucles de eventos ejecutan tareas asíncronas y llamadas de ..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>Bucle de eventos &#8212; documentación de Python - 3.15.0a0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=bf1f176d"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f85f4cfb"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.15.0a0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Derechos de autor" href="../copyright.html" />
    <link rel="next" title="Futures" href="asyncio-future.html" />
    <link rel="prev" title="Call Graph Introspection" href="asyncio-graph.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/library/asyncio-eventloop.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menú">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Bucle de eventos</a><ul>
<li><a class="reference internal" href="#event-loop-methods">Métodos del bucle de eventos</a><ul>
<li><a class="reference internal" href="#running-and-stopping-the-loop">Iniciar y para el bucle</a></li>
<li><a class="reference internal" href="#scheduling-callbacks">Programación de llamadas de retorno</a></li>
<li><a class="reference internal" href="#scheduling-delayed-callbacks">Planificando llamadas retardadas</a></li>
<li><a class="reference internal" href="#creating-futures-and-tasks">Creando futuros y tareas</a></li>
<li><a class="reference internal" href="#opening-network-connections">Abriendo conexiones de red</a></li>
<li><a class="reference internal" href="#creating-network-servers">Creando servidores de red</a></li>
<li><a class="reference internal" href="#transferring-files">Transfiriendo archivos</a></li>
<li><a class="reference internal" href="#tls-upgrade">Actualización de TLS</a></li>
<li><a class="reference internal" href="#watching-file-descriptors">Viendo descriptores de archivos</a></li>
<li><a class="reference internal" href="#working-with-socket-objects-directly">Trabajar con objetos sockets directamente</a></li>
<li><a class="reference internal" href="#dns">DNS</a></li>
<li><a class="reference internal" href="#working-with-pipes">Trabajando con tuberías</a></li>
<li><a class="reference internal" href="#unix-signals">Señales Unix</a></li>
<li><a class="reference internal" href="#executing-code-in-thread-or-process-pools">Ejecutando código en un hilos o grupos de procesos</a></li>
<li><a class="reference internal" href="#error-handling-api">API para manejo de errores</a></li>
<li><a class="reference internal" href="#enabling-debug-mode">Habilitando el modo depuración</a></li>
<li><a class="reference internal" href="#running-subprocesses">Ejecutando subprocesos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callback-handles">Gestores de llamadas</a></li>
<li><a class="reference internal" href="#server-objects">Objetos Servidor</a></li>
<li><a class="reference internal" href="#event-loop-implementations">Implementaciones del bucle de eventos</a></li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#hello-world-with-call-soon">Hola Mundo con call_soon()</a></li>
<li><a class="reference internal" href="#display-the-current-date-with-call-later">Muestra la fecha actual con call_later()</a></li>
<li><a class="reference internal" href="#watch-a-file-descriptor-for-read-events">Mirar un descriptor de archivo para leer eventos</a></li>
<li><a class="reference internal" href="#set-signal-handlers-for-sigint-and-sigterm">Establece los gestores de señal para SIGINT y SIGTERM</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="asyncio-graph.html"
                          title="capítulo anterior">Call Graph Introspection</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="asyncio-future.html"
                          title="próximo capítulo">Futures</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/asyncio-eventloop.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="Futures"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="asyncio-graph.html" title="Call Graph Introspection"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >Comunicación en redes y entre procesos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> — Asynchronous I/O</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Bucle de eventos</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="event-loop">
<span id="asyncio-event-loop"></span><h1 class="translated">Bucle de eventos<a class="headerlink" href="#event-loop" title="Link to this heading">¶</a></h1>
<p class="translated"><strong>Código fuente:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/main/Lib/asyncio/events.py">Lib/asyncio/events.py</a>, <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/main/Lib/asyncio/base_events.py">Lib/asyncio/base_events.py</a></p>
<hr class="docutils" />
<p class="translated rubric">Prólogo</p>
<p class="translated">El bucle de eventos es el núcleo de cada aplicación asyncio. Los bucles de eventos ejecutan tareas asíncronas y llamadas de retorno, realizan operaciones de E/S de red y ejecutan subprocesos.</p>
<p class="translated">Los desarrolladores de aplicaciones normalmente deberían usar las funciones asyncio de alto nivel, como: <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>, y rara vez deberían necesitar hacer referencia al objeto de bucle o llamar a sus métodos. Esta sección esta dirigida principalmente a autores de código de nivel inferior, bibliotecas y frameworks, quienes necesitan un control mas preciso sobre el comportamiento del bucle de eventos.</p>
<p class="translated rubric">Obtención del bucle de eventos</p>
<p class="translated">Las siguientes funciones de bajo nivel se pueden utilizar para obtener, establecer o crear un bucle de eventos:</p>
<dl class="py function">
<dt class="sig sig-object py" id="asyncio.get_running_loop">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">get_running_loop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.get_running_loop" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna el bucle de eventos en ejecución en el hilo del sistema operativo actual.</p>
<p class="untranslated">Raise a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> if there is no running event loop.</p>
<p class="untranslated">This function can only be called from a coroutine or a callback.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.get_event_loop">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">get_event_loop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.get_event_loop" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Obtiene bucle de eventos actual.</p>
<p class="untranslated">When called from a coroutine or a callback (e.g. scheduled with
call_soon or similar API), this function will always return the
running event loop.</p>
<p class="untranslated">If there is no running event loop set, the function will return
the result of the <code class="docutils literal notranslate"><span class="pre">get_event_loop_policy().get_event_loop()</span></code> call.</p>
<p class="translated">Dado que esta función tiene un comportamiento bastante complejo (especialmente cuando están en uso las políticas de bucle de eventos personalizadas), usar la función <a class="reference internal" href="#asyncio.get_running_loop" title="asyncio.get_running_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_running_loop()</span></code></a> es preferible antes que <a class="reference internal" href="#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_event_loop()</span></code></a> en corrutinas y llamadas de retorno.</p>
<p class="untranslated">As noted above, consider using the higher-level <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a> function,
instead of using these lower level functions to manually create and close an
event loop.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.14: </span>Raises a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> if there is no current event loop.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">The <code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> policy system is deprecated and will be removed
in Python 3.16; from there on, this function will return the current
running event loop if present else it will return the
loop set by <a class="reference internal" href="#asyncio.set_event_loop" title="asyncio.set_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_event_loop()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.set_event_loop">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">set_event_loop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loop</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.set_event_loop" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Set <em>loop</em> as the current event loop for the current OS thread.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="asyncio.new_event_loop">
<span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">new_event_loop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.new_event_loop" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Crea y retorna un nuevo objeto de bucle de eventos.</p>
</dd></dl>

<p class="translated">Tenga en cuenta que el comportamiento de las funciones <a class="reference internal" href="#asyncio.get_event_loop" title="asyncio.get_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_event_loop()</span></code></a>, <a class="reference internal" href="#asyncio.set_event_loop" title="asyncio.set_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_event_loop()</span></code></a>, y <a class="reference internal" href="#asyncio.new_event_loop" title="asyncio.new_event_loop"><code class="xref py py-func docutils literal notranslate"><span class="pre">new_event_loop()</span></code></a> puede ser modificado mediante <a class="reference internal" href="asyncio-policy.html#asyncio-policies"><span class="std std-ref">estableciendo una política de bucle de eventos personalizada</span></a>.</p>
<p class="translated rubric">Contenidos</p>
<p class="translated">Esta página de documentación contiene las siguientes secciones:</p>
<ul class="simple">
<li><p class="translated">La sección <a class="reference internal" href="#event-loop-methods">Métodos del bucle de eventos</a> es la documentación de referencia de las APIs del bucle de eventos;</p></li>
<li><p class="translated">La sección <a class="reference internal" href="#callback-handles">Callback Handles</a> documenta las instancias <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a> y <a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimerHandle</span></code></a> las cuales son retornadas por métodos planificados como <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a> y <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a>;</p></li>
<li><p class="translated">La sección <a class="reference internal" href="#server-objects">Objetos del servidor</a> documenta tipos retornados por los métodos del bucle de eventos como <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>;</p></li>
<li><p class="translated">La sección <a class="reference internal" href="#event-loop-implementations">Implementaciones de bucle de eventos</a> documenta las clases <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> y <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>;</p></li>
<li><p class="translated">La sección <a class="reference internal" href="#examples">Ejemplos</a> muestra como trabajar con algunas APIs de bucle de eventos.</p></li>
</ul>
<section id="event-loop-methods">
<span id="asyncio-event-loop-methods"></span><h2 class="translated">Métodos del bucle de eventos<a class="headerlink" href="#event-loop-methods" title="Link to this heading">¶</a></h2>
<p class="translated">Los bucles de eventos tienen APIs de <strong>bajo nivel</strong> para lo siguiente:</p>
<nav class="contents local" id="contenido">
<ul class="simple">
<li><p><a class="reference internal" href="#running-and-stopping-the-loop" id="id1">Iniciar y para el bucle</a></p></li>
<li><p><a class="reference internal" href="#scheduling-callbacks" id="id2">Programación de llamadas de retorno</a></p></li>
<li><p><a class="reference internal" href="#scheduling-delayed-callbacks" id="id3">Planificando llamadas retardadas</a></p></li>
<li><p><a class="reference internal" href="#creating-futures-and-tasks" id="id4">Creando futuros y tareas</a></p></li>
<li><p><a class="reference internal" href="#opening-network-connections" id="id5">Abriendo conexiones de red</a></p></li>
<li><p><a class="reference internal" href="#creating-network-servers" id="id6">Creando servidores de red</a></p></li>
<li><p><a class="reference internal" href="#transferring-files" id="id7">Transfiriendo archivos</a></p></li>
<li><p><a class="reference internal" href="#tls-upgrade" id="id8">Actualización de TLS</a></p></li>
<li><p><a class="reference internal" href="#watching-file-descriptors" id="id9">Viendo descriptores de archivos</a></p></li>
<li><p><a class="reference internal" href="#working-with-socket-objects-directly" id="id10">Trabajar con objetos sockets directamente</a></p></li>
<li><p><a class="reference internal" href="#dns" id="id11">DNS</a></p></li>
<li><p><a class="reference internal" href="#working-with-pipes" id="id12">Trabajando con tuberías</a></p></li>
<li><p><a class="reference internal" href="#unix-signals" id="id13">Señales Unix</a></p></li>
<li><p><a class="reference internal" href="#executing-code-in-thread-or-process-pools" id="id14">Ejecutando código en un hilos o grupos de procesos</a></p></li>
<li><p><a class="reference internal" href="#error-handling-api" id="id15">API para manejo de errores</a></p></li>
<li><p><a class="reference internal" href="#enabling-debug-mode" id="id16">Habilitando el modo depuración</a></p></li>
<li><p><a class="reference internal" href="#running-subprocesses" id="id17">Ejecutando subprocesos</a></p></li>
</ul>
</nav>
<section id="running-and-stopping-the-loop">
<h3 class="translated"><a class="toc-backref" href="#id1" role="doc-backlink">Iniciar y para el bucle</a><a class="headerlink" href="#running-and-stopping-the-loop" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.run_until_complete">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">run_until_complete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">future</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_until_complete" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Se ejecuta hasta que <em>future</em> (una instancia de <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>) se haya completado.</p>
<p class="translated">Si el argumento es un <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">objeto corrutina</span></a> está implícitamente planificado para ejecutarse como una <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a>.</p>
<p class="translated">Retorna el resultado del Futuro o genera una excepción.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.run_forever">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">run_forever</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_forever" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Ejecuta el bucle de eventos hasta que <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> es llamado.</p>
<p class="untranslated">If <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> is called before <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> is called,
the loop will poll the I/O selector once with a timeout of zero,
run all callbacks scheduled in response to I/O events (and
those that were already scheduled), and then exit.</p>
<p class="translated">Si <a class="reference internal" href="#asyncio.loop.stop" title="asyncio.loop.stop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stop()</span></code></a> es llamado mientras <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> se está ejecutando, el loop ejecutará el lote actual de llamadas y después finalizará. Tenga en cuenta que llamadas planificadas por otras llamadas no se ejecutarán en este caso; en su lugar, ellas correrán la próxima vez que <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_forever()</span></code></a> o <a class="reference internal" href="#asyncio.loop.run_until_complete" title="asyncio.loop.run_until_complete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_until_complete()</span></code></a> sean llamados.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.stop">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">stop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.stop" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Detener el bucle de eventos.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.is_running">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">is_running</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.is_running" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si el bucle de eventos esta en ejecución actualmente.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.is_closed">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">is_closed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.is_closed" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si el bucle de eventos se cerró.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.close">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.close" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Cierra el bucle de eventos.</p>
<p class="translated">El bucle no debe estar en ejecución cuando se llama a esta función. Cualquier llamada de retorno pendiente será descartada.</p>
<p class="translated">Este método limpia todas las colas y apaga el ejecutor, pero no espera a que el ejecutor termine.</p>
<p class="translated">Este método es idempotente e irreversible. No se debe llamar ningún otro método después que el bucle de eventos es cerrado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.shutdown_asyncgens">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">shutdown_asyncgens</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.shutdown_asyncgens" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Schedule all currently open <a class="reference internal" href="../glossary.html#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a> objects to
close with an <a class="reference internal" href="../reference/expressions.html#agen.aclose" title="agen.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> call.  After calling this method,
the event loop will issue a warning if a new asynchronous generator
is iterated. This should be used to reliably finalize all scheduled
asynchronous generators.</p>
<p class="translated">Tenga en cuenta que no hay necesidad de llamar esta función cuando <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a> es utilizado.</p>
<p class="translated">Ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">shutdown_asyncgens</span><span class="p">())</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.shutdown_default_executor">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">shutdown_default_executor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.shutdown_default_executor" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Schedule the closure of the default executor and wait for it to join all of
the threads in the <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>.
Once this method has been called,
using the default executor with <a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a>
will raise a <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>.</p>
<p class="untranslated">The <em>timeout</em> parameter specifies the amount of time
(in <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> seconds) the executor will be given to finish joining.
With the default, <code class="docutils literal notranslate"><span class="pre">None</span></code>,
the executor is allowed an unlimited amount of time.</p>
<p class="untranslated">If the <em>timeout</em> is reached, a <a class="reference internal" href="exceptions.html#RuntimeWarning" title="RuntimeWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeWarning</span></code></a> is emitted
and the default executor is terminated
without waiting for its threads to finish joining.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">Do not call this method when using <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>,
as the latter handles default executor shutdown automatically.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>Added the <em>timeout</em> parameter.</p>
</div>
</dd></dl>

</section>
<section id="scheduling-callbacks">
<h3 class="translated"><a class="toc-backref" href="#id2" role="doc-backlink">Programación de llamadas de retorno</a><a class="headerlink" href="#scheduling-callbacks" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_soon">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_soon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_soon" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Programa el <em>callback</em> (retrollamada) <a class="reference internal" href="../glossary.html#term-callback"><span class="xref std std-term">callback</span></a> para que se llame con argumentos <em>args</em> en la próxima iteración del ciclo de eventos.</p>
<p class="untranslated">Return an instance of <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Handle</span></code></a>,
which can be used later to cancel the callback.</p>
<p class="translated">Llamadas que son ejecutadas en el orden en el que fueron registradas. Cada llamada será ejecutada exactamente una sola vez.</p>
<p class="untranslated">The optional keyword-only <em>context</em> argument specifies a
custom <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> for the <em>callback</em> to run in.
Callbacks use the current context when no <em>context</em> is provided.</p>
<p class="untranslated">Unlike <a class="reference internal" href="#asyncio.loop.call_soon_threadsafe" title="asyncio.loop.call_soon_threadsafe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon_threadsafe()</span></code></a>, this method is not thread-safe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_soon_threadsafe">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_soon_threadsafe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_soon_threadsafe" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A thread-safe variant of <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon()</span></code></a>. When scheduling callbacks from
another thread, this function <em>must</em> be used, since <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_soon()</span></code></a> is not
thread-safe.</p>
<p class="untranslated">This function is safe to be called from a reentrant context or signal handler,
however, it is not safe or fruitful to use the returned handle in such contexts.</p>
<p class="translated">Lanza <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> si se llama en un bucle que ha sido cerrado. Esto puede suceder en un hilo secundario cuando la aplicación principal se está apagando.</p>
<p class="translated">Vea sección <a class="reference internal" href="asyncio-dev.html#asyncio-multithreading"><span class="std std-ref">concurrencia y multiproceso</span></a> de la documentación.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Fue agregado el parámetro solo de palabra clave <em>context</em>. Vea <span class="target" id="index-12"></span><a class="pep reference external" href="https://peps.python.org/pep-0567/"><strong>PEP 567</strong></a> para mas detalles.</p>
</div>
</dd></dl>

<div class="admonition note" id="asyncio-pass-keywords">
<p class="admonition-title">Nota</p>
<p class="translated">La mayoría de las funciones planificadas de <a class="reference internal" href="asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> no permiten pasar argumentos de palabra clave. Para hacer eso utilice <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># will schedule &quot;print(&quot;Hello&quot;, flush=True)&quot;</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span>
    <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
<p class="translated">El uso de objetos parciales es usualmente mas conveniente que utilizar lambdas, ya que asyncio puede renderizar mejor objetos parciales en mensajes de depuración y error.</p>
</div>
</section>
<section id="scheduling-delayed-callbacks">
<span id="asyncio-delayed-calls"></span><h3 class="translated"><a class="toc-backref" href="#id3" role="doc-backlink">Planificando llamadas retardadas</a><a class="headerlink" href="#scheduling-delayed-callbacks" title="Link to this heading">¶</a></h3>
<p class="translated">El bucle de eventos provee mecanismos para planificar funciones de llamadas que serán ejecutadas en algún punto en el futuro. El bucle de eventos usa relojes monotónicos para seguir el tiempo.</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_later">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_later</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delay</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_later" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Planifica <em>callback</em> para ser ejecutada luego de <em>delay</em> número de segundos (puede ser tanto un entero como un flotante).</p>
<p class="translated">Una instancia de <a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TimerHandle</span></code></a> es retornada, la que puede ser utilizada para cancelar la ejecución.</p>
<p class="translated"><em>callback</em> será ejecutada exactamente una sola vez. Si dos llamadas son planificadas para el mismo momento exacto, el orden en el que son ejecutadas es indefinido.</p>
<p class="translated">El argumento posicional opcional <em>args</em> será pasado a la llamada cuando esta sea ejecutada. Si quieres que la llamada sea ejecutada con argumentos de palabra clave usa <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>.</p>
<p class="translated">Un argumento <em>context</em> opcional y solo de palabra clave que permite especificar una clase <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> personalizada en la cual <em>callback</em> será ejecutada. Cuando no se provee <em>context</em> el contexto actual es utilizado.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">For performance, callbacks scheduled with <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a>
may run up to one clock-resolution early (see
<code class="docutils literal notranslate"><span class="pre">time.get_clock_info('monotonic').resolution</span></code>).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Fue agregado el parámetro solo de palabra clave <em>context</em>. Vea <span class="target" id="index-13"></span><a class="pep reference external" href="https://peps.python.org/pep-0567/"><strong>PEP 567</strong></a> para mas detalles.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>En Python 3.7 y versiones anteriores con la implementación del bucle de eventos predeterminada, el <em>delay</em> no puede exceder un día. Esto fue arreglado en Python 3.8.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_at">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">when</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_at" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Planifica <em>callback</em> para ser ejecutada en una marca de tiempo absoluta <em>when</em> (un entero o un flotante), usando la misma referencia de tiempo que <a class="reference internal" href="#asyncio.loop.time" title="asyncio.loop.time"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.time()</span></code></a>.</p>
<p class="translated">El comportamiento de este método es el mismo que <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_later()</span></code></a>.</p>
<p class="translated">Una instancia de <a class="reference internal" href="#asyncio.TimerHandle" title="asyncio.TimerHandle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.TimerHandle</span></code></a> es retornada, la que puede ser utilizada para cancelar la ejecución.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">For performance, callbacks scheduled with <a class="reference internal" href="#asyncio.loop.call_at" title="asyncio.loop.call_at"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_at()</span></code></a>
may run up to one clock-resolution early (see
<code class="docutils literal notranslate"><span class="pre">time.get_clock_info('monotonic').resolution</span></code>).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Fue agregado el parámetro solo de palabra clave <em>context</em>. Vea <span class="target" id="index-14"></span><a class="pep reference external" href="https://peps.python.org/pep-0567/"><strong>PEP 567</strong></a> para mas detalles.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>En Python 3.7 y versiones anteriores con la implementación del bucle de eventos predeterminada, la diferencia entre <em>when</em> y el tiempo actual no puede exceder un día. Esto fue arreglado en Python 3.8.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.time">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">time</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.time" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna el tiempo actual, como un <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, de acuerdo al reloj monotónico interno del bucle de evento.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>En Python 3.7 y versiones anteriores los tiempos de espera (<em>delay</em> relativo o <em>when</em> absoluto) no deben exceder un día. Esto fue arreglado en Python 3.8.</p>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="translated">La función <a class="reference internal" href="asyncio-task.html#asyncio.sleep" title="asyncio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.sleep()</span></code></a>.</p>
</div>
</section>
<section id="creating-futures-and-tasks">
<h3 class="translated"><a class="toc-backref" href="#id4" role="doc-backlink">Creando futuros y tareas</a><a class="headerlink" href="#creating-futures-and-tasks" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_future">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_future</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_future" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Crea un objeto <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> adjunto al bucle de eventos.</p>
<p class="translated">Esta es la manera preferida de crear Futures en asyncio. Esto permite que bucles de eventos de terceros provean implementaciones alternativas del objeto Future (con mejor rendimiento o instrumentación).</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_task">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_task</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coro</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eager_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_task" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Planifica la ejecución de la <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">corrutina</span></a> <em>coro</em>. Retorna un objeto <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>.</p>
<p class="translated">Bucles de eventos de terceros pueden usar sus propias subclases de <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> por interoperabilidad. En este caso, el tipo de resultado es una subclase de <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>.</p>
<p class="untranslated">The full function signature is largely the same as that of the
<a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> constructor (or factory) - all of the keyword arguments to
this function are passed through to that interface.</p>
<p class="translated">Si el argumento <em>name</em> es provisto y no <code class="docutils literal notranslate"><span class="pre">None</span></code>, se establece como el nombre de la tarea usando <a class="reference internal" href="asyncio-task.html#asyncio.Task.set_name" title="asyncio.Task.set_name"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Task.set_name()</span></code></a>.</p>
<p class="translated">Un argumento opcional y solo de palabra clave <em>context</em> que permite especificar una clase <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> personalizada en la cual <em>coro</em> será ejecutada. Cuando no se provee <em>context</em> el contexto actual es utilizado.</p>
<p class="untranslated">An optional keyword-only <em>eager_start</em> argument allows specifying
if the task should execute eagerly during the call to create_task,
or be scheduled later. If <em>eager_start</em> is not passed the mode set
by <a class="reference internal" href="#asyncio.loop.set_task_factory" title="asyncio.loop.set_task_factory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.set_task_factory()</span></code></a> will be used.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Agregado el parámetro <em>name</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Agregado el parámetro <em>context</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13.3: </span>Added <code class="docutils literal notranslate"><span class="pre">kwargs</span></code> which passes on arbitrary extra parameters, including  <code class="docutils literal notranslate"><span class="pre">name</span></code> and <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13.4: </span>Rolled back the change that passes on <em>name</em> and <em>context</em> (if it is None),
while still passing on other arbitrary keyword arguments (to avoid breaking backwards compatibility with 3.13.3).</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.14: </span>All <em>kwargs</em> are now passed on. The <em>eager_start</em> parameter works with eager task factories.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.set_task_factory">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">set_task_factory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factory</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_task_factory" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Establece una fábrica de tareas que será utilizada por <a class="reference internal" href="#asyncio.loop.create_task" title="asyncio.loop.create_task"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_task()</span></code></a>.</p>
<p class="untranslated">If <em>factory</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code> the default task factory will be set.
Otherwise, <em>factory</em> must be a <em>callable</em> with the signature matching
<code class="docutils literal notranslate"><span class="pre">(loop,</span> <span class="pre">coro,</span> <span class="pre">**kwargs)</span></code>, where <em>loop</em> is a reference to the active
event loop, and <em>coro</em> is a coroutine object.  The callable
must pass on all <em>kwargs</em>, and return a <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a>-compatible object.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13.3: </span>Required that all <em>kwargs</em> are passed on to <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13.4: </span><em>name</em> is no longer passed to task factories. <em>context</em> is no longer passed
to task factories if it is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.14: </span><em>name</em> and <em>context</em> are now unconditionally passed on to task factories again.</p>
</div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.get_task_factory">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">get_task_factory</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_task_factory" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna una fábrica de tareas o <code class="docutils literal notranslate"><span class="pre">None</span></code> si la predefinida está en uso.</p>
</dd></dl>

</section>
<section id="opening-network-connections">
<h3 class="translated"><a class="toc-backref" href="#id5" role="doc-backlink">Abriendo conexiones de red</a><a class="headerlink" href="#opening-network-connections" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_connection">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_connection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_addr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">happy_eyeballs_delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interleave</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_connection" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Abre una conexión de transmisión de transporte a una dirección especificada por <em>host</em> y <em>port</em>.</p>
<p class="untranslated">The socket family can be either <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a> or
<a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a> depending on <em>host</em> (or the <em>family</em>
argument, if provided).</p>
<p class="untranslated">The socket type will be <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>.</p>
<p class="translated"><em>protocol_factory</em> debe ser un ejecutable que retorna una implementación del <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">asyncio protocol</span></a>.</p>
<p class="translated">Este método tratará de establecer la conexión en un segundo plano. Cuando es exitosa, retorna un par <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>.</p>
<p class="translated">La sinopsis cronológica de las operaciones subyacentes es como sigue:</p>
<ol class="arabic simple">
<li><p class="translated">La conexión es establecida y un <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">transporte</span></a> es creado para ello.</p></li>
<li><p class="translated"><em>protocol_factory</em> es llamado sin argumentos y se espera que retorne una instancia de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocol</span></a>.</p></li>
<li><p class="translated">La instancia del protocolo se acopla con el transporte mediante el llamado de su método <a class="reference internal" href="asyncio-protocol.html#asyncio.BaseProtocol.connection_made" title="asyncio.BaseProtocol.connection_made"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connection_made()</span></code></a>.</p></li>
<li><p class="translated">Una tupla <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> es retornada cuando se tiene éxito.</p></li>
</ol>
<p class="translated">El transporte creado es una transmisión (<em>stream</em>) bidireccional que depende de la implementación.</p>
<p class="translated">Otros argumentos:</p>
<ul>
<li><p class="translated"><em>ssl</em>: si se provee y no es falso, un transporte SSL/TLS es creado (de manera predeterminada se crea un transporte TCP plano).  Si <em>ssl</em> es un objeto <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a>, este contexto es utilizado para crear el transporte; si <em>ssl</em> es <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>, se utiliza un contexto predeterminado retornado por <a class="reference internal" href="ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="translated"><a class="reference internal" href="ssl.html#ssl-security"><span class="std std-ref">Consideraciones de seguridad SSL/TLS</span></a></p>
</div>
</li>
<li><p class="translated"><em>server_hostname</em> establece o reemplaza el nombre de servidor (<em>hostname</em>) contra el cual el certificado del servidor de destino será comparado. Sólo debería ser pasado si <em>ssl</em> no es <code class="docutils literal notranslate"><span class="pre">None</span></code>. De manera predeterminada es usado el valor del argumento <em>host</em>.  Si <em>host</em> está vacío, no hay valor predeterminado y debes pasar un valor para <em>server_hostname</em>. Si <em>server_hostname</em> es una cadena vacía, la comparación de nombres de servidores es deshabilitada (lo que es un riesgo de seguridad serio, permitiendo potenciales ataques de hombre-en-el-medio, <em>man-in-the-middle attacks</em>).</p></li>
<li><p class="translated"><em>family</em>, <em>proto</em>, <em>flags</em> son dirección de familia, protocolo y banderas opcionales que serán pasadas a través de <cite>getaddrinfo()</cite> para la resolución de <em>host</em>. Si están dados, todos ellos deberían ser enteros de las constantes del módulo <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> correspondiente.</p></li>
<li><p class="translated"><em>happy_eyeballs_delay</em>, si se proporciona, habilita Happy Eyeballs para esta conexión. Debe ser un número de punto flotante que represente la cantidad de tiempo en segundos para esperar a que se complete un intento de conexión, antes de comenzar el siguiente intento en paralelo. Este es el «Retraso de intento de conexión» como se define en <span class="target" id="index-15"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8305.html"><strong>RFC 8305</strong></a>. Un valor predeterminado sensato recomendado por el RFC es <code class="docutils literal notranslate"><span class="pre">0.25</span></code> (250 milisegundos).</p></li>
<li><p class="translated"><em>interleave</em> controla reordenamientos de dirección cuando un nombre de servidor resuelve a múltiples direcciones IP. Si es <code class="docutils literal notranslate"><span class="pre">0</span></code> o no es especificado, no se hace ningún reordenamiento, y las direcciones son intentadas en el orden retornado por <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>. Si un entero positivo es especificado, las direcciones son intercaladas por dirección de familia, y el entero dado es interpretado como «Número de familias de la primera dirección» (<em>First Address Family Count</em>) como es definida en <span class="target" id="index-16"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc8305.html"><strong>RFC 8305</strong></a>. El valor predefinido es <code class="docutils literal notranslate"><span class="pre">0</span></code> si <em>happy_eyeballs_delay</em> no es especificado, y <code class="docutils literal notranslate"><span class="pre">1</span></code> si lo es.</p></li>
<li><p class="translated"><em>sock</em>, si está dado, debe ser un objeto <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> existente y ya conectado, que será utilizado por el transporte. Si <em>sock</em> es dado, ningún <em>host</em>, <em>port</em>, <em>family</em>, <em>proto</em>, <em>flags</em>, <em>happy_eyeballs_delay</em>, <em>interleave</em> o <em>local_addr</em> deben ser especificados.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">El argumento <em>sock</em> transfiere la propiedad del socket al transporte creado. Para cerrar el socket, llame al método <a class="reference internal" href="asyncio-protocol.html#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> del transporte.</p>
</div>
</li>
<li><p class="translated"><em>local_addr</em>, si está dado, es una tupla <code class="docutils literal notranslate"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> usada para enlazar el socket localmente.  Los <em>local_host</em> y <em>local_port</em> son buscados usando <code class="docutils literal notranslate"><span class="pre">getaddrinfo()</span></code>, de manera similar que con <em>host</em> y <em>port</em>.</p></li>
<li><p class="translated"><em>ssl_handshake_timeout</em> es (para una conexión TLS) el tiempo en segundos a esperar que se complete el <em>handshake</em> TLS antes de abortar la conexión. <code class="docutils literal notranslate"><span class="pre">60.0</span></code> segundos si es <code class="docutils literal notranslate"><span class="pre">None</span></code> (predefinido).</p></li>
<li><p class="translated"><em>ssl_shutdown_timeout</em> es el tiempo en segundos a esperar a que se complete el apagado SSL antes de abortar la conexión. <code class="docutils literal notranslate"><span class="pre">30.0</span></code> segundos si es <code class="docutils literal notranslate"><span class="pre">None</span></code> (predefinido).</p></li>
<li><p class="untranslated"><em>all_errors</em> determines what exceptions are raised when a connection cannot
be created. By default, only a single <code class="docutils literal notranslate"><span class="pre">Exception</span></code> is raised: the first
exception if there is only one or all errors have same message, or a single
<code class="docutils literal notranslate"><span class="pre">OSError</span></code> with the error messages combined. When <code class="docutils literal notranslate"><span class="pre">all_errors</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>,
an <code class="docutils literal notranslate"><span class="pre">ExceptionGroup</span></code> will be raised containing all exceptions (even if there
is only one).</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Agregado el soporte para SSL/TLS en <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>The socket option <a class="reference internal" href="socket.html#socket-unix-constants"><span class="std std-ref">socket.TCP_NODELAY</span></a> is set by default
for all TCP connections.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Agregado el parámetro <em>ssl_handshake_timeout</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Agregados los parámetros <em>happy_eyeballs_delay</em> y <em>interleave</em>.</p>
<p class="untranslated">Happy Eyeballs Algorithm: Success with Dual-Stack Hosts.
When a server’s IPv4 path and protocol are working, but the server’s
IPv6 path and protocol are not working, a dual-stack client
application experiences significant connection delay compared to an
IPv4-only client.  This is undesirable because it causes the
dual-stack client to have a worse user experience.  This document
specifies requirements for algorithms that reduce this user-visible
delay and provides an algorithm.</p>
<p class="untranslated">For more information: <a class="reference external" href="https://datatracker.ietf.org/doc/html/rfc6555">https://datatracker.ietf.org/doc/html/rfc6555</a></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Agregado el parámetro <em>ssl_shutdown_timeout</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span><em>all_errors</em> was added.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="translated">La función <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_connection()</span></code></a> es una API alternativa de alto nivel. Retorna un par de (<a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a>) que puede ser usado directamente en código async/await.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_datagram_endpoint">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_datagram_endpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_addr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remote_addr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuse_port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">allow_broadcast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_datagram_endpoint" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Crea un datagrama de conexión.</p>
<p class="untranslated">The socket family can be either <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET</span></code></a>,
<a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a>, or <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>,
depending on <em>host</em> (or the <em>family</em> argument, if provided).</p>
<p class="untranslated">The socket type will be <a class="reference internal" href="socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code></a>.</p>
<p class="translated"><em>protocol_factory</em> debe ser un ejecutable que retorne una implementación de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocol</span></a>.</p>
<p class="translated">Una tupla de <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> es retornada cuando se tiene éxito.</p>
<p class="translated">Otros argumentos:</p>
<ul>
<li><p class="translated"><em>local_addr</em>, si está dado, es una tupla <code class="docutils literal notranslate"><span class="pre">(local_host,</span> <span class="pre">local_port)</span></code> usada para enlazar el socket localmente.  Los <em>local_host</em> y <em>local_port</em> son buscados utilizando <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">On Windows, when using the proactor event loop with <code class="docutils literal notranslate"><span class="pre">local_addr=None</span></code>,
an <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> with <code class="xref py py-attr docutils literal notranslate"><span class="pre">errno.WSAEINVAL</span></code> will be raised
when running it.</p>
</div>
</li>
<li><p class="translated"><em>remote_addr</em>, si está dado, es una tupla <code class="docutils literal notranslate"><span class="pre">(remote_host,</span> <span class="pre">remote_port)</span></code> utilizada para conectar el socket a una dirección remota. Los <em>remote_host</em> y <em>remote_port</em> son buscados utilizando <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>.</p></li>
<li><p class="translated"><em>family</em>, <em>proto</em>, <em>flags</em> son direcciones de familia, protocolo y banderas opcionales que serán pasadas a través de <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> para la resolución de <em>host</em>. Si está dado, estos deben ser todos enteros de las constantes del módulo <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> correspondiente.</p></li>
<li><p class="untranslated"><em>reuse_port</em> tells the kernel to allow this endpoint to be bound to the
same port as other existing endpoints are bound to, so long as they all
set this flag when being created. This option is not supported on Windows
and some Unixes. If the <a class="reference internal" href="socket.html#socket-unix-constants"><span class="std std-ref">socket.SO_REUSEPORT</span></a> constant is not
defined then this capability is unsupported.</p></li>
<li><p class="translated"><em>allow_broadcast</em> dice al kernel que habilite este punto de conexión para enviar mensajes a la dirección de transmisión (<em>broadcast</em>).</p></li>
<li><p class="translated"><em>sock</em> puede opcionalmente ser especificado para usar un objeto <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> preexistente y ya conectado que será utilizado por el transporte. Si están especificados, <em>local_addr</em> y <em>remote_addr</em> deben ser omitidos (tienen que ser <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>).</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">El argumento <em>sock</em> transfiere la propiedad del socket al transporte creado. Para cerrar el socket, llame al método <a class="reference internal" href="asyncio-protocol.html#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> del transporte.</p>
</div>
</li>
</ul>
<p class="translated">Refiérase a los ejemplos <a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-client-protocol"><span class="std std-ref">UDP echo client protocol</span></a> y <a class="reference internal" href="asyncio-protocol.html#asyncio-udp-echo-server-protocol"><span class="std std-ref">UDP echo server protocol</span></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4.4: </span>Los parámetros <em>family</em>, <em>proto</em>, <em>flags</em>, <em>reuse_address</em>, <em>reuse_port</em>, <em>allow_broadcast</em> y <em>sock</em> fueron agregados.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Se agregó soporte para Windows.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8.1: </span>The <em>reuse_address</em> parameter is no longer supported, as using
<a class="reference internal" href="socket.html#socket-unix-constants"><span class="std std-ref">socket.SO_REUSEADDR</span></a>
poses a significant security concern for
UDP. Explicitly passing <code class="docutils literal notranslate"><span class="pre">reuse_address=True</span></code> will raise an exception.</p>
<p class="translated">Cuando múltiples procesos con UIDs diferentes asignan sockets a una misma dirección socket UDP con <code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code>, los paquetes entrantes pueden distribuirse aleatoriamente entre los sockets.</p>
<p class="untranslated">For supported platforms, <em>reuse_port</em> can be used as a replacement for
similar functionality. With <em>reuse_port</em>,
<a class="reference internal" href="socket.html#socket-unix-constants"><span class="std std-ref">socket.SO_REUSEPORT</span></a>
is used instead, which specifically
prevents processes with differing UIDs from assigning sockets to the same
socket address.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>The <em>reuse_address</em> parameter, disabled since Python 3.8.1,
3.7.6 and 3.6.10, has been entirely removed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_unix_connection">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_unix_connection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_unix_connection" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Crear una conexión Unix.</p>
<p class="untranslated">The socket family will be <a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a>; socket
type will be <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>.</p>
<p class="translated">Una tupla de <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code> es retornada cuando se tiene éxito.</p>
<p class="translated"><em>path</em> es el nombre de un dominio de un socket Unix y es requerido, a menos que un parámetro <em>sock</em> sea especificado. Los socket Unix abstractos, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, y <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> son soportados.</p>
<p class="translated">Vea la documentación del método <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> para información acerca de los argumentos de este método.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Agregado el parámetro <em>ssl_handshake_timeout</em>. El parámetro <em>path</em> ahora puede ser un <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Agregado el parámetro <em>ssl_shutdown_timeout</em>.</p>
</div>
</dd></dl>

</section>
<section id="creating-network-servers">
<h3 class="translated"><a class="toc-backref" href="#id6" role="doc-backlink">Creando servidores de red</a><a class="headerlink" href="#creating-network-servers" title="Link to this heading">¶</a></h3>
<dl class="py method" id="loop-create-server">
<dt class="sig sig-object py" id="asyncio.loop.create_server">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_server</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">host</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">socket.AF_UNSPEC</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">socket.AI_PASSIVE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuse_address</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuse_port</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_alive</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_serving</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_server" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Create a TCP server (socket type <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code></a>) listening
on <em>port</em> of the <em>host</em> address.</p>
<p class="translated">Retorna un objeto <a class="reference internal" href="#asyncio.Server" title="asyncio.Server"><code class="xref py py-class docutils literal notranslate"><span class="pre">Server</span></code></a>.</p>
<p class="translated">Argumentos:</p>
<ul>
<li><p class="translated"><em>protocol_factory</em> debe ser un ejecutable que retorne una implementación de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocol</span></a>.</p></li>
<li><p class="translated">El parámetro <em>host</em> puede ser establecido a distintos tipos que determinan donde el servidor estaría escuchando:</p>
<ul class="simple">
<li><p class="translated">Si <em>host</em> es una cadena, el servidor TCP está enlazado a una sola interfaz de red especificada por <em>host</em>.</p></li>
<li><p class="translated">Si <em>host</em> es una secuencia de cadenas, el servidor TCP está enlazado a todas las interfaces de red especificadas por la secuencia.</p></li>
<li><p class="translated">Si <em>host</em> es una cadena vacía o <code class="docutils literal notranslate"><span class="pre">None</span></code>, se asumen todas las interfaces y una lista con múltiples sockets será retornada (mas probablemente uno para IPv4 y otro para IPv6).</p></li>
</ul>
</li>
<li><p class="translated">El parámetro <em>port</em> puede establecerse para especificar en qué puerto debe escuchar el servidor. Si es <code class="docutils literal notranslate"><span class="pre">0</span></code> o <code class="docutils literal notranslate"><span class="pre">None</span></code> (por defecto), se seleccionará un puerto aleatorio no utilizado (tenga en cuenta que si <em>host</em> resuelve a múltiples interfaces de red, se seleccionará un puerto aleatorio diferente para cada interfaz).</p></li>
<li><p class="untranslated"><em>family</em> can be set to either <a class="reference internal" href="socket.html#socket.AF_INET" title="socket.AF_INET"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.AF_INET</span></code></a> or
<a class="reference internal" href="socket.html#socket.AF_INET6" title="socket.AF_INET6"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_INET6</span></code></a> to force the socket to use IPv4 or IPv6.
If not set, the <em>family</em> will be determined from host name
(defaults to <a class="reference internal" href="socket.html#socket.AF_UNSPEC" title="socket.AF_UNSPEC"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNSPEC</span></code></a>).</p></li>
<li><p class="translated"><em>flags</em> es una máscara de bits para <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>.</p></li>
<li><p class="translated"><em>sock</em> puede ser especificado opcionalmente para usar objetos socket preexistentes. Si se utiliza, entonces <em>host</em> y <em>port</em> no deben ser especificados.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">El argumento <em>sock</em> transfiere la propiedad del socket al servidor creado. Para cerrar el socket, llame al método <a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> del servidor.</p>
</div>
</li>
<li><p class="translated"><em>backlog</em> es el número máximo de conexiones encoladas pasadas a <a class="reference internal" href="socket.html#socket.socket.listen" title="socket.socket.listen"><code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code></a> (el valor predeterminado es 100).</p></li>
<li><p class="translated"><em>ssl</em> puede ser establecido como una instancia de <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> para habilitar TLS sobre las conexiones aceptadas.</p></li>
<li><p class="translated"><em>reuse_address</em> indica al kernel que reutilice un socket local en estado <code class="docutils literal notranslate"><span class="pre">TIME_WAIT</span></code>, sin esperar que su plazo de ejecución expire. Si no es especificado será establecido automáticamente como <code class="docutils literal notranslate"><span class="pre">True</span></code> en Unix.</p></li>
<li><p class="translated"><em>reuse_port</em> dice al kernel que habilite este punto de conexión para ser unido al mismo puerto de la misma forma que otros puntos de conexión existentes también están unidos, siempre y cuando todos ellos establezcan esta bandera al ser creados.</p></li>
<li><p class="untranslated"><em>keep_alive</em> set to <code class="docutils literal notranslate"><span class="pre">True</span></code> keeps connections active by enabling the
periodic transmission of messages.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13: </span>Added the <em>keep_alive</em> parameter.</p>
</div>
<ul class="simple">
<li><p class="translated"><em>ssl_handshake_timeout</em> es (para un servidor TLS) el tiempo en segundos a esperar por el apretón de manos (<em>handshake</em>) TLS a ser completado antes de abortar la conexión. <code class="docutils literal notranslate"><span class="pre">60.0</span></code> si es <code class="docutils literal notranslate"><span class="pre">None</span></code> (su valor predeterminado).</p></li>
<li><p class="translated"><em>ssl_shutdown_timeout</em> es el tiempo en segundos a esperar a que se complete el apagado SSL antes de abortar la conexión. <code class="docutils literal notranslate"><span class="pre">30.0</span></code> segundos si es <code class="docutils literal notranslate"><span class="pre">None</span></code> (predefinido).</p></li>
<li><p class="translated"><em>start_serving</em> establecido como <code class="docutils literal notranslate"><span class="pre">True</span></code> (de manera predeterminada) produce que los servidores creados comiencen a aceptar conexiones inmediatamente. Si es establecido como <code class="docutils literal notranslate"><span class="pre">False</span></code>, el usuario debe esperar por <a class="reference internal" href="#asyncio.Server.start_serving" title="asyncio.Server.start_serving"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.start_serving()</span></code></a> o <a class="reference internal" href="#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.serve_forever()</span></code></a> para que el servidor comience a aceptar conexiones.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Agregado el soporte para SSL/TLS en <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5.1: </span>El parámetro <em>host</em> puede ser una secuencia de cadenas.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Added <em>ssl_handshake_timeout</em> and <em>start_serving</em> parameters.
The socket option <a class="reference internal" href="socket.html#socket-unix-constants"><span class="std std-ref">socket.TCP_NODELAY</span></a> is set by default
for all TCP connections.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Agregado el parámetro <em>ssl_shutdown_timeout</em>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="translated">La función <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a> es una API alternativa de alto nivel que retorna un par de <a class="reference internal" href="asyncio-stream.html#asyncio.StreamReader" title="asyncio.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> y <a class="reference internal" href="asyncio-stream.html#asyncio.StreamWriter" title="asyncio.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> que pueden ser usados en código async/await.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.create_unix_server">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">create_unix_server</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backlog</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_serving</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cleanup_socket</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.create_unix_server" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Similar to <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> but works with the
<a class="reference internal" href="socket.html#socket.AF_UNIX" title="socket.AF_UNIX"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_UNIX</span></code></a> socket family.</p>
<p class="translated"><em>path</em> es el nombre de un dominio de socket Unix, y es requerido a menos que el argumento <em>sock</em> sea provisto. Son soportados sockets unix abstractos, <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, y rutas <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a>.</p>
<p class="untranslated">If <em>cleanup_socket</em> is true then the Unix socket will automatically
be removed from the filesystem when the server is closed, unless the
socket has been replaced after the server has been created.</p>
<p class="translated">Vea la documentación de el método <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> para mas información acerca de los argumentos de este método.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Agregados los parámetros <em>ssl_handshake_timeout</em> y <em>start_serving</em>. El parámetro <em>path</em> ahora puede ser un objeto <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Agregado el parámetro <em>ssl_shutdown_timeout</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13: </span>Added the <em>cleanup_socket</em> parameter.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.connect_accepted_socket">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">connect_accepted_socket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_accepted_socket" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Envuelve una conexión ya aceptada en un par de transporte/protocolo.</p>
<p class="translated">Este método puede ser usado por servidores que acepten conexiones por fuera de asyncio, pero que usen asyncio para manejarlas.</p>
<p class="translated">Parámetros:</p>
<ul>
<li><p class="translated"><em>protocol_factory</em> debe ser un ejecutable que retorne una implementación de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">protocol</span></a>.</p></li>
<li><p class="translated"><em>sock</em> es un objeto socket preexistente retornado por <a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.accept</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">El argumento <em>sock</em> transfiere la propiedad del socket al transporte creado. Para cerrar el socket, llame al método <a class="reference internal" href="asyncio-protocol.html#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> del transporte.</p>
</div>
</li>
<li><p class="translated"><em>ssl</em> puede ser establecido como un <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> para habilitar SSL sobre las conexiones aceptadas.</p></li>
<li><p class="translated"><em>ssl_handshake_timeout</em> es (para una conexión SSL) el tiempo en segundos que se esperará para que se complete el apretón de manos (<em>handshake</em>) SSL antes de abortar la conexión. <code class="docutils literal notranslate"><span class="pre">60.0</span></code> si es <code class="docutils literal notranslate"><span class="pre">None</span></code> (su valor predeterminado).</p></li>
<li><p class="translated"><em>ssl_shutdown_timeout</em> es el tiempo en segundos a esperar a que se complete el apagado SSL antes de abortar la conexión. <code class="docutils literal notranslate"><span class="pre">30.0</span></code> segundos si es <code class="docutils literal notranslate"><span class="pre">None</span></code> (predefinido).</p></li>
</ul>
<p class="translated">Retorna un par <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Agregado el parámetro <em>ssl_handshake_timeout</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Agregado el parámetro <em>ssl_shutdown_timeout</em>.</p>
</div>
</dd></dl>

</section>
<section id="transferring-files">
<h3 class="translated"><a class="toc-backref" href="#id7" role="doc-backlink">Transfiriendo archivos</a><a class="headerlink" href="#transferring-files" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sendfile">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sendfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transport</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">fallback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sendfile" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Envía un <em>file</em> a través de un <em>transport</em>. Retorna el numero total de bytes enviados.</p>
<p class="translated">El método usa <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">os.sendfile()</span></code></a> de alto rendimiento si está disponible.</p>
<p class="translated"><em>file</em> debe ser un objeto de archivo regular abierto en modo binario.</p>
<p class="translated"><em>offset</em> indica desde donde se empezará a leer el archivo. Si es especificado, <em>count</em> es el número total de bytes a transmitir en contraposición con enviar el archivo hasta que se alcance EOF. La posición del archivo es actualizada siempre, incluso cuando este método genere un error, y <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">file.tell()</span></code></a> puede ser usado para obtener el número de bytes enviados hasta el momento.</p>
<p class="translated"><em>fallback</em> establecido como <code class="docutils literal notranslate"><span class="pre">True</span></code> hace que asyncio lea y envíe el archivo manualmente cuando la plataforma no soporta la llamada de envío de archivos del sistema (por ejemplo, Windows o sockets SSL en Unix).</p>
<p class="translated">Lanza <a class="reference internal" href="asyncio-exceptions.html#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SendfileNotAvailableError</span></code></a> si el sistema no soporta la llamada de envío de archivos del sistema y <em>fallback</em> es <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

</section>
<section id="tls-upgrade">
<h3 class="translated"><a class="toc-backref" href="#id8" role="doc-backlink">Actualización de TLS</a><a class="headerlink" href="#tls-upgrade" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.start_tls">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">start_tls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transport</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sslcontext</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server_hostname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_handshake_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ssl_shutdown_timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.start_tls" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Actualiza una conexión basada en transporte ya existente a TLS.</p>
<p class="untranslated">Create a TLS coder/decoder instance and insert it between the <em>transport</em>
and the <em>protocol</em>. The coder/decoder implements both <em>transport</em>-facing
protocol and <em>protocol</em>-facing transport.</p>
<p class="untranslated">Return the created two-interface instance. After <em>await</em>, the <em>protocol</em>
must stop using the original <em>transport</em> and communicate with the returned
object only because the coder caches <em>protocol</em>-side data and sporadically
exchanges extra TLS session packets with <em>transport</em>.</p>
<p class="untranslated">In some situations (e.g. when the passed transport is already closing) this
may return <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p class="translated">Parámetros:</p>
<ul class="simple">
<li><p class="translated">Las instancias <em>transport</em> y <em>protocol</em> que retornan los métodos como <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_server()</span></code></a> y <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_connection()</span></code></a>.</p></li>
<li><p class="translated"><em>sslcontext</em>: una instancia configurada de <a class="reference internal" href="ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a>.</p></li>
<li><p class="translated"><em>server_side</em> pasa <cite>True</cite> cuando se actualiza una conexión del lado del servidor (como en el caso de una creada por <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_server()</span></code></a>).</p></li>
<li><p class="translated"><em>server_hostname</em>: establece o reemplaza el nombre del host contra el cual se compara el certificado del servidor de destino.</p></li>
<li><p class="translated"><em>ssl_handshake_timeout</em> es (para una conexión TLS) el tiempo en segundos a esperar que se complete el <em>handshake</em> TLS antes de abortar la conexión. <code class="docutils literal notranslate"><span class="pre">60.0</span></code> segundos si es <code class="docutils literal notranslate"><span class="pre">None</span></code> (predefinido).</p></li>
<li><p class="translated"><em>ssl_shutdown_timeout</em> es el tiempo en segundos a esperar a que se complete el apagado SSL antes de abortar la conexión. <code class="docutils literal notranslate"><span class="pre">30.0</span></code> segundos si es <code class="docutils literal notranslate"><span class="pre">None</span></code> (predefinido).</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Agregado el parámetro <em>ssl_shutdown_timeout</em>.</p>
</div>
</dd></dl>

</section>
<section id="watching-file-descriptors">
<h3 class="translated"><a class="toc-backref" href="#id9" role="doc-backlink">Viendo descriptores de archivos</a><a class="headerlink" href="#watching-file-descriptors" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.add_reader">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">add_reader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_reader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Empieza a monitorear el descriptor de archivos <em>fd</em> para disponibilidad de lectura e invoca <em>callback</em> con los argumentos especificados una vez que <em>fd</em> está habilitado para ser leído.</p>
<p class="untranslated">Any preexisting callback registered for <em>fd</em> is cancelled and replaced by
<em>callback</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.remove_reader">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">remove_reader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_reader" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Stop monitoring the <em>fd</em> file descriptor for read availability. Returns
<code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>fd</em> was previously being monitored for reads.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.add_writer">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">add_writer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_writer" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Empieza a monitorear el descriptor de archivos <em>fd</em> para disponibilidad de escritura e invoca <em>callback</em> con los argumentos especificados una vez que <em>fd</em> está habilitado para ser escrito.</p>
<p class="untranslated">Any preexisting callback registered for <em>fd</em> is cancelled and replaced by
<em>callback</em>.</p>
<p class="translated">Use <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">para pasar argumentos de palabra clave</span></a> a <em>callback</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.remove_writer">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">remove_writer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fd</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_writer" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Stop monitoring the <em>fd</em> file descriptor for write availability. Returns
<code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>fd</em> was previously being monitored for writes.</p>
</dd></dl>

<p class="translated">Vea también la sección <a class="reference internal" href="asyncio-platforms.html#asyncio-platform-support"><span class="std std-ref">Soporte de plataforma</span></a> para algunas limitaciones de estos métodos.</p>
</section>
<section id="working-with-socket-objects-directly">
<h3 class="translated"><a class="toc-backref" href="#id10" role="doc-backlink">Trabajar con objetos sockets directamente</a><a class="headerlink" href="#working-with-socket-objects-directly" title="Link to this heading">¶</a></h3>
<p class="translated">En general, implementaciones de protocolo que usen APIs basadas en transporte como <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> y <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> son mas rápidas que aquellas implementaciones que trabajan con directamente con sockets. De cualquier forma, hay algunos casos de uso en los cuales el rendimiento no es crítico, y trabajar directamente con objetos <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> es mas conveniente.</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_recv">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_recv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbytes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recv" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Recibe hasta <em>nbytes</em> de <em>sock</em>. Versión asíncrona de <a class="reference internal" href="socket.html#socket.socket.recv" title="socket.socket.recv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recv()</span></code></a>.</p>
<p class="translated">Retorna los datos recibidos como un objeto bytes.</p>
<p class="translated"><em>sock</em> debe ser un socket no bloqueante.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>A pesar de que este método siempre fue documentado como un método de corrutina, los lanzamientos previos a Python 3.7 retornaban un <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>. Desde Python 3.7 este es un método <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_recv_into">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_recv_into</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recv_into" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Recibe datos desde <em>sock</em> en el búfer <em>buf</em>. Modelado después del método bloqueante <a class="reference internal" href="socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recv_into()</span></code></a>.</p>
<p class="translated">Retorna el número de bytes escritos en el búfer.</p>
<p class="translated"><em>sock</em> debe ser un socket no bloqueante.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_recvfrom">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_recvfrom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bufsize</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recvfrom" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Recibe un datagrama de hasta <em>bufsize</em> de <em>sock</em>.  Versión asíncrona de <a class="reference internal" href="socket.html#socket.socket.recvfrom" title="socket.socket.recvfrom"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recvfrom()</span></code></a>.</p>
<p class="translated">Retorna una tupla de (datos recibidos, dirección remota).</p>
<p class="translated"><em>sock</em> debe ser un socket no bloqueante.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_recvfrom_into">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_recvfrom_into</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbytes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_recvfrom_into" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Recibe un datagrama de hasta <em>nbytes</em> de <em>sock</em> en <em>buf</em>. Versión asíncrona de <a class="reference internal" href="socket.html#socket.socket.recvfrom_into" title="socket.socket.recvfrom_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.recvfrom_into()</span></code></a>.</p>
<p class="translated">Retorna una dupla de (número de bytes recibidos, dirección remota).</p>
<p class="translated"><em>sock</em> debe ser un socket no bloqueante.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_sendall">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_sendall</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_sendall" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Envía <em>data</em> al socket <em>sock</em>. Versión asíncrona de <a class="reference internal" href="socket.html#socket.socket.sendall" title="socket.socket.sendall"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendall()</span></code></a>.</p>
<p class="translated">Este método continua enviando al socket hasta que se hayan enviado todos los datos en <em>data</em> u ocurra un error. <code class="docutils literal notranslate"><span class="pre">None</span></code> es retornado cuando se tiene éxito. Cuando ocurre un error, se lanza una excepción. Adicionalmente, no hay manera de determinar cuantos datos, si es que se hubo alguno, se procesaron correctamente por el extremo receptor de la conexión.</p>
<p class="translated"><em>sock</em> debe ser un socket no bloqueante.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>A pesar de que este método siempre fue documentado como un método de corrutina, antes de Python 3.7 retorna un <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>. Desde Python 3.7, este es un método <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_sendto">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_sendto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_sendto" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Envía un datagrama desde <em>sock</em> a <em>address</em>. Versión asíncrona de <a class="reference internal" href="socket.html#socket.socket.sendto" title="socket.socket.sendto"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendto()</span></code></a>.</p>
<p class="translated">Retorna el número de bytes enviados.</p>
<p class="translated"><em>sock</em> debe ser un socket no bloqueante.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_connect">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_connect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_connect" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Conecta <em>sock</em> a un socket remoto en <em>address</em>.</p>
<p class="translated">Versión asíncrona de <a class="reference internal" href="socket.html#socket.socket.connect" title="socket.socket.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code></a>.</p>
<p class="translated"><em>sock</em> debe ser un socket no bloqueante.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5.2: </span><code class="docutils literal notranslate"><span class="pre">address</span></code> ya no necesita ser resuelto. <code class="docutils literal notranslate"><span class="pre">sock_connect</span></code> va a intentar verificar si <em>address</em> ya fue resuelto a partir del llamado de <a class="reference internal" href="socket.html#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.inet_pton()</span></code></a>. Si no lo fue, se utilizará <a class="reference internal" href="#asyncio.loop.getaddrinfo" title="asyncio.loop.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.getaddrinfo()</span></code></a> ara resolver <em>address</em>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="translated"><a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a> y <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.open_connection()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_accept">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_accept</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_accept" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Acepta una conexión. Modelado después del método bloqueante <a class="reference internal" href="socket.html#socket.socket.accept" title="socket.socket.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.accept()</span></code></a>.</p>
<p class="untranslated">The socket must be bound to an address and listening
for connections. The return value is a pair <code class="docutils literal notranslate"><span class="pre">(conn,</span> <span class="pre">address)</span></code> where <em>conn</em>
is a <em>new</em> socket object usable to send and receive data on the connection,
and <em>address</em> is the address bound to the socket on the other end of the
connection.</p>
<p class="translated"><em>sock</em> debe ser un socket no bloqueante.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>A pesar de que este método siempre fue documentado como un método de corrutina, antes de Python 3.7 retorna un <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>. Desde Python 3.7, este es un método <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="translated"><a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> y <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.sock_sendfile">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">sock_sendfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">fallback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.sock_sendfile" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Envía un archivo usando <a class="reference internal" href="os.html#os.sendfile" title="os.sendfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.sendfile</span></code></a> de alto rendimiento si es posible. Retorna el número total de bytes enviados.</p>
<p class="translated">Versión asíncrona de <a class="reference internal" href="socket.html#socket.socket.sendfile" title="socket.socket.sendfile"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.sendfile()</span></code></a>.</p>
<p class="translated"><em>sock</em> debe ser un <a class="reference internal" href="socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_STREAM</span></code></a> <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket</span></code></a> no bloqueante.</p>
<p class="translated"><em>file</em> debe ser un objeto de archivo regular abierto en modo binario.</p>
<p class="translated"><em>offset</em> indica desde donde se empezará a leer el archivo. Si es especificado, <em>count</em> es el número total de bytes a transmitir en contraposición con enviar el archivo hasta que se alcance EOF. La posición del archivo es actualizada siempre, incluso cuando este método genere un error, y <a class="reference internal" href="io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">file.tell()</span></code></a> puede ser usado para obtener el número de bytes enviados hasta el momento.</p>
<p class="translated"><em>fallback</em>, cuando es establecida como <code class="docutils literal notranslate"><span class="pre">True</span></code>, hace que asyncio lea y escriba el archivo manualmente cuando el sistema no soporta la llamada de envío de archivos del sistema (por ejemplo, Windows o sockets SSL en Unix).</p>
<p class="translated">Lanza <a class="reference internal" href="asyncio-exceptions.html#asyncio.SendfileNotAvailableError" title="asyncio.SendfileNotAvailableError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SendfileNotAvailableError</span></code></a> si el sistema no soporta la llamada de envío de archivos del sistema <em>sendfile</em> y <em>fallback</em> es <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p class="translated"><em>sock</em> debe ser un socket no bloqueante.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

</section>
<section id="dns">
<h3 class="translated"><a class="toc-backref" href="#id11" role="doc-backlink">DNS</a><a class="headerlink" href="#dns" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.getaddrinfo">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">getaddrinfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">host</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">family</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.getaddrinfo" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Versión asíncrona de <a class="reference internal" href="socket.html#socket.getaddrinfo" title="socket.getaddrinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getaddrinfo()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.getnameinfo">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">getnameinfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sockaddr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.getnameinfo" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Asynchronous version of <a class="reference internal" href="socket.html#socket.getnameinfo" title="socket.getnameinfo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.getnameinfo()</span></code></a>.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">Both <em>getaddrinfo</em> and <em>getnameinfo</em> internally utilize their synchronous
versions through the loop’s default thread pool executor.
When this executor is saturated, these methods may experience delays,
which higher-level networking libraries may report as increased timeouts.
To mitigate this, consider using a custom executor for other user tasks,
or setting a default executor with a larger number of workers.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Ambos métodos <em>getaddrinfo</em> y <em>getnameinfo</em> siempre fueron documentados para retornar una corrutina, pero antes de Python 3.7 retornaban, de hecho, objetos <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">Future</span></code></a>. A partir de Python 3.7, ambos métodos son corrutinas.</p>
</div>
</section>
<section id="working-with-pipes">
<h3 class="translated"><a class="toc-backref" href="#id12" role="doc-backlink">Trabajando con tuberías</a><a class="headerlink" href="#working-with-pipes" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.connect_read_pipe">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">connect_read_pipe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipe</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_read_pipe" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Registra el fin de lectura de <em>pipe</em> en el bucle de eventos.</p>
<p class="translated"><em>protocol_factory</em> debe ser un ejecutable que retorna una implementación del <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">asyncio protocol</span></a>.</p>
<p class="translated"><em>pipe</em> es un <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">objeto de tipo archivo</span></a>.</p>
<p class="translated">Retorna un par <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, donde <em>transport</em>  soporta la interface <a class="reference internal" href="asyncio-protocol.html#asyncio.ReadTransport" title="asyncio.ReadTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReadTransport</span></code></a> y <em>protocol</em> es un objeto instanciado por <em>protocol_factory</em>.</p>
<p class="translated">Con el bucle de eventos <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a>, el <em>pipe</em> es establecido en modo no bloqueante.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.connect_write_pipe">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">connect_write_pipe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pipe</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.connect_write_pipe" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Registra el fin de escritura de <em>pipe</em> en el bucle de eventos.</p>
<p class="translated"><em>protocol_factory</em> debe ser un ejecutable que retorna una implementación del <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">asyncio protocol</span></a>.</p>
<p class="translated"><em>pipe</em> es un <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">objeto de tipo archivo</span></a>.</p>
<p class="translated">Retorna un par <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, donde <em>transport</em> soporta la interface <a class="reference internal" href="asyncio-protocol.html#asyncio.WriteTransport" title="asyncio.WriteTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">WriteTransport</span></code></a> y <em>protocol</em> es un objeto inicializado por <em>protocol_factory</em>.</p>
<p class="translated">Con el bucle de eventos <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a>, el <em>pipe</em> es establecido en modo no bloqueante.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated"><a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> no soporta los métodos anteriores en windows. En su lugar, use <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> para Windows.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="translated">Los métodos <a class="reference internal" href="#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_exec()</span></code></a> y <a class="reference internal" href="#asyncio.loop.subprocess_shell" title="asyncio.loop.subprocess_shell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.subprocess_shell()</span></code></a>.</p>
</div>
</section>
<section id="unix-signals">
<h3 class="translated"><a class="toc-backref" href="#id13" role="doc-backlink">Señales Unix</a><a class="headerlink" href="#unix-signals" title="Link to this heading">¶</a></h3>
<dl class="py method" id="loop-add-signal-handler">
<dt class="sig sig-object py" id="asyncio.loop.add_signal_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">add_signal_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.add_signal_handler" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Establece <em>callback</em> como el gestor para la señal <em>signum</em>.</p>
<p class="translated">La llamada será invocada por <em>loop</em>, junto con otras llamadas encoladas y corrutinas ejecutables de ese bucle de eventos. A menos que los gestores de señal la registren usando <a class="reference internal" href="signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.signal()</span></code></a>, una llamada registrada con esta función tiene permitido interactuar con el bucle de eventos.</p>
<p class="translated">Lanza <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> si el número de señal es invalido o inalcanzable. Lanza <a class="reference internal" href="exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> si hay algún problema preparando el gestor.</p>
<p class="translated">Use <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">para pasar argumentos de palabra clave</span></a> a <em>callback</em>.</p>
<p class="translated">Como <a class="reference internal" href="signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.signal()</span></code></a>, esta función debe ser invocada en el hilo principal.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.remove_signal_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">remove_signal_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sig</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.remove_signal_handler" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Elimina el gestor para la señal <em>sig</em>.</p>
<p class="translated">Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si el gestor de señal fue eliminado, o <code class="docutils literal notranslate"><span class="pre">False</span></code> si no se estableció gestor para la señal dada.</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix.</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="translated">El módulo <a class="reference internal" href="signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a>.</p>
</div>
</section>
<section id="executing-code-in-thread-or-process-pools">
<h3 class="translated"><a class="toc-backref" href="#id14" role="doc-backlink">Ejecutando código en un hilos o grupos de procesos</a><a class="headerlink" href="#executing-code-in-thread-or-process-pools" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.run_in_executor">
<em class="property"><span class="pre">awaitable</span> </em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">run_in_executor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">executor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.run_in_executor" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Hace arreglos para que <em>func</em> sea llamado en el ejecutor especificado.</p>
<p class="untranslated">The <em>executor</em> argument should be an <a class="reference internal" href="concurrent.futures.html#concurrent.futures.Executor" title="concurrent.futures.Executor"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.Executor</span></code></a>
instance. The default executor is used if <em>executor</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.
The default executor can be set by <a class="reference internal" href="#asyncio.loop.set_default_executor" title="asyncio.loop.set_default_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.set_default_executor()</span></code></a>,
otherwise, a <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">concurrent.futures.ThreadPoolExecutor</span></code></a> will be
lazy-initialized and used by <a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-func docutils literal notranslate"><span class="pre">run_in_executor()</span></code></a> if needed.</p>
<p class="translated">Ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">concurrent.futures</span>

<span class="k">def</span><span class="w"> </span><span class="nf">blocking_io</span><span class="p">():</span>
    <span class="c1"># File operations (such as logging) can block the</span>
    <span class="c1"># event loop: run them in a thread pool.</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/dev/urandom&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">cpu_bound</span><span class="p">():</span>
    <span class="c1"># CPU-bound operations will block the event loop:</span>
    <span class="c1"># in general it is preferable to run them in a</span>
    <span class="c1"># process pool.</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="mi">7</span><span class="p">))</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="c1">## Options:</span>

    <span class="c1"># 1. Run in the default loop&#39;s executor:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span> <span class="n">blocking_io</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;default thread pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="c1"># 2. Run in a custom thread pool:</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
            <span class="n">pool</span><span class="p">,</span> <span class="n">blocking_io</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;custom thread pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="c1"># 3. Run in a custom process pool:</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
            <span class="n">pool</span><span class="p">,</span> <span class="n">cpu_bound</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;custom process pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

    <span class="c1"># 4. Run in a custom interpreter pool:</span>
    <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">InterpreterPoolExecutor</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span>
            <span class="n">pool</span><span class="p">,</span> <span class="n">cpu_bound</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;custom interpreter pool&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
<p class="translated">Tenga en cuenta que la protección del punto de entrada (<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code>) es requerida para la opción 3 debido a las peculiaridades de <a class="reference internal" href="multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a>, que es utilizado por <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" title="concurrent.futures.ProcessPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProcessPoolExecutor</span></code></a>. Vea <a class="reference internal" href="multiprocessing.html#multiprocessing-safe-main-import"><span class="std std-ref">Importación segura del módulo principal</span></a>.</p>
<p class="translated">Este método retorna un objeto <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a>.</p>
<p class="translated">Use <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> <a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">para pasar argumentos de palabra clave</span></a> a <em>func</em>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5.3: </span><a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_in_executor()</span></code></a> ya no configura el <code class="docutils literal notranslate"><span class="pre">max_workers</span></code> del ejecutor del grupo de subprocesos que crea, sino que lo deja en manos del ejecutor del grupo de subprocesos (<a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>) para establecer el valor por defecto.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.set_default_executor">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">set_default_executor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">executor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_default_executor" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Set <em>executor</em> as the default executor used by <a class="reference internal" href="#asyncio.loop.run_in_executor" title="asyncio.loop.run_in_executor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_in_executor()</span></code></a>.
<em>executor</em> must be an instance of
<a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>, which includes
<a class="reference internal" href="concurrent.futures.html#concurrent.futures.InterpreterPoolExecutor" title="concurrent.futures.InterpreterPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">InterpreterPoolExecutor</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span><em>executor</em> debe ser una instancia de <a class="reference internal" href="concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadPoolExecutor</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="error-handling-api">
<h3 class="translated"><a class="toc-backref" href="#id15" role="doc-backlink">API para manejo de errores</a><a class="headerlink" href="#error-handling-api" title="Link to this heading">¶</a></h3>
<p class="translated">Permite personalizar como son manejadas las excepciones en el bucle de eventos.</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.set_exception_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">set_exception_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handler</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_exception_handler" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Establece <em>handler</em> como el nuevo gestor de excepciones del bucle de eventos.</p>
<p class="translated">Si <em>handler</em> es <code class="docutils literal notranslate"><span class="pre">None</span></code>, se establecerá el gestor de excepciones predeterminado. De otro modo, <em>handler</em> debe ser un invocable con la misma firma <code class="docutils literal notranslate"><span class="pre">(loop,</span> <span class="pre">context)</span></code>, donde <code class="docutils literal notranslate"><span class="pre">loop</span></code> es una referencia al bucle de eventos activo, y <code class="docutils literal notranslate"><span class="pre">context</span></code> es un objeto <code class="docutils literal notranslate"><span class="pre">dict</span></code> que contiene los detalles de la excepción (vea la documentación de <a class="reference internal" href="#asyncio.loop.call_exception_handler" title="asyncio.loop.call_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_exception_handler()</span></code></a> para detalles acerca del contexto).</p>
<p class="untranslated">If the handler is called on behalf of a <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> or
<a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a>, it is run in the
<a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> of that task or callback handle.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>The handler may be called in the <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a>
of the task or handle where the exception originated.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.get_exception_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">get_exception_handler</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_exception_handler" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna el gesto de excepciones actual, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no fue establecido ningún gestor de excepciones personalizado.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.default_exception_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">default_exception_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.default_exception_handler" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Gestor de excepciones por defecto.</p>
<p class="translated">Esto es llamado cuando ocurre una excepción y no se estableció ningún gestor de excepciones. Esto puede ser llamado por un gestor de excepciones personalizado que quiera cambiar el comportamiento del gestor predeterminado.</p>
<p class="translated">El parámetro <em>context</em> tiene el mismo significado que en <a class="reference internal" href="#asyncio.loop.call_exception_handler" title="asyncio.loop.call_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call_exception_handler()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.call_exception_handler">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">call_exception_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.call_exception_handler" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Llama al gestor de excepciones del bucle de eventos actual.</p>
<p class="translated"><em>context</em> es un objeto <code class="docutils literal notranslate"><span class="pre">dict</span></code> conteniendo las siguientes claves (en futuras versiones de Python podrían introducirse nuevas claves):</p>
<ul class="simple">
<li><p class="translated">“message”: Mensaje de error;</p></li>
<li><p class="translated">“exception” (opcional): Objeto de excepción;</p></li>
<li><p class="translated">“future” (opcional): instancia de <a class="reference internal" href="asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a>;</p></li>
<li><p class="translated">“task” (opcional): instancia de <a class="reference internal" href="asyncio-task.html#asyncio.Task" title="asyncio.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Task</span></code></a>;</p></li>
<li><p class="translated">“handle” (opcional): instancia de <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Handle</span></code></a>;</p></li>
<li><p class="translated">“protocol” (opcional): instancia de <a class="reference internal" href="asyncio-protocol.html#asyncio-protocol"><span class="std std-ref">Protocol</span></a>;</p></li>
<li><p class="translated">“transport” (opcional): instancia de <a class="reference internal" href="asyncio-protocol.html#asyncio-transport"><span class="std std-ref">Transport</span></a>;</p></li>
<li><p class="translated">“socket” (opcional): instancia de <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>;</p></li>
<li><p class="untranslated">“source_traceback” (optional): Traceback of the source;</p></li>
<li><p class="untranslated">“handle_traceback” (optional): Traceback of the handle;</p></li>
<li><dl class="simple">
<dt class="translated">“asyncgen” (opcional): Generador asíncrono que causó</dt><dd><p class="translated">la excepción.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">This method should not be overloaded in subclassed
event loops.  For custom exception handling, use
the <a class="reference internal" href="#asyncio.loop.set_exception_handler" title="asyncio.loop.set_exception_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_exception_handler()</span></code></a> method.</p>
</div>
</dd></dl>

</section>
<section id="enabling-debug-mode">
<h3 class="translated"><a class="toc-backref" href="#id16" role="doc-backlink">Habilitando el modo depuración</a><a class="headerlink" href="#enabling-debug-mode" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.get_debug">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">get_debug</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.get_debug" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Obtiene el modo depuración (<a class="reference internal" href="functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>) del bucle de eventos.</p>
<p class="translated">El valor predeterminado es <code class="docutils literal notranslate"><span class="pre">True</span></code> si la variable de entorno <span class="target" id="index-17"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONASYNCIODEBUG"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONASYNCIODEBUG</span></code></a> es establecida a una cadena no vacía, de otro modo será <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.set_debug">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">set_debug</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">enabled</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="functions.html#bool" title="bool"><span class="pre">bool</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.set_debug" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Establece el modo de depuración del bucle de eventos.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>El nuevo <a class="reference internal" href="devmode.html#devmode"><span class="std std-ref">Python Modo de Desarrollo</span></a> ahora también se puede usar para habilitar el modo de depuración.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="asyncio.loop.slow_callback_duration">
<span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">slow_callback_duration</span></span><a class="headerlink" href="#asyncio.loop.slow_callback_duration" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">This attribute can be used to set the
minimum execution duration in seconds that is considered «slow».
When debug mode is enabled, «slow» callbacks are logged.</p>
<p class="untranslated">Default value is 100 milliseconds.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="translated">El <a class="reference internal" href="asyncio-dev.html#asyncio-debug-mode"><span class="std std-ref">modo depuración de asyncio</span></a>.</p>
</div>
</section>
<section id="running-subprocesses">
<h3 class="translated"><a class="toc-backref" href="#id17" role="doc-backlink">Ejecutando subprocesos</a><a class="headerlink" href="#running-subprocesses" title="Link to this heading">¶</a></h3>
<p class="translated">Los métodos descritos en esta subsección son de bajo nivel. En código async/await regular considere usar las convenientes funciones de alto nivel <a class="reference internal" href="asyncio-subprocess.html#asyncio.create_subprocess_shell" title="asyncio.create_subprocess_shell"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_subprocess_shell()</span></code></a> y <a class="reference internal" href="asyncio-subprocess.html#asyncio.create_subprocess_exec" title="asyncio.create_subprocess_exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.create_subprocess_exec()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">En Windows, el bucle de eventos por defecto <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> soporta subprocesos, mientras que <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> no. Vea <a class="reference internal" href="asyncio-platforms.html#asyncio-windows-subprocess"><span class="std std-ref">Soporte de subprocesos en Windows</span></a> para más detalles.</p>
</div>
<dl class="py method" id="loop-subprocess-exec">
<dt class="sig sig-object py" id="asyncio.loop.subprocess_exec">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">subprocess_exec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stderr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.subprocess_exec" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Crea un subproceso de uno o mas argumentos de cadena especificados por <em>args</em>.</p>
<p class="translated"><em>args</em> debe ser una lista de cadenas representadas por:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>;</p></li>
<li><p class="translated">o <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, codificados a la <a class="reference internal" href="os.html#filesystem-encoding"><span class="std std-ref">codificación del sistema de archivos</span></a>.</p></li>
</ul>
<p class="translated">La primer cadena especifica el programa ejecutable, y las cadenas restantes especifican los argumentos. En conjunto, los argumentos de cadena forman el <code class="docutils literal notranslate"><span class="pre">argv</span></code> del programa.</p>
<p class="translated">Esto es similar a la clase de la librería estándar <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> llamada con <code class="docutils literal notranslate"><span class="pre">shell=False</span></code> y la lista de cadenas pasadas como el primer argumento; de cualquier forma, cuando <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">Popen</span></code></a> toma un sólo argumento que es una lista de cadenas, <em>subprocess_exec</em> toma múltiples cadenas como argumentos.</p>
<p class="translated">El <em>protocol_factory</em> debe ser un ejecutable que retorne una subclase de la clase <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.SubprocessProtocol</span></code></a>.</p>
<p class="translated">Otros parámetros:</p>
<ul>
<li><p class="translated"><em>stdin</em> puede ser cualquier de estos:</p>
<ul class="simple">
<li><p class="untranslated">a file-like object</p></li>
<li><p class="untranslated">an existing file descriptor (a positive integer), for example those created with <a class="reference internal" href="os.html#os.pipe" title="os.pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">os.pipe()</span></code></a></p></li>
<li><p class="translated">la constante <a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> (predeterminado) que creará una tubería nueva y la conectará,</p></li>
<li><p class="translated">el valor <code class="docutils literal notranslate"><span class="pre">None</span></code> que hará que el subproceso herede el descriptor de archivo de este proceso</p></li>
<li><p class="translated">la constante <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> que indica que el archivo especial <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> será utilizado</p></li>
</ul>
</li>
<li><p class="translated"><em>stdout</em> puede ser cualquier de estos:</p>
<ul class="simple">
<li><p class="untranslated">a file-like object</p></li>
<li><p class="translated">la constante <a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> (predeterminado) que creará una tubería nueva y la conectará,</p></li>
<li><p class="translated">el valor <code class="docutils literal notranslate"><span class="pre">None</span></code> que hará que el subproceso herede el descriptor de archivo de este proceso</p></li>
<li><p class="translated">la constante <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> que indica que el archivo especial <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> será utilizado</p></li>
</ul>
</li>
<li><p class="translated"><em>stderr</em> puede ser cualquier de estos:</p>
<ul class="simple">
<li><p class="untranslated">a file-like object</p></li>
<li><p class="translated">la constante <a class="reference internal" href="subprocess.html#subprocess.PIPE" title="subprocess.PIPE"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code></a> (predeterminado) que creará una tubería nueva y la conectará,</p></li>
<li><p class="translated">el valor <code class="docutils literal notranslate"><span class="pre">None</span></code> que hará que el subproceso herede el descriptor de archivo de este proceso</p></li>
<li><p class="translated">la constante <a class="reference internal" href="subprocess.html#subprocess.DEVNULL" title="subprocess.DEVNULL"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code></a> que indica que el archivo especial <a class="reference internal" href="os.html#os.devnull" title="os.devnull"><code class="xref py py-data docutils literal notranslate"><span class="pre">os.devnull</span></code></a> será utilizado</p></li>
<li><p class="translated">la constante <a class="reference internal" href="subprocess.html#subprocess.STDOUT" title="subprocess.STDOUT"><code class="xref py py-const docutils literal notranslate"><span class="pre">subprocess.STDOUT</span></code></a> que conectará el flujo de errores predeterminado al flujo de salida predeterminado del proceso</p></li>
</ul>
</li>
<li><p class="translated">El resto de argumentos de palabra clave son pasados a <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> sin interpretación, excepto por <em>bufsize</em>, <em>universal_newlines</em>, <em>shell</em>, <em>text</em>, <em>encoding</em> y <em>errors</em>, que no deben ser especificados en lo absoluto.</p>
<p class="translated">La API subproceso <code class="docutils literal notranslate"><span class="pre">asyncio</span></code> no soporta decodificar los flujos como texto. <a class="reference internal" href="stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> puede ser usado para convertir a texto los bytes retornados por el flujo.</p>
</li>
</ul>
<p class="untranslated">If a file-like object passed as <em>stdin</em>, <em>stdout</em> or <em>stderr</em> represents a
pipe, then the other side of this pipe should be registered with
<a class="reference internal" href="#asyncio.loop.connect_write_pipe" title="asyncio.loop.connect_write_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_write_pipe()</span></code></a> or <a class="reference internal" href="#asyncio.loop.connect_read_pipe" title="asyncio.loop.connect_read_pipe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect_read_pipe()</span></code></a> for use
with the event loop.</p>
<p class="translated">Vea el constructor de la clase <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> para documentación acerca de otros argumentos.</p>
<p class="translated">Retorna un par de <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, donde <em>transport</em> se ajusta a la clase base <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessTransport" title="asyncio.SubprocessTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.SubprocessTransport</span></code></a> y <em>protocol</em> es un objeto instanciado por <em>protocol_factory</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.loop.subprocess_shell">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">loop.</span></span><span class="sig-name descname"><span class="pre">subprocess_shell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol_factory</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmd</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stderr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">subprocess.PIPE</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.loop.subprocess_shell" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Crea un subproceso desde <em>cmd</em>, que puede ser una cadena <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> o <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> codificado a la <a class="reference internal" href="os.html#filesystem-encoding"><span class="std std-ref">codificación del sistema de archivos</span></a>, usando la sintaxis «shell» de la plataforma.</p>
<p class="translated">Esto es similar a la clase de la librería estándar <a class="reference internal" href="subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> llamada con <code class="docutils literal notranslate"><span class="pre">shell=True</span></code>.</p>
<p class="translated">El <em>protocol_factory</em> debe ser un ejecutable que retorne una subclase de la clase <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.SubprocessProtocol</span></code></a>.</p>
<p class="translated">Vea <a class="reference internal" href="#asyncio.loop.subprocess_exec" title="asyncio.loop.subprocess_exec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess_exec()</span></code></a> para mas detalles acerca de los argumentos restantes.</p>
<p class="translated">Retorna un par de <code class="docutils literal notranslate"><span class="pre">(transport,</span> <span class="pre">protocol)</span></code>, donde <em>transport</em> se ajusta a la clase base <a class="reference internal" href="asyncio-protocol.html#asyncio.SubprocessTransport" title="asyncio.SubprocessTransport"><code class="xref py py-class docutils literal notranslate"><span class="pre">SubprocessTransport</span></code></a> y <em>protocol</em> es un objeto instanciado por <em>protocol_factory</em>.</p>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Es responsabilidad de la aplicación asegurar que todos los espacios en blanco y caracteres especiales estén escapados correctamente para evitar vulnerabilidades de <a class="reference external" href="https://en.wikipedia.org/wiki/Shell_injection#Shell_injection">inyección de código</a>. La función <a class="reference internal" href="shlex.html#shlex.quote" title="shlex.quote"><code class="xref py py-func docutils literal notranslate"><span class="pre">shlex.quote()</span></code></a> puede ser usada para escapar apropiadamente espacios en blanco y caracteres especiales en cadenas que van a ser usadas para construir comandos de consola.</p>
</div>
</section>
</section>
<section id="callback-handles">
<h2 class="translated">Gestores de llamadas<a class="headerlink" href="#callback-handles" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.Handle">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">Handle</span></span><a class="headerlink" href="#asyncio.Handle" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Un objeto de contenedor de llamada retornado por <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a>, <a class="reference internal" href="#asyncio.loop.call_soon_threadsafe" title="asyncio.loop.call_soon_threadsafe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon_threadsafe()</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Handle.get_context">
<span class="sig-name descname"><span class="pre">get_context</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.get_context" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return the <a class="reference internal" href="contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> object
associated with the handle.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Handle.cancel">
<span class="sig-name descname"><span class="pre">cancel</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.cancel" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Cancela la llamada. Si la llamada ya fue cancelada o ejecutada, este método no tiene efecto.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Handle.cancelled">
<span class="sig-name descname"><span class="pre">cancelled</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Handle.cancelled" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si la llamada fue cancelada.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncio.TimerHandle">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">TimerHandle</span></span><a class="headerlink" href="#asyncio.TimerHandle" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Un objeto de contenedor de llamada retornado por <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a>, and <a class="reference internal" href="#asyncio.loop.call_at" title="asyncio.loop.call_at"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_at()</span></code></a>.</p>
<p class="translated">Esta clase es una subclase de <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handle</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.TimerHandle.when">
<span class="sig-name descname"><span class="pre">when</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.TimerHandle.when" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna el tiempo de una llamada planificada como <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> segundos.</p>
<p class="translated">El tiempo es una marca de tiempo absoluta, usando la misma referencia de tiempo que <a class="reference internal" href="#asyncio.loop.time" title="asyncio.loop.time"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.time()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="server-objects">
<h2 class="translated">Objetos Servidor<a class="headerlink" href="#server-objects" title="Link to this heading">¶</a></h2>
<p class="translated">Los objetos de servidor son creados por las funciones <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a>, <a class="reference internal" href="#asyncio.loop.create_unix_server" title="asyncio.loop.create_unix_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_unix_server()</span></code></a>, <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_server()</span></code></a>, y <a class="reference internal" href="asyncio-stream.html#asyncio.start_unix_server" title="asyncio.start_unix_server"><code class="xref py py-func docutils literal notranslate"><span class="pre">start_unix_server()</span></code></a>.</p>
<p class="untranslated">Do not instantiate the <a class="reference internal" href="#asyncio.Server" title="asyncio.Server"><code class="xref py py-class docutils literal notranslate"><span class="pre">Server</span></code></a> class directly.</p>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.Server">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">Server</span></span><a class="headerlink" href="#asyncio.Server" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Los objetos <em>Server</em> son gestores de asíncronos de contexto. Cuando son usados en una declaración <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>, está garantizado que el objeto Servidor está cerrado y no está aceptando nuevas conexiones cuando la declaración <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> es completada:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="k">async</span> <span class="k">with</span> <span class="n">srv</span><span class="p">:</span>
    <span class="c1"># some code</span>

<span class="c1"># At this point, srv is closed and no longer accepts new connections.</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>El objeto Servidor es un gestor asíncrono de contexto desde Python 3.7.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>This class was exposed publicly as <code class="docutils literal notranslate"><span class="pre">asyncio.Server</span></code> in Python 3.9.11, 3.10.3 and 3.11.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.close" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Deja de servir: deja de escuchar sockets y establece el atributo <a class="reference internal" href="#asyncio.Server.sockets" title="asyncio.Server.sockets"><code class="xref py py-attr docutils literal notranslate"><span class="pre">sockets</span></code></a> a <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p class="translated">Los sockets que representan conexiones entrantes existentes de clientes se dejan abiertas.</p>
<p class="untranslated">The server is closed asynchronously; use the <a class="reference internal" href="#asyncio.Server.wait_closed" title="asyncio.Server.wait_closed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_closed()</span></code></a>
coroutine to wait until the server is closed (and no more
connections are active).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.close_clients">
<span class="sig-name descname"><span class="pre">close_clients</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.close_clients" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Close all existing incoming client connections.</p>
<p class="untranslated">Calls <a class="reference internal" href="asyncio-protocol.html#asyncio.BaseTransport.close" title="asyncio.BaseTransport.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> on all associated
transports.</p>
<p class="untranslated"><a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> should be called before <a class="reference internal" href="#asyncio.Server.close_clients" title="asyncio.Server.close_clients"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close_clients()</span></code></a> when
closing the server to avoid races with new clients connecting.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.abort_clients">
<span class="sig-name descname"><span class="pre">abort_clients</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.abort_clients" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Close all existing incoming client connections immediately,
without waiting for pending operations to complete.</p>
<p class="untranslated">Calls <a class="reference internal" href="asyncio-protocol.html#asyncio.WriteTransport.abort" title="asyncio.WriteTransport.abort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abort()</span></code></a> on all associated
transports.</p>
<p class="untranslated"><a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> should be called before <a class="reference internal" href="#asyncio.Server.abort_clients" title="asyncio.Server.abort_clients"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abort_clients()</span></code></a> when
closing the server to avoid races with new clients connecting.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.get_loop">
<span class="sig-name descname"><span class="pre">get_loop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.get_loop" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna el bucle de eventos asociado con el objeto Servidor.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.start_serving">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">start_serving</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.start_serving" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Comienza a aceptar conexiones.</p>
<p class="translated">Este método es idempotente, así que puede ser llamado cuando el servidor ya está sirviendo.</p>
<p class="translated">El parámetro sólo de palabra clave <em>start_serving</em> de <a class="reference internal" href="#asyncio.loop.create_server" title="asyncio.loop.create_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_server()</span></code></a> y <a class="reference internal" href="asyncio-stream.html#asyncio.start_server" title="asyncio.start_server"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asyncio.start_server()</span></code></a> permite crear un objeto Servidor que no está aceptando conexiones inicialmente. En este caso <code class="docutils literal notranslate"><span class="pre">Server.start_serving()</span></code>, o <a class="reference internal" href="#asyncio.Server.serve_forever" title="asyncio.Server.serve_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Server.serve_forever()</span></code></a> pueden ser usados para hacer que el servidor empiece a aceptar conexiones.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.serve_forever">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">serve_forever</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.serve_forever" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Comienza a aceptar conexiones hasta que la corrutina sea cancelada. La cancelación de la tarea <code class="docutils literal notranslate"><span class="pre">serve_forever</span></code> hace que el servidor sea cerrado.</p>
<p class="translated">Este método puede ser llamado si el servidor ya está aceptando conexiones. Solamente una tarea <code class="docutils literal notranslate"><span class="pre">serve_forever</span></code> puede existir para un objeto <em>Server</em>.</p>
<p class="translated">Ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">client_connected</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
    <span class="c1"># Communicate with the client with</span>
    <span class="c1"># reader/writer streams.  For example:</span>
    <span class="k">await</span> <span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">srv</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">start_server</span><span class="p">(</span>
        <span class="n">client_connected</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">srv</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.is_serving">
<span class="sig-name descname"><span class="pre">is_serving</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.is_serving" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna <code class="docutils literal notranslate"><span class="pre">True</span></code> si el servidor está aceptando nuevas conexiones.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="asyncio.Server.wait_closed">
<em class="property"><span class="k"><span class="pre">async</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wait_closed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#asyncio.Server.wait_closed" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Wait until the <a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> method completes and all active
connections have finished.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="asyncio.Server.sockets">
<span class="sig-name descname"><span class="pre">sockets</span></span><a class="headerlink" href="#asyncio.Server.sockets" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">List of socket-like objects, <code class="docutils literal notranslate"><span class="pre">asyncio.trsock.TransportSocket</span></code>, which
the server is listening on.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Antes de Python 3.7 <code class="docutils literal notranslate"><span class="pre">Server.sockets</span></code> solía retornar directamente una lista interna de servidores socket. En 3.7 se retorna una copia de esa lista.</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="event-loop-implementations">
<span id="asyncio-event-loop-implementations"></span><span id="asyncio-event-loops"></span><h2 class="translated">Implementaciones del bucle de eventos<a class="headerlink" href="#event-loop-implementations" title="Link to this heading">¶</a></h2>
<p class="translated">asyncio viene con dos implementaciones diferentes del bucle de eventos: <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> y <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a>.</p>
<p class="untranslated">By default asyncio is configured to use <a class="reference internal" href="#asyncio.EventLoop" title="asyncio.EventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">EventLoop</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="asyncio.SelectorEventLoop">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">SelectorEventLoop</span></span><a class="headerlink" href="#asyncio.SelectorEventLoop" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A subclass of <a class="reference internal" href="#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractEventLoop</span></code></a> based on the
<a class="reference internal" href="selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a> module.</p>
<p class="translated">Usa el <em>selector</em> disponible mas eficiente para la plataforma dada. También es posible configurar manualmente la implementación exacta del selector a utilizar:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">selectors</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span>
   <span class="o">...</span>

<span class="n">loop_factory</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">SelectorEventLoop</span><span class="p">(</span><span class="n">selectors</span><span class="o">.</span><span class="n">SelectSelector</span><span class="p">())</span>
<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">(),</span> <span class="n">loop_factory</span><span class="o">=</span><span class="n">loop_factory</span><span class="p">)</span>
</pre></div>
</div>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Unix, Windows.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncio.ProactorEventLoop">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">ProactorEventLoop</span></span><a class="headerlink" href="#asyncio.ProactorEventLoop" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A subclass of <a class="reference internal" href="#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractEventLoop</span></code></a> for Windows that uses «I/O Completion Ports» (IOCP).</p>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="untranslated"><a class="reference external" href="https://learn.microsoft.com/windows/win32/fileio/i-o-completion-ports">MSDN documentation on I/O Completion Ports</a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncio.EventLoop">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">EventLoop</span></span><a class="headerlink" href="#asyncio.EventLoop" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p class="untranslated">An alias to the most efficient available subclass of <a class="reference internal" href="#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractEventLoop</span></code></a> for the given
platform.</p>
<p class="untranslated">It is an alias to <a class="reference internal" href="#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">SelectorEventLoop</span></code></a> on Unix and <a class="reference internal" href="#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProactorEventLoop</span></code></a> on Windows.</p>
</div></blockquote>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="asyncio.AbstractEventLoop">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">asyncio.</span></span><span class="sig-name descname"><span class="pre">AbstractEventLoop</span></span><a class="headerlink" href="#asyncio.AbstractEventLoop" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Clase base abstracta para bucles de evento compatibles con asyncio.</p>
<p class="translated">La sección <a class="reference internal" href="#asyncio-event-loop-methods"><span class="std std-ref">Métodos del bucle de eventos</span></a> lista todos los métodos que una implementación alternativa de <code class="docutils literal notranslate"><span class="pre">AbstractEventLoop</span></code> debería tener definidos.</p>
</dd></dl>

</section>
<section id="examples">
<h2 class="translated">Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h2>
<p class="translated">Nótese que todos los ejemplos en esta sección muestran <strong>a propósito</strong> como usar las APIs de bucle de eventos de bajo nivel, como ser <a class="reference internal" href="#asyncio.loop.run_forever" title="asyncio.loop.run_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.run_forever()</span></code></a> y <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a>. Aplicaciones asyncio modernas raramente necesitan ser escritas de esta manera; considere utilizar funciones de alto nivel como <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.run()</span></code></a>.</p>
<section id="hello-world-with-call-soon">
<span id="asyncio-example-lowlevel-helloworld"></span><h3 class="translated">Hola Mundo con call_soon()<a class="headerlink" href="#hello-world-with-call-soon" title="Link to this heading">¶</a></h3>
<p class="translated">Un ejemplo usando el método <a class="reference internal" href="#asyncio.loop.call_soon" title="asyncio.loop.call_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_soon()</span></code></a> para planificar una llamada. La llamada muestra <code class="docutils literal notranslate"><span class="pre">&quot;Hello</span> <span class="pre">World&quot;</span></code> y luego para el bucle de eventos:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="k">def</span><span class="w"> </span><span class="nf">hello_world</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A callback to print &#39;Hello World&#39; and stop the event loop&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>

<span class="c1"># Schedule a call to hello_world()</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">hello_world</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># Blocking call interrupted by loop.stop()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="translated">Un ejemplo similar de <a class="reference internal" href="asyncio-task.html#coroutine"><span class="std std-ref">Hola Mundo</span></a> creado con una corrutina y la función <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a>.</p>
</div>
</section>
<section id="display-the-current-date-with-call-later">
<span id="asyncio-example-call-later"></span><h3 class="translated">Muestra la fecha actual con call_later()<a class="headerlink" href="#display-the-current-date-with-call-later" title="Link to this heading">¶</a></h3>
<p class="translated">Un ejemplo de llamada mostrando la fecha actual cada un segundo. La llamada usa el método <a class="reference internal" href="#asyncio.loop.call_later" title="asyncio.loop.call_later"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.call_later()</span></code></a> para volver a planificarse después de 5 segundos, y después para el bucle de eventos:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>

<span class="k">def</span><span class="w"> </span><span class="nf">display_date</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">end_time</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>

<span class="c1"># Schedule the first call to display_date()</span>
<span class="n">end_time</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="mf">5.0</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">display_date</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">loop</span><span class="p">)</span>

<span class="c1"># Blocking call interrupted by loop.stop()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="translated">Un ejemplo similar a <a class="reference internal" href="asyncio-task.html#asyncio-example-sleep"><span class="std std-ref">fecha actual</span></a> creado con una corrutina y la función <a class="reference internal" href="asyncio-runner.html#asyncio.run" title="asyncio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a>.</p>
</div>
</section>
<section id="watch-a-file-descriptor-for-read-events">
<span id="asyncio-example-watch-fd"></span><h3 class="translated">Mirar un descriptor de archivo para leer eventos<a class="headerlink" href="#watch-a-file-descriptor-for-read-events" title="Link to this heading">¶</a></h3>
<p class="translated">Espera hasta que el descriptor de archivo reciba algún dato usando el método <a class="reference internal" href="#asyncio.loop.add_reader" title="asyncio.loop.add_reader"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_reader()</span></code></a> y entonces cierra el bucle de eventos:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">socket</span><span class="w"> </span><span class="kn">import</span> <span class="n">socketpair</span>

<span class="c1"># Create a pair of connected file descriptors</span>
<span class="n">rsock</span><span class="p">,</span> <span class="n">wsock</span> <span class="o">=</span> <span class="n">socketpair</span><span class="p">()</span>

<span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">reader</span><span class="p">():</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">rsock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Received:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>

    <span class="c1"># We are done: unregister the file descriptor</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">remove_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">)</span>

    <span class="c1"># Stop the event loop</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="c1"># Register the file descriptor for read event</span>
<span class="n">loop</span><span class="o">.</span><span class="n">add_reader</span><span class="p">(</span><span class="n">rsock</span><span class="p">,</span> <span class="n">reader</span><span class="p">)</span>

<span class="c1"># Simulate the reception of data from the network</span>
<span class="n">loop</span><span class="o">.</span><span class="n">call_soon</span><span class="p">(</span><span class="n">wsock</span><span class="o">.</span><span class="n">send</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># Run the event loop</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="c1"># We are done. Close sockets and the event loop.</span>
    <span class="n">rsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">wsock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<ul class="simple">
<li><p class="translated">Un <a class="reference internal" href="asyncio-protocol.html#asyncio-example-create-connection"><span class="std std-ref">ejemplo</span></a> similar usando transportes, protocolos y el método <a class="reference internal" href="#asyncio.loop.create_connection" title="asyncio.loop.create_connection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.create_connection()</span></code></a>.</p></li>
<li><p class="translated">Otro <a class="reference internal" href="asyncio-stream.html#asyncio-example-create-connection-streams"><span class="std std-ref">ejemplo</span></a> similar usando la función de alto nivel <a class="reference internal" href="asyncio-stream.html#asyncio.open_connection" title="asyncio.open_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">asyncio.open_connection()</span></code></a> y transmisiones.</p></li>
</ul>
</div>
</section>
<section id="set-signal-handlers-for-sigint-and-sigterm">
<span id="asyncio-example-unix-signals"></span><h3 class="translated">Establece los gestores de señal para SIGINT y SIGTERM<a class="headerlink" href="#set-signal-handlers-for-sigint-and-sigterm" title="Link to this heading">¶</a></h3>
<p class="translated">(Este ejemplo de <code class="docutils literal notranslate"><span class="pre">signals</span></code> solamente funcionan en Unix.)</p>
<p class="untranslated">Register handlers for signals <a class="reference internal" href="signal.html#signal.SIGINT" title="signal.SIGINT"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGINT</span></code></a> and <a class="reference internal" href="signal.html#signal.SIGTERM" title="signal.SIGTERM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGTERM</span></code></a>
using the <a class="reference internal" href="#asyncio.loop.add_signal_handler" title="asyncio.loop.add_signal_handler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loop.add_signal_handler()</span></code></a> method:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">signal</span>

<span class="k">def</span><span class="w"> </span><span class="nf">ask_exit</span><span class="p">(</span><span class="n">signame</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;got signal </span><span class="si">%s</span><span class="s2">: exit&quot;</span> <span class="o">%</span> <span class="n">signame</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">signame</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;SIGINT&#39;</span><span class="p">,</span> <span class="s1">&#39;SIGTERM&#39;</span><span class="p">}:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">add_signal_handler</span><span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">signame</span><span class="p">),</span>
            <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">ask_exit</span><span class="p">,</span> <span class="n">signame</span><span class="p">,</span> <span class="n">loop</span><span class="p">))</span>

    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3600</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Event loop running for 1 hour, press Ctrl+C to interrupt.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pid </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span><span class="si">}</span><span class="s2">: send SIGINT or SIGTERM to exit.&quot;</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Bucle de eventos</a><ul>
<li><a class="reference internal" href="#event-loop-methods">Métodos del bucle de eventos</a><ul>
<li><a class="reference internal" href="#running-and-stopping-the-loop">Iniciar y para el bucle</a></li>
<li><a class="reference internal" href="#scheduling-callbacks">Programación de llamadas de retorno</a></li>
<li><a class="reference internal" href="#scheduling-delayed-callbacks">Planificando llamadas retardadas</a></li>
<li><a class="reference internal" href="#creating-futures-and-tasks">Creando futuros y tareas</a></li>
<li><a class="reference internal" href="#opening-network-connections">Abriendo conexiones de red</a></li>
<li><a class="reference internal" href="#creating-network-servers">Creando servidores de red</a></li>
<li><a class="reference internal" href="#transferring-files">Transfiriendo archivos</a></li>
<li><a class="reference internal" href="#tls-upgrade">Actualización de TLS</a></li>
<li><a class="reference internal" href="#watching-file-descriptors">Viendo descriptores de archivos</a></li>
<li><a class="reference internal" href="#working-with-socket-objects-directly">Trabajar con objetos sockets directamente</a></li>
<li><a class="reference internal" href="#dns">DNS</a></li>
<li><a class="reference internal" href="#working-with-pipes">Trabajando con tuberías</a></li>
<li><a class="reference internal" href="#unix-signals">Señales Unix</a></li>
<li><a class="reference internal" href="#executing-code-in-thread-or-process-pools">Ejecutando código en un hilos o grupos de procesos</a></li>
<li><a class="reference internal" href="#error-handling-api">API para manejo de errores</a></li>
<li><a class="reference internal" href="#enabling-debug-mode">Habilitando el modo depuración</a></li>
<li><a class="reference internal" href="#running-subprocesses">Ejecutando subprocesos</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callback-handles">Gestores de llamadas</a></li>
<li><a class="reference internal" href="#server-objects">Objetos Servidor</a></li>
<li><a class="reference internal" href="#event-loop-implementations">Implementaciones del bucle de eventos</a></li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#hello-world-with-call-soon">Hola Mundo con call_soon()</a></li>
<li><a class="reference internal" href="#display-the-current-date-with-call-later">Muestra la fecha actual con call_later()</a></li>
<li><a class="reference internal" href="#watch-a-file-descriptor-for-read-events">Mirar un descriptor de archivo para leer eventos</a></li>
<li><a class="reference internal" href="#set-signal-handlers-for-sigint-and-sigterm">Establece los gestores de señal para SIGINT y SIGTERM</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="asyncio-graph.html"
                          title="capítulo anterior">Call Graph Introspection</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="asyncio-future.html"
                          title="próximo capítulo">Futures</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/asyncio-eventloop.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Contraer barra lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="asyncio-future.html" title="Futures"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="asyncio-graph.html" title="Call Graph Introspection"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >Comunicación en redes y entre procesos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="asyncio.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code> — Asynchronous I/O</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Bucle de eventos</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Derechos de autor</a> 2001 Python Software Foundation.
    <br>
    Ésta página tiene la licencia Python Software Foundation Versión 2.
    <br>
    Ejemplos, guías, y otro código en la documentación están bajo la licencia adicional Zero Clause BSD.
    <br>
    
      Ver <a href="/license.html">Historia y Licencia</a> para más información.<br>
    
    
    <br>

    La Python Software Foundation es una corporación sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor dona.</a>
<br>
    <br>
      Última actualización en oct 06, 2025 (04:51 UTC).
    
      <a href="/bugs.html">Encontraste un bug</a>?
    
    <br>

    Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a>8.2.3.
    </div>

  </body>
</html>