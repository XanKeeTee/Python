<!DOCTYPE html>

<html lang="es" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="importlib — La implementación de import" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/importlib.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Código fuente: Lib/importlib/__init__.py Introducción: El propósito del paquete importlib es triple: Uno es proveer la implementación de la declaración de import(y así, por extensión, el método__im..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.15/es/_images/social_previews/summary_library_importlib_b9d02863.png" />
<meta property="og:image:alt" content="Código fuente: Lib/importlib/__init__.py Introducción: El propósito del paquete importlib es triple: Uno es proveer la implementación de la declaración de import(y así, por extensión, el método__im..." />
<meta name="description" content="Código fuente: Lib/importlib/__init__.py Introducción: El propósito del paquete importlib es triple: Uno es proveer la implementación de la declaración de import(y así, por extensión, el método__im..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>importlib — La implementación de import &#8212; documentación de Python - 3.15.0a0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=bf1f176d"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f85f4cfb"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.15.0a0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Derechos de autor" href="../copyright.html" />
    <link rel="next" title="importlib.resources – Package resource reading, opening and access" href="importlib.resources.html" />
    <link rel="prev" title="runpy — Localización y ejecución de módulos Python" href="runpy.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/library/importlib.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menú">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — La implementación de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a><ul>
<li><a class="reference internal" href="#introduction">Introducción</a></li>
<li><a class="reference internal" href="#functions">Funciones</a></li>
<li><a class="reference internal" href="#module-importlib.abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code> – Clases base abstractas relacionadas con la importación</a></li>
<li><a class="reference internal" href="#module-importlib.machinery"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code> – Importadores y enlaces de ruta</a></li>
<li><a class="reference internal" href="#module-importlib.util"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code> – Código de utilidad para importadores</a></li>
<li><a class="reference internal" href="#examples">Ejemplos</a><ul>
<li><a class="reference internal" href="#importing-programmatically">Importar programáticamente</a></li>
<li><a class="reference internal" href="#checking-if-a-module-can-be-imported">Comprobando si se puede importar un módulo</a></li>
<li><a class="reference internal" href="#importing-a-source-file-directly">Importar un archivo fuente directamente</a></li>
<li><a class="reference internal" href="#implementing-lazy-imports">Implementar importaciones diferidas</a></li>
<li><a class="reference internal" href="#setting-up-an-importer">Configurar un importador</a></li>
<li><a class="reference internal" href="#approximating-importlib-import-module">Aproximando <code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="runpy.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code> — Localización y ejecución de módulos Python</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="importlib.resources.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code> – Package resource reading, opening and access</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/importlib.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="importlib.resources.html" title="importlib.resources – Package resource reading, opening and access"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="runpy — Localización y ejecución de módulos Python"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" accesskey="U">Importando módulos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — La implementación de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-importlib">
<span id="importlib-the-implementation-of-import"></span><h1 class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — La implementación de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code><a class="headerlink" href="#module-importlib" title="Link to this heading">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.1.</span></p>
</div>
<p class="translated"><strong>Código fuente:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/main/Lib/importlib/__init__.py">Lib/importlib/__init__.py</a></p>
<hr class="docutils" />
<section id="introduction">
<h2 class="translated">Introducción<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p class="translated">El propósito del paquete <a class="reference internal" href="#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> es triple:</p>
<p class="translated">Uno es proveer la implementación de la declaración de <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> (y así, por extensión, el método <a class="reference internal" href="functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> ) en el código fuente de Python. Esto provee una implementación de la <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> la cual es compatible con cualquier intérprete de Python. También provee una implementación que es más fácil de comprender que una implementada en un lenguajes que no es Python.</p>
<p class="translated">Dos, los componentes incluidos para implementar <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>  están expuestos en este paquete para que sea más fácil para los usuarios crear sus propios objetos (conocidos de forma genérica como <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>) para participar en el proceso de importación.</p>
<p class="translated">Tres, el paquete contiene módulos exponiendo funcionalidad adicional para administrar aspectos de paquetes de Python:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="importlib.metadata.html#module-importlib.metadata" title="importlib.metadata: Accessing package metadata"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.metadata</span></code></a> presenta acceso a metadatos de distribuciones de terceros.</p></li>
<li><p class="translated"><a class="reference internal" href="importlib.resources.html#module-importlib.resources" title="importlib.resources: Package resource reading, opening, and access"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code></a> provee rutinas para acceder a <em>recursos</em> que no son código de paquetes de Python.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><a class="reference internal" href="../reference/simple_stmts.html#import"><span class="std std-ref">La declaración import</span></a></dt><dd><p class="translated">La referencia en el lenguaje para la declaración de <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>.</p>
</dd>
<dt class="translated"><a class="reference external" href="https://www.python.org/doc/essays/packages/">Especificaciones de paquetes</a></dt><dd><p class="translated">Especificaciones originales de los paquetes. Algunas semánticas han cambiado desde que este documento fue escrito (ejemplo, redirección de acuerdo a <code class="docutils literal notranslate"><span class="pre">None</span></code> en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>).</p>
</dd>
<dt class="translated">La función <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a></dt><dd><p class="translated">La declaración de <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> es una decoración sintáctica para esta función.</p>
</dd>
<dt class="translated"><a class="reference internal" href="sys_path_init.html#sys-path-init"><span class="std std-ref">La inicialización de la ruta de búsqueda de módulo de sys.path</span></a></dt><dd><p class="translated">La inicialización de <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>.</p>
</dd>
<dt class="translated"><span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0235/"><strong>PEP 235</strong></a></dt><dd><p class="translated">Importar en sistemas que no distinguen entre mayúsculas y minúsculas</p>
</dd>
<dt class="translated"><span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0263/"><strong>PEP 263</strong></a></dt><dd><p class="translated">Definiendo las codificaciones del código fuente de Python</p>
</dd>
<dt class="translated"><span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a></dt><dd><p class="translated">Nuevos ganchos de importación</p>
</dd>
<dt class="translated"><span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0328/"><strong>PEP 328</strong></a></dt><dd><p class="translated">Importaciones: Multilíneas, y absolutos/relativos</p>
</dd>
<dt class="translated"><span class="target" id="index-4"></span><a class="pep reference external" href="https://peps.python.org/pep-0366/"><strong>PEP 366</strong></a></dt><dd><p class="translated">Importaciones relativas, explicitas, del módulo principal</p>
</dd>
<dt class="translated"><span class="target" id="index-5"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a></dt><dd><p class="translated">Paquetes implícitos en el espacio de nombres</p>
</dd>
<dt class="translated"><span class="target" id="index-6"></span><a class="pep reference external" href="https://peps.python.org/pep-0451/"><strong>PEP 451</strong></a></dt><dd><p class="translated">Un tipo de ModuleSpec para el sistema de importación</p>
</dd>
<dt class="translated"><span class="target" id="index-7"></span><a class="pep reference external" href="https://peps.python.org/pep-0488/"><strong>PEP 488</strong></a></dt><dd><p class="translated">Eliminación de archivos PYO</p>
</dd>
<dt class="translated"><span class="target" id="index-8"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a></dt><dd><p class="translated">Inicialización de extensión de módulo en múltiples fases</p>
</dd>
<dt class="translated"><span class="target" id="index-9"></span><a class="pep reference external" href="https://peps.python.org/pep-0552/"><strong>PEP 552</strong></a></dt><dd><p class="translated">Pycs determinísticos</p>
</dd>
<dt class="translated"><span class="target" id="index-10"></span><a class="pep reference external" href="https://peps.python.org/pep-3120/"><strong>PEP 3120</strong></a></dt><dd><p class="translated">Usando UTF-8 como la codificación fuente por defecto</p>
</dd>
<dt class="translated"><span class="target" id="index-11"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a></dt><dd><p class="translated">Repositorio de directorios PYC</p>
</dd>
</dl>
</div>
</section>
<section id="functions">
<h2 class="translated">Funciones<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="importlib.__import__">
<span class="sig-prename descclassname"><span class="pre">importlib.</span></span><span class="sig-name descname"><span class="pre">__import__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fromlist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.__import__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una implementación de la función <a class="reference internal" href="functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> incorporada.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">La importación programática los módulos debe usar <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> en lugar de esta función.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.import_module">
<span class="sig-prename descclassname"><span class="pre">importlib.</span></span><span class="sig-name descname"><span class="pre">import_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">package</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.import_module" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Importar un módulo. El argumento llamado <em>name</em> especifica qué módulo importar en términos absolutos o relativos (ejemplo, puede ser <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code> o <code class="docutils literal notranslate"><span class="pre">..mod</span></code>). Si el nombre fuera especificado en términos relativos, entonces el argumento llamado <em>package</em> debe ser igual al nombre del paquete que será el ancla para resolver el nombre del paquete (ejemplo <code class="docutils literal notranslate"><span class="pre">import_module('..mod',</span> <span class="pre">'pkg.subpkg')</span></code> importará <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>).</p>
<p class="translated">La función <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> actúa como un envoltorio simplificador alrededor de <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.__import__()</span></code></a>.  Esto quiere decir que las semánticas de la función son derivadas de <a class="reference internal" href="#importlib.__import__" title="importlib.__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.__import__()</span></code></a>. La diferencia más importante entre las dos funciones es que <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> retorna el paquete especificado o el módulo (ejemplo <code class="docutils literal notranslate"><span class="pre">pkg.mod</span></code>), mientras que <a class="reference internal" href="functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> retorna el paquete o módulo del nivel superior (ejemplo <code class="docutils literal notranslate"><span class="pre">pkg</span></code>).</p>
<p class="translated">Si está importando dinámicamente un módulo que se creó desde que el intérprete comenzó la ejecución (por ejemplo, creó un archivo fuente de Python), es posible que deba llamar a <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">invalidate_caches()</span></code></a> para que el nuevo módulo sea detectado por el sistema de importación.</p>
<p class="untranslated">If the module cannot be imported, <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> will raise
<a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> or an appropriate subclass like
<a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>Paquetes padres son importados automáticamente.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.invalidate_caches">
<span class="sig-prename descclassname"><span class="pre">importlib.</span></span><span class="sig-name descname"><span class="pre">invalidate_caches</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.invalidate_caches" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Invalide los cache internos de ubicadores encontrados en <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>.Si un buscador implementa <code class="docutils literal notranslate"><span class="pre">invalidate_caches()</span></code> entonces será llamado para realizar la invalidación.Esta función debe ser llamada si cualquier módulo ha sido creado/instalado mientras tu programa esta siendo ejecutado para garantizar que todos los buscadores noten la existencia del nuevo módulo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Paquetes de espacio de nombres creados/instalados en una ubicación <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> distinta después de que el mismo espacio de nombres fue importado son notados.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.reload">
<span class="sig-prename descclassname"><span class="pre">importlib.</span></span><span class="sig-name descname"><span class="pre">reload</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.reload" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Recarga un <em>modulo</em> previamente importado. El argumento debe ser un objeto módulo, por lo que debe haber sido importado exitosamente. Esto es útil cuando has editado el código fuente de un archivo usando un editor externo y deseas probar la nueva versión sin abandonar el interprete de Python. El valor retornado es el objeto módulo (que puede ser diferente si la reimportación crea un nuevo objeto en <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>).</p>
<p class="translated">Cuando <a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a> es ejecutada:</p>
<ul class="simple">
<li><p class="translated">El código de un módulo de Python es recompilado y el código del módulo reejecutado, definiendo un nuevo conjunto de objetos que son asignados a los nombres de los módulos en el diccionario, reusando el <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> que originalmente carga los módulos. El método <code class="docutils literal notranslate"><span class="pre">init</span></code> de los módulos de extension no es llamado de nuevo.</p></li>
<li><p class="translated">Al igual que con todos los demás objetos en Python, los objetos antiguos solo se recuperan después de que sus recuentos de referencias caen a cero.</p></li>
<li><p class="translated">Los nombres en el espacio de nombres del módulo se actualizan para señalar cualquier objeto nuevo o modificado.</p></li>
<li><p class="translated">Otras referencias a los objetos antiguos (como los nombres externos al módulo) no se vuelven a vincular para hacer referencia a los nuevos objetos y deben actualizarse en cada espacio de nombres donde se produzcan si se desea.</p></li>
</ul>
<p class="translated">Hay una serie de otras advertencias:</p>
<p class="translated">Cuando se vuelve a cargar un módulo, se conserva su diccionario (que contiene las variables globales del módulo). Las redefiniciones de nombres anularán las antiguas definiciones, por lo que generalmente esto no es un problema. Si la nueva versión de un módulo no define un nombre que fue definido por la versión anterior, la definición anterior permanece. Esta característica se puede utilizar en beneficio del módulo si mantiene una tabla global o caché de objetos — con una declaración <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> puede probar la presencia de la tabla y omitir su inicialización si lo desea:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">cache</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p class="translated">Por lo general, no es muy útil recargar módulos integrados o cargados dinámicamente. No se recomienda recargar <a class="reference internal" href="sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>, <a class="reference internal" href="__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a>, <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> y otros módulos clave. En muchos casos, los módulos de extensión no están diseñados para inicializarse más de una vez y pueden fallar de manera arbitraria cuando se vuelven a cargar.</p>
<p class="translated">Si un módulo importa objetos de otro módulo usando <a class="reference internal" href="../reference/simple_stmts.html#from"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code></a> … <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> …, al llamar a <a class="reference internal" href="#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a> para el otro módulo no redefine los objetos importados de él — una forma de evitar esto es volver a ejecutar la instrucción <code class="xref std std-keyword docutils literal notranslate"><span class="pre">from</span></code>, otra es usar <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> y nombres calificados (<em>module.name</em>) en su lugar.</p>
<p class="translated">Si un módulo crea instancias de una clase, volver a cargar el módulo que define la clase no afecta las definiciones de método de las instancias — continúan usando la definición de clase anterior. Lo mismo ocurre con las clases derivadas.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span><a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> se lanza cuando el módulo que se está recargando carece de <a class="reference internal" href="#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p class="untranslated">This function is not thread-safe. Calling it from multiple threads can result
in unexpected behavior. It’s recommended to use the <a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a>
or other synchronization primitives for thread-safe module reloading.</p>
</div>
</dd></dl>

</section>
<section id="module-importlib.abc">
<span id="importlib-abc-abstract-base-classes-related-to-import"></span><h2 class="translated"><a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> – Clases base abstractas relacionadas con la importación<a class="headerlink" href="#module-importlib.abc" title="Link to this heading">¶</a></h2>
<p class="translated"><strong>Código fuente:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/main/Lib/importlib/abc.py">Lib/importlib/abc.py</a></p>
<hr class="docutils" />
<p class="translated">El módulo <a class="reference internal" href="#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> contiene todas las clases base abstractas principales utilizadas por <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>. También se proporcionan algunas subclases de las clases base abstractas centrales para ayudar a implementar los ABC centrales.</p>
<p class="translated">Jerarquía ABC:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">object</span>
 <span class="o">+--</span> <span class="n">MetaPathFinder</span>
 <span class="o">+--</span> <span class="n">PathEntryFinder</span>
 <span class="o">+--</span> <span class="n">Loader</span>
      <span class="o">+--</span> <span class="n">ResourceLoader</span> <span class="o">--------+</span>
      <span class="o">+--</span> <span class="n">InspectLoader</span>          <span class="o">|</span>
           <span class="o">+--</span> <span class="n">ExecutionLoader</span> <span class="o">--+</span>
                                 <span class="o">+--</span> <span class="n">FileLoader</span>
                                 <span class="o">+--</span> <span class="n">SourceLoader</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.MetaPathFinder">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">MetaPathFinder</span></span><a class="headerlink" href="#importlib.abc.MetaPathFinder" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una clase base abstracta que representa <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>No longer a subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">Finder</span></code>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.MetaPathFinder.find_spec">
<span class="sig-name descname"><span class="pre">find_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.find_spec" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">An abstract method for finding a <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> for
the specified module.  If this is a top-level import, <em>path</em> will
be <code class="docutils literal notranslate"><span class="pre">None</span></code>.  Otherwise, this is a search for a subpackage or
module and <em>path</em> will be the value of <a class="reference internal" href="../reference/datamodel.html#module.__path__" title="module.__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> from the
parent package. If a spec cannot be found, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.
When passed in, <code class="docutils literal notranslate"><span class="pre">target</span></code> is a module object that the finder may
use to make a more educated guess about what spec to return.
<a class="reference internal" href="#importlib.util.spec_from_loader" title="importlib.util.spec_from_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.spec_from_loader()</span></code></a> may be useful for implementing
concrete <code class="docutils literal notranslate"><span class="pre">MetaPathFinders</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.MetaPathFinder.invalidate_caches">
<span class="sig-name descname"><span class="pre">invalidate_caches</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.MetaPathFinder.invalidate_caches" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Un método opcional que, cuando se llama, debería invalidar cualquier caché interno utilizado por el buscador. Utilizado por <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.invalidate_caches()</span></code></a> al invalidar los cachés de todos los buscadores en <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> when called instead of <a class="reference internal" href="constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.PathEntryFinder">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">PathEntryFinder</span></span><a class="headerlink" href="#importlib.abc.PathEntryFinder" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una clase base abstracta que representa un <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">buscador de entradas de ruta</span></a>. Aunque tiene algunas similitudes con <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaPathFinder</span></code></a>, <code class="docutils literal notranslate"><span class="pre">PathEntryFinder</span></code> está diseñado para usarse solo dentro del subsistema de importación basado en rutas proporcionado por <a class="reference internal" href="#importlib.machinery.PathFinder" title="importlib.machinery.PathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>No longer a subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">Finder</span></code>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.PathEntryFinder.find_spec">
<span class="sig-name descname"><span class="pre">find_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.find_spec" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Un método abstracto para encontrar un <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> para el módulo especificado. El buscador buscará el módulo solo dentro del <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">path entry</span></a> a la que está asignado. Si no se puede encontrar una especificación, se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>. Cuando se pasa, <code class="docutils literal notranslate"><span class="pre">target</span></code> es un objeto de módulo que el buscador puede usar para hacer una suposición más informada sobre qué especificación retornar. <a class="reference internal" href="#importlib.util.spec_from_loader" title="importlib.util.spec_from_loader"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.spec_from_loader()</span></code></a> puede ser útil para implementar <code class="docutils literal notranslate"><span class="pre">PathEntryFinders</span></code> concretos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.PathEntryFinder.invalidate_caches">
<span class="sig-name descname"><span class="pre">invalidate_caches</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Un método opcional que, cuando se llama, debería invalidar cualquier caché interno utilizado por el buscador. Usado por <a class="reference internal" href="#importlib.machinery.PathFinder.invalidate_caches" title="importlib.machinery.PathFinder.invalidate_caches"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder.invalidate_caches()</span></code></a> al invalidar las cachés de todos los buscadores en caché.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.Loader">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">Loader</span></span><a class="headerlink" href="#importlib.abc.Loader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una clase base abstracta para un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>. Consulte <span class="target" id="index-39"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> para obtener la definición exacta de cargador.</p>
<p class="translated">Los cargadores que deseen admitir la lectura de recursos deben implementar un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_resource_reader()</span></code> según lo especificado por <a class="reference internal" href="#importlib.abc.ResourceReader" title="importlib.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ResourceReader</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Introducido el método opcional <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_resource_reader()</span></code>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Loader.create_module">
<span class="sig-name descname"><span class="pre">create_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.create_module" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Un método que retorna el objeto de módulo que se utilizará al importar un módulo. Este método puede retornar <code class="docutils literal notranslate"><span class="pre">None</span></code>, lo que indica que se debe llevar a cabo la semántica de creación de módulos predeterminada.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Este método ya no es opcional cuando se defina <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Loader.exec_module">
<span class="sig-name descname"><span class="pre">exec_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.exec_module" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Un método abstracto que ejecuta el módulo en su propio espacio de nombres cuando se importa o se vuelve a cargar un módulo. El módulo ya debería estar inicializado cuando se llama a <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>. Cuando existe este método, se debe definir <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span><a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> también debe definirse.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Loader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Loader.load_module" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Un método heredado para cargar un módulo. Si el módulo no se puede cargar, se lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>; de lo contrario, se retorna el módulo cargado.</p>
<p class="untranslated">If the requested module already exists in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, that
module should be used and reloaded.
Otherwise the loader should create a new module and insert it into
<a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> before any loading begins, to prevent recursion
from the import.  If the loader inserted a module and the load fails, it
must be removed by the loader from <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>; modules already
in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> before the loader began execution should be left
alone.</p>
<p class="translated">El cargador debe establecer varios atributos en el módulo (tenga en cuenta que algunos de estos atributos pueden cambiar cuando se recarga un módulo):</p>
<ul class="simple">
<li><p class="untranslated"><a class="reference internal" href="../reference/datamodel.html#module.__name__" title="module.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__name__</span></code></a></p></li>
<li><p class="untranslated"><a class="reference internal" href="../reference/datamodel.html#module.__file__" title="module.__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__file__</span></code></a></p></li>
<li><p class="untranslated"><a class="reference internal" href="../reference/datamodel.html#module.__cached__" title="module.__cached__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__cached__</span></code></a> <em>(deprecated)</em></p></li>
<li><p class="untranslated"><a class="reference internal" href="../reference/datamodel.html#module.__path__" title="module.__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__path__</span></code></a></p></li>
<li><p class="untranslated"><a class="reference internal" href="../reference/datamodel.html#module.__package__" title="module.__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__package__</span></code></a> <em>(deprecated)</em></p></li>
<li><p class="untranslated"><a class="reference internal" href="../reference/datamodel.html#module.__loader__" title="module.__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__loader__</span></code></a> <em>(deprecated)</em></p></li>
</ul>
<p class="translated">Cuando <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> está disponible, se proporciona una funcionalidad compatible con versiones anteriores.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> cuando se llama en lugar de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>. Funcionalidad proporcionada cuando <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> está disponible.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified removed">Deprecated since version 3.4, removed in version 3.15: </span>La API recomendada para cargar un módulo es <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> (y <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>). Los cargadores deberían implementarlo en lugar de <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code></a>. La maquinaria de importación se encarga de todas las demás responsabilidades de <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code></a> cuando se implementa <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.ResourceLoader">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">ResourceLoader</span></span><a class="headerlink" href="#importlib.abc.ResourceLoader" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated"><em>Superseded by TraversableResources</em></p>
<blockquote>
<div><p class="translated">Una clase base abstracta para un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> que implementa el protocolo opcional <span class="target" id="index-40"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> para cargar recursos arbitrarios desde el back-end de almacenamiento.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.7: </span>This ABC is deprecated in favour of supporting resource loading
through <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.TraversableResources" title="importlib.resources.abc.TraversableResources"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.TraversableResources</span></code></a>.
This class exists for backwards compatibility only with other ABCs in
this module.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.ResourceLoader.get_data">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceLoader.get_data" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p class="untranslated">An abstract method to return the bytes for the data located at <em>path</em>.
Loaders that have a file-like storage back-end
that allows storing arbitrary data
can implement this abstract method to give direct access
to the data stored. <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> is to be raised if the <em>path</em> cannot
be found. The <em>path</em> is expected to be constructed using a module’s
<a class="reference internal" href="../reference/datamodel.html#module.__file__" title="module.__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> attribute or an item from a package’s
<a class="reference internal" href="../reference/datamodel.html#module.__path__" title="module.__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</div></blockquote>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">InspectLoader</span></span><a class="headerlink" href="#importlib.abc.InspectLoader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una clase base abstracta para un <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> que implementa el protocolo opcional <span class="target" id="index-41"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> para cargadores que inspeccionan módulos.</p>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.get_code">
<span class="sig-name descname"><span class="pre">get_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.get_code" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna el objeto código para un módulo, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si el módulo no tiene un objeto código (como sería el caso, por ejemplo, para un módulo integrado). Lanza un <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> si el cargador no puede encontrar el módulo solicitado.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Si bien el método tiene una implementación predeterminada, se sugiere que se anule si es posible para mejorar el rendimiento.</p>
</div>
<div class="versionchanged" id="index-15">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Ya no es un método abstracto y se proporciona una implementación concreta.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.get_source">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.get_source" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p class="translated">Un método abstracto para retornar la fuente de un módulo. Se retorna como una cadena de caracteres de texto usando <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a>, traduciendo todos los separadores de línea reconocidos en caracteres <code class="docutils literal notranslate"><span class="pre">'</span>
<span class="pre">'</span></code>. Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> si no hay una fuente disponible (por ejemplo, un módulo integrado). Lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> si el cargador no puede encontrar el módulo especificado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.is_package">
<span class="sig-name descname"><span class="pre">is_package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.is_package" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Un método opcional para retornar un valor verdadero si el módulo es un paquete, un valor falso en caso contrario. Se lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> si el <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">cargador</span></a> no puede encontrar el módulo.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.source_to_code">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">source_to_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'&lt;string&gt;'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.source_to_code" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Cree un objeto de código a partir de la fuente de Python.</p>
<p class="translated">El argumento <em>data</em> puede ser cualquier cosa que admita la función <a class="reference internal" href="functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> (es decir, cadena de caracteres o bytes). El argumento <em>path</em> debe ser la «ruta» de donde se originó el código fuente, que puede ser un concepto abstracto (por ejemplo, ubicación en un archivo zip).</p>
<p class="translated">Con el objeto de código subsiguiente, uno puede ejecutarlo en un módulo ejecutando <code class="docutils literal notranslate"><span class="pre">exec(code,</span> <span class="pre">module.__dict__)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Hace el método estático.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.exec_module">
<span class="sig-name descname"><span class="pre">exec_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.exec_module" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Implementación de <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.InspectLoader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.InspectLoader.load_module" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Implementación de <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.load_module()</span></code></a>.</p>
<div class="deprecated-removed">
<p><span class="versionmodified removed">Deprecated since version 3.4, removed in version 3.15: </span>use <a class="reference internal" href="#importlib.abc.InspectLoader.exec_module" title="importlib.abc.InspectLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.ExecutionLoader">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">ExecutionLoader</span></span><a class="headerlink" href="#importlib.abc.ExecutionLoader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una clase base abstracta que hereda de <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">InspectLoader</span></code></a> que, cuando se implementa, ayuda a que un módulo se ejecute como un script. El ABC representa un protocolo opcional <span class="target" id="index-42"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.ExecutionLoader.get_filename">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_filename</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ExecutionLoader.get_filename" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p class="untranslated">An abstract method that is to return the value of
<a class="reference internal" href="../reference/datamodel.html#module.__file__" title="module.__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> for the specified module. If no path is
available, <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> is raised.</p>
<p class="translated">Si el código fuente está disponible, entonces el método debe devolver la ruta al archivo fuente, independientemente de si se utilizó un código de bytes para cargar el módulo.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.FileLoader">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">FileLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una clase base abstracta que hereda de <a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceLoader</span></code></a> y <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExecutionLoader</span></code></a>, proporcionando implementaciones concretas de <a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResourceLoader.get_data()</span></code></a> y <a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a>.</p>
<p class="translated">El argumento <em>fullname</em> es un nombre completamente resuelto del módulo que el cargador debe manejar. El argumento <em>path</em> es la ruta al archivo del módulo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.abc.FileLoader.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#importlib.abc.FileLoader.name" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El nombre del módulo que puede manejar el cargador.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.abc.FileLoader.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="#importlib.abc.FileLoader.path" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Ruta al archivo del módulo.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.FileLoader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.load_module" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Llama a super’s <code class="docutils literal notranslate"><span class="pre">load_module()</span></code>.</p>
<div class="deprecated-removed">
<p><span class="versionmodified removed">Deprecated since version 3.4, removed in version 3.15: </span>Utilice <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.FileLoader.get_filename">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_filename</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.get_filename" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna <a class="reference internal" href="#importlib.abc.FileLoader.path" title="importlib.abc.FileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.FileLoader.get_data">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.FileLoader.get_data" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Lee <em>path</em> como un archivo binario y devuelve los bytes de él.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">SourceLoader</span></span><a class="headerlink" href="#importlib.abc.SourceLoader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una clase base abstracta para implementar la carga de archivos fuente (y opcionalmente bytecode). La clase hereda tanto de <a class="reference internal" href="#importlib.abc.ResourceLoader" title="importlib.abc.ResourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ResourceLoader</span></code></a> como de <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExecutionLoader</span></code></a>, lo que requiere la implementación de:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="#importlib.abc.ResourceLoader.get_data" title="importlib.abc.ResourceLoader.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ResourceLoader.get_data()</span></code></a></p></li>
<li><dl class="simple">
<dt class="translated"><a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a></dt><dd><p class="translated">Solo debe devolver la ruta al archivo de origen; la carga sin fuente no es compatible.</p>
</dd>
</dl>
</li>
</ul>
<p class="translated">Los métodos abstractos definidos por esta clase son para agregar soporte de archivo de código de bytes opcional. No implementar estos métodos opcionales (o hacer que se lance <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>) hace que el cargador solo funcione con el código fuente. La implementación de los métodos permite que el cargador trabaje con archivos fuente <em>y</em> código de bytes; no permite la carga <em>sin fuente</em> donde solo se proporciona un código de bytes. Los archivos de código de bytes son una optimización para acelerar la carga al eliminar el paso de análisis del compilador de Python, por lo que no se expone ninguna API específica de código de bytes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.path_stats">
<span class="sig-name descname"><span class="pre">path_stats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.path_stats" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Método abstracto opcional que devuelve un <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> que contiene metadatos sobre la ruta especificada. Las claves de diccionario admitidas son:</p>
<ul class="simple">
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">'mtime'</span></code> (obligatorio): un número entero o de punto flotante que representa la hora de modificación del código fuente;</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">'size'</span></code> (opcional): el tamaño en bytes del código fuente.</p></li>
</ul>
<p class="translated">Cualquier otra clave del diccionario se ignora para permitir futuras extensiones. Si no se puede manejar la ruta, se genera <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.path_mtime">
<span class="sig-name descname"><span class="pre">path_mtime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.path_mtime" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Método abstracto opcional que retorna la hora de modificación de la ruta especificada.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.3: </span>Este método está obsoleto en favor de <a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">path_stats()</span></code></a>. No tiene que implementarlo, pero aún está disponible para fines de compatibilidad. Lanza <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> si la ruta no se puede manejar.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Lanza <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> en vez de <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.set_data">
<span class="sig-name descname"><span class="pre">set_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.set_data" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Método abstracto opcional que escribe los bytes especificados en una ruta de archivo. Los directorios intermedios que no existan se crearán automáticamente.</p>
<p class="untranslated">When writing to the path fails because the path is read-only
(<a class="reference internal" href="errno.html#errno.EACCES" title="errno.EACCES"><code class="xref py py-const docutils literal notranslate"><span class="pre">errno.EACCES</span></code></a>/<a class="reference internal" href="exceptions.html#PermissionError" title="PermissionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PermissionError</span></code></a>), do not propagate the
exception.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Ya no lanza <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> cuando se llama.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.get_code">
<span class="sig-name descname"><span class="pre">get_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.get_code" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Implementación concreta de <a class="reference internal" href="#importlib.abc.InspectLoader.get_code" title="importlib.abc.InspectLoader.get_code"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_code()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.exec_module">
<span class="sig-name descname"><span class="pre">exec_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.exec_module" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Implementación concreta de <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.load_module" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Implementación concreta de <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.load_module()</span></code></a>.</p>
<div class="deprecated-removed">
<p><span class="versionmodified removed">Deprecated since version 3.4, removed in version 3.15: </span>Utilice <a class="reference internal" href="#importlib.abc.SourceLoader.exec_module" title="importlib.abc.SourceLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.get_source">
<span class="sig-name descname"><span class="pre">get_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.get_source" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Implementación concreta de <a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_source()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.SourceLoader.is_package">
<span class="sig-name descname"><span class="pre">is_package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.SourceLoader.is_package" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Implementación concreta de <a class="reference internal" href="#importlib.abc.InspectLoader.is_package" title="importlib.abc.InspectLoader.is_package"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.is_package()</span></code></a>. Se determina que un módulo es un paquete si su ruta de archivo (proporcionada por <a class="reference internal" href="#importlib.abc.ExecutionLoader.get_filename" title="importlib.abc.ExecutionLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ExecutionLoader.get_filename()</span></code></a>) es un archivo llamado <code class="docutils literal notranslate"><span class="pre">__init__</span></code> cuando se elimina la extensión del archivo <strong>y</strong> el nombre del módulo sí lo hace no termina en <code class="docutils literal notranslate"><span class="pre">__init__</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.ResourceReader">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">ResourceReader</span></span><a class="headerlink" href="#importlib.abc.ResourceReader" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated"><em>Superseded by TraversableResources</em></p>
<p class="untranslated">An <a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a> to provide the ability to read
<em>resources</em>.</p>
<p class="untranslated">From the perspective of this ABC, a <em>resource</em> is a binary
artifact that is shipped within a package. Typically this is
something like a data file that lives next to the <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>
file of the package. The purpose of this class is to help abstract
out the accessing of such data files so that it does not matter if
the package and its data file(s) are stored e.g. in a zip file
versus on the file system.</p>
<p class="untranslated">For any of methods of this class, a <em>resource</em> argument is
expected to be a <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a> which represents
conceptually just a file name. This means that no subdirectory
paths should be included in the <em>resource</em> argument. This is
because the location of the package the reader is for, acts as the
«directory». Hence the metaphor for directories and file
names is packages and resources, respectively. This is also why
instances of this class are expected to directly correlate to
a specific package (instead of potentially representing multiple
packages or a module).</p>
<p class="untranslated">Loaders that wish to support resource reading are expected to
provide a method called <code class="docutils literal notranslate"><span class="pre">get_resource_reader(fullname)</span></code> which
returns an object implementing this ABC’s interface. If the module
specified by fullname is not a package, this method should return
<a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>. An object compatible with this ABC should only be
returned when the specified module is a package.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified removed">Deprecated since version 3.12, removed in version 3.14: </span>Use <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.TraversableResources" title="importlib.resources.abc.TraversableResources"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.TraversableResources</span></code></a> instead.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.ResourceReader.open_resource">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">open_resource</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">resource</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.open_resource" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p class="untranslated">Returns an opened, <a class="reference internal" href="../glossary.html#term-file-like-object"><span class="xref std std-term">file-like object</span></a> for binary reading
of the <em>resource</em>.</p>
<p class="untranslated">If the resource cannot be found, <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a> is
raised.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.ResourceReader.resource_path">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">resource_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">resource</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.resource_path" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p class="untranslated">Returns the file system path to the <em>resource</em>.</p>
<p class="untranslated">If the resource does not concretely exist on the file system,
raise <a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a>.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.ResourceReader.is_resource">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_resource</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.is_resource" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p class="untranslated">Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the named <em>name</em> is considered a resource.
<a class="reference internal" href="exceptions.html#FileNotFoundError" title="FileNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileNotFoundError</span></code></a> is raised if <em>name</em> does not exist.</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.ResourceReader.contents">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">contents</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.ResourceReader.contents" title="Link to this definition">¶</a></dt>
<dd><blockquote>
<div><p class="untranslated">Returns an <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> of strings over the contents of
the package. Do note that it is not required that all names
returned by the iterator be actual resources, e.g. it is
acceptable to return names for which <a class="reference internal" href="#importlib.abc.ResourceReader.is_resource" title="importlib.abc.ResourceReader.is_resource"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_resource()</span></code></a> would
be false.</p>
<p class="untranslated">Allowing non-resource names to be returned is to allow for
situations where how a package and its resources are stored
are known a priori and the non-resource names would be useful.
For instance, returning subdirectory names is allowed so that
when it is known that the package and resources are stored on
the file system then those subdirectory names can be used
directly.</p>
<p class="untranslated">The abstract method returns an iterable of no items.</p>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.Traversable">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">Traversable</span></span><a class="headerlink" href="#importlib.abc.Traversable" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">An object with a subset of <a class="reference internal" href="pathlib.html#pathlib.Path" title="pathlib.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> methods suitable for
traversing directories and opening files.</p>
<p class="untranslated">For a representation of the object on the file-system, use
<a class="reference internal" href="importlib.resources.html#importlib.resources.as_file" title="importlib.resources.as_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.resources.as_file()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified removed">Deprecated since version 3.12, removed in version 3.14: </span>Use <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.Traversable" title="importlib.resources.abc.Traversable"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.Traversable</span></code></a> instead.</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.abc.Traversable.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#importlib.abc.Traversable.name" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Abstract. The base name of this object without any parent references.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Traversable.iterdir">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iterdir</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.iterdir" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Yield <code class="docutils literal notranslate"><span class="pre">Traversable</span></code> objects in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Traversable.is_dir">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_dir</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.is_dir" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">self</span></code> is a directory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Traversable.is_file">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_file</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.is_file" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">self</span></code> is a file.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Traversable.joinpath">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">joinpath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">child</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.joinpath" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return Traversable child in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Traversable.__truediv__">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">child</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.__truediv__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return <code class="docutils literal notranslate"><span class="pre">Traversable</span></code> child in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Traversable.open">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'r'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.open" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated"><em>mode</em> may be “r” or “rb” to open as text or binary. Return a handle
suitable for reading (same as <a class="reference internal" href="pathlib.html#pathlib.Path.open" title="pathlib.Path.open"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pathlib.Path.open</span></code></a>).</p>
<p class="untranslated">When opening as text, accepts encoding parameters such as those
accepted by <a class="reference internal" href="io.html#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOWrapper</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Traversable.read_bytes">
<span class="sig-name descname"><span class="pre">read_bytes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.read_bytes" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Read contents of <code class="docutils literal notranslate"><span class="pre">self</span></code> as bytes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.Traversable.read_text">
<span class="sig-name descname"><span class="pre">read_text</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.Traversable.read_text" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Read contents of <code class="docutils literal notranslate"><span class="pre">self</span></code> as text.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.abc.TraversableResources">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.abc.</span></span><span class="sig-name descname"><span class="pre">TraversableResources</span></span><a class="headerlink" href="#importlib.abc.TraversableResources" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">An abstract base class for resource readers capable of serving
the <a class="reference internal" href="importlib.resources.html#importlib.resources.files" title="importlib.resources.files"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.resources.files()</span></code></a> interface. Subclasses
<a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.ResourceReader" title="importlib.resources.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.ResourceReader</span></code></a> and provides
concrete implementations of the <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.ResourceReader" title="importlib.resources.abc.ResourceReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.ResourceReader</span></code></a>’s
abstract methods. Therefore, any loader supplying
<a class="reference internal" href="#importlib.abc.TraversableResources" title="importlib.abc.TraversableResources"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.TraversableResources</span></code></a> also supplies ResourceReader.</p>
<p class="untranslated">Loaders that wish to support resource reading are expected to
implement this interface.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified removed">Deprecated since version 3.12, removed in version 3.14: </span>Use <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.TraversableResources" title="importlib.resources.abc.TraversableResources"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.TraversableResources</span></code></a> instead.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.abc.TraversableResources.files">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">files</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.abc.TraversableResources.files" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Returns a <a class="reference internal" href="importlib.resources.abc.html#importlib.resources.abc.Traversable" title="importlib.resources.abc.Traversable"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.resources.abc.Traversable</span></code></a> object for the loaded
package.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-importlib.machinery">
<span id="importlib-machinery-importers-and-path-hooks"></span><h2 class="translated"><a class="reference internal" href="#module-importlib.machinery" title="importlib.machinery: Importers and path hooks"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code></a> – Importadores y enlaces de ruta<a class="headerlink" href="#module-importlib.machinery" title="Link to this heading">¶</a></h2>
<p class="translated"><strong>Código fuente:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/main/Lib/importlib/machinery.py">Lib/importlib/machinery.py</a></p>
<hr class="docutils" />
<p class="translated">Este módulo contiene varios objetos que ayudan <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> buscar y cargar módulos.</p>
<dl class="py data">
<dt class="sig sig-object py" id="importlib.machinery.SOURCE_SUFFIXES">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">SOURCE_SUFFIXES</span></span><a class="headerlink" href="#importlib.machinery.SOURCE_SUFFIXES" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una lista de cadenas de caracteres que representan los sufijos de archivo reconocidos para los módulos de origen.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="importlib.machinery.DEBUG_BYTECODE_SUFFIXES">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">DEBUG_BYTECODE_SUFFIXES</span></span><a class="headerlink" href="#importlib.machinery.DEBUG_BYTECODE_SUFFIXES" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una lista de cadenas que representan los sufijos de archivo para módulos de código de bytes no optimizados.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.5: </span>Use <a class="reference internal" href="#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-const docutils literal notranslate"><span class="pre">BYTECODE_SUFFIXES</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">OPTIMIZED_BYTECODE_SUFFIXES</span></span><a class="headerlink" href="#importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una lista de cadenas de caracteres que representan los sufijos de archivo para módulos de código de bytes optimizados.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.5: </span>Use <a class="reference internal" href="#importlib.machinery.BYTECODE_SUFFIXES" title="importlib.machinery.BYTECODE_SUFFIXES"><code class="xref py py-const docutils literal notranslate"><span class="pre">BYTECODE_SUFFIXES</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="importlib.machinery.BYTECODE_SUFFIXES">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">BYTECODE_SUFFIXES</span></span><a class="headerlink" href="#importlib.machinery.BYTECODE_SUFFIXES" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una lista de cadenas de caracteres que representan los sufijos de archivo reconocidos para los módulos de código de bytes (incluido el punto inicial).</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>El valor ya no depende de <code class="docutils literal notranslate"><span class="pre">__debug__</span></code>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="importlib.machinery.EXTENSION_SUFFIXES">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">EXTENSION_SUFFIXES</span></span><a class="headerlink" href="#importlib.machinery.EXTENSION_SUFFIXES" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una lista de cadenas de caracteres que representan los sufijos de archivo reconocidos para los módulos de extensión.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.machinery.all_suffixes">
<span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">all_suffixes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.all_suffixes" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna una lista combinada de cadenas de caracteres que representan todos los sufijos de archivo para módulos reconocidos por la maquinaria de importación estándar. Este es un ayudante para el código que simplemente necesita saber si una ruta del sistema de archivos potencialmente se refiere a un módulo sin necesidad de detalles sobre el tipo de módulo (por ejemplo, <a class="reference internal" href="inspect.html#inspect.getmodulename" title="inspect.getmodulename"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getmodulename()</span></code></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.BuiltinImporter">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">BuiltinImporter</span></span><a class="headerlink" href="#importlib.machinery.BuiltinImporter" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Un <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> para módulos integrados. Todos los módulos integrados conocidos se enumeran en <a class="reference internal" href="sys.html#sys.builtin_module_names" title="sys.builtin_module_names"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.builtin_module_names</span></code></a>. Esta clase implementa los ABC <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> y <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a>.</p>
<p class="translated">Esta clase solo define los métodos de clase para aliviar la necesidad de instanciación.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Como parte de <span class="target" id="index-43"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a>, el importador integrado ahora implementa <code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.create_module()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">Loader.exec_module()</span></code></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.FrozenImporter">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">FrozenImporter</span></span><a class="headerlink" href="#importlib.machinery.FrozenImporter" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Un <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> para módulos congelados. Esta clase implementa los ABC <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> y <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a>.</p>
<p class="translated">Esta clase solo define los métodos de clase para aliviar la necesidad de instanciación.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Métodos obtenidos <code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.WindowsRegistryFinder">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">WindowsRegistryFinder</span></span><a class="headerlink" href="#importlib.machinery.WindowsRegistryFinder" title="Link to this definition">¶</a></dt>
<dd><p class="translated"><a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a> para los módulos declarados en el registro de Windows. Esta clase implementa el <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> ABC.</p>
<p class="translated">Esta clase solo define los métodos de clase para aliviar la necesidad de instanciación.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.6: </span>Utilice la configuración de <a class="reference internal" href="site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> en su lugar. Es posible que las versiones futuras de Python no habiliten este buscador de forma predeterminada.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.PathFinder">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">PathFinder</span></span><a class="headerlink" href="#importlib.machinery.PathFinder" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Un <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">Finder</span></a> para <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> y atributos del paquete <code class="docutils literal notranslate"><span class="pre">__path__</span></code>. Esta clase implementa el <a class="reference internal" href="#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> ABC.</p>
<p class="translated">Esta clase solo define los métodos de clase para aliviar la necesidad de instanciación.</p>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.PathFinder.find_spec">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">find_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.find_spec" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Método de clase que intenta encontrar un <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> para el módulo especificado por <em>fullname</em> en <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> o, si está definido, en <em>path</em>. Para cada entrada de ruta que se busca, se comprueba <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>. Si se encuentra un objeto que no es falso, se utiliza como <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> para buscar el módulo que se está buscando. Si no se encuentra ninguna entrada en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>, entonces <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> se busca un buscador para la entrada de ruta y, si se encuentra, se almacena en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> junto con ser consultado sobre el módulo. Si nunca se encuentra ningún buscador, entonces <code class="docutils literal notranslate"><span class="pre">None</span></code> se almacena en el caché y se retorna.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Si el directorio de trabajo actual, representado por una cadena de caracteres vacía, ya no es válido, se retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> pero no se almacena ningún valor en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.PathFinder.invalidate_caches">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">invalidate_caches</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.PathFinder.invalidate_caches" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Llama <a class="reference internal" href="#importlib.abc.PathEntryFinder.invalidate_caches" title="importlib.abc.PathEntryFinder.invalidate_caches"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder.invalidate_caches()</span></code></a> en todos los buscadores almacenados en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> que definen el método. De lo contrario, las entradas en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> establecidas en <code class="docutils literal notranslate"><span class="pre">None</span></code> se eliminan.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Se eliminan las entradas de <code class="docutils literal notranslate"><span class="pre">None</span></code> en <a class="reference internal" href="sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>.</p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>Llama a objetos en <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> con el directorio de trabajo actual para <code class="docutils literal notranslate"><span class="pre">''</span></code> (es decir, la cadena de caracteres vacía).</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.FileFinder">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">FileFinder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">loader_details</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una implementación concreta de <a class="reference internal" href="#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> que almacena en caché los resultados del sistema de archivos.</p>
<p class="translated">El argumento <em>path</em> es el directorio que el buscador se encarga de buscar.</p>
<p class="translated">El argumento <em>loader_details</em> es un número variable de tuplas de 2 elementos, cada una de las cuales contiene un cargador y una secuencia de sufijos de archivo que el cargador reconoce. Se espera que los cargadores sean invocables que acepten dos argumentos del nombre del módulo y la ruta al archivo encontrado.</p>
<p class="translated">El buscador almacenará en caché el contenido del directorio según sea necesario, haciendo llamadas estadísticas para cada búsqueda de módulo para verificar que la caché no esté desactualizada. Debido a que la obsolescencia de la caché se basa en la granularidad de la información de estado del sistema operativo del sistema de archivos, existe una condición de carrera potencial de buscar un módulo, crear un nuevo archivo y luego buscar el módulo que representa el nuevo archivo. Si las operaciones ocurren lo suficientemente rápido como para ajustarse a la granularidad de las llamadas estadísticas, la búsqueda del módulo fallará. Para evitar que esto suceda, cuando cree un módulo dinámicamente, asegúrese de llamar a <a class="reference internal" href="#importlib.invalidate_caches" title="importlib.invalidate_caches"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.invalidate_caches()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.FileFinder.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="#importlib.machinery.FileFinder.path" title="Link to this definition">¶</a></dt>
<dd><p class="translated">La ruta en la que buscará el buscador.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.FileFinder.find_spec">
<span class="sig-name descname"><span class="pre">find_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.find_spec" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Intente encontrar la especificación para manejar <em>fullname</em> dentro de <a class="reference internal" href="#importlib.machinery.FileFinder.path" title="importlib.machinery.FileFinder.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.FileFinder.invalidate_caches">
<span class="sig-name descname"><span class="pre">invalidate_caches</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.invalidate_caches" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Borrar el caché interno.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.FileFinder.path_hook">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">path_hook</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">loader_details</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.FileFinder.path_hook" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A class method which returns a closure for use on <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>.
An instance of <a class="reference internal" href="#importlib.machinery.FileFinder" title="importlib.machinery.FileFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileFinder</span></code></a> is returned by the closure using the
path argument given to the closure directly and <em>loader_details</em>
indirectly.</p>
<p class="translated">Si el argumento del cierre no es un directorio existente, se lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">SourceFileLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una implementación concreta de <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader</span></code></a> subclasificando <a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.FileLoader</span></code></a> y proporcionando algunas implementaciones concretas de otros métodos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.name" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El nombre del módulo que manejará este cargador.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.path" title="Link to this definition">¶</a></dt>
<dd><p class="translated">La ruta al archivo de origen.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.is_package">
<span class="sig-name descname"><span class="pre">is_package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.is_package" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Devuelve <code class="docutils literal notranslate"><span class="pre">True</span></code> si <a class="reference internal" href="#importlib.machinery.SourceFileLoader.path" title="importlib.machinery.SourceFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a> parece ser para un paquete.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.path_stats">
<span class="sig-name descname"><span class="pre">path_stats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.path_stats" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Implementación concreta de <a class="reference internal" href="#importlib.abc.SourceLoader.path_stats" title="importlib.abc.SourceLoader.path_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.path_stats()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.set_data">
<span class="sig-name descname"><span class="pre">set_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.set_data" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Implementación concreta de <a class="reference internal" href="#importlib.abc.SourceLoader.set_data" title="importlib.abc.SourceLoader.set_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.set_data()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourceFileLoader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourceFileLoader.load_module" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Implementación concreta de <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> donde especificar el nombre del módulo a cargar es opcional.</p>
<div class="deprecated-removed">
<p><span class="versionmodified removed">Deprecated since version 3.6, removed in version 3.15: </span>Utilice <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">SourcelessFileLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una implementación concreta de <a class="reference internal" href="#importlib.abc.FileLoader" title="importlib.abc.FileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.FileLoader</span></code></a> que puede importar archivos de código de bytes (es decir, no existen archivos de código fuente).</p>
<p class="translated">Tenga en cuenta que el uso directo de archivos de código de bytes (y, por lo tanto, no de archivos de código fuente) impide que sus módulos sean utilizables por todas las implementaciones de Python o las nuevas versiones de Python que cambian el formato de código de bytes.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.name" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El nombre del módulo que manejará el cargador.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.path" title="Link to this definition">¶</a></dt>
<dd><p class="translated">La ruta al archivo de código de bytes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.is_package">
<span class="sig-name descname"><span class="pre">is_package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.is_package" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Determina si el módulo es un paquete basado en <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.get_code">
<span class="sig-name descname"><span class="pre">get_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.get_code" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna el objeto de código para <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.name" title="importlib.machinery.SourcelessFileLoader.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> creado a partir de <a class="reference internal" href="#importlib.machinery.SourcelessFileLoader.path" title="importlib.machinery.SourcelessFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.get_source">
<span class="sig-name descname"><span class="pre">get_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.get_source" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Devuelve <code class="docutils literal notranslate"><span class="pre">None</span></code> ya que los archivos de código de bytes no tienen fuente cuando se usa este cargador.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.SourcelessFileLoader.load_module">
<span class="sig-name descname"><span class="pre">load_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.SourcelessFileLoader.load_module" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p class="translated">Implementación concreta de <a class="reference internal" href="#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a> donde especificar el nombre del módulo a cargar es opcional.</p>
<div class="deprecated-removed">
<p><span class="versionmodified removed">Deprecated since version 3.6, removed in version 3.15: </span>Utilice <a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">ExtensionFileLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una implementación concreta de <a class="reference internal" href="#importlib.abc.ExecutionLoader" title="importlib.abc.ExecutionLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.ExecutionLoader</span></code></a> para módulos de extensión.</p>
<p class="translated">El argumento <em>fullname</em> especifica el nombre del módulo que el cargador debe admitir. El argumento <em>path</em> es la ruta al archivo del módulo de extensión.</p>
<p class="untranslated">Note that, by default, importing an extension module will fail
in subinterpreters if it doesn’t implement multi-phase init
(see <span class="target" id="index-18"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a>), even if it would otherwise import successfully.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>Multi-phase init is now required for use in subinterpreters.</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.name" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Nombre del módulo que admite el cargador.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.path" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Ruta al módulo de extensión.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.create_module">
<span class="sig-name descname"><span class="pre">create_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.create_module" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Crea el objeto de módulo a partir de la especificación dada de acuerdo con <span class="target" id="index-44"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.exec_module">
<span class="sig-name descname"><span class="pre">exec_module</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.exec_module" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Inicializa el objeto de módulo dado de acuerdo con <span class="target" id="index-45"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.is_package">
<span class="sig-name descname"><span class="pre">is_package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.is_package" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the file path points to a package’s <code class="docutils literal notranslate"><span class="pre">__init__</span></code>
module based on <a class="reference internal" href="#importlib.machinery.EXTENSION_SUFFIXES" title="importlib.machinery.EXTENSION_SUFFIXES"><code class="xref py py-const docutils literal notranslate"><span class="pre">EXTENSION_SUFFIXES</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.get_code">
<span class="sig-name descname"><span class="pre">get_code</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_code" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> ya que los módulos de extensión carecen de un objeto de código.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.get_source">
<span class="sig-name descname"><span class="pre">get_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_source" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna <code class="docutils literal notranslate"><span class="pre">None</span></code> ya que los módulos de extensión no tienen código fuente.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="importlib.machinery.ExtensionFileLoader.get_filename">
<span class="sig-name descname"><span class="pre">get_filename</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fullname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ExtensionFileLoader.get_filename" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna <a class="reference internal" href="#importlib.machinery.ExtensionFileLoader.path" title="importlib.machinery.ExtensionFileLoader.path"><code class="xref py py-attr docutils literal notranslate"><span class="pre">path</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.NamespaceLoader">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">NamespaceLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_finder</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.NamespaceLoader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una implementación concreta de <a class="reference internal" href="#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader</span></code></a> para paquetes de espacio de nombres. Ésta es un alias para una clase privada y sólo se hace pública para introspeccionar el atributo <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> en paquetes de espacio de nombres:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">importlib.machinery</span><span class="w"> </span><span class="kn">import</span> <span class="n">NamespaceLoader</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">my_namespace</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">my_namespace</span><span class="o">.</span><span class="n">__loader__</span><span class="p">,</span> <span class="n">NamespaceLoader</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">importlib.abc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">my_namespace</span><span class="o">.</span><span class="n">__loader__</span><span class="p">,</span> <span class="n">importlib</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Loader</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">ModuleSpec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_package</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.ModuleSpec" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A specification for a module’s import-system-related state.  This is
typically exposed as the module’s <a class="reference internal" href="../reference/datamodel.html#module.__spec__" title="module.__spec__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__</span></code></a> attribute.  Many
of these attributes are also available directly on a module: for example,
<code class="docutils literal notranslate"><span class="pre">module.__spec__.origin</span> <span class="pre">==</span> <span class="pre">module.__file__</span></code>.  Note, however, that
while the <em>values</em> are usually equivalent, they can differ since there is
no synchronization between the two objects.  For example, it is possible to
update the module’s <a class="reference internal" href="../reference/datamodel.html#module.__file__" title="module.__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> at runtime and this will not be
automatically reflected in the module’s
<a class="reference internal" href="#importlib.machinery.ModuleSpec.origin" title="importlib.machinery.ModuleSpec.origin"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__.origin</span></code></a>, and vice versa.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#importlib.machinery.ModuleSpec.name" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The module’s fully qualified name (see <a class="reference internal" href="../reference/datamodel.html#module.__name__" title="module.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__name__</span></code></a>).
The <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> should always set this attribute to a non-empty string.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.loader">
<span class="sig-name descname"><span class="pre">loader</span></span><a class="headerlink" href="#importlib.machinery.ModuleSpec.loader" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> used to load the module (see <a class="reference internal" href="../reference/datamodel.html#module.__loader__" title="module.__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__loader__</span></code></a>).
The <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> should always set this attribute.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.origin">
<span class="sig-name descname"><span class="pre">origin</span></span><a class="headerlink" href="#importlib.machinery.ModuleSpec.origin" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The location the <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> should use to load the module
(see <a class="reference internal" href="../reference/datamodel.html#module.__file__" title="module.__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__file__</span></code></a>).
For example, for modules loaded from a <code class="docutils literal notranslate"><span class="pre">.py</span></code> file this is the filename.
The <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> should always set this attribute to a meaningful value
for the <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> to use.  In the uncommon case that there is not one
(like for namespace packages), it should be set to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.submodule_search_locations">
<span class="sig-name descname"><span class="pre">submodule_search_locations</span></span><a class="headerlink" href="#importlib.machinery.ModuleSpec.submodule_search_locations" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A (possibly empty) <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a> of strings enumerating the locations
in which a package’s submodules will be found
(see <a class="reference internal" href="../reference/datamodel.html#module.__path__" title="module.__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__path__</span></code></a>). Most of the time there will only be a
single directory in this list.</p>
<p class="untranslated">The <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> should set this attribute to a sequence, even an empty
one, to indicate
to the import system that the module is a package.  It should be set to <code class="docutils literal notranslate"><span class="pre">None</span></code> for
non-package modules.  It is set automatically later to a special object for
namespace packages.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.loader_state">
<span class="sig-name descname"><span class="pre">loader_state</span></span><a class="headerlink" href="#importlib.machinery.ModuleSpec.loader_state" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">buscador</span></a> podría establecer este atributo a un objeto conteniendo datos adicionales y específicos al módulo para usar cuando se carga el módulo.. De lo contrario, debe establecerse en <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.cached">
<span class="sig-name descname"><span class="pre">cached</span></span><a class="headerlink" href="#importlib.machinery.ModuleSpec.cached" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The filename of a compiled version of the module’s code
(see <a class="reference internal" href="../reference/datamodel.html#module.__cached__" title="module.__cached__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__cached__</span></code></a>).
The <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> should always set this attribute but it may be <code class="docutils literal notranslate"><span class="pre">None</span></code>
for modules that do not need compiled code stored.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.parent">
<span class="sig-name descname"><span class="pre">parent</span></span><a class="headerlink" href="#importlib.machinery.ModuleSpec.parent" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">(Read-only) The fully qualified name of the package the module is in (or the
empty string for a top-level module).
See <a class="reference internal" href="../reference/datamodel.html#module.__package__" title="module.__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__package__</span></code></a>.
If the module is a package then this is the same as <a class="reference internal" href="#importlib.machinery.ModuleSpec.name" title="importlib.machinery.ModuleSpec.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.ModuleSpec.has_location">
<span class="sig-name descname"><span class="pre">has_location</span></span><a class="headerlink" href="#importlib.machinery.ModuleSpec.has_location" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated"><code class="docutils literal notranslate"><span class="pre">True</span></code> if the spec’s <a class="reference internal" href="#importlib.machinery.ModuleSpec.origin" title="importlib.machinery.ModuleSpec.origin"><code class="xref py py-attr docutils literal notranslate"><span class="pre">origin</span></code></a> refers to a loadable location,
<code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.  This value impacts how <code class="xref py py-attr docutils literal notranslate"><span class="pre">origin</span></code> is interpreted
and how the module’s <a class="reference internal" href="../reference/datamodel.html#module.__file__" title="module.__file__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code></a> is populated.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.machinery.AppleFrameworkLoader">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.machinery.</span></span><span class="sig-name descname"><span class="pre">AppleFrameworkLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.machinery.AppleFrameworkLoader" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A specialization of <a class="reference internal" href="#importlib.machinery.ExtensionFileLoader" title="importlib.machinery.ExtensionFileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ExtensionFileLoader</span></code></a> that
is able to load extension modules in Framework format.</p>
<p class="untranslated">For compatibility with the iOS App Store, <em>all</em> binary modules in an iOS app
must be dynamic libraries, contained in a framework with appropriate
metadata, stored in the <code class="docutils literal notranslate"><span class="pre">Frameworks</span></code> folder of the packaged app. There can
be only a single binary per framework, and there can be no executable binary
material outside the Frameworks folder.</p>
<p class="untranslated">To accommodate this requirement, when running on iOS, extension module
binaries are <em>not</em> packaged as <code class="docutils literal notranslate"><span class="pre">.so</span></code> files on <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>, but as
individual standalone frameworks. To discover those frameworks, this loader
is be registered against the <code class="docutils literal notranslate"><span class="pre">.fwork</span></code> file extension, with a <code class="docutils literal notranslate"><span class="pre">.fwork</span></code>
file acting as a placeholder in the original location of the binary on
<code class="docutils literal notranslate"><span class="pre">sys.path</span></code>. The <code class="docutils literal notranslate"><span class="pre">.fwork</span></code> file contains the path of the actual binary in
the <code class="docutils literal notranslate"><span class="pre">Frameworks</span></code> folder, relative to the app bundle. To allow for
resolving a framework-packaged binary back to the original location, the
framework is expected to contain a <code class="docutils literal notranslate"><span class="pre">.origin</span></code> file that contains the
location of the <code class="docutils literal notranslate"><span class="pre">.fwork</span></code> file, relative to the app bundle.</p>
<p class="untranslated">For example, consider the case of an import <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">foo.bar</span> <span class="pre">import</span> <span class="pre">_whiz</span></code>,
where <code class="docutils literal notranslate"><span class="pre">_whiz</span></code> is implemented with the binary module
<code class="docutils literal notranslate"><span class="pre">sources/foo/bar/_whiz.abi3.so</span></code>, with <code class="docutils literal notranslate"><span class="pre">sources</span></code> being the location
registered on <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>, relative to the application bundle. This module
<em>must</em> be distributed as
<code class="docutils literal notranslate"><span class="pre">Frameworks/foo.bar._whiz.framework/foo.bar._whiz</span></code> (creating the framework
name from the full import path of the module), with an <code class="docutils literal notranslate"><span class="pre">Info.plist</span></code> file
in the <code class="docutils literal notranslate"><span class="pre">.framework</span></code> directory identifying the binary as a framework. The
<code class="docutils literal notranslate"><span class="pre">foo.bar._whiz</span></code> module would be represented in the original location with
a <code class="docutils literal notranslate"><span class="pre">sources/foo/bar/_whiz.abi3.fwork</span></code> marker file, containing the path
<code class="docutils literal notranslate"><span class="pre">Frameworks/foo.bar._whiz/foo.bar._whiz</span></code>. The framework would also contain
<code class="docutils literal notranslate"><span class="pre">Frameworks/foo.bar._whiz.framework/foo.bar._whiz.origin</span></code>, containing the
path to the <code class="docutils literal notranslate"><span class="pre">.fwork</span></code> file.</p>
<p class="untranslated">When a module is loaded with this loader, the <code class="docutils literal notranslate"><span class="pre">__file__</span></code> for the module
will report as the location of the <code class="docutils literal notranslate"><span class="pre">.fwork</span></code> file. This allows code to use
the <code class="docutils literal notranslate"><span class="pre">__file__</span></code> of a  module as an anchor for file system traversal.
However, the spec origin will reference the location of the <em>actual</em> binary
in the <code class="docutils literal notranslate"><span class="pre">.framework</span></code> folder.</p>
<p class="untranslated">The Xcode project building the app is responsible for converting any <code class="docutils literal notranslate"><span class="pre">.so</span></code>
files from wherever they exist in the <code class="docutils literal notranslate"><span class="pre">PYTHONPATH</span></code> into frameworks in the
<code class="docutils literal notranslate"><span class="pre">Frameworks</span></code> folder (including stripping extensions from the module file,
the addition of framework metadata, and signing the resulting framework),
and creating the <code class="docutils literal notranslate"><span class="pre">.fwork</span></code> and <code class="docutils literal notranslate"><span class="pre">.origin</span></code> files. This will usually be done
with a build step in the Xcode project; see the iOS documentation for
details on how to construct this build step.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
<div class="availability docutils container">
<p class="untranslated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: iOS.</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.AppleFrameworkLoader.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#importlib.machinery.AppleFrameworkLoader.name" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Nombre del módulo que admite el cargador.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="importlib.machinery.AppleFrameworkLoader.path">
<span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="#importlib.machinery.AppleFrameworkLoader.path" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Path to the <code class="docutils literal notranslate"><span class="pre">.fwork</span></code> file for the extension module.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-importlib.util">
<span id="importlib-util-utility-code-for-importers"></span><h2 class="translated"><a class="reference internal" href="#module-importlib.util" title="importlib.util: Utility code for importers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code></a> – Código de utilidad para importadores<a class="headerlink" href="#module-importlib.util" title="Link to this heading">¶</a></h2>
<p class="translated"><strong>Código fuente:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/main/Lib/importlib/util.py">Lib/importlib/util.py</a></p>
<hr class="docutils" />
<p class="translated">Este módulo contiene los diversos objetos que ayudan en la construcción de un <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>.</p>
<dl class="py data">
<dt class="sig sig-object py" id="importlib.util.MAGIC_NUMBER">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">MAGIC_NUMBER</span></span><a class="headerlink" href="#importlib.util.MAGIC_NUMBER" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Los bytes que representan el número de versión del código de bytes. Si necesita ayuda para cargar/escribir código de bytes, considere <a class="reference internal" href="#importlib.abc.SourceLoader" title="importlib.abc.SourceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.cache_from_source">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">cache_from_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debug_override</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.cache_from_source" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna la ruta <span class="target" id="index-46"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a>/<span class="target" id="index-47"></span><a class="pep reference external" href="https://peps.python.org/pep-0488/"><strong>PEP 488</strong></a> al archivo compilado por bytes asociado con la <em>path</em> de origen. Por ejemplo, si <em>path</em> es <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>, el valor de retorno sería <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code> para Python 3.2. La cadena de caracteres <code class="docutils literal notranslate"><span class="pre">cpython-32</span></code> proviene de la etiqueta mágica actual (ver <code class="xref py py-func docutils literal notranslate"><span class="pre">get_tag()</span></code>; si <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code> no está definido, se lanzará <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>).</p>
<p class="translated">El parámetro <em>optimization</em> se utiliza para especificar el nivel de optimización del archivo de código de bytes. Una cadena de caracteres vacía no representa optimización, por lo que <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code> con una <em>optimization</em> de <code class="docutils literal notranslate"><span class="pre">''</span></code> dará como resultado una ruta de código de bytes de <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>. <code class="docutils literal notranslate"><span class="pre">None</span></code> hace que se utilice el nivel de optimización del intérprete. Se usa la representación de cadena de caracteres de cualquier otro valor, por lo que <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code> con una <em>optimization</em> de <code class="docutils literal notranslate"><span class="pre">2</span></code> conducirá a la ruta del código de bytes de <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc</span></code>. La representación de cadena de caracteres <em>optimization</em> solo puede ser alfanumérica, de lo contrario se lanza <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<p class="translated">El parámetro <em>debug_override</em> está obsoleto y se puede usar para anular el valor del sistema para <code class="docutils literal notranslate"><span class="pre">__debug__</span></code>. Un valor <code class="docutils literal notranslate"><span class="pre">True</span></code> es el equivalente a establecer <em>optimization</em> en la cadena de caracteres vacía. Un valor <code class="docutils literal notranslate"><span class="pre">False</span></code> es lo mismo que establecer <em>optimization</em> en <code class="docutils literal notranslate"><span class="pre">1</span></code>. Si tanto <em>debug_override</em> como <em>optimization</em> no es <code class="docutils literal notranslate"><span class="pre">None</span></code>, entonces se lanza <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>Se agregó el parámetro <em>optimization</em> y el parámetro <em>debug_override</em> quedó obsoleto.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Acepta un <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.source_from_cache">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">source_from_cache</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.source_from_cache" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Dado el <em>path</em> a un nombre de archivo <span class="target" id="index-48"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a>, retorna la ruta del archivo del código fuente asociado. Por ejemplo, si <em>path</em> es <code class="docutils literal notranslate"><span class="pre">/foo/bar/__pycache__/baz.cpython-32.pyc</span></code>, la ruta retornada sería <code class="docutils literal notranslate"><span class="pre">/foo/bar/baz.py</span></code>. <em>path</em> no necesita existir, sin embargo, si no se ajusta al formato <span class="target" id="index-49"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a> o <span class="target" id="index-50"></span><a class="pep reference external" href="https://peps.python.org/pep-0488/"><strong>PEP 488</strong></a>, se lanza un <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>. Si <code class="xref py py-attr docutils literal notranslate"><span class="pre">sys.implementation.cache_tag</span></code> no está definido, se lanza <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Acepta un <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.decode_source">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">decode_source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_bytes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.decode_source" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Decodifica los bytes dados que representan el código fuente y los retorna como una cadena de caracteres con nuevas líneas universales (como lo requiere <a class="reference internal" href="#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader.get_source()</span></code></a>).</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.resolve_name">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">resolve_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">package</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.resolve_name" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Resuelve un nombre de módulo relativo a uno absoluto.</p>
<p class="translated">Si <strong>name</strong> no tiene puntos iniciales, entonces <strong>name</strong> simplemente se retorna. Esto permite el uso como <code class="docutils literal notranslate"><span class="pre">importlib.util.resolve_name('sys',</span> <span class="pre">__spec__.parent)</span></code> sin hacer una verificación para ver si se necesita el argumento <strong>package</strong>.</p>
<p class="translated"><a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> se lanza si <strong>name</strong> es un nombre de módulo relativo pero <strong>package</strong> es un valor falso (por ejemplo, <code class="docutils literal notranslate"><span class="pre">None</span></code> o la cadena de caracteres vacía). También se lanza <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> si un nombre relativo escaparía del paquete que lo contiene (por ejemplo, solicitando <code class="docutils literal notranslate"><span class="pre">..bacon</span></code> desde el paquete <code class="docutils literal notranslate"><span class="pre">spam</span></code>).</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>Para mejorar la coherencia con las declaraciones de importación, aumente <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> en lugar de <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> para intentos de importación relativa no válidos.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.find_spec">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">find_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">package</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.find_spec" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Find the <a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a> for a module, optionally relative to
the specified <strong>package</strong> name. If the module is in <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>,
then <code class="docutils literal notranslate"><span class="pre">sys.modules[name].__spec__</span></code> is returned (unless the spec would be
<code class="docutils literal notranslate"><span class="pre">None</span></code> or is not set, in which case <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised).
Otherwise a search using <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> is done. <code class="docutils literal notranslate"><span class="pre">None</span></code> is
returned if no spec is found.</p>
<p class="translated">Si <strong>name</strong> es para un submódulo (contiene un punto), el módulo principal se importa automáticamente.</p>
<p class="translated"><strong>name</strong> y <strong>package</strong> funcionan igual que para <code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Raises <a class="reference internal" href="exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> instead of <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> if
<strong>package</strong> is in fact not a package (i.e. lacks a
<a class="reference internal" href="../reference/datamodel.html#module.__path__" title="module.__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> attribute).</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.module_from_spec">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">module_from_spec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">spec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.module_from_spec" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Cree un nuevo módulo basado en <strong>spec</strong> y <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spec.loader.create_module</span></code></a>.</p>
<p class="translated">Si <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">spec.loader.create_module</span></code></a> no retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>, no se restablecerán los atributos preexistentes. Además, no se lanzará <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> si se activa mientras se accede a <strong>spec</strong> o se establece un atributo en el módulo.</p>
<p class="translated">Esta función es preferible a usar <a class="reference internal" href="types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> para crear un nuevo módulo ya que <strong>spec</strong> se usa para establecer tantos atributos de importación controlados en el módulo como sea posible.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.spec_from_loader">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">spec_from_loader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_package</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.spec_from_loader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una función de fábrica para crear una instancia de <a class="reference internal" href="#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a> basada en un cargador. Los parámetros tienen el mismo significado que para ModuleSpec. La función utiliza APIs disponibles de <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>, tal como <code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.is_package()</span></code>, para completar cualquier información que falte en la especificación.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.spec_from_file_location">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">spec_from_file_location</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">location</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">loader</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">submodule_search_locations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.spec_from_file_location" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una función de fábrica para crear una instancia de <a class="reference internal" href="#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a> basada en la ruta a un archivo. La información que falte se completará en la especificación mediante el uso de las API de loader y la implicación de que el módulo estará basado en archivos.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Acepta un <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util.source_hash">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">source_hash</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_bytes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.source_hash" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna el hash de <em>source_bytes</em> como bytes. Un archivo <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> basado en hash incrusta <a class="reference internal" href="#importlib.util.source_hash" title="importlib.util.source_hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">source_hash()</span></code></a> del contenido del archivo fuente correspondiente en su encabezado.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="importlib.util._incompatible_extension_module_restrictions">
<span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">_incompatible_extension_module_restrictions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">disable_check</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util._incompatible_extension_module_restrictions" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A context manager that can temporarily skip the compatibility check
for extension modules.  By default the check is enabled and will fail
when a single-phase init module is imported in a subinterpreter.
It will also fail for a multi-phase init module that doesn’t
explicitly support a per-interpreter GIL, when imported
in an interpreter with its own GIL.</p>
<p class="untranslated">Note that this function is meant to accommodate an unusual case;
one which is likely to eventually go away.  There’s is a pretty good
chance this is not what you were looking for.</p>
<p class="untranslated">You can get the same effect as this function by implementing the
basic interface of multi-phase init (<span class="target" id="index-26"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a>) and lying about
support for multiple interpreters (or per-interpreter GIL).</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p class="untranslated">Using this function to disable the check can lead to
unexpected behavior and even crashes.  It should only be used during
extension module development.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="importlib.util.LazyLoader">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">importlib.util.</span></span><span class="sig-name descname"><span class="pre">LazyLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loader</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.LazyLoader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una clase que pospone la ejecución del cargador de un módulo hasta que el módulo tiene acceso a un atributo.</p>
<p class="untranslated">This class <strong>only</strong> works with loaders that define
<a class="reference internal" href="#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> as control over what module type
is used for the module is required. For those same reasons, the loader’s
<a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a> method must return <code class="docutils literal notranslate"><span class="pre">None</span></code> or a
type for which its <code class="docutils literal notranslate"><span class="pre">__class__</span></code> attribute can be mutated along with not
using <a class="reference internal" href="../glossary.html#term-__slots__"><span class="xref std std-term">slots</span></a>. Finally, modules which substitute the object
placed into <a class="reference internal" href="sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> will not work as there is no way to properly
replace the module references throughout the interpreter safely;
<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised if such a substitution is detected.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Para proyectos donde el tiempo de inicio es crítico, esta clase permite minimizar potencialmente el costo de cargar un módulo si nunca se usa. Para proyectos en los que el tiempo de inicio no es esencial, el uso de esta clase se desaconseja <strong>en gran medida</strong> debido a que los mensajes de error creados durante la carga se posponen y, por lo tanto, ocurren fuera de contexto.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Comenzó a llamar <a class="reference internal" href="#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>, eliminando la advertencia de compatibilidad para <a class="reference internal" href="#importlib.machinery.BuiltinImporter" title="importlib.machinery.BuiltinImporter"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.BuiltinImporter</span></code></a> y <a class="reference internal" href="#importlib.machinery.ExtensionFileLoader" title="importlib.machinery.ExtensionFileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ExtensionFileLoader</span></code></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="importlib.util.LazyLoader.factory">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">factory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loader</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#importlib.util.LazyLoader.factory" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A class method which returns a callable that creates a lazy loader. This
is meant to be used in situations where the loader is passed by class
instead of by instance.</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">suffixes</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span>
<span class="n">loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span>
<span class="n">lazy_loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">LazyLoader</span><span class="o">.</span><span class="n">factory</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="p">(</span><span class="n">lazy_loader</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="examples">
<span id="importlib-examples"></span><h2 class="translated">Ejemplos<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h2>
<section id="importing-programmatically">
<h3 class="translated">Importar programáticamente<a class="headerlink" href="#importing-programmatically" title="Link to this heading">¶</a></h3>
<p class="translated">Para importar un módulo mediante programación, use <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>.</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">importlib</span>

<span class="n">itertools</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;itertools&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="checking-if-a-module-can-be-imported">
<h3 class="translated">Comprobando si se puede importar un módulo<a class="headerlink" href="#checking-if-a-module-can-be-imported" title="Link to this heading">¶</a></h3>
<p class="translated">Si necesita averiguar si un módulo se puede importar sin realmente realizar la importación, entonces debe usar <a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a>.</p>
<p class="translated">Note que si <code class="docutils literal notranslate"><span class="pre">name</span></code> es un sub-módulo (contiene sólo un punto), <a class="reference internal" href="#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a> importará el módulo padre.</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">importlib.util</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="c1"># For illustrative purposes.</span>
<span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;itertools&#39;</span>

<span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> already in sys.modules&quot;</span><span class="p">)</span>
<span class="k">elif</span> <span class="p">(</span><span class="n">spec</span> <span class="o">:=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># If you chose to perform the actual import ...</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> has been imported&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;can&#39;t find the </span><span class="si">{</span><span class="n">name</span><span class="si">!r}</span><span class="s2"> module&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="importing-a-source-file-directly">
<h3 class="translated">Importar un archivo fuente directamente<a class="headerlink" href="#importing-a-source-file-directly" title="Link to this heading">¶</a></h3>
<p class="untranslated">This recipe should be used with caution: it is an approximation of an import
statement where the file path is specified directly, rather than
<a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> being searched. Alternatives should first be considered first,
such as modifying <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> when a proper module is required, or using
<a class="reference internal" href="runpy.html#runpy.run_path" title="runpy.run_path"><code class="xref py py-func docutils literal notranslate"><span class="pre">runpy.run_path()</span></code></a> when the global namespace resulting from running a Python
file is appropriate.</p>
<p class="untranslated">To import a Python source file directly from a path, use the following recipe:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">importlib.util</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>


<span class="k">def</span><span class="w"> </span><span class="nf">import_from_path</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">):</span>
    <span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">spec_from_file_location</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">module_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">module</span>


<span class="c1"># For illustrative purposes only (use of `json` is arbitrary).</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="vm">__file__</span>
<span class="n">module_name</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="vm">__name__</span>

<span class="c1"># Similar outcome as `import json`.</span>
<span class="n">json</span> <span class="o">=</span> <span class="n">import_from_path</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="implementing-lazy-imports">
<h3 class="translated">Implementar importaciones diferidas<a class="headerlink" href="#implementing-lazy-imports" title="Link to this heading">¶</a></h3>
<p class="translated">El ejemplo de abajo muestra cómo implementar importaciones diferidas:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">importlib.util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">lazy_import</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">loader</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">LazyLoader</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="o">=</span> <span class="n">loader</span>
<span class="gp">... </span>    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
<span class="gp">... </span>    <span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">module</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lazy_typing</span> <span class="o">=</span> <span class="n">lazy_import</span><span class="p">(</span><span class="s2">&quot;typing&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#lazy_typing is a real module object,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#but it is not loaded in memory yet.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lazy_typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span>
<span class="go">False</span>
</pre></div>
</div>
</section>
<section id="setting-up-an-importer">
<h3 class="translated">Configurar un importador<a class="headerlink" href="#setting-up-an-importer" title="Link to this heading">¶</a></h3>
<p class="untranslated">For deep customizations of import, you typically want to implement an
<a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a>. This means managing both the <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> and <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a>
side of things. For finders there are two flavours to choose from depending on
your needs: a <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a> or a <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>. The
former is what you would put on <a class="reference internal" href="sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> while the latter is what
you create using a <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">path entry hook</span></a> on <a class="reference internal" href="sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> which works
with <a class="reference internal" href="sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> entries to potentially create a finder. This example will
show you how to register your own importers so that import will use them (for
creating an importer for yourself, read the documentation for the appropriate
classes defined within this package):</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">importlib.machinery</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="c1"># For illustrative purposes only.</span>
<span class="n">SpamMetaPathFinder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">PathFinder</span>
<span class="n">SpamPathEntryFinder</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">FileFinder</span>
<span class="n">loader_details</span> <span class="o">=</span> <span class="p">(</span><span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SourceFileLoader</span><span class="p">,</span>
                  <span class="n">importlib</span><span class="o">.</span><span class="n">machinery</span><span class="o">.</span><span class="n">SOURCE_SUFFIXES</span><span class="p">)</span>

<span class="c1"># Setting up a meta path finder.</span>
<span class="c1"># Make sure to put the finder in the proper location in the list in terms of</span>
<span class="c1"># priority.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SpamMetaPathFinder</span><span class="p">)</span>

<span class="c1"># Setting up a path entry finder.</span>
<span class="c1"># Make sure to put the path hook in the proper location in the list in terms</span>
<span class="c1"># of priority.</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SpamPathEntryFinder</span><span class="o">.</span><span class="n">path_hook</span><span class="p">(</span><span class="n">loader_details</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="approximating-importlib-import-module">
<h3 class="translated">Aproximando <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a><a class="headerlink" href="#approximating-importlib-import-module" title="Link to this heading">¶</a></h3>
<p class="translated">La importación en sí está implementada en código Python, lo que permite exponer la mayor parte de la maquinaria de importación a través de importlib. Lo siguiente ayuda a ilustrar las diversas API que importlib expone al proporcionar una implementación aproximada de <a class="reference internal" href="#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">importlib.util</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="k">def</span><span class="w"> </span><span class="nf">import_module</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An approximate implementation of import.&quot;&quot;&quot;</span>
    <span class="n">absolute_name</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">resolve_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">absolute_name</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">path</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">absolute_name</span><span class="p">:</span>
        <span class="n">parent_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">child_name</span> <span class="o">=</span> <span class="n">absolute_name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="n">parent_module</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="n">parent_name</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">parent_module</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">submodule_search_locations</span>
    <span class="k">for</span> <span class="n">finder</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">find_spec</span><span class="p">(</span><span class="n">absolute_name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;No module named </span><span class="si">{</span><span class="n">absolute_name</span><span class="si">!r}</span><span class="s1">&#39;</span>
        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">absolute_name</span><span class="p">)</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">absolute_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">parent_module</span><span class="p">,</span> <span class="n">child_name</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">module</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — La implementación de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a><ul>
<li><a class="reference internal" href="#introduction">Introducción</a></li>
<li><a class="reference internal" href="#functions">Funciones</a></li>
<li><a class="reference internal" href="#module-importlib.abc"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code> – Clases base abstractas relacionadas con la importación</a></li>
<li><a class="reference internal" href="#module-importlib.machinery"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.machinery</span></code> – Importadores y enlaces de ruta</a></li>
<li><a class="reference internal" href="#module-importlib.util"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code> – Código de utilidad para importadores</a></li>
<li><a class="reference internal" href="#examples">Ejemplos</a><ul>
<li><a class="reference internal" href="#importing-programmatically">Importar programáticamente</a></li>
<li><a class="reference internal" href="#checking-if-a-module-can-be-imported">Comprobando si se puede importar un módulo</a></li>
<li><a class="reference internal" href="#importing-a-source-file-directly">Importar un archivo fuente directamente</a></li>
<li><a class="reference internal" href="#implementing-lazy-imports">Implementar importaciones diferidas</a></li>
<li><a class="reference internal" href="#setting-up-an-importer">Configurar un importador</a></li>
<li><a class="reference internal" href="#approximating-importlib-import-module">Aproximando <code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="runpy.html"
                          title="capítulo anterior"><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code> — Localización y ejecución de módulos Python</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="importlib.resources.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.resources</span></code> – Package resource reading, opening and access</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/importlib.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Contraer barra lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="importlib.resources.html" title="importlib.resources – Package resource reading, opening and access"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="runpy.html" title="runpy — Localización y ejecución de módulos Python"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modules.html" >Importando módulos</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code> — La implementación de <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Derechos de autor</a> 2001 Python Software Foundation.
    <br>
    Ésta página tiene la licencia Python Software Foundation Versión 2.
    <br>
    Ejemplos, guías, y otro código en la documentación están bajo la licencia adicional Zero Clause BSD.
    <br>
    
      Ver <a href="/license.html">Historia y Licencia</a> para más información.<br>
    
    
    <br>

    La Python Software Foundation es una corporación sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor dona.</a>
<br>
    <br>
      Última actualización en oct 06, 2025 (04:51 UTC).
    
      <a href="/bugs.html">Encontraste un bug</a>?
    
    <br>

    Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a>8.2.3.
    </div>

  </body>
</html>