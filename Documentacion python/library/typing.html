<!DOCTYPE html>

<html lang="es" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="typing — Support for type hints" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/typing.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Source code: Lib/typing.py This module provides runtime support for type hints. Consider the function below: The function surface_area_of_cube takes an argument expected to be an instance of float,..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.15/es/_images/social_previews/summary_library_typing_cafdca99.png" />
<meta property="og:image:alt" content="Source code: Lib/typing.py This module provides runtime support for type hints. Consider the function below: The function surface_area_of_cube takes an argument expected to be an instance of float,..." />
<meta name="description" content="Source code: Lib/typing.py This module provides runtime support for type hints. Consider the function below: The function surface_area_of_cube takes an argument expected to be an instance of float,..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>typing — Support for type hints &#8212; documentación de Python - 3.15.0a0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=bf1f176d"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f85f4cfb"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.15.0a0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Derechos de autor" href="../copyright.html" />
    <link rel="next" title="pydoc — Documentation generator and online help system" href="pydoc.html" />
    <link rel="prev" title="Herramientas de desarrollo" href="development.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/library/typing.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menú">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> — Support for type hints</a><ul>
<li><a class="reference internal" href="#specification-for-the-python-type-system">Specification for the Python Type System</a></li>
<li><a class="reference internal" href="#type-aliases">Alias de tipo</a></li>
<li><a class="reference internal" href="#newtype">NewType</a></li>
<li><a class="reference internal" href="#annotating-callable-objects">Anotaciones en objetos invocables</a></li>
<li><a class="reference internal" href="#generics">Genéricos</a></li>
<li><a class="reference internal" href="#annotating-tuples">Anotaciones en tuplas</a></li>
<li><a class="reference internal" href="#the-type-of-class-objects">El tipo de objetos de clase</a></li>
<li><a class="reference internal" href="#annotating-generators-and-coroutines">Annotating generators and coroutines</a></li>
<li><a class="reference internal" href="#user-defined-generic-types">Tipos genéricos definidos por el usuario</a></li>
<li><a class="reference internal" href="#the-any-type">El tipo <code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a></li>
<li><a class="reference internal" href="#nominal-vs-structural-subtyping">Subtipado nominal vs estructural</a></li>
<li><a class="reference internal" href="#module-contents">Contenido del módulo</a><ul>
<li><a class="reference internal" href="#special-typing-primitives">Primitivos especiales de tipado</a><ul>
<li><a class="reference internal" href="#special-types">Tipos especiales</a></li>
<li><a class="reference internal" href="#special-forms">Formas especiales</a></li>
<li><a class="reference internal" href="#building-generic-types-and-type-aliases">Creación de tipos genéricos y alias de tipos</a></li>
<li><a class="reference internal" href="#other-special-directives">Otras directivas especiales</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocols">Protocolos</a></li>
<li><a class="reference internal" href="#abcs-and-protocols-for-working-with-i-o">ABCs and Protocols for working with I/O</a></li>
<li><a class="reference internal" href="#functions-and-decorators">Funciones y decoradores</a></li>
<li><a class="reference internal" href="#introspection-helpers">Ayudas de introspección</a></li>
<li><a class="reference internal" href="#constant">Constantes</a></li>
<li><a class="reference internal" href="#deprecated-aliases">Alias obsoletos</a><ul>
<li><a class="reference internal" href="#aliases-to-built-in-types">Alias de tipos integrados</a></li>
<li><a class="reference internal" href="#aliases-to-types-in-collections">Alias de tipos en <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a></li>
<li><a class="reference internal" href="#aliases-to-other-concrete-types">Alias ​​a otros tipos concretos</a></li>
<li><a class="reference internal" href="#aliases-to-container-abcs-in-collections-abc">Alias de ABCs de contenedores en <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a></li>
<li><a class="reference internal" href="#aliases-to-asynchronous-abcs-in-collections-abc">Alias para ABCs asíncronos en <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a></li>
<li><a class="reference internal" href="#aliases-to-other-abcs-in-collections-abc">Alias a otros ABCs en <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a></li>
<li><a class="reference internal" href="#aliases-to-contextlib-abcs">Alias de ABCs <code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#deprecation-timeline-of-major-features">Línea de tiempo de obsolescencia de características principales</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="development.html"
                          title="capítulo anterior">Herramientas de desarrollo</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="pydoc.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code> — Documentation generator and online help system</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/typing.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc — Documentation generator and online help system"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="development.html" title="Herramientas de desarrollo"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" accesskey="U">Herramientas de desarrollo</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> — Support for type hints</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="typing-support-for-type-hints">
<h1 class="untranslated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> — Support for type hints<a class="headerlink" href="#typing-support-for-type-hints" title="Link to this heading">¶</a></h1>
<div class="versionadded" id="module-typing">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<p class="translated"><strong>Source code:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/main/Lib/typing.py">Lib/typing.py</a></p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">The Python runtime does not enforce function and variable type annotations.
They can be used by third party tools such as <a class="reference internal" href="../glossary.html#term-static-type-checker"><span class="xref std std-term">type checkers</span></a>,
IDEs, linters, etc.</p>
</div>
<hr class="docutils" />
<p class="untranslated">This module provides runtime support for type hints.</p>
<p class="untranslated">Consider the function below:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">surface_area_of_cube</span><span class="p">(</span><span class="n">edge_length</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;The surface area of the cube is </span><span class="si">{</span><span class="mi">6</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">edge_length</span><span class="w"> </span><span class="o">**</span><span class="w"> </span><span class="mi">2</span><span class="si">}</span><span class="s2">.&quot;</span>
</pre></div>
</div>
<p class="untranslated">The function <code class="docutils literal notranslate"><span class="pre">surface_area_of_cube</span></code> takes an argument expected to
be an instance of <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, as indicated by the <a class="reference internal" href="../glossary.html#term-type-hint"><span class="xref std std-term">type hint</span></a>
<code class="docutils literal notranslate"><span class="pre">edge_length:</span> <span class="pre">float</span></code>. The function is expected to return an instance
of <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, as indicated by the <code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">str</span></code> hint.</p>
<p class="untranslated">While type hints can be simple classes like <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> or <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>,
they can also be more complex. The <a class="reference internal" href="#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> module provides a vocabulary of
more advanced type hints.</p>
<p class="untranslated">New features are frequently added to the <code class="docutils literal notranslate"><span class="pre">typing</span></code> module.
The <a class="extlink-pypi reference external" href="https://pypi.org/project/typing_extensions/">typing_extensions</a> package
provides backports of these new features to older versions of Python.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="untranslated"><a class="reference external" href="https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html">Typing cheat sheet</a></dt><dd><p class="translated">Una visión general de los indicadores de tipo (hospedado por mypy docs, en inglés.)</p>
</dd>
<dt class="untranslated">Type System Reference section of <a class="reference external" href="https://mypy.readthedocs.io/en/stable/index.html">the mypy docs</a></dt><dd><p class="translated">El sistema de tipos de Python es estandarizado por medio de las PEPs, así que esta referencia debe aplicarse a la mayoría de validadores de tipo de Python. (Algunas partes pueden referirse específicamente a mypy.)</p>
</dd>
<dt class="untranslated"><a class="reference external" href="https://typing.python.org/en/latest/">Static Typing with Python</a></dt><dd><p class="translated">Documentación independiente del validador de tipos escrita por la comunidad que detalla las características del sistema de tipos, herramientas útiles relacionadas con el tipado y mejores prácticas.</p>
</dd>
</dl>
</div>
<section id="specification-for-the-python-type-system">
<span id="relevant-peps"></span><h2 class="untranslated">Specification for the Python Type System<a class="headerlink" href="#specification-for-the-python-type-system" title="Link to this heading">¶</a></h2>
<p class="untranslated">The canonical, up-to-date specification of the Python type system can be
found at <a class="reference external" href="https://typing.python.org/en/latest/spec/index.html">Specification for the Python type system</a>.</p>
</section>
<section id="type-aliases">
<span id="id2"></span><h2 class="translated">Alias de tipo<a class="headerlink" href="#type-aliases" title="Link to this heading">¶</a></h2>
<p class="translated">Un alias de tipo se define usando la declaración <a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a>, el cual crea una instancia de <a class="reference internal" href="#typing.TypeAliasType" title="typing.TypeAliasType"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeAliasType</span></code></a>. En este ejemplo, <code class="docutils literal notranslate"><span class="pre">Vector</span></code> y <code class="docutils literal notranslate"><span class="pre">list[float]</span></code> serán tratados de manera equivalente a los validadores de tipo estático:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Vector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">scale</span><span class="p">(</span><span class="n">scalar</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">Vector</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Vector</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">scalar</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">]</span>

<span class="c1"># passes type checking; a list of floats qualifies as a Vector.</span>
<span class="n">new_vector</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.2</span><span class="p">,</span> <span class="mf">5.4</span><span class="p">])</span>
</pre></div>
</div>
<p class="translated">Los alias de tipo son útiles para simplificar firmas de tipo complejas. Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>

<span class="nb">type</span> <span class="n">ConnectionOptions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="nb">type</span> <span class="n">Address</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="nb">type</span> <span class="n">Server</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Address</span><span class="p">,</span> <span class="n">ConnectionOptions</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">broadcast_message</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Server</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># The static type checker will treat the previous type signature as</span>
<span class="c1"># being exactly equivalent to this one.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">broadcast_message</span><span class="p">(</span>
    <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">servers</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">La declaración <a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a> es nueva en Python 3.12. Para compatibilidad con versiones anteriores, los alias de tipo también se pueden crear mediante una asignación simple.:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
<p class="translated">O marcarse con <a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a> para dejar explícito que se trata de un alias de tipo, no de una asignación de variable normal:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeAlias</span>

<span class="n">Vector</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
</section>
<section id="newtype">
<span id="distinct"></span><h2 class="translated">NewType<a class="headerlink" href="#newtype" title="Link to this heading">¶</a></h2>
<p class="translated">Use la clase auxiliar <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-class docutils literal notranslate"><span class="pre">NewType</span></code></a> para crear tipos distintos:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">some_id</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">524313</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">El validador estático de tipos tratará el nuevo tipo como si fuera una subclase del tipo original. Esto es útil para capturar errores lógicos:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_user_name</span><span class="p">(</span><span class="n">user_id</span><span class="p">:</span> <span class="n">UserId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="c1"># passes type checking</span>
<span class="n">user_a</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="n">UserId</span><span class="p">(</span><span class="mi">42351</span><span class="p">))</span>

<span class="c1"># fails type checking; an int is not a UserId</span>
<span class="n">user_b</span> <span class="o">=</span> <span class="n">get_user_name</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Se pueden realizar todas las operaciones de <code class="docutils literal notranslate"><span class="pre">int</span></code> en una variable de tipo <code class="docutils literal notranslate"><span class="pre">UserId</span></code>, pero el resultado siempre será de tipo <code class="docutils literal notranslate"><span class="pre">int</span></code>. Esto permite pasar un <code class="docutils literal notranslate"><span class="pre">UserId</span></code> allí donde se espere un <code class="docutils literal notranslate"><span class="pre">int</span></code>, pero evitará la creación accidental de un <code class="docutils literal notranslate"><span class="pre">UserId</span></code> de manera incorrecta:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># &#39;output&#39; is of type &#39;int&#39;, not &#39;UserId&#39;</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">23413</span><span class="p">)</span> <span class="o">+</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">54341</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Tenga en cuenta que estas validaciones solo las aplica el validador de tipo estático. En tiempo de ejecución, la declaración <code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Base)</span></code> hará que <code class="docutils literal notranslate"><span class="pre">Derived</span></code> sea una clase que retorna inmediatamente cualquier parámetro que le pase. Eso significa que la expresión <code class="docutils literal notranslate"><span class="pre">Derived(some_value)</span></code> no crea una nueva clase ni introduce mucha sobrecarga más allá de la de una llamada de función regular.</p>
<p class="translated">Más concretamente, la expresión <code class="docutils literal notranslate"><span class="pre">some_value</span> <span class="pre">is</span> <span class="pre">Derived(some_value)</span></code> será siempre verdadera en tiempo de ejecución.</p>
<p class="translated">No es válido crear un subtipo de <code class="docutils literal notranslate"><span class="pre">Derived</span></code>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="c1"># Fails at runtime and does not pass type checking</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AdminUserId</span><span class="p">(</span><span class="n">UserId</span><span class="p">):</span> <span class="k">pass</span>
</pre></div>
</div>
<p class="translated">Sin embargo, es posible crear un <a class="reference internal" href="#typing.NewType" title="typing.NewType"><code class="xref py py-class docutils literal notranslate"><span class="pre">NewType</span></code></a> basado en un <code class="docutils literal notranslate"><span class="pre">NewType</span></code> “derivado”:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NewType</span>

<span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<span class="n">ProUserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;ProUserId&#39;</span><span class="p">,</span> <span class="n">UserId</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">y la comprobación de tipo para <code class="docutils literal notranslate"><span class="pre">ProUserId</span></code> funcionará como se espera.</p>
<p class="translated">Véase <span class="target" id="index-152"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> para más detalle.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Recuerde que el uso de alias de tipo implica que los dos tipos son <em>equivalentes</em> entre sí. Haciendo <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">Alias</span> <span class="pre">=</span> <span class="pre">Original</span></code> provocará que el validador estático de tipos trate <code class="docutils literal notranslate"><span class="pre">Alias</span></code> como algo <em>exactamente equivalente</em> a <code class="docutils literal notranslate"><span class="pre">Original</span></code> en todos los casos. Esto es útil para cuando se quiera simplificar indicadores de tipo complejos.</p>
<p class="translated">En cambio, <code class="docutils literal notranslate"><span class="pre">NewType</span></code> declara un tipo que es <em>subtipo</em> de otro. Haciendo <code class="docutils literal notranslate"><span class="pre">Derived</span> <span class="pre">=</span> <span class="pre">NewType('Derived',</span> <span class="pre">Original)</span></code> hará que el Validador estático de tipos trate <code class="docutils literal notranslate"><span class="pre">Derived</span></code> como una <em>subclase</em> de <code class="docutils literal notranslate"><span class="pre">Original</span></code>, lo que implica que un valor de tipo <code class="docutils literal notranslate"><span class="pre">Original</span></code> no puede ser usado allí donde se espere un valor de tipo <code class="docutils literal notranslate"><span class="pre">Derived</span></code>. Esto es útil para prevenir errores lógicos con un coste de ejecución mínimo.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span><code class="docutils literal notranslate"><span class="pre">NewType</span></code> es ahora una clase en lugar de una función. Existe un costo de tiempo de ejecución adicional cuando se llama a <code class="docutils literal notranslate"><span class="pre">NewType</span></code> a través de una función normal.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>El rendimiento al llamar <code class="docutils literal notranslate"><span class="pre">NewType</span></code> ha sido restaurado a su nivel en Python 3.9.</p>
</div>
</section>
<section id="annotating-callable-objects">
<span id="annotating-callables"></span><h2 class="translated">Anotaciones en objetos invocables<a class="headerlink" href="#annotating-callable-objects" title="Link to this heading">¶</a></h2>
<p class="untranslated">Functions – or other <a class="reference internal" href="../glossary.html#term-callable"><span class="xref std std-term">callable</span></a> objects – can be annotated using
<a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> or deprecated <a class="reference internal" href="#typing.Callable" title="typing.Callable"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.Callable</span></code></a>.
<code class="docutils literal notranslate"><span class="pre">Callable[[int],</span> <span class="pre">str]</span></code> signifies a function that takes a single parameter
of type <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> and returns a <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Awaitable</span>

<span class="k">def</span><span class="w"> </span><span class="nf">feeder</span><span class="p">(</span><span class="n">get_next_item</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># Body</span>

<span class="k">def</span><span class="w"> </span><span class="nf">async_query</span><span class="p">(</span><span class="n">on_success</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
                <span class="n">on_error</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># Body</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">on_update</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># Body</span>

<span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Awaitable</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="n">on_update</span>
</pre></div>
</div>
<p class="untranslated" id="index-1">The subscription syntax must always be used with exactly two values: the
argument list and the return type.  The argument list must be a list of types,
a <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>, <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a>, or an ellipsis (<code class="docutils literal notranslate"><span class="pre">...</span></code>). The return type must
be a single type.</p>
<p class="translated">Si se proporciona una elipsis como lista de argumentos, indica que sería aceptable un invocable con cualquier lista de parámetros arbitraria:</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">concat</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="n">x</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">str</span>     <span class="c1"># OK</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">concat</span>  <span class="c1"># Also OK</span>
</pre></div>
</div>
<p class="untranslated"><code class="docutils literal notranslate"><span class="pre">Callable</span></code> cannot express complex signatures such as functions that take a
variadic number of arguments, <a class="reference internal" href="#overload"><span class="std std-ref">overloaded functions</span></a>, or
functions that have keyword-only parameters. However, these signatures can be
expressed by defining a <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a> class with a
<a class="reference internal" href="../reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> method:</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Protocol</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Combiner</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">vals</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span> <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">batch_proc</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span> <span class="n">cb_results</span><span class="p">:</span> <span class="n">Combiner</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">good_cb</span><span class="p">(</span><span class="o">*</span><span class="n">vals</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">maxlen</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="k">def</span><span class="w"> </span><span class="nf">bad_cb</span><span class="p">(</span><span class="o">*</span><span class="n">vals</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">maxitems</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]:</span>
    <span class="o">...</span>

<span class="n">batch_proc</span><span class="p">([],</span> <span class="n">good_cb</span><span class="p">)</span>  <span class="c1"># OK</span>
<span class="n">batch_proc</span><span class="p">([],</span> <span class="n">bad_cb</span><span class="p">)</span>   <span class="c1"># Error! Argument 2 has incompatible type because of</span>
                         <span class="c1"># different name and kind in the callback</span>
</pre></div>
</div>
<p class="translated">Los invocables que toman otros invocables como argumentos pueden indicar que sus tipos de parámetros dependen unos de otros utilizando <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>. Además, si ese invocable agrega o elimina argumentos de otros invocables, se puede utilizar el operador <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a>. Toman la forma <code class="docutils literal notranslate"><span class="pre">Callable[ParamSpecVariable,</span> <span class="pre">ReturnType]</span></code> y <code class="docutils literal notranslate"><span class="pre">Callable[Concatenate[Arg1Type,</span> <span class="pre">Arg2Type,</span> <span class="pre">...,</span> <span class="pre">ParamSpecVariable],</span> <span class="pre">ReturnType]</span></code> respectivamente.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span><code class="docutils literal notranslate"><span class="pre">Callable</span></code> ahora es compatible con <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> y <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a>. Consulte <span class="target" id="index-153"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> para obtener más información.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="translated">La documentación de <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> y <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Concatenate</span></code></a> proporciona ejemplos de uso en <code class="docutils literal notranslate"><span class="pre">Callable</span></code>.</p>
</div>
</section>
<section id="generics">
<span id="id3"></span><h2 class="translated">Genéricos<a class="headerlink" href="#generics" title="Link to this heading">¶</a></h2>
<p class="translated">Dado que la información de tipo sobre los objetos guardados en contenedores no se puede inferir estáticamente de manera genérica, muchas clases de contenedor en la biblioteca estándar admiten suscripción para indicar los tipos esperados de elementos de contenedor.</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Employee</span><span class="p">:</span> <span class="o">...</span>

<span class="c1"># Sequence[Employee] indicates that all elements in the sequence</span>
<span class="c1"># must be instances of &quot;Employee&quot;.</span>
<span class="c1"># Mapping[str, str] indicates that all keys and all values in the mapping</span>
<span class="c1"># must be strings.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">notify_by_email</span><span class="p">(</span><span class="n">employees</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Employee</span><span class="p">],</span>
                    <span class="n">overrides</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Funciones y clases genéricas pueden ser parametrizadas usando <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">type parameter syntax</span></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>

<span class="k">def</span><span class="w"> </span><span class="nf">first</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">l</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>  <span class="c1"># Function is generic over the TypeVar &quot;T&quot;</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p class="translated">O utilizando directamente la fábrica <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">U</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>                  <span class="c1"># Declare type variable &quot;U&quot;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">second</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">U</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">U</span><span class="p">:</span>  <span class="c1"># Function is generic over the TypeVar &quot;U&quot;</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>El soporte sintáctico para genéricos es nuevo en Python 3.12.</p>
</div>
</section>
<section id="annotating-tuples">
<span id="id4"></span><h2 class="translated">Anotaciones en tuplas<a class="headerlink" href="#annotating-tuples" title="Link to this heading">¶</a></h2>
<p class="translated">En la mayoría de los contenedores de Python, el sistema de tipado supone que todos los elementos del contenedor serán del mismo tipo. Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mapping</span>

<span class="c1"># Type checker will infer that all elements in ``x`` are meant to be ints</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Type checker error: ``list`` only accepts a single type argument:</span>
<span class="n">y</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">]</span>

<span class="c1"># Type checker will infer that all keys in ``z`` are meant to be strings,</span>
<span class="c1"># and that all values in ``z`` are meant to be either strings or ints</span>
<span class="n">z</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> solo acepta un argumento de tipo, por lo que un validador de tipos emitiría un error en la asignación <code class="docutils literal notranslate"><span class="pre">y</span></code> anterior. De manera similar, <a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a> solo acepta dos argumentos de tipo: el primero indica el tipo de las claves y el segundo indica el tipo de los valores.</p>
<p class="translated">Sin embargo, a diferencia de la mayoría de los demás contenedores de Python, es común en el código idiomático de Python que las tuplas tengan elementos que no sean todos del mismo tipo. Por este motivo, las tuplas son un caso especial en el sistema de tipado de Python. <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> acepta <em>cualquier número</em> de argumentos de tipo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># OK: ``x`` is assigned to a tuple of length 1 where the sole element is an int</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,)</span>

<span class="c1"># OK: ``y`` is assigned to a tuple of length 2;</span>
<span class="c1"># element 1 is an int, element 2 is a str</span>
<span class="n">y</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="c1"># Error: the type annotation indicates a tuple of length 1,</span>
<span class="c1"># but ``z`` has been assigned to a tuple of length 3</span>
<span class="n">z</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p class="untranslated" id="index-3">To denote a tuple which could be of <em>any</em> length, and in which all elements are
of the same type <code class="docutils literal notranslate"><span class="pre">T</span></code>, use the literal ellipsis <code class="docutils literal notranslate"><span class="pre">...</span></code>: <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">...]</span></code>.
To denote an empty tuple, use
<code class="docutils literal notranslate"><span class="pre">tuple[()]</span></code>. Using plain <code class="docutils literal notranslate"><span class="pre">tuple</span></code> as an annotation is equivalent to using
<code class="docutils literal notranslate"><span class="pre">tuple[Any,</span> <span class="pre">...]</span></code>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1"># These reassignments are OK: ``tuple[int, ...]`` indicates x can be of any length</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">()</span>
<span class="c1"># This reassignment is an error: all elements in ``x`` must be ints</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">)</span>

<span class="c1"># ``y`` can only ever be assigned to an empty tuple</span>
<span class="n">y</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[()]</span> <span class="o">=</span> <span class="p">()</span>

<span class="n">z</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="c1"># These reassignments are OK: plain ``tuple`` is equivalent to ``tuple[Any, ...]``</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">()</span>
</pre></div>
</div>
</section>
<section id="the-type-of-class-objects">
<span id="type-of-class-objects"></span><h2 class="translated">El tipo de objetos de clase<a class="headerlink" href="#the-type-of-class-objects" title="Link to this heading">¶</a></h2>
<p class="untranslated">A variable annotated with <code class="docutils literal notranslate"><span class="pre">C</span></code> may accept a value of type <code class="docutils literal notranslate"><span class="pre">C</span></code>. In
contrast, a variable annotated with <code class="docutils literal notranslate"><span class="pre">type[C]</span></code> (or deprecated
<a class="reference internal" href="#typing.Type" title="typing.Type"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Type[C]</span></code></a>) may accept values that are classes
themselves – specifically, it will accept the <em>class object</em> of <code class="docutils literal notranslate"><span class="pre">C</span></code>. For
example:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>         <span class="c1"># Has type ``int``</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">int</span>       <span class="c1"># Has type ``type[int]``</span>
<span class="n">c</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>   <span class="c1"># Also has type ``type[int]``</span>
</pre></div>
</div>
<p class="translated">Tenga en cuenta que <code class="docutils literal notranslate"><span class="pre">type[C]</span></code> es covariante:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">User</span><span class="p">:</span> <span class="o">...</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ProUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TeamUser</span><span class="p">(</span><span class="n">User</span><span class="p">):</span> <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">make_new_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">User</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">User</span><span class="p">:</span>
    <span class="c1"># ...</span>
    <span class="k">return</span> <span class="n">user_class</span><span class="p">()</span>

<span class="n">make_new_user</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>      <span class="c1"># OK</span>
<span class="n">make_new_user</span><span class="p">(</span><span class="n">ProUser</span><span class="p">)</span>   <span class="c1"># Also OK: ``type[ProUser]`` is a subtype of ``type[User]``</span>
<span class="n">make_new_user</span><span class="p">(</span><span class="n">TeamUser</span><span class="p">)</span>  <span class="c1"># Still fine</span>
<span class="n">make_new_user</span><span class="p">(</span><span class="n">User</span><span class="p">())</span>    <span class="c1"># Error: expected ``type[User]`` but got ``User``</span>
<span class="n">make_new_user</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>       <span class="c1"># Error: ``type[int]`` is not a subtype of ``type[User]``</span>
</pre></div>
</div>
<p class="translated">Los únicos parámetros legales para <a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> son las clases, <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, <a class="reference internal" href="#generics"><span class="std std-ref">variables de tipo</span></a> y uniones de cualquiera de estos tipos. Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">new_non_team_user</span><span class="p">(</span><span class="n">user_class</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">BasicUser</span> <span class="o">|</span> <span class="n">ProUser</span><span class="p">]):</span> <span class="o">...</span>

<span class="n">new_non_team_user</span><span class="p">(</span><span class="n">BasicUser</span><span class="p">)</span>  <span class="c1"># OK</span>
<span class="n">new_non_team_user</span><span class="p">(</span><span class="n">ProUser</span><span class="p">)</span>    <span class="c1"># OK</span>
<span class="n">new_non_team_user</span><span class="p">(</span><span class="n">TeamUser</span><span class="p">)</span>   <span class="c1"># Error: ``type[TeamUser]`` is not a subtype</span>
                              <span class="c1"># of ``type[BasicUser | ProUser]``</span>
<span class="n">new_non_team_user</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>       <span class="c1"># Also an error</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">type[Any]</span></code> es equivalente a <a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>, que es la raíz de la <a class="reference internal" href="../reference/datamodel.html#metaclasses"><span class="std std-ref">jerarquía de metaclases</span></a> de Python.</p>
</section>
<section id="annotating-generators-and-coroutines">
<span id="id5"></span><h2 class="untranslated">Annotating generators and coroutines<a class="headerlink" href="#annotating-generators-and-coroutines" title="Link to this heading">¶</a></h2>
<p class="untranslated">A generator can be annotated using the generic type
<a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></code></a>.
For example:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">echo_round</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">sent</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="k">yield</span> <span class="nb">round</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;Done&#39;</span>
</pre></div>
</div>
<p class="untranslated">Note that unlike many other generic classes in the standard library,
the <code class="docutils literal notranslate"><span class="pre">SendType</span></code> of <a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a> behaves
contravariantly, not covariantly or invariantly.</p>
<p class="untranslated">The <code class="docutils literal notranslate"><span class="pre">SendType</span></code> and <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> parameters default to <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p class="untranslated">It is also possible to set these types explicitly:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p class="untranslated">Simple generators that only ever yield values can also be annotated
as having a return type of either
<a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable[YieldType]</span></code></a>
or <a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterator[YieldType]</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p class="untranslated">Async generators are handled in a similar fashion, but don’t
expect a <code class="docutils literal notranslate"><span class="pre">ReturnType</span></code> type argument
(<a class="reference internal" href="collections.abc.html#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncGenerator[YieldType,</span> <span class="pre">SendType]</span></code></a>).
The <code class="docutils literal notranslate"><span class="pre">SendType</span></code> argument defaults to <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>, so the following definitions
are equivalent:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<p class="untranslated">As in the synchronous case,
<a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncIterable[YieldType]</span></code></a>
and <a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncIterator[YieldType]</span></code></a> are
available as well:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">infinite_stream</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="k">await</span> <span class="n">increment</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
</pre></div>
</div>
<p class="untranslated">Coroutines can be annotated using
<a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Coroutine[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></code></a>.
Generic arguments correspond to those of <a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generator</span></code></a>,
for example:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Coroutine</span>
<span class="n">c</span><span class="p">:</span> <span class="n">Coroutine</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>  <span class="c1"># Some coroutine defined elsewhere</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s1">&#39;hi&#39;</span><span class="p">)</span>                   <span class="c1"># Inferred type of &#39;x&#39; is list[str]</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">bar</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="k">await</span> <span class="n">c</span>                    <span class="c1"># Inferred type of &#39;y&#39; is int</span>
</pre></div>
</div>
</section>
<section id="user-defined-generic-types">
<span id="user-defined-generics"></span><h2 class="translated">Tipos genéricos definidos por el usuario<a class="headerlink" href="#user-defined-generic-types" title="Link to this heading">¶</a></h2>
<p class="translated">Una clase definida por el usuario puede ser definida como una clase genérica.</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">logging</span><span class="w"> </span><span class="kn">import</span> <span class="n">Logger</span>

<span class="k">class</span><span class="w"> </span><span class="nc">LoggedVar</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">Logger</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Set &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Get &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p class="untranslated">This syntax indicates that the class <code class="docutils literal notranslate"><span class="pre">LoggedVar</span></code> is parameterised around a
single <a class="reference internal" href="#typevar"><span class="std std-ref">type variable</span></a> <code class="docutils literal notranslate"><span class="pre">T</span></code> . This also makes <code class="docutils literal notranslate"><span class="pre">T</span></code> valid as
a type within the class body.</p>
<p class="translated">Las clases genéricas heredan implícitamente de <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>. Para compatibilidad con Python 3.11 y versiones anteriores, también es posible heredar explícitamente de <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> para indicar una clase genérica:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">LoggedVar</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Las clases genéricas tienen métodos <a class="reference internal" href="../reference/datamodel.html#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>, lo que significa que se pueden parametrizar en tiempo de ejecución (por ejemplo, <code class="docutils literal notranslate"><span class="pre">LoggedVar[int]</span></code> a continuación):</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>

<span class="k">def</span><span class="w"> </span><span class="nf">zero_all_vars</span><span class="p">(</span><span class="nb">vars</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">LoggedVar</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">var</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Un tipo genérico puede tener un numero cualquiera de variables de tipo. Se permiten todas las variaciones de <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> para ser usadas como parámetros de un tipo genérico:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="k">class</span><span class="w"> </span><span class="nc">WeirdTrio</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span> <span class="n">S</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)]:</span>
    <span class="o">...</span>

<span class="n">OldT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;OldT&#39;</span><span class="p">,</span> <span class="n">contravariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">OldB</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;OldB&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">OldS</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;OldS&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">OldWeirdTrio</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">OldT</span><span class="p">,</span> <span class="n">OldB</span><span class="p">,</span> <span class="n">OldS</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Cada argumento de variable de tipo de <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> debe ser distinto. Por lo tanto, esto no es válido:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="o">...</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Pair</span><span class="p">[</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">]:</span>  <span class="c1"># SyntaxError</span>
    <span class="o">...</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Pair</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>   <span class="c1"># INVALID</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Las clases genéricas también pueden heredar de otras clases:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sized</span>

<span class="k">class</span><span class="w"> </span><span class="nc">LinkedList</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Sized</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Al heredar de clases genéricas, algunos parámetros de tipo podrían ser fijos:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mapping</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyDict</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">En este caso <code class="docutils literal notranslate"><span class="pre">MyDict</span></code> tiene un solo parámetro, <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<p class="translated">El uso de una clase genérica sin especificar parámetros de tipo supone <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> para cada posición. En el siguiente ejemplo, <code class="docutils literal notranslate"><span class="pre">MyIterable</span></code> no es genérico, sino que hereda implícitamente de <code class="docutils literal notranslate"><span class="pre">Iterable[Any]</span></code>:</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyIterable</span><span class="p">(</span><span class="n">Iterable</span><span class="p">):</span> <span class="c1"># Same as Iterable[Any]</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">También se admiten alias de tipos genéricos definidos por el usuario. Ejemplos:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>

<span class="nb">type</span> <span class="n">Response</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span>

<span class="c1"># Return type here is same as Iterable[str] | int</span>
<span class="k">def</span><span class="w"> </span><span class="nf">response</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>

<span class="nb">type</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">inproduct</span><span class="p">[</span><span class="n">T</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)](</span><span class="n">v</span><span class="p">:</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span> <span class="c1"># Same as Iterable[tuple[T, T]]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Para compatibilidad con versiones anteriores, también se pueden crear alias de tipos genéricos mediante una asignación simple:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
<span class="n">Response</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">S</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> ya no posee una metaclase personalizable.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>La compatibilidad sintáctica con genéricos y alias de tipo es una novedad en la versión 3.12. Antes, las clases genéricas debían heredar explícitamente de <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> o contener una variable de tipo en una de sus bases.</p>
</div>
<p class="untranslated">User-defined generics for parameter expressions are also supported via parameter
specification variables in the form <code class="docutils literal notranslate"><span class="pre">[**P]</span></code>.  The behavior is consistent
with type variables” described above as parameter specification variables are
treated by the <code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> module as a specialized type variable.  The one exception
to this is that a list of types can be used to substitute a <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Z</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">P</span><span class="p">]:</span> <span class="o">...</span>  <span class="c1"># T is a TypeVar; P is a ParamSpec</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Z</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span>
<span class="go">__main__.Z[int, [dict, float]]</span>
</pre></div>
</div>
<p class="translated">También se pueden crear clases genéricas sobre <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> utilizando herencia explícita de <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>. En este caso, no se utiliza <code class="docutils literal notranslate"><span class="pre">**</span></code>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">Generic</span>

<span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Z</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">P</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Otra diferencia entre <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> y <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> es que una variable genérica con una sola especificación de parámetros aceptará listas de parámetros en los formatos <code class="docutils literal notranslate"><span class="pre">X[[Type1,</span> <span class="pre">Type2,</span> <span class="pre">...]]</span></code> y también <code class="docutils literal notranslate"><span class="pre">X[Type1,</span> <span class="pre">Type2,</span> <span class="pre">...]</span></code> por razones estéticas. Internamente, el último se convierte al primero, por lo que los siguientes son equivalentes:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">X</span><span class="p">[</span><span class="o">**</span><span class="n">P</span><span class="p">]:</span> <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="go">__main__.X[[int, str]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>
<span class="go">__main__.X[[int, str]]</span>
</pre></div>
</div>
<p class="translated">Tenga en cuenta que los genéricos con <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> pueden no tener <code class="docutils literal notranslate"><span class="pre">__parameters__</span></code> correctos después de la sustitución en algunos casos porque están destinados principalmente a la verificación de tipos estáticos.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span><a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> ahora se puede parametrizar sobre expresiones de parámetros. Consulte <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> y <span class="target" id="index-154"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> para obtener más detalles.</p>
</div>
<p class="untranslated">A user-defined generic class can have ABCs as base classes without a metaclass
conflict. Generic metaclasses are not supported. The outcome of parameterizing
generics is cached, and most types in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> module are <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> and
comparable for equality.</p>
</section>
<section id="the-any-type">
<h2 class="translated">El tipo <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a><a class="headerlink" href="#the-any-type" title="Link to this heading">¶</a></h2>
<p class="translated">Un caso especial de tipo es <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>. Un Validador estático de tipos tratará cualquier tipo como compatible con <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, y <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> como compatible con todos los tipos.</p>
<p class="translated">Esto significa que es posible realizar cualquier operación o llamada a un método en un valor de tipo <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> y asignarlo a cualquier variable:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>          <span class="c1"># OK</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>           <span class="c1"># OK</span>

<span class="n">s</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">a</span>           <span class="c1"># OK</span>

<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Passes type checking; &#39;item&#39; could be any type,</span>
    <span class="c1"># and that type might have a &#39;bar&#39; method</span>
    <span class="n">item</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Nótese que no se realiza comprobación de tipo cuando se asigna un valor de tipo <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> a un tipo más preciso. Por ejemplo, el Validador estático de tipos no reportó ningún error cuando se asignó <code class="docutils literal notranslate"><span class="pre">a</span></code> a <code class="docutils literal notranslate"><span class="pre">s</span></code>, aún cuando se declaró <code class="docutils literal notranslate"><span class="pre">s</span></code> como de tipo <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> y recibió un valor <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> en tiempo de ejecución!</p>
<p class="translated">Además, todas las funciones sin un tipo de retorno o tipos en los parámetros serán asignadas implícitamente a <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> por defecto:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="c1"># A static type checker will treat the above</span>
<span class="c1"># as having the same signature as:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">legacy_parser</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<p class="translated">Este comportamiento permite que <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> sea usado como una <em>vía de escape</em> cuando es necesario mezclar código tipado estática y dinámicamente.</p>
<p class="translated">Compárese el comportamiento de <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> con el de <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>. De manera similar a <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, todo tipo es un subtipo de <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>. Sin embargo, en oposición a <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>, lo contrario no es cierto: <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> <em>no</em> es un subtipo de ningún otro tipo.</p>
<p class="translated">Esto implica que cuando el tipo de un valor es <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>, un validador de tipos rechazará prácticamente todas las operaciones con él, y al asignarlo a una variable (o usarlo como valor de retorno) de un tipo más preciso será un error de tipo. Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">hash_a</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Fails type checking; an object does not have a &#39;magic&#39; method.</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">hash_b</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Passes type checking</span>
    <span class="n">item</span><span class="o">.</span><span class="n">magic</span><span class="p">()</span>
    <span class="o">...</span>

<span class="c1"># Passes type checking, since ints and strs are subclasses of object</span>
<span class="n">hash_a</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_a</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>

<span class="c1"># Passes type checking, since Any is compatible with all types</span>
<span class="n">hash_b</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">hash_b</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Úsese <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> para indicar que un valor puede ser de cualquier tipo de manera segura. Úsese <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> para indicar que un valor es de tipado dinámico.</p>
</section>
<section id="nominal-vs-structural-subtyping">
<h2 class="translated">Subtipado nominal vs estructural<a class="headerlink" href="#nominal-vs-structural-subtyping" title="Link to this heading">¶</a></h2>
<p class="translated">Inicialmente, el <span class="target" id="index-155"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> definió el uso de <em>subtipado nominal</em> para el sistema de tipado estático de Python. Esto implica que una clase <code class="docutils literal notranslate"><span class="pre">A</span></code> será permitida allí donde se espere una clase <code class="docutils literal notranslate"><span class="pre">B</span></code> si y solo si <code class="docutils literal notranslate"><span class="pre">A</span></code> es una subclase de <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
<p class="translated">Este requisito también se aplicaba anteriormente a clases base abstractas (ABC), tales como <a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>. El problema con esta estrategia es que una clase debía de ser marcada explícitamente para proporcionar esta funcionalidad, lo que resulta poco <em>pythónico</em> (idiomático) y poco ajustado a lo que uno normalmente haría en un código Python tipado dinámicamente. Por ejemplo, esto sí se ajusta al <span class="target" id="index-156"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Bucket</span><span class="p">(</span><span class="n">Sized</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p class="translated">El <span class="target" id="index-157"></span><a class="pep reference external" href="https://peps.python.org/pep-0544/"><strong>PEP 544</strong></a> permite resolver este problema al permitir escribir el código anterior sin una clase base explícita en la definición de la clase, permitiendo que el Validador estático de tipo considere implícitamente que <code class="docutils literal notranslate"><span class="pre">Bucket</span></code> es un subtipo tanto de <code class="docutils literal notranslate"><span class="pre">Sized</span></code> como de <code class="docutils literal notranslate"><span class="pre">Iterable[int]</span></code>. Esto se conoce como tipado <em>estructural</em> (o <em>duck-typing</em> estático):</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterable</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Bucket</span><span class="p">:</span>  <span class="c1"># Note: no base classes</span>
    <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">collect</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">Bucket</span><span class="p">())</span>  <span class="c1"># Passes type check</span>
</pre></div>
</div>
<p class="translated">Asimismo, creando subclases de la clase especial  <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>, el usuario puede definir nuevos protocolos personalizados y beneficiarse del tipado estructural (véanse los ejemplos de abajo).</p>
</section>
<section id="module-contents">
<h2 class="translated">Contenido del módulo<a class="headerlink" href="#module-contents" title="Link to this heading">¶</a></h2>
<p class="translated">El módulo <code class="docutils literal notranslate"><span class="pre">typing</span></code> define las siguientes clases, funciones y decoradores.</p>
<section id="special-typing-primitives">
<h3 class="translated">Primitivos especiales de tipado<a class="headerlink" href="#special-typing-primitives" title="Link to this heading">¶</a></h3>
<section id="special-types">
<h4 class="translated">Tipos especiales<a class="headerlink" href="#special-types" title="Link to this heading">¶</a></h4>
<p class="translated">Estos pueden ser usados como tipos en anotaciones. No soportan suscripción usando <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p>
<dl class="py data">
<dt class="sig sig-object py" id="typing.Any">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Any</span></span><a class="headerlink" href="#typing.Any" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Tipo especial que indica un tipo sin restricciones.</p>
<ul class="simple">
<li><p class="translated">Todos los tipos son compatibles con <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>.</p></li>
<li><p class="translated"><a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> es compatible con todos los tipos.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Ahora es posible utilizar <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a> como una clase base. Esto puede ser útil para evitar errores del validador de tipos con clases que pueden hacer uso del <em>duck typing</em> en cualquier punto, o que sean altamente dinámicas.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.AnyStr">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AnyStr</span></span><a class="headerlink" href="#typing.AnyStr" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una <a class="reference internal" href="#typing-constrained-typevar"><span class="std std-ref">variables de tipo restringida</span></a>.</p>
<p class="translated">Definición:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">AnyStr</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;AnyStr&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> está pensado para ser utilizado por funciones que pueden aceptar argumentos <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> o <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> pero que no puedan permitir que los dos se mezclen.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">concat</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">concat</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">)</span>    <span class="c1"># OK, output has type &#39;str&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>  <span class="c1"># OK, output has type &#39;bytes&#39;</span>
<span class="n">concat</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>   <span class="c1"># Error, cannot mix str and bytes</span>
</pre></div>
</div>
<p class="translated">Tenga en cuenta que, a pesar de su nombre, <code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> no tiene nada que ver con el tipo <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-class docutils literal notranslate"><span class="pre">Any</span></code></a>, ni significa “cualquier cadena de caracteres”. En particular, <code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> y <code class="docutils literal notranslate"><span class="pre">str</span> <span class="pre">|</span> <span class="pre">bytes</span></code> son diferentes entre sí y tienen diferentes casos de uso:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Invalid use of AnyStr:</span>
<span class="c1"># The type variable is used only once in the function signature,</span>
<span class="c1"># so cannot be &quot;solved&quot; by the type checker</span>
<span class="k">def</span><span class="w"> </span><span class="nf">greet_bad</span><span class="p">(</span><span class="n">cond</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">return</span> <span class="s2">&quot;hi there!&quot;</span> <span class="k">if</span> <span class="n">cond</span> <span class="k">else</span> <span class="sa">b</span><span class="s2">&quot;greetings!&quot;</span>

<span class="c1"># The better way of annotating this function:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">greet_proper</span><span class="p">(</span><span class="n">cond</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">bytes</span><span class="p">:</span>
    <span class="k">return</span> <span class="s2">&quot;hi there!&quot;</span> <span class="k">if</span> <span class="n">cond</span> <span class="k">else</span> <span class="sa">b</span><span class="s2">&quot;greetings!&quot;</span>
</pre></div>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.18: </span>Deprecated in favor of the new <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">type parameter syntax</span></a>.
Use <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">A[T:</span> <span class="pre">(str,</span> <span class="pre">bytes)]:</span> <span class="pre">...</span></code> instead of importing <code class="docutils literal notranslate"><span class="pre">AnyStr</span></code>. See
<span class="target" id="index-8"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a> for more details.</p>
<p class="untranslated">In Python 3.16, <code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> will be removed from <code class="docutils literal notranslate"><span class="pre">typing.__all__</span></code>, and
deprecation warnings will be emitted at runtime when it is accessed or
imported from <code class="docutils literal notranslate"><span class="pre">typing</span></code>. <code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> will be removed from <code class="docutils literal notranslate"><span class="pre">typing</span></code>
in Python 3.18.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.LiteralString">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">LiteralString</span></span><a class="headerlink" href="#typing.LiteralString" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Tipo especial que incluye sólo cadenas de caracteres literales.</p>
<p class="translated">Cualquier cadena de caracteres literal es compatible con <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code>, al igual que cualquier otro <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code>. Sin embargo, un objeto cuyo tipo sea simplemente <code class="docutils literal notranslate"><span class="pre">str</span></code> no lo es. Una cadena de caracteres creada mediante la composición de objetos cuyo tipo sea <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code> también es aceptable como <code class="docutils literal notranslate"><span class="pre">LiteralString</span></code>.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">run_query</span><span class="p">(</span><span class="n">sql</span><span class="p">:</span> <span class="n">LiteralString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">caller</span><span class="p">(</span><span class="n">arbitrary_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">literal_string</span><span class="p">:</span> <span class="n">LiteralString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">run_query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM students&quot;</span><span class="p">)</span>  <span class="c1"># OK</span>
    <span class="n">run_query</span><span class="p">(</span><span class="n">literal_string</span><span class="p">)</span>  <span class="c1"># OK</span>
    <span class="n">run_query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM &quot;</span> <span class="o">+</span> <span class="n">literal_string</span><span class="p">)</span>  <span class="c1"># OK</span>
    <span class="n">run_query</span><span class="p">(</span><span class="n">arbitrary_string</span><span class="p">)</span>  <span class="c1"># type checker error</span>
    <span class="n">run_query</span><span class="p">(</span>  <span class="c1"># type checker error</span>
        <span class="sa">f</span><span class="s2">&quot;SELECT * FROM students WHERE name = </span><span class="si">{</span><span class="n">arbitrary_string</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">LiteralString</span></code> es útil para API sensibles en las que cadenas de caracteres arbitrarias generadas por el usuario podrían generar problemas. Por ejemplo, los dos casos anteriores que generan errores de verificación de tipos podrían ser vulnerables a un ataque de inyección SQL.</p>
<p class="translated">Véase <span class="target" id="index-158"></span><a class="pep reference external" href="https://peps.python.org/pep-0675/"><strong>PEP 675</strong></a> para más detalle.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Never">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Never</span></span><a class="headerlink" href="#typing.Never" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="typing.NoReturn">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NoReturn</span></span><a class="headerlink" href="#typing.NoReturn" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated"><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code> and <code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code> represent the
<a class="reference external" href="https://en.wikipedia.org/wiki/Bottom_type">bottom type</a>,
a type that has no members.</p>
<p class="untranslated">They can be used to indicate that a function never returns,
such as <a class="reference internal" href="sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Never</span>  <span class="c1"># or NoReturn</span>

<span class="k">def</span><span class="w"> </span><span class="nf">stop</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Never</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;no way&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="untranslated">Or to define a function that should never be
called, as there are no valid arguments, such as
<a class="reference internal" href="#typing.assert_never" title="typing.assert_never"><code class="xref py py-func docutils literal notranslate"><span class="pre">assert_never()</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Never</span>  <span class="c1"># or NoReturn</span>

<span class="k">def</span><span class="w"> </span><span class="nf">never_call_me</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Never</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="k">def</span><span class="w"> </span><span class="nf">int_or_str</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">never_call_me</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>  <span class="c1"># type checker error</span>
    <span class="k">match</span> <span class="n">arg</span><span class="p">:</span>
        <span class="k">case</span> <span class="nb">int</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s an int&quot;</span><span class="p">)</span>
        <span class="k">case</span> <span class="nb">str</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s a str&quot;</span><span class="p">)</span>
        <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
            <span class="n">never_call_me</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>  <span class="c1"># OK, arg is of type Never (or NoReturn)</span>
</pre></div>
</div>
<p class="untranslated"><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code> and <code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code> have the same meaning in the type system
and static type checkers treat both equivalently.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.2: </span>Added <a class="reference internal" href="#typing.NoReturn" title="typing.NoReturn"><code class="xref py py-data docutils literal notranslate"><span class="pre">NoReturn</span></code></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11: </span>Added <a class="reference internal" href="#typing.Never" title="typing.Never"><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Self">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Self</span></span><a class="headerlink" href="#typing.Self" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Tipo especial que representa la clase capturada actual.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Self</span><span class="p">,</span> <span class="n">reveal_type</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">return_self</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SubclassOfFoo</span><span class="p">(</span><span class="n">Foo</span><span class="p">):</span> <span class="k">pass</span>

<span class="n">reveal_type</span><span class="p">(</span><span class="n">Foo</span><span class="p">()</span><span class="o">.</span><span class="n">return_self</span><span class="p">())</span>  <span class="c1"># Revealed type is &quot;Foo&quot;</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">SubclassOfFoo</span><span class="p">()</span><span class="o">.</span><span class="n">return_self</span><span class="p">())</span>  <span class="c1"># Revealed type is &quot;SubclassOfFoo&quot;</span>
</pre></div>
</div>
<p class="translated">Esta anotación es semánticamente equivalente a lo siguiente, aunque de una manera más sucinta:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVar</span>

<span class="n">Self</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;Self&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Foo&quot;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">return_self</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
<p class="translated">En general, si algo devuelve <code class="docutils literal notranslate"><span class="pre">self</span></code>, como en los ejemplos anteriores, se debe utilizar <code class="docutils literal notranslate"><span class="pre">Self</span></code> en la  anotación del retorno. Si <code class="docutils literal notranslate"><span class="pre">Foo.return_self</span></code> se anotó como que devuelve <code class="docutils literal notranslate"><span class="pre">”Foo”</span></code>, entonces el validador de tipos inferiría que el objeto devuelto desde <code class="docutils literal notranslate"><span class="pre">SubclassOfFoo.return_self</span></code> es del tipo <code class="docutils literal notranslate"><span class="pre">Foo</span></code> en lugar de <code class="docutils literal notranslate"><span class="pre">SubclassOfFoo</span></code>.</p>
<p class="translated">Otros casos de uso comunes incluyen:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="functions.html#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a> usados como constructores alternativos y retornan instancias del parámetro <code class="docutils literal notranslate"><span class="pre">cls</span></code>.</p></li>
<li><p class="translated">Anotar un método <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> que retorna self.</p></li>
</ul>
<p class="translated">No debe utilizar <code class="docutils literal notranslate"><span class="pre">Self</span></code> como anotación de retorno si no se garantiza que el método devuelva una instancia de una subclase cuando la clase sea heredada:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Eggs</span><span class="p">:</span>
    <span class="c1"># Self would be an incorrect return annotation here,</span>
    <span class="c1"># as the object returned is always an instance of Eggs,</span>
    <span class="c1"># even in subclasses</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">returns_eggs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Eggs&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Eggs</span><span class="p">()</span>
</pre></div>
</div>
<p class="translated">Véase <span class="target" id="index-159"></span><a class="pep reference external" href="https://peps.python.org/pep-0673/"><strong>PEP 673</strong></a> para más detalle.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.TypeAlias">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeAlias</span></span><a class="headerlink" href="#typing.TypeAlias" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Anotación especial para declarar explícitamente un <a class="reference internal" href="#type-aliases"><span class="std std-ref">alias de tipo</span></a>.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeAlias</span>

<span class="n">Factors</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">TypeAlias</span></code> es particularmente útil en versiones anteriores de Python para anotar alias que utilizan referencias para versiones posteriores, ya que puede ser difícil para los validadores de tipos distinguirlos de las asignaciones de variables normales:</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">TypeAlias</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="c1"># &quot;Box&quot; does not exist yet,</span>
<span class="c1"># so we have to use quotes for the forward reference on Python &lt;3.12.</span>
<span class="c1"># Using ``TypeAlias`` tells the type checker that this is a type alias declaration,</span>
<span class="c1"># not a variable assignment to a string.</span>
<span class="n">BoxOfStrings</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="s2">&quot;Box[str]&quot;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Box</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_box_of_strings</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BoxOfStrings</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Ver <span class="target" id="index-160"></span><a class="pep reference external" href="https://peps.python.org/pep-0613/"><strong>PEP 613</strong></a> para más detalle.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.12: </span><a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a> ha sido descontinuado en favor de la declaración <a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a>, la cual crea instancias de <a class="reference internal" href="#typing.TypeAliasType" title="typing.TypeAliasType"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeAliasType</span></code></a> y que admite de forma nativa referencias de versiones posteriores de Python. Tenga en cuenta que, si bien <a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a> y <a class="reference internal" href="#typing.TypeAliasType" title="typing.TypeAliasType"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeAliasType</span></code></a> tienen propósitos similares y tienen nombres similares, son distintos y el último no es el tipo del primero. La eliminación de <a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeAlias</span></code></a> no está prevista actualmente, pero se recomienda a los usuarios que migren a las declaraciones <a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="special-forms">
<h4 class="translated">Formas especiales<a class="headerlink" href="#special-forms" title="Link to this heading">¶</a></h4>
<p class="translated">Estos se pueden utilizar como tipos en anotaciones. Todos admiten la suscripción mediante <code class="docutils literal notranslate"><span class="pre">[]</span></code>, pero cada uno tiene una sintaxis única.</p>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Union">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Union</span></span><a class="headerlink" href="#typing.Union" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Tipo de unión; <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">Y]</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code> y significa X o Y.</p>
<p class="translated">Para definir una unión, use p. ej. <code class="docutils literal notranslate"><span class="pre">Union[int,</span> <span class="pre">str]</span></code> o la abreviatura <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">|</span> <span class="pre">str</span></code>. Se recomienda el uso de la abreviatura. Detalles:</p>
<ul>
<li><p class="translated">Los argumentos deben ser tipos y haber al menos uno.</p></li>
<li><p class="translated">Las uniones de uniones se simplifican (se aplanan), p. ej.:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
<p class="untranslated">However, this does not apply to unions referenced through a type
alias, to avoid forcing evaluation of the underlying <a class="reference internal" href="#typing.TypeAliasType" title="typing.TypeAliasType"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeAliasType</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">Union</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="translated">Las uniones con un solo argumento se eliminan, p. ej.:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span>  <span class="c1"># The constructor actually returns int</span>
</pre></div>
</div>
</li>
<li><p class="translated">Argumentos repetidos se omiten, p. ej.:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span>
</pre></div>
</div>
</li>
<li><p class="translated">Cuando se comparan uniones, el orden de los argumentos se ignoran, p. ej.:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">==</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="translated">No es posible crear una subclase o instanciar un <code class="docutils literal notranslate"><span class="pre">Union</span></code>.</p></li>
<li><p class="translated">No es posible escribir <code class="docutils literal notranslate"><span class="pre">Union[X][Y]</span></code>.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>No elimina subclases explícitas de una unión en tiempo de ejecución.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Las uniones ahora se pueden escribir como <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">Y</span></code>. Consulte <a class="reference internal" href="stdtypes.html#types-union"><span class="std std-ref">union type expressions</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.14: </span><a class="reference internal" href="types.html#types.UnionType" title="types.UnionType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.UnionType</span></code></a> is now an alias for <a class="reference internal" href="#typing.Union" title="typing.Union"><code class="xref py py-class docutils literal notranslate"><span class="pre">Union</span></code></a>, and both
<code class="docutils literal notranslate"><span class="pre">Union[int,</span> <span class="pre">str]</span></code> and <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">|</span> <span class="pre">str</span></code> create instances of the same class.
To check whether an object is a <code class="docutils literal notranslate"><span class="pre">Union</span></code> at runtime, use
<code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">Union)</span></code>. For compatibility with earlier versions of
Python, use
<code class="docutils literal notranslate"><span class="pre">get_origin(obj)</span> <span class="pre">is</span> <span class="pre">typing.Union</span> <span class="pre">or</span> <span class="pre">get_origin(obj)</span> <span class="pre">is</span> <span class="pre">types.UnionType</span></code>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Optional">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Optional</span></span><a class="headerlink" href="#typing.Optional" title="Link to this definition">¶</a></dt>
<dd><p class="translated"><code class="docutils literal notranslate"><span class="pre">Optional[X]</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">None</span></code> (o <code class="docutils literal notranslate"><span class="pre">Union[X,</span> <span class="pre">None]</span></code>).</p>
<p class="translated">Nótese que no es lo mismo que un argumento opcional, que es aquel que tiene un valor por defecto. Un argumento opcional con un valor por defecto no necesita el indicador <code class="docutils literal notranslate"><span class="pre">Optional</span></code> en su anotación de tipo simplemente por que sea opcional. Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Por otro lado, si se permite un valor <code class="docutils literal notranslate"><span class="pre">None</span></code>, es apropiado el uso de <code class="docutils literal notranslate"><span class="pre">Optional</span></code>, independientemente de que sea opcional o no. Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Optional ahora se puede escribir como <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">None</span></code>. Consulte <a class="reference internal" href="stdtypes.html#types-union"><span class="std std-ref">union type expressions</span></a>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Concatenate">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Concatenate</span></span><a class="headerlink" href="#typing.Concatenate" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Forma especial para anotar funciones de orden superior.</p>
<p class="translated" id="index-12"><code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> se puede utilizar junto con <a class="reference internal" href="#annotating-callables"><span class="std std-ref">Callable</span></a> y <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> para anotar un objeto invocable de orden superior que agrega, elimina o transforma parámetros de otro objeto invocable. El uso se realiza en el formato <code class="docutils literal notranslate"><span class="pre">Concatenate[Arg1Type,</span> <span class="pre">Arg2Type,</span> <span class="pre">...,</span> <span class="pre">ParamSpecVariable]</span></code>. <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> actualmente solo es válido cuando se utiliza como primer argumento de un <a class="reference internal" href="#annotating-callables"><span class="std std-ref">Callable</span></a>. El último parámetro de <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> debe ser un <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> o elipsis.</p>
<p class="translated">Por ejemplo, para anotar un decorador <code class="docutils literal notranslate"><span class="pre">with_lock</span></code> que proporciona un <a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a> a la función decorada, <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code> puede usarse para indicar que <code class="docutils literal notranslate"><span class="pre">with_lock</span></code> espera un invocable que toma un <code class="docutils literal notranslate"><span class="pre">Lock</span></code> como primer argumento y retorna un invocable con un tipo de firma diferente. En este caso, el <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> indica que los tipos de parámetros de los invocables retornados dependen de los tipos de parámetros de los invocables que se pasan en</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">threading</span><span class="w"> </span><span class="kn">import</span> <span class="n">Lock</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Concatenate</span>

<span class="c1"># Use this lock to ensure that only one thread is executing a function</span>
<span class="c1"># at any time.</span>
<span class="n">my_lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">with_lock</span><span class="p">[</span><span class="o">**</span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">](</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">Concatenate</span><span class="p">[</span><span class="n">Lock</span><span class="p">,</span> <span class="n">P</span><span class="p">],</span> <span class="n">R</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;A type-safe decorator which provides a lock.&#39;&#39;&#39;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="p">:</span>
        <span class="c1"># Provide the lock as the first argument.</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">my_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="nd">@with_lock</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sum_threadsafe</span><span class="p">(</span><span class="n">lock</span><span class="p">:</span> <span class="n">Lock</span><span class="p">,</span> <span class="n">numbers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Add a list of numbers together in a thread-safe manner.&#39;&#39;&#39;</span>
    <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>

<span class="c1"># We don&#39;t need to pass in the lock ourselves thanks to the decorator.</span>
<span class="n">sum_threadsafe</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">])</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<ul class="simple">
<li><p class="translated"><span class="target" id="index-161"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> - Variables de especificación de parámetros (el PEP que introdujo <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> y <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code>)</p></li>
<li><p class="translated"><a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#annotating-callables"><span class="std std-ref">Anotaciones en objetos invocables</span></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Literal">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Literal</span></span><a class="headerlink" href="#typing.Literal" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Tipo especial que solo incluye cadenas literales.</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">Literal</span></code> se puede utilizar para indicar a los validadores de tipos que el objeto anotado tiene un valor equivalente a uno de los literales proporcionados.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">validate_simple</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]:</span>  <span class="c1"># always returns True</span>
    <span class="o">...</span>

<span class="nb">type</span> <span class="n">Mode</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">]</span>
<span class="k">def</span><span class="w"> </span><span class="nf">open_helper</span><span class="p">(</span><span class="n">file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">Mode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>

<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/some/path&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>      <span class="c1"># Passes type check</span>
<span class="n">open_helper</span><span class="p">(</span><span class="s1">&#39;/other/path&#39;</span><span class="p">,</span> <span class="s1">&#39;typo&#39;</span><span class="p">)</span>  <span class="c1"># Error in type checker</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code> no puede ser derivado. En tiempo de ejecución, se permite un valor arbitrario como argumento de tipo de <code class="docutils literal notranslate"><span class="pre">Literal[...]</span></code>, pero los validadores de tipos pueden imponer sus restricciones. Véase <span class="target" id="index-162"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> para más detalles sobre tipos literales.</p>
<p class="untranslated">Additional details:</p>
<ul>
<li><p class="untranslated">The arguments must be literal values and there must be at least one.</p></li>
<li><p class="untranslated">Nested <code class="docutils literal notranslate"><span class="pre">Literal</span></code> types are flattened, e.g.:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Literal</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p class="untranslated">However, this does not apply to <code class="docutils literal notranslate"><span class="pre">Literal</span></code> types referenced through a type
alias, to avoid forcing evaluation of the underlying <a class="reference internal" href="#typing.TypeAliasType" title="typing.TypeAliasType"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeAliasType</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">Literal</span><span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="translated">Argumentos repetidos se omiten, p. ej.:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="untranslated">When comparing literals, the argument order is ignored, e.g.:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="untranslated">You cannot subclass or instantiate a <code class="docutils literal notranslate"><span class="pre">Literal</span></code>.</p></li>
<li><p class="untranslated">You cannot write <code class="docutils literal notranslate"><span class="pre">Literal[X][Y]</span></code>.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9.1: </span><code class="docutils literal notranslate"><span class="pre">Literal</span></code> ahora elimina los parámetros duplicados. Las comparaciones de igualdad de los objetos <code class="docutils literal notranslate"><span class="pre">Literal</span></code> ya no dependen del orden. Los objetos <code class="docutils literal notranslate"><span class="pre">Literal</span></code> ahora lanzarán una excepción <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> durante las comparaciones de igualdad si uno de sus parámetros no es <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.ClassVar">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ClassVar</span></span><a class="headerlink" href="#typing.ClassVar" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Construcción especial para tipado para marcar variables de clase.</p>
<p class="translated">Tal y como introduce <span class="target" id="index-163"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>, una anotación de variable rodeada por ClassVar indica que la intención de un atributo dado es ser usado como variable de clase y que no debería ser modificado en las instancias de esa misma clase. Uso:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Starship</span><span class="p">:</span>
    <span class="n">stats</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># class variable</span>
    <span class="n">damage</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span>                     <span class="c1"># instance variable</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> solo acepta tipos y no admite más niveles de subíndices.</p>
<p class="translated"><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> no es un clase en sí misma, y no debe ser usado con <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> o <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>. <a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> no modifica el comportamiento de Python en tiempo de ejecución pero puede ser utilizado por validadores de terceros. Por ejemplo, un validador de tipos puede marcar el siguiente código como erróneo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">enterprise_d</span> <span class="o">=</span> <span class="n">Starship</span><span class="p">(</span><span class="mi">3000</span><span class="p">)</span>
<span class="n">enterprise_d</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Error, setting class variable on instance</span>
<span class="n">Starship</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>     <span class="c1"># This is OK</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13: </span><a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> can now be nested in <a class="reference internal" href="#typing.Final" title="typing.Final"><code class="xref py py-data docutils literal notranslate"><span class="pre">Final</span></code></a> and vice versa.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Final">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Final</span></span><a class="headerlink" href="#typing.Final" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Construcción de tipado especial para indicar nombres finales a los validadores de tipos.</p>
<p class="translated">Los nombres finales no se pueden reasignar en ningún ámbito. Los nombres finales declarados en ámbitos de clase no se pueden anular en subclases.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">MAX_SIZE</span><span class="p">:</span> <span class="n">Final</span> <span class="o">=</span> <span class="mi">9000</span>
<span class="n">MAX_SIZE</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Error reported by type checker</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Connection</span><span class="p">:</span>
    <span class="n">TIMEOUT</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FastConnector</span><span class="p">(</span><span class="n">Connection</span><span class="p">):</span>
    <span class="n">TIMEOUT</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Error reported by type checker</span>
</pre></div>
</div>
<p class="translated">No hay comprobación en tiempo de ejecución para estas propiedades. Véase <span class="target" id="index-164"></span><a class="pep reference external" href="https://peps.python.org/pep-0591/"><strong>PEP 591</strong></a> para más detalles.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13: </span><a class="reference internal" href="#typing.Final" title="typing.Final"><code class="xref py py-data docutils literal notranslate"><span class="pre">Final</span></code></a> can now be nested in <a class="reference internal" href="#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-data docutils literal notranslate"><span class="pre">ClassVar</span></code></a> and vice versa.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Required">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Required</span></span><a class="headerlink" href="#typing.Required" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Construcción de tipado especial para marcar una clave <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> como requerida.</p>
<p class="translated">Esto es útil principalmente para TypedDicts <code class="docutils literal notranslate"><span class="pre">total=False</span></code>. Vea <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> y <span class="target" id="index-165"></span><a class="pep reference external" href="https://peps.python.org/pep-0655/"><strong>PEP 655</strong></a> para obtener más detalles.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.NotRequired">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NotRequired</span></span><a class="headerlink" href="#typing.NotRequired" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Construcción de tipado especial para marcar una clave <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> como potencialmente faltante.</p>
<p class="translated">Véase <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> y <span class="target" id="index-166"></span><a class="pep reference external" href="https://peps.python.org/pep-0655/"><strong>PEP 655</strong></a> para más detalle.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.ReadOnly">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ReadOnly</span></span><a class="headerlink" href="#typing.ReadOnly" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A special typing construct to mark an item of a <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> as read-only.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Movie</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
   <span class="n">title</span><span class="p">:</span> <span class="n">ReadOnly</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
   <span class="n">year</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">def</span><span class="w"> </span><span class="nf">mutate_movie</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">Movie</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
   <span class="n">m</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1999</span>  <span class="c1"># allowed</span>
   <span class="n">m</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;The Matrix&quot;</span>  <span class="c1"># typechecker error</span>
</pre></div>
</div>
<p class="untranslated">There is no runtime checking for this property.</p>
<p class="untranslated">See <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> and <span class="target" id="index-19"></span><a class="pep reference external" href="https://peps.python.org/pep-0705/"><strong>PEP 705</strong></a> for more details.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Annotated">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Annotated</span></span><a class="headerlink" href="#typing.Annotated" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Forma de escritura especial para agregar metadatos específicos del contexto a una anotación.</p>
<p class="translated">Agregue metadatos <code class="docutils literal notranslate"><span class="pre">x</span></code> a un tipo <code class="docutils literal notranslate"><span class="pre">T</span></code> determinado mediante la anotación <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code>. Los metadatos agregados mediante <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> pueden usarse con herramientas de análisis estático o en tiempo de ejecución. En tiempo de ejecución, los metadatos se almacenan en un atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__metadata__</span></code>.</p>
<p class="translated">Si una biblioteca o herramienta encuentra una anotación <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code> y no tiene una lógica especial para los metadatos, debe ignorar los metadatos y simplemente tratar la anotación como <code class="docutils literal notranslate"><span class="pre">T</span></code>. Como tal, <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> puede ser útil para el código que desea usar anotaciones para fines fuera del sistema de tipado estático de Python.</p>
<p class="untranslated">Using <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">x]</span></code> as an annotation still allows for static
typechecking of <code class="docutils literal notranslate"><span class="pre">T</span></code>, as type checkers will simply ignore the metadata <code class="docutils literal notranslate"><span class="pre">x</span></code>.
In this way, <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> differs from the
<a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-deco docutils literal notranslate"><span class="pre">&#64;no_type_check</span></code></a> decorator, which can also be used for
adding annotations outside the scope of the typing system, but
completely disables typechecking for a function or class.</p>
<p class="untranslated">The responsibility of how to interpret the metadata
lies with the tool or library encountering an
<code class="docutils literal notranslate"><span class="pre">Annotated</span></code> annotation. A tool or library encountering an <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> type
can scan through the metadata elements to determine if they are of interest
(e.g., using <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>).</p>
<dl class="describe">
<dt class="sig sig-object">
<span class="sig-name descname"><span class="pre">Annotated[&lt;type&gt;,</span> <span class="pre">&lt;metadata&gt;]</span></span></dt>
<dd></dd></dl>

<p class="translated">A continuación se muestra un ejemplo de cómo podría utilizar <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> para agregar metadatos a las anotaciones de tipo si estuviera realizando un análisis de rango:</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ValueRange</span><span class="p">:</span>
    <span class="n">lo</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">hi</span><span class="p">:</span> <span class="nb">int</span>

<span class="n">T1</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
<span class="n">T2</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">T1</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p class="untranslated">The first argument to <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> must be a valid type. Multiple metadata
elements can be supplied as <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> supports variadic arguments. The
order of the metadata elements is preserved and matters for equality checks:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ctype</span><span class="p">:</span>
     <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span>

<span class="n">a1</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">),</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>

<span class="k">assert</span> <span class="n">a1</span> <span class="o">!=</span> <span class="n">a2</span>  <span class="c1"># Order matters</span>
</pre></div>
</div>
<p class="translated">Depende de la herramienta que consume las anotaciones decidir si el cliente puede agregar varios elementos de metadatos a una anotación y cómo fusionar esas anotaciones.</p>
<p class="translated">Los tipos anidados <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> se aplanan. El orden de los elementos de metadatos comienza con la anotación más interna:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)],</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span> <span class="o">==</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
<p class="untranslated">However, this does not apply to <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> types referenced through a type
alias, to avoid forcing evaluation of the underlying <a class="reference internal" href="#typing.TypeAliasType" title="typing.TypeAliasType"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeAliasType</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">From3To10</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span>
<span class="k">assert</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">From3To10</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">Annotated</span><span class="p">[</span>
   <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ctype</span><span class="p">(</span><span class="s2">&quot;char&quot;</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
<p class="translated">Los elementos de metadatos duplicados no se eliminan:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">Annotated</span><span class="p">[</span>
    <span class="nb">int</span><span class="p">,</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">ValueRange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">Annotated</span></code> se puede utilizar con alias anidados y genéricos:</p>
<blockquote>
<div><div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MaxLen</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">int</span>

<span class="nb">type</span> <span class="n">Vec</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">]],</span> <span class="n">MaxLen</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

<span class="c1"># When used in a type annotation, a type checker will treat &quot;V&quot; the same as</span>
<span class="c1"># ``Annotated[list[tuple[int, int]], MaxLen(10)]``:</span>
<span class="nb">type</span> <span class="n">V</span> <span class="o">=</span> <span class="n">Vec</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
</div></blockquote>
<p class="translated">No se puede utilizar <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> con un <a class="reference internal" href="#typing.TypeVarTuple" title="typing.TypeVarTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVarTuple</span></code></a> descomprimido:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Variadic</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="n">Ann1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">Ann1</span><span class="p">]</span>  <span class="c1"># NOT valid</span>
</pre></div>
</div>
<p class="untranslated">where <code class="docutils literal notranslate"><span class="pre">T1</span></code>, <code class="docutils literal notranslate"><span class="pre">T2</span></code>, … are <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVars</span></code></a>. This is invalid as
only one type should be passed to Annotated.</p>
<p class="translated">De forma predeterminada, <a class="reference internal" href="#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_type_hints()</span></code></a> elimina los metadatos de las anotaciones. Pase <code class="docutils literal notranslate"><span class="pre">include_extras=True</span></code> para conservar los metadatos:</p>
<blockquote>
<div><div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Annotated</span><span class="p">,</span> <span class="n">get_type_hints</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_type_hints</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="go">{&#39;x&#39;: &lt;class &#39;int&#39;&gt;, &#39;return&#39;: &lt;class &#39;NoneType&#39;&gt;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_type_hints</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{&#39;x&#39;: typing.Annotated[int, &#39;metadata&#39;], &#39;return&#39;: &lt;class &#39;NoneType&#39;&gt;}</span>
</pre></div>
</div>
</div></blockquote>
<p class="translated">En tiempo de ejecución, los metadatos asociados con un tipo <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> se pueden recuperar a través del atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">__metadata__</span></code>:</p>
<blockquote>
<div><div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Annotated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;very&quot;</span><span class="p">,</span> <span class="s2">&quot;important&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span>
<span class="go">typing.Annotated[int, &#39;very&#39;, &#39;important&#39;, &#39;metadata&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="o">.</span><span class="n">__metadata__</span>
<span class="go">(&#39;very&#39;, &#39;important&#39;, &#39;metadata&#39;)</span>
</pre></div>
</div>
</div></blockquote>
<p class="untranslated">If you want to retrieve the original type wrapped by <code class="docutils literal notranslate"><span class="pre">Annotated</span></code>, use the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__origin__</span></code> attribute:</p>
<blockquote>
<div><div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Annotated</span><span class="p">,</span> <span class="n">get_origin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Password</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;secret&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Password</span><span class="o">.</span><span class="n">__origin__</span>
<span class="go">&lt;class &#39;str&#39;&gt;</span>
</pre></div>
</div>
</div></blockquote>
<p class="untranslated">Note that using <a class="reference internal" href="#typing.get_origin" title="typing.get_origin"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_origin()</span></code></a> will return <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> itself:</p>
<blockquote>
<div><div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">get_origin</span><span class="p">(</span><span class="n">Password</span><span class="p">)</span>
<span class="go">typing.Annotated</span>
</pre></div>
</div>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-167"></span><a class="pep reference external" href="https://peps.python.org/pep-0593/"><strong>PEP 593</strong></a> - Anotaciones flexibles de funciones y variables</dt><dd><p class="translated">El PEP introduce <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> en la biblioteca estándar.</p>
</dd>
</dl>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.TypeIs">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeIs</span></span><a class="headerlink" href="#typing.TypeIs" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Special typing construct for marking user-defined type predicate functions.</p>
<p class="untranslated"><code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> can be used to annotate the return type of a user-defined
type predicate function.  <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> only accepts a single type argument.
At runtime, functions marked this way should return a boolean and take at
least one positional argument.</p>
<p class="untranslated"><code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> aims to benefit <em>type narrowing</em> – a technique used by static
type checkers to determine a more precise type of an expression within a
program’s code flow.  Usually type narrowing is done by analyzing
conditional code flow and applying the narrowing to a block of code.  The
conditional expression here is sometimes referred to as a «type predicate»:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">is_str</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">float</span><span class="p">):</span>
    <span class="c1"># &quot;isinstance&quot; type predicate</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># Type of ``val`` is narrowed to ``str``</span>
        <span class="o">...</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Else, type of ``val`` is narrowed to ``float``.</span>
        <span class="o">...</span>
</pre></div>
</div>
<p class="untranslated">Sometimes it would be convenient to use a user-defined boolean function
as a type predicate.  Such a function should use <code class="docutils literal notranslate"><span class="pre">TypeIs[...]</span></code> or
<a class="reference internal" href="#typing.TypeGuard" title="typing.TypeGuard"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeGuard</span></code></a> as its return type to alert static type checkers to
this intention.  <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> usually has more intuitive behavior than
<code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code>, but it cannot be used when the input and output types
are incompatible (e.g., <code class="docutils literal notranslate"><span class="pre">list[object]</span></code> to <code class="docutils literal notranslate"><span class="pre">list[int]</span></code>) or when the
function does not return <code class="docutils literal notranslate"><span class="pre">True</span></code> for all instances of the narrowed type.</p>
<p class="untranslated">Using  <code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">TypeIs[NarrowedType]</span></code> tells the static type checker that for a given
function:</p>
<ol class="arabic simple">
<li><p class="translated">El valor de retorno es un booleano.</p></li>
<li><p class="untranslated">If the return value is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the type of its argument
is the intersection of the argument’s original type and <code class="docutils literal notranslate"><span class="pre">NarrowedType</span></code>.</p></li>
<li><p class="untranslated">If the return value is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the type of its argument
is narrowed to exclude <code class="docutils literal notranslate"><span class="pre">NarrowedType</span></code>.</p></li>
</ol>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">assert_type</span><span class="p">,</span> <span class="n">final</span><span class="p">,</span> <span class="n">TypeIs</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Parent</span><span class="p">:</span> <span class="k">pass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Child</span><span class="p">(</span><span class="n">Parent</span><span class="p">):</span> <span class="k">pass</span>
<span class="nd">@final</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Unrelated</span><span class="p">:</span> <span class="k">pass</span>

<span class="k">def</span><span class="w"> </span><span class="nf">is_parent</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TypeIs</span><span class="p">[</span><span class="n">Parent</span><span class="p">]:</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Parent</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Child</span> <span class="o">|</span> <span class="n">Unrelated</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_parent</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="c1"># Type of ``arg`` is narrowed to the intersection</span>
        <span class="c1"># of ``Parent`` and ``Child``, which is equivalent to</span>
        <span class="c1"># ``Child``.</span>
        <span class="n">assert_type</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Child</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Type of ``arg`` is narrowed to exclude ``Parent``,</span>
        <span class="c1"># so only ``Unrelated`` is left.</span>
        <span class="n">assert_type</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Unrelated</span><span class="p">)</span>
</pre></div>
</div>
<p class="untranslated">The type inside <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> must be consistent with the type of the
function’s argument; if it is not, static type checkers will raise
an error.  An incorrectly written <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> function can lead to
unsound behavior in the type system; it is the user’s responsibility
to write such functions in a type-safe manner.</p>
<p class="untranslated">If a <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> function is a class or instance method, then the type in
<code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> maps to the type of the second parameter (after <code class="docutils literal notranslate"><span class="pre">cls</span></code> or
<code class="docutils literal notranslate"><span class="pre">self</span></code>).</p>
<p class="untranslated">In short, the form <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">foo(arg:</span> <span class="pre">TypeA)</span> <span class="pre">-&gt;</span> <span class="pre">TypeIs[TypeB]:</span> <span class="pre">...</span></code>,
means that if <code class="docutils literal notranslate"><span class="pre">foo(arg)</span></code> returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, then <code class="docutils literal notranslate"><span class="pre">arg</span></code> is an instance
of <code class="docutils literal notranslate"><span class="pre">TypeB</span></code>, and if it returns <code class="docutils literal notranslate"><span class="pre">False</span></code>, it is not an instance of <code class="docutils literal notranslate"><span class="pre">TypeB</span></code>.</p>
<p class="untranslated"><code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> also works with type variables.  For more information, see
<span class="target" id="index-21"></span><a class="pep reference external" href="https://peps.python.org/pep-0742/"><strong>PEP 742</strong></a> (Narrowing types with <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code>).</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.TypeGuard">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeGuard</span></span><a class="headerlink" href="#typing.TypeGuard" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Special typing construct for marking user-defined type predicate functions.</p>
<p class="untranslated">Type predicate functions are user-defined functions that return whether their
argument is an instance of a particular type.
<code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> works similarly to <a class="reference internal" href="#typing.TypeIs" title="typing.TypeIs"><code class="xref py py-data docutils literal notranslate"><span class="pre">TypeIs</span></code></a>, but has subtly different
effects on type checking behavior (see below).</p>
<p class="translated">El uso de <code class="docutils literal notranslate"><span class="pre">-&gt;</span> <span class="pre">TypeGuard</span></code> le dice al validador de tipo estático que para una función determinada:</p>
<ol class="arabic simple">
<li><p class="translated">El valor de retorno es un booleano.</p></li>
<li><p class="translated">Si el valor de retorno es <code class="docutils literal notranslate"><span class="pre">True</span></code>, el tipo de su argumento es el tipo dentro de <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code>.</p></li>
</ol>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> también funciona con variables de tipo. Véase <span class="target" id="index-168"></span><a class="pep reference external" href="https://peps.python.org/pep-0647/"><strong>PEP 647</strong></a> para más detalles.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">is_str_list</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">object</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TypeGuard</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Determines whether all objects in the list are strings&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">val</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">func1</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">object</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">is_str_list</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="c1"># Type of ``val`` is narrowed to ``list[str]``.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Type of ``val`` remains as ``list[object]``.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not a list of strings!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="untranslated"><code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> and <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> differ in the following ways:</p>
<ul class="simple">
<li><p class="untranslated"><code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> requires the narrowed type to be a subtype of the input type, while
<code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> does not.  The main reason is to allow for things like
narrowing <code class="docutils literal notranslate"><span class="pre">list[object]</span></code> to <code class="docutils literal notranslate"><span class="pre">list[str]</span></code> even though the latter
is not a subtype of the former, since <code class="docutils literal notranslate"><span class="pre">list</span></code> is invariant.</p></li>
<li><p class="untranslated">When a <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> function returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, type checkers narrow the type of the
variable to exactly the <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> type. When a <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> function returns <code class="docutils literal notranslate"><span class="pre">True</span></code>,
type checkers can infer a more precise type combining the previously known type of the
variable with the <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> type. (Technically, this is known as an intersection type.)</p></li>
<li><p class="untranslated">When a <code class="docutils literal notranslate"><span class="pre">TypeGuard</span></code> function returns <code class="docutils literal notranslate"><span class="pre">False</span></code>, type checkers cannot narrow the type of
the variable at all. When a <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> function returns <code class="docutils literal notranslate"><span class="pre">False</span></code>, type checkers can narrow
the type of the variable to exclude the <code class="docutils literal notranslate"><span class="pre">TypeIs</span></code> type.</p></li>
</ul>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Unpack">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Unpack</span></span><a class="headerlink" href="#typing.Unpack" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Tipado para marcar conceptualmente un objeto como si hubiera sido desempaquetado.</p>
<p class="untranslated">For example, using the unpack operator <code class="docutils literal notranslate"><span class="pre">*</span></code> on a
<a class="reference internal" href="#typevartuple"><span class="std std-ref">type variable tuple</span></a> is equivalent to using <code class="docutils literal notranslate"><span class="pre">Unpack</span></code>
to mark the type variable tuple as having been unpacked:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Ts&#39;</span><span class="p">)</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>
<span class="c1"># Effectively does:</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Unpack</span><span class="p">[</span><span class="n">Ts</span><span class="p">]]</span>
</pre></div>
</div>
<p class="translated">De hecho, <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> se puede usar indistintamente con <code class="docutils literal notranslate"><span class="pre">*</span></code> en el contexto de los tipos <a class="reference internal" href="#typing.TypeVarTuple" title="typing.TypeVarTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.TypeVarTuple</span></code></a> y <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.tuple</span></code></a>. Es posible que veas que <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> se usa explícitamente en versiones anteriores de Python, donde <code class="docutils literal notranslate"><span class="pre">*</span></code> no se podía usar en ciertos lugares:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># In older versions of Python, TypeVarTuple and Unpack</span>
<span class="c1"># are located in the `typing_extensions` backports package.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVarTuple</span><span class="p">,</span> <span class="n">Unpack</span>

<span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s1">&#39;Ts&#39;</span><span class="p">)</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>         <span class="c1"># Syntax error on Python &lt;= 3.10!</span>
<span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Unpack</span><span class="p">[</span><span class="n">Ts</span><span class="p">]]</span>  <span class="c1"># Semantically equivalent, and backwards-compatible</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">Unpack</span></code> también se puede usar junto con <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.TypedDict</span></code></a> para tipear <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> en una firma de función:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypedDict</span><span class="p">,</span> <span class="n">Unpack</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Movie</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">year</span><span class="p">:</span> <span class="nb">int</span>

<span class="c1"># This function expects two keyword arguments - `name` of type `str`</span>
<span class="c1"># and `year` of type `int`.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Unpack</span><span class="p">[</span><span class="n">Movie</span><span class="p">]):</span> <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Consulte <span class="target" id="index-169"></span><a class="pep reference external" href="https://peps.python.org/pep-0692/"><strong>PEP 692</strong></a> para obtener más información sobre el uso de <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> para tipear <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

</section>
<section id="building-generic-types-and-type-aliases">
<h4 class="translated">Creación de tipos genéricos y alias de tipos<a class="headerlink" href="#building-generic-types-and-type-aliases" title="Link to this heading">¶</a></h4>
<p class="translated">Las siguientes clases no se deben utilizar directamente como anotaciones. Su finalidad es servir de bloques de construcción para crear tipos genéricos y alias de tipos.</p>
<p class="translated">Estos objetos se pueden crear mediante una sintaxis especial (<a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">type parameter lists</span></a> y la declaración <a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a>). Para compatibilidad con Python 3.11 y versiones anteriores, también se pueden crear sin la sintaxis dedicada, como se documenta a continuación.</p>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Generic">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Generic</span></span><a class="headerlink" href="#typing.Generic" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Clase base abstracta para tipos genéricos.</p>
<p class="translated">Un tipo genérico normalmente se declara agregando una lista de parámetros de tipo después del nombre de la clase:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Mapping</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="c1"># Etc.</span>
</pre></div>
</div>
<p class="translated">Esta clase hereda implícitamente de <code class="docutils literal notranslate"><span class="pre">Generic</span></code>. La semántica de tiempo de ejecución de esta sintaxis se analiza en la <a class="reference internal" href="../reference/compound_stmts.html#generic-classes"><span class="std std-ref">Referencia del lenguaje</span></a>.</p>
<p class="translated">Entonces, esta clase se puede usar como sigue:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">lookup_name</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">](</span><span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Y</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
</pre></div>
</div>
<p class="translated">Aquí los corchetes después del nombre de la función indican una <a class="reference internal" href="../reference/compound_stmts.html#generic-functions"><span class="std std-ref">función genérica</span></a>.</p>
<p class="translated">Para compatibilidad con versiones anteriores, las clases genéricas también se pueden declarar heredando explícitamente de <code class="docutils literal notranslate"><span class="pre">Generic</span></code>. En este caso, los parámetros de tipo se deben declarar por separado:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">KT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;KT&#39;</span><span class="p">)</span>
<span class="n">VT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;VT&#39;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Mapping</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">]):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VT</span><span class="p">:</span>
        <span class="o">...</span>
        <span class="c1"># Etc.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class" id="typevar">
<dt class="sig sig-object py" id="typing.TypeVar">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeVar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contravariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">infer_variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">typing.NoDefault</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeVar" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Variable de tipo.</p>
<p class="translated">La forma preferida de construir una variable de tipo es a través de la sintaxis dedicada para <a class="reference internal" href="../reference/compound_stmts.html#generic-functions"><span class="std std-ref">funciones genéricas</span></a>, <a class="reference internal" href="../reference/compound_stmts.html#generic-classes"><span class="std std-ref">clases genéricas</span></a> y <a class="reference internal" href="../reference/compound_stmts.html#generic-type-aliases"><span class="std std-ref">alias de tipo genérico</span></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>  <span class="c1"># T is a TypeVar</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="untranslated">This syntax can also be used to create bounded and constrained type
variables:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">StrSequence</span><span class="p">[</span><span class="n">S</span><span class="p">:</span> <span class="nb">str</span><span class="p">]:</span>  <span class="c1"># S is a TypeVar with a `str` upper bound;</span>
    <span class="o">...</span>                     <span class="c1"># we can say that S is &quot;bounded by `str`&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">StrOrBytesSequence</span><span class="p">[</span><span class="n">A</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)]:</span>  <span class="c1"># A is a TypeVar constrained to str or bytes</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Sin embargo, si se desea, también se pueden construir manualmente variables de tipo reutilizables, de la siguiente manera:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># Can be anything</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>  <span class="c1"># Can be any subtype of str</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># Must be exactly str or bytes</span>
</pre></div>
</div>
<p class="translated">Las variables de tipo existen principalmente para el beneficio de los validadores de tipos estáticos. Sirven como parámetros para tipos genéricos, así como para definiciones de alias de tipo y funciones genéricas. Consulte <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> para obtener más información sobre tipos genéricos. Las funciones genéricas funcionan de la siguiente manera:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">repeat</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a list containing n references to x.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>


<span class="k">def</span><span class="w"> </span><span class="nf">print_capitalized</span><span class="p">[</span><span class="n">S</span><span class="p">:</span> <span class="nb">str</span><span class="p">](</span><span class="n">x</span><span class="p">:</span> <span class="n">S</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Print x capitalized, and return x.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">capitalize</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span><span class="w"> </span><span class="nf">concatenate</span><span class="p">[</span><span class="n">A</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)](</span><span class="n">x</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">A</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add two strings or bytes objects together.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p class="untranslated">Note that type variables can be <em>bounded</em>, <em>constrained</em>, or neither, but
cannot be both bounded <em>and</em> constrained.</p>
<p class="translated">La varianza de las variables de tipo es inferida por los validadores de tipo cuando se crean a través de la <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">sintáxis de parámetros de tipo</span></a> o cuando se pasa <code class="docutils literal notranslate"><span class="pre">infer_variance=True</span></code>. Las variables de tipo creadas manualmente se pueden marcar explícitamente como covariantes o contravariantes al pasar <code class="docutils literal notranslate"><span class="pre">covariant=True</span></code> o <code class="docutils literal notranslate"><span class="pre">contravariant=True</span></code>. De manera predeterminada, las variables de tipo creadas manualmente son invariantes. Consulte <span class="target" id="index-170"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> y <span class="target" id="index-171"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a> para obtener más detalles.</p>
<p class="untranslated">Bounded type variables and constrained type variables have different
semantics in several important ways. Using a <em>bounded</em> type variable means
that the <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> will be solved using the most specific type possible:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">print_capitalized</span><span class="p">(</span><span class="s1">&#39;a string&#39;</span><span class="p">)</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># revealed type is str</span>

<span class="k">class</span><span class="w"> </span><span class="nc">StringSubclass</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">print_capitalized</span><span class="p">(</span><span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;another string&#39;</span><span class="p">))</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># revealed type is StringSubclass</span>

<span class="n">z</span> <span class="o">=</span> <span class="n">print_capitalized</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>  <span class="c1"># error: int is not a subtype of str</span>
</pre></div>
</div>
<p class="untranslated">The upper bound of a type variable can be a concrete type, abstract type
(ABC or Protocol), or even a union of types:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Can be anything with an __abs__ method</span>
<span class="k">def</span><span class="w"> </span><span class="nf">print_abs</span><span class="p">[</span><span class="n">T</span><span class="p">:</span> <span class="n">SupportsAbs</span><span class="p">](</span><span class="n">arg</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Absolute value:&quot;</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

<span class="n">U</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">str</span><span class="o">|</span><span class="nb">bytes</span><span class="p">)</span>  <span class="c1"># Can be any subtype of the union str|bytes</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">SupportsAbs</span><span class="p">)</span>  <span class="c1"># Can be anything with an __abs__ method</span>
</pre></div>
</div>
<p class="translated" id="typing-constrained-typevar">Sin embargo, usar una variable de tipo <em>constrained</em> significa que la <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> sólo podrá ser determinada como exactamente una de las restricciones dadas:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">)</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># revealed type is str</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">),</span> <span class="n">StringSubclass</span><span class="p">(</span><span class="s1">&#39;two&#39;</span><span class="p">))</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># revealed type is str, despite StringSubclass being passed in</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;two&#39;</span><span class="p">)</span>  <span class="c1"># error: type variable &#39;A&#39; can be either str or bytes in a function call, but not both</span>
</pre></div>
</div>
<p class="translated">En tiempo de ejecución, <code class="docutils literal notranslate"><span class="pre">isinstance(x,</span> <span class="pre">T)</span></code> lanzará <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#typing.TypeVar.__name__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El nombre de la variable de tipo.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__covariant__">
<span class="sig-name descname"><span class="pre">__covariant__</span></span><a class="headerlink" href="#typing.TypeVar.__covariant__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Si la variable de tipo ha sido marcado explícitamente como covariante.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__contravariant__">
<span class="sig-name descname"><span class="pre">__contravariant__</span></span><a class="headerlink" href="#typing.TypeVar.__contravariant__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Si la variable de tipo ha sido marcado explícitamente como covariante.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__infer_variance__">
<span class="sig-name descname"><span class="pre">__infer_variance__</span></span><a class="headerlink" href="#typing.TypeVar.__infer_variance__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Si los validadores de tipo deben inferir la variación de la variable de tipo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__bound__">
<span class="sig-name descname"><span class="pre">__bound__</span></span><a class="headerlink" href="#typing.TypeVar.__bound__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The upper bound of the type variable, if any.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>Para las variables de tipo creadas a través de <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">sintáxis de parámetros de tipo</span></a>, el límite se evalúa solo cuando se accede al atributo, no cuando se crea la variable de tipo (consulte <a class="reference internal" href="../reference/executionmodel.html#lazy-evaluation"><span class="std std-ref">Evaluación perezosa</span></a>).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="typing.TypeVar.evaluate_bound">
<span class="sig-name descname"><span class="pre">evaluate_bound</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeVar.evaluate_bound" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">An <a class="reference internal" href="../glossary.html#term-evaluate-function"><span class="xref std std-term">evaluate function</span></a> corresponding to the <a class="reference internal" href="#typing.TypeVar.__bound__" title="typing.TypeVar.__bound__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bound__</span></code></a> attribute.
When called directly, this method supports only the <a class="reference internal" href="annotationlib.html#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE</span></code></a>
format, which is equivalent to accessing the <a class="reference internal" href="#typing.TypeVar.__bound__" title="typing.TypeVar.__bound__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bound__</span></code></a> attribute directly,
but the method object can be passed to <a class="reference internal" href="annotationlib.html#annotationlib.call_evaluate_function" title="annotationlib.call_evaluate_function"><code class="xref py py-func docutils literal notranslate"><span class="pre">annotationlib.call_evaluate_function()</span></code></a>
to evaluate the value in a different format.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__constraints__">
<span class="sig-name descname"><span class="pre">__constraints__</span></span><a class="headerlink" href="#typing.TypeVar.__constraints__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una tupla que contiene las restricciones de la variable de tipo, si las hay.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>Para las variables de tipo creadas a través de la <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">sintáxis de parámetros de tipo</span></a>, las restricciones se evalúan solo cuando se accede al atributo, no cuando se crea la variable de tipo (consulte <a class="reference internal" href="../reference/executionmodel.html#lazy-evaluation"><span class="std std-ref">Evaluación perezosa</span></a>).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="typing.TypeVar.evaluate_constraints">
<span class="sig-name descname"><span class="pre">evaluate_constraints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeVar.evaluate_constraints" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">An <a class="reference internal" href="../glossary.html#term-evaluate-function"><span class="xref std std-term">evaluate function</span></a> corresponding to the <a class="reference internal" href="#typing.TypeVar.__constraints__" title="typing.TypeVar.__constraints__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__constraints__</span></code></a> attribute.
When called directly, this method supports only the <a class="reference internal" href="annotationlib.html#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE</span></code></a>
format, which is equivalent to accessing the <a class="reference internal" href="#typing.TypeVar.__constraints__" title="typing.TypeVar.__constraints__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__constraints__</span></code></a> attribute directly,
but the method object can be passed to <a class="reference internal" href="annotationlib.html#annotationlib.call_evaluate_function" title="annotationlib.call_evaluate_function"><code class="xref py py-func docutils literal notranslate"><span class="pre">annotationlib.call_evaluate_function()</span></code></a>
to evaluate the value in a different format.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVar.__default__">
<span class="sig-name descname"><span class="pre">__default__</span></span><a class="headerlink" href="#typing.TypeVar.__default__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The default value of the type variable, or <a class="reference internal" href="#typing.NoDefault" title="typing.NoDefault"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.NoDefault</span></code></a> if it
has no default.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="typing.TypeVar.evaluate_default">
<span class="sig-name descname"><span class="pre">evaluate_default</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeVar.evaluate_default" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">An <a class="reference internal" href="../glossary.html#term-evaluate-function"><span class="xref std std-term">evaluate function</span></a> corresponding to the <a class="reference internal" href="#typing.TypeVar.__default__" title="typing.TypeVar.__default__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__default__</span></code></a> attribute.
When called directly, this method supports only the <a class="reference internal" href="annotationlib.html#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE</span></code></a>
format, which is equivalent to accessing the <a class="reference internal" href="#typing.TypeVar.__default__" title="typing.TypeVar.__default__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__default__</span></code></a> attribute directly,
but the method object can be passed to <a class="reference internal" href="annotationlib.html#annotationlib.call_evaluate_function" title="annotationlib.call_evaluate_function"><code class="xref py py-func docutils literal notranslate"><span class="pre">annotationlib.call_evaluate_function()</span></code></a>
to evaluate the value in a different format.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="typing.TypeVar.has_default">
<span class="sig-name descname"><span class="pre">has_default</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeVar.has_default" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return whether or not the type variable has a default value. This is equivalent
to checking whether <a class="reference internal" href="#typing.TypeVar.__default__" title="typing.TypeVar.__default__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__default__</span></code></a> is not the <a class="reference internal" href="#typing.NoDefault" title="typing.NoDefault"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.NoDefault</span></code></a>
singleton, except that it does not force evaluation of the
<a class="reference internal" href="../reference/executionmodel.html#lazy-evaluation"><span class="std std-ref">lazily evaluated</span></a> default value.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>Ahora es posible declarar variables de tipo utilizando la sintaxis de <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">parámetros de tipo</span></a> introducida por <span class="target" id="index-172"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a>. Se agregó el parámetro <code class="docutils literal notranslate"><span class="pre">infer_variance</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13: </span>Support for default values was added.</p>
</div>
</dd></dl>

<dl class="py class" id="typevartuple">
<dt class="sig sig-object py" id="typing.TypeVarTuple">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeVarTuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">typing.NoDefault</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeVarTuple" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Type variable tuple. A specialized form of <a class="reference internal" href="#typevar"><span class="std std-ref">type variable</span></a>
that enables <em>variadic</em> generics.</p>
<p class="translated">Las tuplas de variables de tipo se pueden declarar en <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">listas de parámetros de tipo</span></a> usando un solo asterisco (<code class="docutils literal notranslate"><span class="pre">*</span></code>) antes del nombre:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">move_first_element_to_last</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">](</span><span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p class="translated">O invocando explícitamente el constructor <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
<span class="n">Ts</span> <span class="o">=</span> <span class="n">TypeVarTuple</span><span class="p">(</span><span class="s2">&quot;Ts&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p class="translated">Una variable de tipo normal permite parametrizar con un solo tipo. Una tupla de variables de tipo, en contraste, permite la parametrización con un número <em>arbitrario</em> de tipos, al actuar como un número <em>arbitrario</em> de variables de tipo envueltas en una tupla. Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># T is bound to int, Ts is bound to ()</span>
<span class="c1"># Return value is (1,), which has type tuple[int]</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>

<span class="c1"># T is bound to int, Ts is bound to (str,)</span>
<span class="c1"># Return value is (&#39;spam&#39;, 1), which has type tuple[str, int]</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">))</span>

<span class="c1"># T is bound to int, Ts is bound to (str, float)</span>
<span class="c1"># Return value is (&#39;spam&#39;, 3.0, 1), which has type tuple[str, float, int]</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;spam&#39;</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">))</span>

<span class="c1"># This fails to type check (and fails at runtime)</span>
<span class="c1"># because tuple[()] is not compatible with tuple[T, *Ts]</span>
<span class="c1"># (at least one element is required)</span>
<span class="n">move_first_element_to_last</span><span class="p">(</span><span class="n">tup</span><span class="o">=</span><span class="p">())</span>
</pre></div>
</div>
<p class="translated">Nótese el uso del operador de desempaquetado <code class="docutils literal notranslate"><span class="pre">*</span></code> en <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">*Ts]</span></code>. Conceptualmente, puede pensarse en <code class="docutils literal notranslate"><span class="pre">Ts</span></code> como una tupla de variables de tipo <code class="docutils literal notranslate"><span class="pre">(T1,</span> <span class="pre">T2,</span> <span class="pre">...)</span></code>. <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">*Ts]</span></code> se convertiría en <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">*(T1,</span> <span class="pre">T2,</span> <span class="pre">...)]</span></code>, lo que es equivalente a <code class="docutils literal notranslate"><span class="pre">tuple[T,</span> <span class="pre">T1,</span> <span class="pre">T2,</span> <span class="pre">...]</span></code>. (Nótese que en versiones más antiguas de Python, ésto puede verse escrito usando en cambio <a class="reference internal" href="#typing.Unpack" title="typing.Unpack"><code class="xref py py-data docutils literal notranslate"><span class="pre">Unpack</span></code></a>, en la forma <code class="docutils literal notranslate"><span class="pre">Unpack[Ts]</span></code>.)</p>
<p class="translated">Las tuplas de variables de tipo <em>siempre</em> deben descomprimirse. Esto ayuda a distinguir las tuplas de variables de tipo, de las variables de tipo normales:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="n">Ts</span>          <span class="c1"># Not valid</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Ts</span><span class="p">]</span>   <span class="c1"># Not valid</span>
<span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">]</span>  <span class="c1"># The correct way to do it</span>
</pre></div>
</div>
<p class="translated">Las tuplas de variables de tipo pueden ser utilizadas en los mismos contextos que las variables de tipo normales. Por ejemplo en definiciones de clases, argumentos y tipos de retorno:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Array[*Shape]&quot;</span><span class="p">:</span> <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">]:</span> <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Las tuplas de variables de tipo se pueden combinar sin problemas con variables de tipo normales:</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]:</span>  <span class="c1"># This is fine</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Array2</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">,</span> <span class="n">DType</span><span class="p">]:</span>  <span class="c1"># This would also be fine</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Height</span><span class="p">:</span> <span class="o">...</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Width</span><span class="p">:</span> <span class="o">...</span>

<span class="n">float_array_1d</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Height</span><span class="p">]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>     <span class="c1"># Totally fine</span>
<span class="n">int_array_2d</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Height</span><span class="p">,</span> <span class="n">Width</span><span class="p">]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>  <span class="c1"># Yup, fine too</span>
</pre></div>
</div>
<p class="translated">Sin embargo, nótese que en una determinada lista de argumentos de tipo o de parámetros de tipo puede haber como máximo una tupla de variables de tipo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">,</span> <span class="o">*</span><span class="n">Ts</span><span class="p">]</span>            <span class="c1"># Not valid</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]:</span>  <span class="c1"># Not valid</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p class="translated">Finalmente, una tupla de variables de tipo desempaquetada puede ser utilizada como la anotación de tipo de <code class="docutils literal notranslate"><span class="pre">*args</span></code>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">call_soon</span><span class="p">[</span><span class="o">*</span><span class="n">Ts</span><span class="p">](</span>
    <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="o">*</span><span class="n">Ts</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span>
    <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="o">*</span><span class="n">Ts</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="n">callback</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">En contraste con las anotaciones no-desempaquetadas de <code class="docutils literal notranslate"><span class="pre">*args</span></code>, por ej. <code class="docutils literal notranslate"><span class="pre">*args:</span> <span class="pre">int</span></code>, que especificaría que <em>todos</em> los argumentos son <code class="docutils literal notranslate"><span class="pre">int</span></code> - <code class="docutils literal notranslate"><span class="pre">*args:</span> <span class="pre">*Ts</span></code> permite referenciar los tipos de los argumentos <em>individuales</em> en <code class="docutils literal notranslate"><span class="pre">*args</span></code>. Aquí, ésto permite asegurarse de que los tipos de los <code class="docutils literal notranslate"><span class="pre">*args</span></code> que son pasados a <code class="docutils literal notranslate"><span class="pre">call_soon</span></code> calcen con los tipos de los argumentos (posicionales) de <code class="docutils literal notranslate"><span class="pre">callback</span></code>.</p>
<p class="translated">Véase <span class="target" id="index-173"></span><a class="pep reference external" href="https://peps.python.org/pep-0646/"><strong>PEP 646</strong></a> para obtener más detalles sobre las tuplas de variables de tipo.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVarTuple.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#typing.TypeVarTuple.__name__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El nombre de la tupla de variables de tipo.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeVarTuple.__default__">
<span class="sig-name descname"><span class="pre">__default__</span></span><a class="headerlink" href="#typing.TypeVarTuple.__default__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The default value of the type variable tuple, or <a class="reference internal" href="#typing.NoDefault" title="typing.NoDefault"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.NoDefault</span></code></a> if it
has no default.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="typing.TypeVarTuple.evaluate_default">
<span class="sig-name descname"><span class="pre">evaluate_default</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeVarTuple.evaluate_default" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">An <a class="reference internal" href="../glossary.html#term-evaluate-function"><span class="xref std std-term">evaluate function</span></a> corresponding to the <a class="reference internal" href="#typing.TypeVarTuple.__default__" title="typing.TypeVarTuple.__default__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__default__</span></code></a> attribute.
When called directly, this method supports only the <a class="reference internal" href="annotationlib.html#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE</span></code></a>
format, which is equivalent to accessing the <a class="reference internal" href="#typing.TypeVarTuple.__default__" title="typing.TypeVarTuple.__default__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__default__</span></code></a> attribute directly,
but the method object can be passed to <a class="reference internal" href="annotationlib.html#annotationlib.call_evaluate_function" title="annotationlib.call_evaluate_function"><code class="xref py py-func docutils literal notranslate"><span class="pre">annotationlib.call_evaluate_function()</span></code></a>
to evaluate the value in a different format.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="typing.TypeVarTuple.has_default">
<span class="sig-name descname"><span class="pre">has_default</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeVarTuple.has_default" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return whether or not the type variable tuple has a default value. This is equivalent
to checking whether <a class="reference internal" href="#typing.TypeVarTuple.__default__" title="typing.TypeVarTuple.__default__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__default__</span></code></a> is not the <a class="reference internal" href="#typing.NoDefault" title="typing.NoDefault"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.NoDefault</span></code></a>
singleton, except that it does not force evaluation of the
<a class="reference internal" href="../reference/executionmodel.html#lazy-evaluation"><span class="std std-ref">lazily evaluated</span></a> default value.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>Ahora es posible declarar tuplas de variables de tipo utilizando la sintaxis de <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">parámetros de tipo</span></a> introducida por <span class="target" id="index-174"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13: </span>Support for default values was added.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ParamSpec">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ParamSpec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contravariant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">typing.NoDefault</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ParamSpec" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Parameter specification variable.  A specialized version of
<a class="reference internal" href="#typevar"><span class="std std-ref">type variables</span></a>.</p>
<p class="translated">En las <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">listas de parámetros de tipo</span></a>, las especificaciones de parámetros se pueden declarar con dos asteriscos (<code class="docutils literal notranslate"><span class="pre">**</span></code>):</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">IntFunc</span><span class="p">[</span><span class="o">**</span><span class="n">P</span><span class="p">]</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
</pre></div>
</div>
<p class="translated">Para compatibilidad con Python 3.11 y versiones anteriores, los objetos <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> también se pueden crear de la siguiente manera:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Las variables de especificación de parámetros existen principalmente para el beneficio de los validadores de tipo estático. Se utilizan para reenviar los tipos de parámetros de un invocable a otro invocable, un patrón que se encuentra comúnmente en funciones y decoradores de orden superior. Solo son válidos cuando se utilizan en <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code>, o como primer argumento de <code class="docutils literal notranslate"><span class="pre">Callable</span></code>, o como parámetros para genéricos definidos por el usuario. Consulte <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> para obtener más información sobre tipos genéricos.</p>
<p class="translated">Por ejemplo, para agregar un registro básico a una función, se puede crear un decorador <code class="docutils literal notranslate"><span class="pre">add_logging</span></code> para registrar llamadas a funciones. La variable de especificación de parámetros le dice al validador de tipo que el invocable pasado al decorador y el nuevo invocable retornado por él tienen parámetros de tipo interdependientes:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>

<span class="k">def</span><span class="w"> </span><span class="nf">add_logging</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">P</span><span class="p">](</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;A type-safe decorator to add logging to a function.&#39;&#39;&#39;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> was called&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>

<span class="nd">@add_logging</span>
<span class="k">def</span><span class="w"> </span><span class="nf">add_two</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Add two numbers together.&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
<p class="untranslated">Without <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code>, the simplest way to annotate this previously was to
use a <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a> with upper bound <code class="docutils literal notranslate"><span class="pre">Callable[...,</span> <span class="pre">Any]</span></code>.  However this
causes two problems:</p>
<ol class="arabic simple">
<li><p class="translated">El validador de tipo no puede verificar la función <code class="docutils literal notranslate"><span class="pre">inner</span></code> porque <code class="docutils literal notranslate"><span class="pre">*args</span></code> y <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> deben escribirse <a class="reference internal" href="#typing.Any" title="typing.Any"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a>.</p></li>
<li><p class="translated">Es posible que se requiera <a class="reference internal" href="#typing.cast" title="typing.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> en el cuerpo del decorador <code class="docutils literal notranslate"><span class="pre">add_logging</span></code> al retornar la función <code class="docutils literal notranslate"><span class="pre">inner</span></code>, o se debe indicar al validador de tipo estático que ignore el <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">inner</span></code>.</p></li>
</ol>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.ParamSpec.args">
<span class="sig-name descname"><span class="pre">args</span></span><a class="headerlink" href="#typing.ParamSpec.args" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.ParamSpec.kwargs">
<span class="sig-name descname"><span class="pre">kwargs</span></span><a class="headerlink" href="#typing.ParamSpec.kwargs" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Dado que <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> captura tanto parámetros posicionales como de palabras clave, <code class="docutils literal notranslate"><span class="pre">P.args</span></code> y <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> se pueden utilizar para dividir un <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> en sus componentes. <code class="docutils literal notranslate"><span class="pre">P.args</span></code> representa la tupla de parámetros posicionales en una llamada determinada y solo debe usarse para anotar <code class="docutils literal notranslate"><span class="pre">*args</span></code>. <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> representa la asignación de parámetros de palabras clave a sus valores en una llamada determinada y solo debe usarse para anotar <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>. Ambos atributos requieren que el parámetro anotado esté dentro del alcance. En tiempo de ejecución, <code class="docutils literal notranslate"><span class="pre">P.args</span></code> y <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> son instancias respectivamente de <a class="reference internal" href="#typing.ParamSpecArgs" title="typing.ParamSpecArgs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecArgs</span></code></a> y <a class="reference internal" href="#typing.ParamSpecKwargs" title="typing.ParamSpecKwargs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecKwargs</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.ParamSpec.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#typing.ParamSpec.__name__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El nombre de la especificación del parámetro.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.ParamSpec.__default__">
<span class="sig-name descname"><span class="pre">__default__</span></span><a class="headerlink" href="#typing.ParamSpec.__default__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The default value of the parameter specification, or <a class="reference internal" href="#typing.NoDefault" title="typing.NoDefault"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.NoDefault</span></code></a> if it
has no default.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="typing.ParamSpec.evaluate_default">
<span class="sig-name descname"><span class="pre">evaluate_default</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.ParamSpec.evaluate_default" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">An <a class="reference internal" href="../glossary.html#term-evaluate-function"><span class="xref std std-term">evaluate function</span></a> corresponding to the <a class="reference internal" href="#typing.ParamSpec.__default__" title="typing.ParamSpec.__default__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__default__</span></code></a> attribute.
When called directly, this method supports only the <a class="reference internal" href="annotationlib.html#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE</span></code></a>
format, which is equivalent to accessing the <a class="reference internal" href="#typing.ParamSpec.__default__" title="typing.ParamSpec.__default__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__default__</span></code></a> attribute directly,
but the method object can be passed to <a class="reference internal" href="annotationlib.html#annotationlib.call_evaluate_function" title="annotationlib.call_evaluate_function"><code class="xref py py-func docutils literal notranslate"><span class="pre">annotationlib.call_evaluate_function()</span></code></a>
to evaluate the value in a different format.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="typing.ParamSpec.has_default">
<span class="sig-name descname"><span class="pre">has_default</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.ParamSpec.has_default" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return whether or not the parameter specification has a default value. This is equivalent
to checking whether <a class="reference internal" href="#typing.ParamSpec.__default__" title="typing.ParamSpec.__default__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__default__</span></code></a> is not the <a class="reference internal" href="#typing.NoDefault" title="typing.NoDefault"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.NoDefault</span></code></a>
singleton, except that it does not force evaluation of the
<a class="reference internal" href="../reference/executionmodel.html#lazy-evaluation"><span class="std std-ref">lazily evaluated</span></a> default value.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<p class="translated">Las variables de especificación de parámetros creadas con <code class="docutils literal notranslate"><span class="pre">covariant=True</span></code> o <code class="docutils literal notranslate"><span class="pre">contravariant=True</span></code> se pueden utilizar para declarar tipos genéricos covariantes o contravariantes. También se acepta el argumento <code class="docutils literal notranslate"><span class="pre">bound</span></code>, similar a <a class="reference internal" href="#typing.TypeVar" title="typing.TypeVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code></a>. Sin embargo, la semántica real de estas palabras clave aún no se ha decidido.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>Las especificaciones de parámetros ahora se pueden declarar utilizando la sintaxis de <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">parámetros de tipo</span></a> introducida por <span class="target" id="index-175"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13: </span>Support for default values was added.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Solo las variables de especificación de parámetros definidas en el ámbito global pueden ser serializadas.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<ul class="simple">
<li><p class="translated"><span class="target" id="index-176"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> - Variables de especificación de parámetros (el PEP que introdujo <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> y <code class="docutils literal notranslate"><span class="pre">Concatenate</span></code>)</p></li>
<li><p class="translated"><a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#annotating-callables"><span class="std std-ref">Anotaciones en objetos invocables</span></a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.ParamSpecArgs">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ParamSpecArgs</span></span><a class="headerlink" href="#typing.ParamSpecArgs" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="typing.ParamSpecKwargs">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ParamSpecKwargs</span></span><a class="headerlink" href="#typing.ParamSpecKwargs" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Argumentos y atributos de argumentos de palabras clave de un <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a>. El atributo <code class="docutils literal notranslate"><span class="pre">P.args</span></code> de un <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> es una instancia de <code class="docutils literal notranslate"><span class="pre">ParamSpecArgs</span></code> y <code class="docutils literal notranslate"><span class="pre">P.kwargs</span></code> es una instancia de <code class="docutils literal notranslate"><span class="pre">ParamSpecKwargs</span></code>. Están pensados para la introspección en tiempo de ejecución y no tienen un significado especial para los validadores de tipo estático.</p>
<p class="translated">Llamar a <a class="reference internal" href="#typing.get_origin" title="typing.get_origin"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_origin()</span></code></a> en cualquiera de estos objetos retornará el <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> original:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">get_origin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.TypeAliasType">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypeAliasType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeAliasType" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El tipo de alias de tipo creado a través de la declaración <a class="reference internal" href="../reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Alias</span><span class="p">)</span>
<span class="go">&lt;class &#39;typing.TypeAliasType&#39;&gt;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeAliasType.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#typing.TypeAliasType.__name__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El nombre del alias de tipo:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Alias</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;Alias&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeAliasType.__module__">
<span class="sig-name descname"><span class="pre">__module__</span></span><a class="headerlink" href="#typing.TypeAliasType.__module__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El módulo en el que se definió el alias de tipo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Alias</span><span class="o">.</span><span class="vm">__module__</span>
<span class="go">&#39;__main__&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeAliasType.__type_params__">
<span class="sig-name descname"><span class="pre">__type_params__</span></span><a class="headerlink" href="#typing.TypeAliasType.__type_params__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Los parámetros de tipo del alias de tipo, o una tupla vacía si el alias no es genérico:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">ListOrSet</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">|</span> <span class="nb">set</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ListOrSet</span><span class="o">.</span><span class="n">__type_params__</span>
<span class="go">(T,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">NotGeneric</span> <span class="o">=</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NotGeneric</span><span class="o">.</span><span class="n">__type_params__</span>
<span class="go">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypeAliasType.__value__">
<span class="sig-name descname"><span class="pre">__value__</span></span><a class="headerlink" href="#typing.TypeAliasType.__value__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El valor del alias de tipo. Se <a class="reference internal" href="../reference/executionmodel.html#lazy-evaluation"><span class="std std-ref">evalúa de forma diferida</span></a>, por lo que los nombres utilizados en la definición del alias no se resuelven hasta que se accede al atributo <code class="docutils literal notranslate"><span class="pre">__value__</span></code>:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Mutually</span> <span class="o">=</span> <span class="n">Recursive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Recursive</span> <span class="o">=</span> <span class="n">Mutually</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mutually</span>
<span class="go">Mutually</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Recursive</span>
<span class="go">Recursive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mutually</span><span class="o">.</span><span class="n">__value__</span>
<span class="go">Recursive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Recursive</span><span class="o">.</span><span class="n">__value__</span>
<span class="go">Mutually</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="typing.TypeAliasType.evaluate_value">
<span class="sig-name descname"><span class="pre">evaluate_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypeAliasType.evaluate_value" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">An <a class="reference internal" href="../glossary.html#term-evaluate-function"><span class="xref std std-term">evaluate function</span></a> corresponding to the <a class="reference internal" href="#typing.TypeAliasType.__value__" title="typing.TypeAliasType.__value__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__value__</span></code></a> attribute.
When called directly, this method supports only the <a class="reference internal" href="annotationlib.html#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE</span></code></a>
format, which is equivalent to accessing the <a class="reference internal" href="#typing.TypeAliasType.__value__" title="typing.TypeAliasType.__value__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__value__</span></code></a> attribute directly,
but the method object can be passed to <a class="reference internal" href="annotationlib.html#annotationlib.call_evaluate_function" title="annotationlib.call_evaluate_function"><code class="xref py py-func docutils literal notranslate"><span class="pre">annotationlib.call_evaluate_function()</span></code></a>
to evaluate the value in a different format:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="n">undefined</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Alias</span><span class="o">.</span><span class="n">__value__</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NameError</span>: <span class="n">name &#39;undefined&#39; is not defined</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">annotationlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Format</span><span class="p">,</span> <span class="n">call_evaluate_function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Alias</span><span class="o">.</span><span class="n">evaluate_value</span><span class="p">(</span><span class="n">Format</span><span class="o">.</span><span class="n">VALUE</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NameError</span>: <span class="n">name &#39;undefined&#39; is not defined</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">call_evaluate_function</span><span class="p">(</span><span class="n">Alias</span><span class="o">.</span><span class="n">evaluate_value</span><span class="p">,</span> <span class="n">Format</span><span class="o">.</span><span class="n">FORWARDREF</span><span class="p">)</span>
<span class="go">ForwardRef(&#39;undefined&#39;)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<p class="untranslated rubric">Unpacking</p>
<p class="untranslated">Type aliases support star unpacking using the <code class="docutils literal notranslate"><span class="pre">*Alias</span></code> syntax.
This is equivalent to using <code class="docutils literal notranslate"><span class="pre">Unpack[Alias]</span></code> directly:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Unpacked</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="o">*</span><span class="n">Alias</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Unpacked</span><span class="o">.</span><span class="n">__value__</span>
<span class="go">tuple[bool, typing.Unpack[Alias]]</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

</section>
<section id="other-special-directives">
<h4 class="translated">Otras directivas especiales<a class="headerlink" href="#other-special-directives" title="Link to this heading">¶</a></h4>
<p class="translated">Estas funciones y clases no se deben utilizar directamente como anotaciones. Su finalidad es servir de bloques de construcción para crear y declarar tipos.</p>
<dl class="py class">
<dt class="sig sig-object py" id="typing.NamedTuple">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NamedTuple</span></span><a class="headerlink" href="#typing.NamedTuple" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Versión para anotación de tipos de <a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a>.</p>
<p class="translated">Uso:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p class="translated">Esto es equivalente a:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Employee</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p class="translated">Para proporcionar a un campo un valor por defecto se puede asignar en el cuerpo de la clase:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">employee</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="s1">&#39;Guido&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">employee</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="mi">3</span>
</pre></div>
</div>
<p class="translated">Los campos con un valor por defecto deben ir después de los campos sin valor por defecto.</p>
<p class="translated">La clase resultante tiene un atributo extra <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> que proporciona un diccionario que mapea el nombre de los campos con sus respectivos tipos. (Los nombres de los campos están en el atributo <code class="docutils literal notranslate"><span class="pre">_fields</span></code> y sus valores por defecto en el atributo <code class="docutils literal notranslate"><span class="pre">_field_defaults</span></code>, ambos parte de la API <a class="reference internal" href="collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">namedtuple()</span></code></a>.)</p>
<p class="translated">Las subclases de <code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> también pueden tener <em>docstrings</em> y métodos:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Employee</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents an employee.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;Employee </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">, id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s1">&gt;&#39;</span>
</pre></div>
</div>
<p class="translated">Las subclases de <code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> pueden ser genéricas:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Group</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
</pre></div>
</div>
<p class="translated">Uso retrocompatible:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># For creating a generic NamedTuple on Python 3.11</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Group</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>

<span class="c1"># A functional syntax is also supported</span>
<span class="n">Employee</span> <span class="o">=</span> <span class="n">NamedTuple</span><span class="p">(</span><span class="s1">&#39;Employee&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Soporte añadido para la sintaxis de anotación de variables propuesto en <span class="target" id="index-177"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6.1: </span>Soporte añadido para valores por defecto, métodos y <em>docstrings</em>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.8: </span>Los atributos <code class="docutils literal notranslate"><span class="pre">_field_types</span></code> y <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> son simples diccionarios en vez de instancias de <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>Se remueve el atributo <code class="docutils literal notranslate"><span class="pre">_field_types</span></code> en favor del atributo más estándar <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> que tiene la misma información.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Se agrega soporte para <em>namedtuples</em> genéricas.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.14: </span>Using <a class="reference internal" href="functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> (and the <code class="docutils literal notranslate"><span class="pre">__class__</span></code> <a class="reference internal" href="../glossary.html#term-closure-variable"><span class="xref std std-term">closure variable</span></a>) in methods of <code class="docutils literal notranslate"><span class="pre">NamedTuple</span></code> subclasses
is unsupported and causes a <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.NewType">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NewType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.NewType" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Clase auxiliar para crear <a class="reference internal" href="#distinct"><span class="std std-ref">tipos distintos</span></a> con bajo consumo de recursos.</p>
<p class="translated">Un validador de tipos considera que un <code class="docutils literal notranslate"><span class="pre">NewType</span></code> es un tipo distinto. Sin embargo, en tiempo de ejecución, llamar a un <code class="docutils literal notranslate"><span class="pre">NewType</span></code> devuelve su argumento sin cambios.</p>
<p class="translated">Uso:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">UserId</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;UserId&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>  <span class="c1"># Declare the NewType &quot;UserId&quot;</span>
<span class="n">first_user</span> <span class="o">=</span> <span class="n">UserId</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># &quot;UserId&quot; returns the argument unchanged at runtime</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.NewType.__module__">
<span class="sig-name descname"><span class="pre">__module__</span></span><a class="headerlink" href="#typing.NewType.__module__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El módulo en el que se define el nuevo tipo.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.NewType.__name__">
<span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#typing.NewType.__name__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El nombre del nuevo tipo.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.NewType.__supertype__">
<span class="sig-name descname"><span class="pre">__supertype__</span></span><a class="headerlink" href="#typing.NewType.__supertype__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">El tipo en el que se basa el nuevo tipo.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span><code class="docutils literal notranslate"><span class="pre">NewType</span></code> es ahora una clase en lugar de una función.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Protocol">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Protocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Generic</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Protocol" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Clase base para clases de protocolo.</p>
<p class="translated">Las clases de protocolo se definen así:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Proto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Tales clases son usadas principalmente con validadores estáticos de tipos que detectan subtipado estructural (<em>duck-typing</em> estático), por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Proto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">meth</span><span class="p">()</span>

<span class="n">func</span><span class="p">(</span><span class="n">C</span><span class="p">())</span>  <span class="c1"># Passes static type check</span>
</pre></div>
</div>
<p class="untranslated">See <span class="target" id="index-32"></span><a class="pep reference external" href="https://peps.python.org/pep-0544/"><strong>PEP 544</strong></a> for more details. Protocol classes decorated with
<a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code></a> (described later) act as simple-minded runtime
protocols that check only the presence of given attributes, ignoring their
type signatures. Protocol classes without this decorator cannot be used
as the second argument to <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> or <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>.</p>
<p class="translated">Las clases protocolo pueden ser genéricas, por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">GenProto</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p class="translated">En el código que necesita ser compatible con Python 3.11 o anterior, los protocolos genéricos se pueden escribir de la siguiente manera:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">GenProto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.runtime_checkable">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">runtime_checkable</span></span><a class="headerlink" href="#typing.runtime_checkable" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Marca una clase protocolo como aplicable en tiempo de ejecución (lo convierte en un <em>runtime protocol</em>).</p>
<p class="untranslated">Such a protocol can be used with <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> and <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>.
This allows a simple-minded structural check, very similar to «one trick ponies»
in <a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> such as <a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>.  For example:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@runtime_checkable</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Closable</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/some/file&#39;</span><span class="p">),</span> <span class="n">Closable</span><span class="p">)</span>

<span class="nd">@runtime_checkable</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Named</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">threading</span>
<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Bob&#39;</span><span class="p">),</span> <span class="n">Named</span><span class="p">)</span>
</pre></div>
</div>
<p class="untranslated">This decorator raises <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> when applied to a non-protocol class.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">runtime_checkable()</span></code> comprobará únicamente la presencia de los métodos o atributos requeridos, no sus firmas de tipo o tipos. Por ejemplo, <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a> es una clase, por lo tanto, pasa una comprobación <a class="reference internal" href="functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> contra <a class="reference internal" href="#annotating-callables"><span class="std std-ref">Callable</span></a>. Sin embargo, el método <code class="docutils literal notranslate"><span class="pre">ssl.SSLObject.__init__</span></code> existe únicamente para generar un <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> con un mensaje más informativo, por lo que es imposible llamar (instanciar) <a class="reference internal" href="ssl.html#ssl.SSLObject" title="ssl.SSLObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Una verificación <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> contra un protocolo comprobable en tiempo de ejecución puede ser sorprendentemente lenta en comparación con una verificación <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code> contra una clase que no es de protocolo. Considere utilizar expresiones alternativas como llamadas <a class="reference internal" href="functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> para comprobaciones estructurales en código sensible al rendimiento.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>La implementación interna de las comprobaciones de <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> con protocolos que se pueden comprobar en tiempo de ejecución ahora utiliza <a class="reference internal" href="inspect.html#inspect.getattr_static" title="inspect.getattr_static"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getattr_static()</span></code></a> para buscar atributos (anteriormente, se utilizaba <a class="reference internal" href="functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a>). Como resultado, algunos objetos que solían considerarse instancias de un protocolo que se podía comprobar en tiempo de ejecución ya no se consideran instancias de ese protocolo en Python 3.12+, y viceversa. Es poco probable que la mayoría de los usuarios se vean afectados por este cambio.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>The members of a runtime-checkable protocol are now considered «frozen»
at runtime as soon as the class has been created. Monkey-patching
attributes onto a runtime-checkable protocol will still work, but will
have no impact on <a class="reference internal" href="functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> checks comparing objects to the
protocol. See <a class="reference internal" href="../whatsnew/3.12.html#whatsnew-typing-py312"><span class="std std-ref">What’s new in Python 3.12</span></a>
for more details.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.TypedDict">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TypedDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.TypedDict" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Es una construcción especial para añadir indicadores de tipo a un diccionario. En tiempo de ejecución es un <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> simple.</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> crea un tipo de diccionario que espera que todas sus instancias tenga un cierto conjunto de claves, donde cada clave está asociada con un valor de un tipo determinado. Esta exigencia no se comprueba en tiempo de ejecución y solo es aplicada por validadores de tipo. Uso:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span>

<span class="n">a</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;good&#39;</span><span class="p">}</span>  <span class="c1"># OK</span>
<span class="n">b</span><span class="p">:</span> <span class="n">Point2D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;bad&#39;</span><span class="p">}</span>           <span class="c1"># Fails type check</span>

<span class="k">assert</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="untranslated">An alternative way to create a <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> is by using
function-call syntax. The second argument must be a literal <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">})</span>
</pre></div>
</div>
<p class="untranslated">This functional syntax allows defining keys which are not valid
<a class="reference internal" href="../reference/lexical_analysis.html#identifiers"><span class="std std-ref">identifiers</span></a>, for example because they are
keywords or contain hyphens, or when key names must not be
<a class="reference internal" href="../reference/expressions.html#private-name-mangling"><span class="std std-ref">mangled</span></a> like regular private names:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># raises SyntaxError</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="ow">in</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># &#39;in&#39; is a keyword</span>
    <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># name with hyphens</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Definition</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">__schema</span><span class="p">:</span> <span class="nb">str</span>  <span class="c1"># mangled to `_Definition__schema`</span>

<span class="c1"># OK, functional syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;x-y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">})</span>
<span class="n">Definition</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Definition&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;__schema&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">})</span>  <span class="c1"># not mangled</span>
</pre></div>
</div>
<p class="translated">De forma predeterminada, todas las llaves deben estar presentes en un <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>. Es posible marcar llaves individuales como <em>no requeridas</em> utilizando <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">label</span><span class="p">:</span> <span class="n">NotRequired</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

<span class="c1"># Alternative syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="n">NotRequired</span><span class="p">[</span><span class="nb">str</span><span class="p">]})</span>
</pre></div>
</div>
<p class="translated">Esto significa que en un <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> que sea una instancia de <code class="docutils literal notranslate"><span class="pre">Point2D</span></code>, será posible omitir la llave <code class="docutils literal notranslate"><span class="pre">label</span></code>.</p>
<p class="translated">Además, es posible marcar todas las llaves como no-requeridas por defecto, al especificar un valor de <code class="docutils literal notranslate"><span class="pre">False</span></code> en el argumento <em>total</em>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="c1"># Alternative syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">},</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Esto significa que un <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> <code class="docutils literal notranslate"><span class="pre">Point2D</span></code> puede tener cualquiera de las llaves omitidas. Solo se espera que un validador de tipo admita un <code class="docutils literal notranslate"><span class="pre">False</span></code> literal o <code class="docutils literal notranslate"><span class="pre">True</span></code> como valor del argumento <code class="docutils literal notranslate"><span class="pre">total</span></code>. <code class="docutils literal notranslate"><span class="pre">True</span></code> es el predeterminado y hace que todos los elementos definidos en el cuerpo de la clase sean obligatorios.</p>
<p class="translated">Las llaves individuales de un <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> <code class="docutils literal notranslate"><span class="pre">total=False</span></code> pueden ser marcadas como requeridas utilizando <a class="reference internal" href="#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span>

<span class="c1"># Alternative syntax</span>
<span class="n">Point2D</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s1">&#39;Point2D&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">Required</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">},</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Es posible que un tipo <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> herede de uno o más tipos <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> usando la sintaxis de clase. Uso:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">Point3D</span></code> tiene tres elementos: <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> y <code class="docutils literal notranslate"><span class="pre">z</span></code>. Lo que es equivalente a la siguiente definición:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Point3D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
<p class="translated">Un <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> no puede heredar de una clase que no sea una subclase de <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>, exceptuando <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>. Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">X</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Y</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Z</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># A non-TypedDict class</span>

<span class="k">class</span><span class="w"> </span><span class="nc">XY</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># OK</span>

<span class="k">class</span><span class="w"> </span><span class="nc">XZ</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># raises TypeError</span>
</pre></div>
</div>
<p class="translated">Un <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> puede ser genérico:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Group</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
</pre></div>
</div>
<p class="translated">Para crear un <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> genérico que sea compatible con Python 3.11 o anterior, herede de <a class="reference internal" href="#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a> explícitamente:</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Group</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">T</span>
    <span class="n">group</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
</pre></div>
</div>
<p class="untranslated">A <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> can be introspected via annotations dicts
(see <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">Prácticas recomendadas para las anotaciones</span></a> for more information on annotations best practices),
<a class="reference internal" href="#typing.TypedDict.__total__" title="typing.TypedDict.__total__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__total__</span></code></a>, <a class="reference internal" href="#typing.TypedDict.__required_keys__" title="typing.TypedDict.__required_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__required_keys__</span></code></a>, and <a class="reference internal" href="#typing.TypedDict.__optional_keys__" title="typing.TypedDict.__optional_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__optional_keys__</span></code></a>.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__total__">
<span class="sig-name descname"><span class="pre">__total__</span></span><a class="headerlink" href="#typing.TypedDict.__total__" title="Link to this definition">¶</a></dt>
<dd><p class="translated"><code class="docutils literal notranslate"><span class="pre">Point2D.__total__</span></code> proporciona el valor del argumento <code class="docutils literal notranslate"><span class="pre">total</span></code>. Ejemplo:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypedDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point2D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point2D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__total__</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="untranslated">This attribute reflects <em>only</em> the value of the <code class="docutils literal notranslate"><span class="pre">total</span></code> argument
to the current <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> class, not whether the class is semantically
total. For example, a <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> with <code class="docutils literal notranslate"><span class="pre">__total__</span></code> set to <code class="docutils literal notranslate"><span class="pre">True</span></code> may
have keys marked with <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a>, or it may inherit from another
<code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> with <code class="docutils literal notranslate"><span class="pre">total=False</span></code>. Therefore, it is generally better to use
<a class="reference internal" href="#typing.TypedDict.__required_keys__" title="typing.TypedDict.__required_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__required_keys__</span></code></a> and <a class="reference internal" href="#typing.TypedDict.__optional_keys__" title="typing.TypedDict.__optional_keys__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__optional_keys__</span></code></a> for introspection.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__required_keys__">
<span class="sig-name descname"><span class="pre">__required_keys__</span></span><a class="headerlink" href="#typing.TypedDict.__required_keys__" title="Link to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__optional_keys__">
<span class="sig-name descname"><span class="pre">__optional_keys__</span></span><a class="headerlink" href="#typing.TypedDict.__optional_keys__" title="Link to this definition">¶</a></dt>
<dd><p class="translated"><code class="docutils literal notranslate"><span class="pre">Point2D.__required_keys__</span></code> y <code class="docutils literal notranslate"><span class="pre">Point2D.__optional_keys__</span></code> retornan objetos de la clase <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>, que contienen las llaves requeridas y no requeridas, respectivamente.</p>
<p class="translated">Las llaves marcadas con <a class="reference internal" href="#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a> siempre aparecerán en <code class="docutils literal notranslate"><span class="pre">__required_keys__</span></code> y las llaves marcadas con <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a> siempre aparecerán en <code class="docutils literal notranslate"><span class="pre">__optional_keys__</span></code>.</p>
<p class="translated">Para compatibilidad con versiones anteriores de Python 3.10, también es posible usar la herencia para declarar claves obligatorias y no obligatorias en el mismo <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>. Esto se hace declarando un <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> con un valor para el argumento <code class="docutils literal notranslate"><span class="pre">total</span></code> y luego heredando de él en otro <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> con un valor diferente para <code class="docutils literal notranslate"><span class="pre">total</span></code>:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Point2D</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">... </span>    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Point3D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">z</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__required_keys__</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;z&#39;</span><span class="p">})</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Point3D</span><span class="o">.</span><span class="n">__optional_keys__</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">If <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code> is used or if annotations
are given as strings, annotations are not evaluated when the
<code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> is defined. Therefore, the runtime introspection that
<code class="docutils literal notranslate"><span class="pre">__required_keys__</span></code> and <code class="docutils literal notranslate"><span class="pre">__optional_keys__</span></code> rely on may not work
properly, and the values of the attributes may be incorrect.</p>
</div>
</dd></dl>

<p class="untranslated">Support for <a class="reference internal" href="#typing.ReadOnly" title="typing.ReadOnly"><code class="xref py py-data docutils literal notranslate"><span class="pre">ReadOnly</span></code></a> is reflected in the following attributes:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__readonly_keys__">
<span class="sig-name descname"><span class="pre">__readonly_keys__</span></span><a class="headerlink" href="#typing.TypedDict.__readonly_keys__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> containing the names of all read-only keys. Keys
are read-only if they carry the <a class="reference internal" href="#typing.ReadOnly" title="typing.ReadOnly"><code class="xref py py-data docutils literal notranslate"><span class="pre">ReadOnly</span></code></a> qualifier.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="typing.TypedDict.__mutable_keys__">
<span class="sig-name descname"><span class="pre">__mutable_keys__</span></span><a class="headerlink" href="#typing.TypedDict.__mutable_keys__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> containing the names of all mutable keys. Keys
are mutable if they do not carry the <a class="reference internal" href="#typing.ReadOnly" title="typing.ReadOnly"><code class="xref py py-data docutils literal notranslate"><span class="pre">ReadOnly</span></code></a> qualifier.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<p class="untranslated">See the <a class="reference external" href="https://typing.python.org/en/latest/spec/typeddict.html#typeddict">TypedDict</a> section in the typing documentation for more examples and detailed rules.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Se agrega soporte para marcar llaves individuales como <a class="reference internal" href="#typing.Required" title="typing.Required"><code class="xref py py-data docutils literal notranslate"><span class="pre">Required</span></code></a> o <a class="reference internal" href="#typing.NotRequired" title="typing.NotRequired"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotRequired</span></code></a>. Véase <span class="target" id="index-178"></span><a class="pep reference external" href="https://peps.python.org/pep-0655/"><strong>PEP 655</strong></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Se agrega soporte para <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> genéricos.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13: </span>Removed support for the keyword-argument method of creating <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>s.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13: </span>Support for the <a class="reference internal" href="#typing.ReadOnly" title="typing.ReadOnly"><code class="xref py py-data docutils literal notranslate"><span class="pre">ReadOnly</span></code></a> qualifier was added.</p>
</div>
</dd></dl>

</section>
</section>
<section id="protocols">
<h3 class="translated">Protocolos<a class="headerlink" href="#protocols" title="Link to this heading">¶</a></h3>
<p class="untranslated">The following protocols are provided by the <code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> module. All are decorated
with <a class="reference internal" href="#typing.runtime_checkable" title="typing.runtime_checkable"><code class="xref py py-deco docutils literal notranslate"><span class="pre">&#64;runtime_checkable</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsAbs">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsAbs</span></span><a class="headerlink" href="#typing.SupportsAbs" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una ABC con un método abstracto <code class="docutils literal notranslate"><span class="pre">__abs__</span></code> que es covariante en su tipo retornado.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsBytes">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsBytes</span></span><a class="headerlink" href="#typing.SupportsBytes" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una ABC con un método abstracto <code class="docutils literal notranslate"><span class="pre">__bytes__</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsComplex">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsComplex</span></span><a class="headerlink" href="#typing.SupportsComplex" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una ABC con un método abstracto <code class="docutils literal notranslate"><span class="pre">__complex__</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsFloat">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsFloat</span></span><a class="headerlink" href="#typing.SupportsFloat" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una ABC con un método abstracto <code class="docutils literal notranslate"><span class="pre">__float__</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsIndex">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsIndex</span></span><a class="headerlink" href="#typing.SupportsIndex" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una ABC con un método abstracto <code class="docutils literal notranslate"><span class="pre">__index__</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsInt">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsInt</span></span><a class="headerlink" href="#typing.SupportsInt" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una ABC con un método abstracto <code class="docutils literal notranslate"><span class="pre">__int__</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.SupportsRound">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">SupportsRound</span></span><a class="headerlink" href="#typing.SupportsRound" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Una ABC con un método abstracto <code class="docutils literal notranslate"><span class="pre">__round__</span></code> que es covariantes en su tipo retornado.</p>
</dd></dl>

</section>
<section id="abcs-and-protocols-for-working-with-i-o">
<span id="typing-io"></span><h3 class="untranslated">ABCs and Protocols for working with I/O<a class="headerlink" href="#abcs-and-protocols-for-working-with-i-o" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="typing.IO">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">IO</span></span><span class="sig-paren">[</span><em class="sig-param"><span class="n"><span class="pre">AnyStr</span></span></em><span class="sig-paren">]</span><a class="headerlink" href="#typing.IO" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="typing.TextIO">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TextIO</span></span><span class="sig-paren">[</span><em class="sig-param"><span class="n"><span class="pre">AnyStr</span></span></em><span class="sig-paren">]</span><a class="headerlink" href="#typing.TextIO" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="typing.BinaryIO">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">BinaryIO</span></span><span class="sig-paren">[</span><em class="sig-param"><span class="n"><span class="pre">AnyStr</span></span></em><span class="sig-paren">]</span><a class="headerlink" href="#typing.BinaryIO" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Generic class <code class="docutils literal notranslate"><span class="pre">IO[AnyStr]</span></code> and its subclasses <code class="docutils literal notranslate"><span class="pre">TextIO(IO[str])</span></code>
and <code class="docutils literal notranslate"><span class="pre">BinaryIO(IO[bytes])</span></code>
represent the types of I/O streams such as returned by
<a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>. Please note that these classes are not protocols, and
their interface is fairly broad.</p>
</dd></dl>

<p class="untranslated">The protocols <a class="reference internal" href="io.html#io.Reader" title="io.Reader"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.Reader</span></code></a> and <a class="reference internal" href="io.html#io.Writer" title="io.Writer"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.Writer</span></code></a> offer a simpler
alternative for argument types, when only the <code class="docutils literal notranslate"><span class="pre">read()</span></code> or <code class="docutils literal notranslate"><span class="pre">write()</span></code>
methods are accessed, respectively:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">read_and_write</span><span class="p">(</span><span class="n">reader</span><span class="p">:</span> <span class="n">Reader</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">writer</span><span class="p">:</span> <span class="n">Writer</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
</pre></div>
</div>
<p class="untranslated">Also consider using <a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a> for iterating over
the lines of an input stream:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">read_config</span><span class="p">(</span><span class="n">stream</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
</section>
<section id="functions-and-decorators">
<h3 class="translated">Funciones y decoradores<a class="headerlink" href="#functions-and-decorators" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="typing.cast">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.cast" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Convertir un valor a un tipo.</p>
<p class="translated">Esto retorna el valor sin modificar. Para el validador de tipos esto indica que el valor de retorno tiene el tipo señalado pero, de manera intencionada, no se comprobará en tiempo de ejecución (para maximizar la velocidad).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.assert_type">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">assert_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">typ</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.assert_type" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Solicitar a un validador de tipos que confirme que <em>val</em> tiene <em>typ</em> por tipo inferido.</p>
<p class="translated">En tiempo de ejecución esto no hace nada: devuelve el primer argumento sin cambios, sin verificaciones ni efectos secundarios, sin importar el tipo real del argumento.</p>
<p class="translated">Cuando un validador de tipo estático encuentra una llamada a <code class="docutils literal notranslate"><span class="pre">assert_type()</span></code>, emite un error si el valor no es del tipo especificado:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>  <span class="c1"># OK, inferred type of `name` is `str`</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>  <span class="c1"># type checker error</span>
</pre></div>
</div>
<p class="translated">Esta función es útil para asegurarse de que la comprensión que el validador de tipos tiene sobre un <em>script</em> está alineada con las intenciones de le desarrolladores:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">complex_function</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">object</span><span class="p">):</span>
    <span class="c1"># Do some complex type-narrowing logic,</span>
    <span class="c1"># after which we hope the inferred type will be `int`</span>
    <span class="o">...</span>
    <span class="c1"># Test whether the type checker correctly understands our function</span>
    <span class="n">assert_type</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.assert_never">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">assert_never</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.assert_never" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Solicitar a un validador estático de tipos confirmar que una línea de código no es alcanzable.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">int_or_str</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">match</span> <span class="n">arg</span><span class="p">:</span>
        <span class="k">case</span> <span class="nb">int</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s an int&quot;</span><span class="p">)</span>
        <span class="k">case</span> <span class="nb">str</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;It&#39;s a str&quot;</span><span class="p">)</span>
        <span class="k">case</span><span class="w"> </span><span class="k">_</span> <span class="k">as</span> <span class="n">unreachable</span><span class="p">:</span>
            <span class="n">assert_never</span><span class="p">(</span><span class="n">unreachable</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Aquí, las anotaciones permiten al validador de tipos inferir que el último caso nunca puede ejecutarse, porque <code class="docutils literal notranslate"><span class="pre">arg</span></code> es un <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> o un <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, y ambas opciones están cubiertas por los casos anteriores.</p>
<p class="translated">Si un validador de tipos encuentra que una llamada a <code class="docutils literal notranslate"><span class="pre">assert_never()</span></code> es alcanzable, emitirá un error. Por ejemplo, si la anotación de tipo para <code class="docutils literal notranslate"><span class="pre">arg</span></code> fuese en cambio <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">|</span> <span class="pre">str</span> <span class="pre">|</span> <span class="pre">float</span></code>, el validador de tipos emitiría un error que indicaría que <code class="docutils literal notranslate"><span class="pre">unreachable</span></code> es de tipo <a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>. Para que una llamada a <code class="docutils literal notranslate"><span class="pre">assert_never</span></code> pase la verificación de tipos, el tipo inferido del argumento pasado debe ser el tipo inferior, <a class="reference internal" href="#typing.Never" title="typing.Never"><code class="xref py py-data docutils literal notranslate"><span class="pre">Never</span></code></a>, y nada más.</p>
<p class="translated">En tiempo de ejecución, ésto lanza una excepción cuando es llamado.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="untranslated"><a class="reference external" href="https://typing.python.org/en/latest/guides/unreachable.html">Unreachable Code and Exhaustiveness Checking</a> has more
information about exhaustiveness checking with static typing.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.reveal_type">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">reveal_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.reveal_type" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Ask a static type checker to reveal the inferred type of an expression.</p>
<p class="untranslated">When a static type checker encounters a call to this function,
it emits a diagnostic with the inferred type of the argument. For example:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">reveal_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Revealed type is &quot;builtins.int&quot;</span>
</pre></div>
</div>
<p class="translated">Ésto puede ser de utilidad cuando se desea <em>debuguear</em> cómo tu validador de tipos maneja una pieza particular de código.</p>
<p class="untranslated">At runtime, this function prints the runtime type of its argument to
<a class="reference internal" href="sys.html#sys.stderr" title="sys.stderr"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stderr</span></code></a> and returns the argument unchanged (allowing the call to
be used within an expression):</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">reveal_type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># prints &quot;Runtime type is int&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># prints &quot;1&quot;</span>
</pre></div>
</div>
<p class="untranslated">Note that the runtime type may be different from (more or less specific
than) the type statically inferred by a type checker.</p>
<p class="untranslated">Most type checkers support <code class="docutils literal notranslate"><span class="pre">reveal_type()</span></code> anywhere, even if the
name is not imported from <code class="docutils literal notranslate"><span class="pre">typing</span></code>. Importing the name from
<code class="docutils literal notranslate"><span class="pre">typing</span></code>, however, allows your code to run without runtime errors and
communicates intent more clearly.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.dataclass_transform">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">dataclass_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kw_only_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frozen_default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_specifiers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.dataclass_transform" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Decorador para marcar un objeto como si proporcionara un comportamiento similar a <a class="reference internal" href="dataclasses.html#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclass</span></code></a>.</p>
<p class="untranslated"><code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code> may be used to
decorate a class, metaclass, or a function that is itself a decorator.
The presence of <code class="docutils literal notranslate"><span class="pre">&#64;dataclass_transform()</span></code> tells a static type checker that the
decorated object performs runtime «magic» that
transforms a class in a similar way to
<a class="reference internal" href="dataclasses.html#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-deco docutils literal notranslate"><span class="pre">&#64;dataclasses.dataclass</span></code></a>.</p>
<p class="translated">Ejemplo de uso con una función decoradora:</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass_transform</span><span class="p">()</span>
<span class="k">def</span><span class="w"> </span><span class="nf">create_model</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="bp">cls</span>

<span class="nd">@create_model</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CustomerModel</span><span class="p">:</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</pre></div>
</div>
<p class="translated">En una clase base:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass_transform</span><span class="p">()</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ModelBase</span><span class="p">:</span> <span class="o">...</span>

<span class="k">class</span><span class="w"> </span><span class="nc">CustomerModel</span><span class="p">(</span><span class="n">ModelBase</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</pre></div>
</div>
<p class="translated">En una metaclase:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@dataclass_transform</span><span class="p">()</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ModelMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span> <span class="o">...</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ModelBase</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ModelMeta</span><span class="p">):</span> <span class="o">...</span>

<span class="k">class</span><span class="w"> </span><span class="nc">CustomerModel</span><span class="p">(</span><span class="n">ModelBase</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
</pre></div>
</div>
<p class="untranslated">The <code class="docutils literal notranslate"><span class="pre">CustomerModel</span></code> classes defined above will
be treated by type checkers similarly to classes created with
<a class="reference internal" href="dataclasses.html#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-deco docutils literal notranslate"><span class="pre">&#64;dataclasses.dataclass</span></code></a>.
For example, type checkers will assume these classes have
<code class="docutils literal notranslate"><span class="pre">__init__</span></code> methods that accept <code class="docutils literal notranslate"><span class="pre">id</span></code> and <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
<p class="untranslated">The decorated class, metaclass, or function may accept the following bool
arguments which type checkers will assume have the same effect as they
would have on the
<a class="reference internal" href="dataclasses.html#dataclasses.dataclass" title="dataclasses.dataclass"><code class="xref py py-deco docutils literal notranslate"><span class="pre">&#64;dataclasses.dataclass</span></code></a> decorator: <code class="docutils literal notranslate"><span class="pre">init</span></code>,
<code class="docutils literal notranslate"><span class="pre">eq</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span></code>, <code class="docutils literal notranslate"><span class="pre">unsafe_hash</span></code>, <code class="docutils literal notranslate"><span class="pre">frozen</span></code>, <code class="docutils literal notranslate"><span class="pre">match_args</span></code>,
<code class="docutils literal notranslate"><span class="pre">kw_only</span></code>, and <code class="docutils literal notranslate"><span class="pre">slots</span></code>. It must be possible for the value of these
arguments (<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>) to be statically evaluated.</p>
<p class="translated">Es posible utilizar los argumentos del decorador <code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code> para personalizar los comportamientos por defecto de la clase, metaclase o función decorada:</p>
<dl class="field-list simple">
<dt class="field-odd untranslated">Parámetros<span class="colon">:</span></dt>
<dd class="field-odd untranslated"><ul class="simple">
<li><p><strong>eq_default</strong> (<a class="reference internal" href="functions.html#bool" title="bool"><em>bool</em></a>) – Indica si se asume que el parámetro <code class="docutils literal notranslate"><span class="pre">eq</span></code> es <code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code> si el llamador lo omite. El valor predeterminado es <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><strong>order_default</strong> (<a class="reference internal" href="functions.html#bool" title="bool"><em>bool</em></a>) – Indica si se asume que el parámetro <code class="docutils literal notranslate"><span class="pre">order</span></code> es <code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code> si el llamador lo omite. El valor predeterminado es <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>kw_only_default</strong> (<a class="reference internal" href="functions.html#bool" title="bool"><em>bool</em></a>) – Indica si se asume que el parámetro <code class="docutils literal notranslate"><span class="pre">kw_only</span></code> es <code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code> si el llamador lo omite. El valor predeterminado es <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
<li><p><strong>frozen_default</strong> (<a class="reference internal" href="functions.html#bool" title="bool"><em>bool</em></a>) – Indica si se asume que el parámetro <code class="docutils literal notranslate"><span class="pre">frozen</span></code> es <code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code> si el llamador lo omite. El valor predeterminado es <code class="docutils literal notranslate"><span class="pre">False</span></code>. .. Agregado en la versión:: 3.12</p></li>
<li><p><strong>field_specifiers</strong> (<a class="reference internal" href="stdtypes.html#tuple" title="tuple"><em>tuple</em></a><em>[</em><a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><em>Callable</em></a><em>[</em><em>...</em><em>, </em><em>Any</em><em>]</em><em>, </em><em>...</em><em>]</em>) – Especifica una lista estática de clases o funciones admitidas que describen campos, parecido  con <a class="reference internal" href="dataclasses.html#dataclasses.field" title="dataclasses.field"><code class="xref py py-func docutils literal notranslate"><span class="pre">dataclasses.field()</span></code></a>. El valor predeterminado es <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p></li>
<li><p><strong>**kwargs</strong> (<em>Any</em>) – Es posible pasar arbitrariamente otros argumentos nombrados para permitir posibles extensiones futuras.</p></li>
</ul>
</dd>
</dl>
<p class="translated">Los validadores de tipos reconocen los siguientes parámetros opcionales en los especificadores de campo:</p>
<table class="docutils align-default" id="id7">
<caption class="translated"><span class="caption-text"><strong>Parámetros reconocidos para especificadores de campo</strong></span><a class="headerlink" href="#id7" title="Link to this table">¶</a></caption>
<colgroup>
<col style="width: 20.0%" />
<col style="width: 80.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Nombre del parámetro</p></th>
<th class="head"><p class="translated">Descripción</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">init</span></code></p></td>
<td><p class="translated">Indica si el campo debe incluirse en el método <code class="docutils literal notranslate"><span class="pre">__init__</span></code> sintetizado. Si no se especifica, el valor predeterminado de <code class="docutils literal notranslate"><span class="pre">init</span></code> es <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">default</span></code></p></td>
<td><p class="translated">Proporciona el valor predeterminado para el campo.</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">default_factory</span></code></p></td>
<td><p class="translated">Proporciona una retrollamada en tiempo de ejecución que devuelve el valor predeterminado del campo. Si no se especifican <code class="docutils literal notranslate"><span class="pre">default</span></code> ni <code class="docutils literal notranslate"><span class="pre">default_factory</span></code>, se supone que el campo no tiene un valor predeterminado y se le debe proporcionar un valor cuando se cree una instancia de la clase.</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">factory</span></code></p></td>
<td><p class="translated">Un alias para el parámetro <code class="docutils literal notranslate"><span class="pre">default_factory</span></code> en los especificadores de campo.</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">kw_only</span></code></p></td>
<td><p class="translated">Indica si el campo debe marcarse como solo para palabras clave. Si es <code class="docutils literal notranslate"><span class="pre">True</span></code>, el campo será solo para palabras clave. Si es <code class="docutils literal notranslate"><span class="pre">False</span></code>, no será solo para palabras clave. Si no se especifica, se utilizará el valor del parámetro <code class="docutils literal notranslate"><span class="pre">kw_only</span></code> en el objeto decorado con <code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code>, o si no se especifica, se utilizará el valor de <code class="docutils literal notranslate"><span class="pre">kw_only_default</span></code> en <code class="docutils literal notranslate"><span class="pre">dataclass_transform</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">alias</span></code></p></td>
<td><p class="translated">Proporciona un nombre alternativo para el campo. Este nombre alternativo se utiliza en el método sintetizado <code class="docutils literal notranslate"><span class="pre">__init__</span></code>.</p></td>
</tr>
</tbody>
</table>
<p class="translated">En tiempo de ejecución, este decorador registra sus argumentos en el atributo <code class="docutils literal notranslate"><span class="pre">__dataclass_transform__</span></code> del objeto decorado. No tiene otro efecto en tiempo de ejecución.</p>
<p class="translated">Véase <span class="target" id="index-179"></span><a class="pep reference external" href="https://peps.python.org/pep-0681/"><strong>PEP 681</strong></a> para más detalle.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function" id="overload">
<dt class="sig sig-object py" id="typing.overload">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">overload</span></span><a class="headerlink" href="#typing.overload" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Decorador para crear funciones y métodos sobrecargados.</p>
<p class="translated">El decorador <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> permite describir funciones y métodos que admiten múltiples combinaciones diferentes de tipos de argumentos. Una serie de definiciones decoradas con <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> debe ir seguida de exactamente una definición que no esté decorada con <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> (para la misma función o método).</p>
<p class="translated">Las definiciones decoradas con <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> son solo para beneficio del validador de tipos, ya que serán sobrescritas por la definición no decorada con <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code>. Mientras tanto, la definición no decorada con <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> se usará en tiempo de ejecución, pero el validador de tipos debe ignorarla. En tiempo de ejecución, llamar a una función decorada con <code class="docutils literal notranslate"><span class="pre">&#64;overload</span></code> directamente generará <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>.</p>
<p class="translated">Un ejemplo de sobrecarga que proporciona un tipo más preciso que el que se puede expresar mediante una unión o una variable de tipo:</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="n">response</span><span class="p">):</span>
    <span class="o">...</span>  <span class="c1"># actual implementation goes here</span>
</pre></div>
</div>
<p class="translated">Véase <span class="target" id="index-180"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> para más detalle y comparación con otras semánticas de tipado.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Ahora es posible introspectar en tiempo de ejecución las funciones sobrecargadas utilizando <a class="reference internal" href="#typing.get_overloads" title="typing.get_overloads"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_overloads()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_overloads">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_overloads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_overloads" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return a sequence of <a class="reference internal" href="#typing.overload" title="typing.overload"><code class="xref py py-deco docutils literal notranslate"><span class="pre">&#64;overload</span></code></a>-decorated definitions for
<em>func</em>.</p>
<p class="untranslated"><em>func</em> is the function object for the implementation of the
overloaded function. For example, given the definition of <code class="docutils literal notranslate"><span class="pre">process</span></code> in
the documentation for <a class="reference internal" href="#typing.overload" title="typing.overload"><code class="xref py py-deco docutils literal notranslate"><span class="pre">&#64;overload</span></code></a>,
<code class="docutils literal notranslate"><span class="pre">get_overloads(process)</span></code> will return a sequence of three function objects
for the three defined overloads. If called on a function with no overloads,
<code class="docutils literal notranslate"><span class="pre">get_overloads()</span></code> returns an empty sequence.</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">get_overloads()</span></code> puede ser utilizada para introspectar en tiempo de ejecución una función sobrecargada.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.clear_overloads">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">clear_overloads</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#typing.clear_overloads" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Borra todas las sobrecargas registradas en el registro interno.</p>
<p class="translated">Esto se puede utilizar para recuperar la memoria utilizada por el registro.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.final">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">final</span></span><a class="headerlink" href="#typing.final" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Decorador para indicar métodos finales y clases finales.</p>
<p class="translated">Decorar un método con <code class="docutils literal notranslate"><span class="pre">&#64;final</span></code> indica a un validador de tipos que el método no se puede anular en una subclase. Decorar una clase con <code class="docutils literal notranslate"><span class="pre">&#64;final</span></code> indica que no se puede subclasificar.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="p">:</span>
    <span class="nd">@final</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Sub</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Error reported by type checker</span>
        <span class="o">...</span>

<span class="nd">@final</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Leaf</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Other</span><span class="p">(</span><span class="n">Leaf</span><span class="p">):</span>  <span class="c1"># Error reported by type checker</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">No hay comprobación en tiempo de ejecución para estas propiedades. Véase <span class="target" id="index-181"></span><a class="pep reference external" href="https://peps.python.org/pep-0591/"><strong>PEP 591</strong></a> para más detalles.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>El decorador intentará ahora establecer un atributo <code class="docutils literal notranslate"><span class="pre">__final__</span></code> como <code class="docutils literal notranslate"><span class="pre">True</span></code> en el objeto decorado. Por lo tanto, se puede utilizar una comprobación como <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">getattr(obj,</span> <span class="pre">“__final__”,</span> <span class="pre">False)</span></code> en tiempo de ejecución para determinar si un objeto <code class="docutils literal notranslate"><span class="pre">obj</span></code> se ha marcado como final. Si el objeto decorado no admite la configuración de atributos, el decorador devuelve el objeto sin cambios sin lanzar una excepción.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.no_type_check">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">no_type_check</span></span><a class="headerlink" href="#typing.no_type_check" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Un decorador para indicar que las anotaciones no deben ser comprobadas como indicadores de tipo.</p>
<p class="translated">Esto funciona como un <a class="reference internal" href="../glossary.html#term-decorator"><span class="xref std std-term">decorator</span></a> (decorador) de clase o función. Con una clase, se aplica recursivamente a todos los métodos y clases definidos en esa clase (pero no a los métodos definidos en sus superclases o subclases). Los validadores de tipos ignorarán todas las anotaciones en una función o clase con este decorador.</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">&#64;no_type_check</span></code> muta el objeto decorado en su lugar.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.no_type_check_decorator">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">no_type_check_decorator</span></span><a class="headerlink" href="#typing.no_type_check_decorator" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Decorador para dar a otro decorador el efecto <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a>.</p>
<p class="translated">Esto hace que el decorador decorado añada el efecto de <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">no_type_check()</span></code></a> a la función decorada.</p>
<div class="deprecated-removed">
<p><span class="versionmodified removed">Deprecated since version 3.13, removed in version 3.15: </span>No type checker ever added support for <code class="docutils literal notranslate"><span class="pre">&#64;no_type_check_decorator</span></code>. It
is therefore deprecated, and will be removed in Python 3.15.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.override">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">override</span></span><a class="headerlink" href="#typing.override" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Decorador para indicar que un método en una subclase está destinado a anular un método o atributo en una superclase.</p>
<p class="translated">Los validadores de tipos deberían emitir un error si un método decorado con <code class="docutils literal notranslate"><span class="pre">&#64;override</span></code> no anula nada. Esto ayuda a evitar errores que pueden ocurrir cuando se modifica una clase base sin un cambio equivalente en una clase secundaria.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">log_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Sub</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="nd">@override</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">log_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Okay: overrides Base.log_status</span>
        <span class="o">...</span>

    <span class="nd">@override</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Error reported by type checker</span>
        <span class="o">...</span>
</pre></div>
</div>
<p class="translated">No hay ninguna comprobación en tiempo de ejecución de esta propiedad.</p>
<p class="translated">El decorador intentará establecer un atributo <code class="docutils literal notranslate"><span class="pre">__override__</span></code> en <code class="docutils literal notranslate"><span class="pre">True</span></code> en el objeto decorado. Por lo tanto, una comprobación como <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">getattr(obj,</span> <span class="pre">“__override__”,</span> <span class="pre">False)</span></code> se puede utilizar en tiempo de ejecución para determinar si un objeto <code class="docutils literal notranslate"><span class="pre">obj</span></code> ha sido marcado como anulado. Si el objeto decorado no admite la configuración de atributos, el decorador devuelve el objeto sin cambios sin generar una excepción.</p>
<p class="translated">Vea <span class="target" id="index-182"></span><a class="pep reference external" href="https://peps.python.org/pep-0681/"><strong>PEP 681</strong></a> para más información.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.type_check_only">
<span class="sig-prename descclassname"><span class="pre">&#64;</span></span><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">type_check_only</span></span><a class="headerlink" href="#typing.type_check_only" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Decorador para marcar una clase o función como no disponible en tiempo de ejecución.</p>
<p class="translated">Este decorador no está disponible en tiempo de ejecución. Existe principalmente para marcar clases que se definen en archivos <em>stub</em> para cuando una implementación retorna una instancia de una clase privada:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@type_check_only</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Response</span><span class="p">:</span>  <span class="c1"># private or not available at runtime</span>
    <span class="n">code</span><span class="p">:</span> <span class="nb">int</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">fetch_response</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Nótese que no se recomienda retornar instancias de clases privadas. Normalmente es preferible convertirlas en clases públicas.</p>
</dd></dl>

</section>
<section id="introspection-helpers">
<h3 class="translated">Ayudas de introspección<a class="headerlink" href="#introspection-helpers" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="typing.get_type_hints">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_type_hints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globalns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">localns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_extras</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_type_hints" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna un diccionario que contiene indicaciones de tipo para una función, método, módulo o objeto clase.</p>
<p class="untranslated">This is often the same as <code class="docutils literal notranslate"><span class="pre">obj.__annotations__</span></code>, but this function makes
the following changes to the annotations dictionary:</p>
<ul class="simple">
<li><p class="untranslated">Forward references encoded as string literals or <a class="reference internal" href="#typing.ForwardRef" title="typing.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a>
objects are handled by evaluating them in <em>globalns</em>, <em>localns</em>, and
(where applicable) <em>obj</em>’s <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">type parameter</span></a> namespace.
If <em>globalns</em> or <em>localns</em> is not given, appropriate namespace
dictionaries are inferred from <em>obj</em>.</p></li>
<li><p class="untranslated"><code class="docutils literal notranslate"><span class="pre">None</span></code> is replaced with <a class="reference internal" href="types.html#types.NoneType" title="types.NoneType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.NoneType</span></code></a>.</p></li>
<li><p class="untranslated">If <a class="reference internal" href="#typing.no_type_check" title="typing.no_type_check"><code class="xref py py-deco docutils literal notranslate"><span class="pre">&#64;no_type_check</span></code></a> has been applied to <em>obj</em>, an
empty dictionary is returned.</p></li>
<li><p class="untranslated">If <em>obj</em> is a class <code class="docutils literal notranslate"><span class="pre">C</span></code>, the function returns a dictionary that merges
annotations from <code class="docutils literal notranslate"><span class="pre">C</span></code>’s base classes with those on <code class="docutils literal notranslate"><span class="pre">C</span></code> directly. This
is done by traversing <a class="reference internal" href="../reference/datamodel.html#type.__mro__" title="type.__mro__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">C.__mro__</span></code></a> and iteratively
combining
<code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> dictionaries. Annotations on classes appearing
earlier in the <a class="reference internal" href="../glossary.html#term-method-resolution-order"><span class="xref std std-term">method resolution order</span></a> always take precedence over
annotations on classes appearing later in the method resolution order.</p></li>
<li><p class="untranslated">The function recursively replaces all occurrences of <code class="docutils literal notranslate"><span class="pre">Annotated[T,</span> <span class="pre">...]</span></code>
with <code class="docutils literal notranslate"><span class="pre">T</span></code>, unless <em>include_extras</em> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> (see
<a class="reference internal" href="#typing.Annotated" title="typing.Annotated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Annotated</span></code></a> for more information).</p></li>
</ul>
<p class="untranslated">See also <a class="reference internal" href="annotationlib.html#annotationlib.get_annotations" title="annotationlib.get_annotations"><code class="xref py py-func docutils literal notranslate"><span class="pre">annotationlib.get_annotations()</span></code></a>, a lower-level function that
returns annotations more directly.</p>
<div class="admonition caution">
<p class="admonition-title">Prudencia</p>
<p class="untranslated">This function may execute arbitrary code contained in annotations.
See <a class="reference internal" href="annotationlib.html#annotationlib-security"><span class="std std-ref">Security implications of introspecting annotations</span></a> for more information.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">If any forward references in the annotations of <em>obj</em> are not resolvable
or are not valid Python code, this function will raise an exception
such as <a class="reference internal" href="exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>. For example, this can happen with imported
<a class="reference internal" href="#type-aliases"><span class="std std-ref">type aliases</span></a> that include forward references,
or with names imported under <a class="reference internal" href="#typing.TYPE_CHECKING" title="typing.TYPE_CHECKING"><code class="xref py py-data docutils literal notranslate"><span class="pre">if</span> <span class="pre">TYPE_CHECKING</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>Se agregó el parámetro <code class="docutils literal notranslate"><span class="pre">include_extras</span></code> como parte de <span class="target" id="index-183"></span><a class="pep reference external" href="https://peps.python.org/pep-0593/"><strong>PEP 593</strong></a>. Consulte la documentación en <a class="reference internal" href="#typing.Annotated" title="typing.Annotated"><code class="xref py py-data docutils literal notranslate"><span class="pre">Annotated</span></code></a> para obtener más información.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.11: </span>Anteriormente, se agregaba <code class="docutils literal notranslate"><span class="pre">Optional[t]</span></code> en las anotaciones de funciones o métodos si se establecía un valor por defecto igual a <code class="docutils literal notranslate"><span class="pre">None</span></code>. Ahora la anotación es retornada sin cambios.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_origin">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_origin" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Obtiene la versión sin suscripción de un tipo: para un objeto de tipado de la forma <code class="docutils literal notranslate"><span class="pre">X[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> devuelve <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
<p class="translated">Si <code class="docutils literal notranslate"><span class="pre">X</span></code> es un alias de módulo de tipado para una clase incorporada o <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a>, se normalizará a la clase original. Si <code class="docutils literal notranslate"><span class="pre">X</span></code> es una instancia de <a class="reference internal" href="#typing.ParamSpecArgs" title="typing.ParamSpecArgs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecArgs</span></code></a> o <a class="reference internal" href="#typing.ParamSpecKwargs" title="typing.ParamSpecKwargs"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpecKwargs</span></code></a>, devuelve la <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> subyacente. Devuelve <code class="docutils literal notranslate"><span class="pre">None</span></code> para objetos no soportados.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="ow">is</span> <span class="n">Union</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">])</span> <span class="ow">is</span> <span class="n">Annotated</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span>
<span class="k">assert</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="ow">is</span> <span class="n">P</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_args">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_args</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_args" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Obtiene los argumentos de tipo con todas las sustituciones realizadas: para un objeto de tipo con la forma <code class="docutils literal notranslate"><span class="pre">X[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> devuelve <code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">Z,</span> <span class="pre">...)</span></code>.</p>
<p class="translated">Si <code class="docutils literal notranslate"><span class="pre">X</span></code> es una unión o <a class="reference internal" href="#typing.Literal" title="typing.Literal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Literal</span></code></a> contenida en otro tipo genérico, el orden de <code class="docutils literal notranslate"><span class="pre">(Y,</span> <span class="pre">Z,</span> <span class="pre">...)</span></code> puede ser diferente del orden de los argumentos originales <code class="docutils literal notranslate"><span class="pre">[Y,</span> <span class="pre">Z,</span> <span class="pre">...]</span></code> debido al almacenamiento en caché de tipos. Devuelve <code class="docutils literal notranslate"><span class="pre">()</span></code> para objetos no soportados.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="p">()</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">get_args</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.get_protocol_members">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">get_protocol_members</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.get_protocol_members" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return the set of members defined in a <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>.</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Protocol</span><span class="p">,</span> <span class="n">get_protocol_members</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="o">...</span>
<span class="gp">... </span>    <span class="n">b</span><span class="p">:</span> <span class="nb">int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_protocol_members</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="untranslated">Raise <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> for arguments that are not Protocols.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.is_protocol">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">is_protocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.is_protocol" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Determine if a type is a <a class="reference internal" href="#typing.Protocol" title="typing.Protocol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Protocol</span></code></a>.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">P</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="o">...</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">int</span>

<span class="n">is_protocol</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>    <span class="c1"># =&gt; True</span>
<span class="n">is_protocol</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># =&gt; False</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.is_typeddict">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">is_typeddict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.is_typeddict" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Compruebe si un tipo es <a class="reference internal" href="#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a>.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Film</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">year</span><span class="p">:</span> <span class="nb">int</span>

<span class="k">assert</span> <span class="n">is_typeddict</span><span class="p">(</span><span class="n">Film</span><span class="p">)</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="n">is_typeddict</span><span class="p">(</span><span class="nb">list</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span>

<span class="c1"># TypedDict is a factory for creating typed dicts,</span>
<span class="c1"># not a typed dict itself</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="n">is_typeddict</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ForwardRef">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ForwardRef</span></span><a class="headerlink" href="#typing.ForwardRef" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Clase utilizada para la representación interna de tipado de cadenas de caracteres en referencias futuras.</p>
<p class="untranslated">For example, <code class="docutils literal notranslate"><span class="pre">List[&quot;SomeClass&quot;]</span></code> is implicitly transformed into
<code class="docutils literal notranslate"><span class="pre">List[ForwardRef(&quot;SomeClass&quot;)]</span></code>.  <code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code> should not be instantiated by
a user, but may be used by introspection tools.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Los tipos genéricos de <span class="target" id="index-184"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a>, como <code class="docutils literal notranslate"><span class="pre">list[&quot;SomeClass&quot;]</span></code>, no se transformarán implícitamente en <code class="docutils literal notranslate"><span class="pre">list[ForwardRef(&quot;SomeClass&quot;)]</span></code> y, por lo tanto, no se resolverán automáticamente en <code class="docutils literal notranslate"><span class="pre">list[SomeClass]</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.14: </span>This is now an alias for <a class="reference internal" href="annotationlib.html#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">annotationlib.ForwardRef</span></code></a>. Several undocumented
behaviors of this class have been changed; for example, after a <code class="docutils literal notranslate"><span class="pre">ForwardRef</span></code> has
been evaluated, the evaluated value is no longer cached.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="typing.evaluate_forward_ref">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">evaluate_forward_ref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">forward_ref</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">owner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">annotationlib.Format.VALUE</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.evaluate_forward_ref" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Evaluate an <a class="reference internal" href="annotationlib.html#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">annotationlib.ForwardRef</span></code></a> as a <a class="reference internal" href="../glossary.html#term-type-hint"><span class="xref std std-term">type hint</span></a>.</p>
<p class="untranslated">This is similar to calling <a class="reference internal" href="annotationlib.html#annotationlib.ForwardRef.evaluate" title="annotationlib.ForwardRef.evaluate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">annotationlib.ForwardRef.evaluate()</span></code></a>,
but unlike that method, <code class="xref py py-func docutils literal notranslate"><span class="pre">evaluate_forward_ref()</span></code> also
recursively evaluates forward references nested within the type hint.</p>
<p class="untranslated">See the documentation for <a class="reference internal" href="annotationlib.html#annotationlib.ForwardRef.evaluate" title="annotationlib.ForwardRef.evaluate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">annotationlib.ForwardRef.evaluate()</span></code></a> for
the meaning of the <em>owner</em>, <em>globals</em>, <em>locals</em>, <em>type_params</em>, and <em>format</em> parameters.</p>
<div class="admonition caution">
<p class="admonition-title">Prudencia</p>
<p class="untranslated">This function may execute arbitrary code contained in annotations.
See <a class="reference internal" href="annotationlib.html#annotationlib-security"><span class="std std-ref">Security implications of introspecting annotations</span></a> for more information.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.NoDefault">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">NoDefault</span></span><a class="headerlink" href="#typing.NoDefault" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A sentinel object used to indicate that a type parameter has no default
value. For example:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">__default__</span> <span class="ow">is</span> <span class="n">typing</span><span class="o">.</span><span class="n">NoDefault</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">__default__</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

</section>
<section id="constant">
<h3 class="translated">Constantes<a class="headerlink" href="#constant" title="Link to this heading">¶</a></h3>
<dl class="py data">
<dt class="sig sig-object py" id="typing.TYPE_CHECKING">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">TYPE_CHECKING</span></span><a class="headerlink" href="#typing.TYPE_CHECKING" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A special constant that is assumed to be <code class="docutils literal notranslate"><span class="pre">True</span></code> by 3rd party static
type checkers. It’s <code class="docutils literal notranslate"><span class="pre">False</span></code> at runtime.</p>
<p class="untranslated">A module which is expensive to import, and which only contain types
used for typing annotations, can be safely imported inside an
<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">TYPE_CHECKING:</span></code> block.  This prevents the module from actually
being imported at runtime; annotations aren’t eagerly evaluated
(see <span class="target" id="index-40"></span><a class="pep reference external" href="https://peps.python.org/pep-0649/"><strong>PEP 649</strong></a>) so using undefined symbols in annotations is
harmless–as long as you don’t later examine them.
Your static type analysis tool will set <code class="docutils literal notranslate"><span class="pre">TYPE_CHECKING</span></code> to
<code class="docutils literal notranslate"><span class="pre">True</span></code> during static type analysis, which means the module will
be imported and the types will be checked properly during such analysis.</p>
<p class="translated">Uso:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">expensive_mod</span>

<span class="k">def</span><span class="w"> </span><span class="nf">fun</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">expensive_mod</span><span class="o">.</span><span class="n">SomeType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">local_var</span><span class="p">:</span> <span class="n">expensive_mod</span><span class="o">.</span><span class="n">AnotherType</span> <span class="o">=</span> <span class="n">other_fun</span><span class="p">()</span>
</pre></div>
</div>
<p class="untranslated">If you occasionally need to examine type annotations at runtime
which may contain undefined symbols, use
<a class="reference internal" href="annotationlib.html#annotationlib.get_annotations" title="annotationlib.get_annotations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">annotationlib.get_annotations()</span></code></a> with a <code class="docutils literal notranslate"><span class="pre">format</span></code> parameter
of <a class="reference internal" href="annotationlib.html#annotationlib.Format.STRING" title="annotationlib.Format.STRING"><code class="xref py py-attr docutils literal notranslate"><span class="pre">annotationlib.Format.STRING</span></code></a> or
<a class="reference internal" href="annotationlib.html#annotationlib.Format.FORWARDREF" title="annotationlib.Format.FORWARDREF"><code class="xref py py-attr docutils literal notranslate"><span class="pre">annotationlib.Format.FORWARDREF</span></code></a> to safely retrieve the
annotations without raising <a class="reference internal" href="exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
</dd></dl>

</section>
<section id="deprecated-aliases">
<span id="generic-concrete-collections"></span><span id="id6"></span><h3 class="translated">Alias obsoletos<a class="headerlink" href="#deprecated-aliases" title="Link to this heading">¶</a></h3>
<p class="untranslated">This module defines several deprecated aliases to pre-existing
standard library classes. These were originally included in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code>
module in order to support parameterizing these generic classes using <code class="docutils literal notranslate"><span class="pre">[]</span></code>.
However, the aliases became redundant in Python 3.9 when the
corresponding pre-existing classes were enhanced to support <code class="docutils literal notranslate"><span class="pre">[]</span></code> (see
<span class="target" id="index-41"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a>).</p>
<p class="translated">Los tipos redundantes están obsoletos a partir de Python 3.9. Sin embargo, si bien los alias pueden eliminarse en algún momento, actualmente no se planea eliminarlos. Por lo tanto, el intérprete no emite advertencias de obsolescencia para estos alias.</p>
<p class="untranslated">If at some point it is decided to remove these deprecated aliases, a
deprecation warning will be issued by the interpreter for at least two releases
prior to removal. The aliases are guaranteed to remain in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> module
without deprecation warnings until at least Python 3.14.</p>
<p class="translated">Se recomienda a los validadores de tipos que marquen los usos de los tipos obsoletos si el programa que están verificando apunta a una versión mínima de Python 3.9 o más reciente.</p>
<section id="aliases-to-built-in-types">
<span id="corresponding-to-built-in-types"></span><h4 class="translated">Alias de tipos integrados<a class="headerlink" href="#aliases-to-built-in-types" title="Link to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Dict">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">dict,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Dict" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.</p>
<p class="untranslated">Note that to annotate arguments, it is preferred
to use an abstract collection type such as <a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a>
rather than to use <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Dict</span></code>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.dict</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-185"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.List">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">List</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">list,</span> <span class="pre">MutableSequence[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.List" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>.</p>
<p class="untranslated">Note that to annotate arguments, it is preferred
to use an abstract collection type such as
<a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequence</span></code></a> or <a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code></a>
rather than to use <a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.List</span></code>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.list</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-186"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Set">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">set,</span> <span class="pre">MutableSet[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Set" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a>.</p>
<p class="untranslated">Note that to annotate arguments, it is preferred
to use an abstract collection type such as <a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a>
rather than to use <a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> or <a class="reference internal" href="#typing.Set" title="typing.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Set</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.set</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-187"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.FrozenSet">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">FrozenSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">frozenset,</span> <span class="pre">AbstractSet[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.FrozenSet" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.frozenset</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-188"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Tuple">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Tuple</span></span><a class="headerlink" href="#typing.Tuple" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>.</p>
<p class="translated"><a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> y <code class="docutils literal notranslate"><span class="pre">Tuple</span></code> son casos especiales en el sistema de tipos; consulte <a class="reference internal" href="#annotating-tuples"><span class="std std-ref">Anotaciones en tuplas</span></a> para más detalles.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.tuple</span></code></a> ahora soporta el uso de subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-189"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Type">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[CT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Type" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
<p class="translated">Vea <a class="reference internal" href="#type-of-class-objects"><span class="std std-ref">El tipo de objetos de clase</span></a> para obtener detalles sobre el uso de <a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> o <code class="docutils literal notranslate"><span class="pre">typing.Type</span></code> en anotaciones de tipo.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></a> ahora soporta el uso de subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-190"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-types-in-collections">
<span id="corresponding-to-types-in-collections"></span><h4 class="translated">Alias de tipos en <a class="reference internal" href="collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a><a class="headerlink" href="#aliases-to-types-in-collections" title="Link to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.DefaultDict">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">DefaultDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.defaultdict,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.DefaultDict" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-191"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.OrderedDict">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">OrderedDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.OrderedDict,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.OrderedDict" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-192"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ChainMap">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ChainMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.ChainMap,</span> <span class="pre">MutableMapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ChainMap" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.1.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.html#collections.ChainMap" title="collections.ChainMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.ChainMap</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-193"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Counter">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Counter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">collections.Counter,</span> <span class="pre">Dict[T,</span> <span class="pre">int]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Counter" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.1.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>)`. Véase <span class="target" id="index-194"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Deque">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Deque</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">deque,</span> <span class="pre">MutableSequence[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Deque" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.1.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-195"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-other-concrete-types">
<span id="other-concrete-types"></span><h4 class="translated">Alias ​​a otros tipos concretos<a class="headerlink" href="#aliases-to-other-concrete-types" title="Link to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Pattern">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Pattern</span></span><a class="headerlink" href="#typing.Pattern" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="typing.Match">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Match</span></span><a class="headerlink" href="#typing.Match" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias ​​obsoletos correspondientes a los tipos de retorno <a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> y <a class="reference internal" href="re.html#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.match()</span></code></a>.</p>
<p class="translated">Estos tipos (y las funciones correspondientes) son genéricos sobre <a class="reference internal" href="#typing.AnyStr" title="typing.AnyStr"><code class="xref py py-data docutils literal notranslate"><span class="pre">AnyStr</span></code></a>. <code class="docutils literal notranslate"><span class="pre">Pattern</span></code> se puede especializar como <code class="docutils literal notranslate"><span class="pre">Pattern[str]</span></code> o <code class="docutils literal notranslate"><span class="pre">Pattern[bytes]</span></code>; <code class="docutils literal notranslate"><span class="pre">Match</span></code> se puede especializar como <code class="docutils literal notranslate"><span class="pre">Match[str]</span></code> o <code class="docutils literal notranslate"><span class="pre">Match[bytes]</span></code>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span>Las clases <code class="docutils literal notranslate"><span class="pre">Pattern</span></code> y <code class="docutils literal notranslate"><span class="pre">Match</span></code> de <a class="reference internal" href="re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> ahora soportan <code class="docutils literal notranslate"><span class="pre">[]</span></code>. Véase <span class="target" id="index-196"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Text">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Text</span></span><a class="headerlink" href="#typing.Text" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto para <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
<p class="translated">Se indica <code class="docutils literal notranslate"><span class="pre">Text</span></code> para proporcionar compatibilidad con versiones de código posteriores a Python 2: en Python 2, <code class="docutils literal notranslate"><span class="pre">Text</span></code> es un alias para <code class="docutils literal notranslate"><span class="pre">unicode</span></code>.</p>
<p class="translated">Úsese <code class="docutils literal notranslate"><span class="pre">Text</span></code> para indicar que un valor debe contener una cadena de texto Unicode de manera que sea compatible con Python 2 y Python 3:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">add_unicode_checkmark</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">Text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Text</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">text</span> <span class="o">+</span> <span class="sa">u</span><span class="s1">&#39; </span><span class="se">\u2713</span><span class="s1">&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.11: </span>Python 2 ya no es compatible, y la mayoría de los validadores de tipos tampoco admiten la verificación de tipos de código Python 2. La eliminación del alias no está planeada actualmente, pero se recomienda a los usuarios utilizar <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> en lugar de <code class="docutils literal notranslate"><span class="pre">Text</span></code>.</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-container-abcs-in-collections-abc">
<span id="corresponding-to-collections-in-collections-abc"></span><span id="abstract-base-classes"></span><h4 class="translated">Alias de ABCs de contenedores en <a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a><a class="headerlink" href="#aliases-to-container-abcs-in-collections-abc" title="Link to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.AbstractSet">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AbstractSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Collection[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AbstractSet" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Set" title="collections.abc.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Set</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-197"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ByteString">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ByteString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Sequence[int]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ByteString" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Deprecated alias to <a class="reference internal" href="collections.abc.html#collections.abc.ByteString" title="collections.abc.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ByteString</span></code></a>.</p>
<p class="untranslated">Use <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Buffer)</span></code> to test if <code class="docutils literal notranslate"><span class="pre">obj</span></code>
implements the <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">buffer protocol</span></a> at runtime. For use in
type annotations, either use <a class="reference internal" href="collections.abc.html#collections.abc.Buffer" title="collections.abc.Buffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Buffer</span></code></a> or a union
that explicitly specifies the types your code supports (e.g.,
<code class="docutils literal notranslate"><span class="pre">bytes</span> <span class="pre">|</span> <span class="pre">bytearray</span> <span class="pre">|</span> <span class="pre">memoryview</span></code>).</p>
<p class="untranslated"><code class="xref py py-class docutils literal notranslate"><span class="pre">ByteString</span></code> was originally intended to be an abstract class that
would serve as a supertype of both <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> and <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>.
However, since the ABC never had any methods, knowing that an object was an
instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">ByteString</span></code> never actually told you anything useful
about the object. Other common buffer types such as <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> were
also never understood as subtypes of <code class="xref py py-class docutils literal notranslate"><span class="pre">ByteString</span></code> (either at runtime
or by static type checkers).</p>
<p class="untranslated">See <span class="target" id="index-55"></span><a class="pep reference external" href="https://peps.python.org/pep-0688/#current-options"><strong>PEP 688</strong></a> for more details.</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.9, will be removed in version 3.17.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Collection">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Collection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Sized,</span> <span class="pre">Iterable[T_co],</span> <span class="pre">Container[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Collection" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Collection" title="collections.abc.Collection"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Collection</span></code></a> ahora soporta la sintaxis de subíndice (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-198"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Container">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Container</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Container" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Container" title="collections.abc.Container"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Container</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-199"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ItemsView">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ItemsView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">MappingView,</span> <span class="pre">AbstractSet[tuple[KT_co,</span> <span class="pre">VT_co]]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ItemsView" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.ItemsView" title="collections.abc.ItemsView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ItemsView</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-200"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.KeysView">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">KeysView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">MappingView,</span> <span class="pre">AbstractSet[KT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.KeysView" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.KeysView" title="collections.abc.KeysView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.KeysView</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-201"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Mapping">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Mapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Collection[KT],</span> <span class="pre">Generic[KT,</span> <span class="pre">VT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Mapping" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-202"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MappingView">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MappingView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Sized</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MappingView" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.MappingView" title="collections.abc.MappingView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MappingView</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-203"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MutableMapping">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MutableMapping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Mapping[KT,</span> <span class="pre">VT]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableMapping" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-204"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MutableSequence">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MutableSequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Sequence[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSequence" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSequence</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-205"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.MutableSet">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">MutableSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">AbstractSet[T]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.MutableSet" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.MutableSet" title="collections.abc.MutableSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableSet</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-206"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Sequence">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Sequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Reversible[T_co],</span> <span class="pre">Collection[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Sequence" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-207"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.ValuesView">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ValuesView</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">MappingView,</span> <span class="pre">Collection[_VT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ValuesView" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.ValuesView" title="collections.abc.ValuesView"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.ValuesView</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-208"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-asynchronous-abcs-in-collections-abc">
<span id="asynchronous-programming"></span><h4 class="translated">Alias para ABCs asíncronos en <a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a><a class="headerlink" href="#aliases-to-asynchronous-abcs-in-collections-abc" title="Link to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Coroutine">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Coroutine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Awaitable[ReturnType],</span> <span class="pre">Generic[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Coroutine" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a>.</p>
<p class="untranslated">See <a class="reference internal" href="#annotating-generators-and-coroutines"><span class="std std-ref">Annotating generators and coroutines</span></a>
for details on using <a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a>
and <code class="docutils literal notranslate"><span class="pre">typing.Coroutine</span></code> in type annotations.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.3.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Coroutine" title="collections.abc.Coroutine"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Coroutine</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-209"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncGenerator">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncGenerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">AsyncIterator[YieldType],</span> <span class="pre">Generic[YieldType,</span> <span class="pre">SendType]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncGenerator" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncGenerator</span></code></a>.</p>
<p class="untranslated">See <a class="reference internal" href="#annotating-generators-and-coroutines"><span class="std std-ref">Annotating generators and coroutines</span></a>
for details on using <a class="reference internal" href="collections.abc.html#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncGenerator</span></code></a>
and <code class="docutils literal notranslate"><span class="pre">typing.AsyncGenerator</span></code> in type annotations.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.1.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsycGenerator</span></code> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-210"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13: </span>The <code class="docutils literal notranslate"><span class="pre">SendType</span></code> parameter now has a default.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncIterable">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncIterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterable" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterable</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-211"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncIterator">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncIterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">AsyncIterable[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncIterator" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.AsyncIterator</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-212"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Awaitable">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Awaitable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Awaitable" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Awaitable" title="collections.abc.Awaitable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Awaitable</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-213"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-other-abcs-in-collections-abc">
<span id="corresponding-to-other-types-in-collections-abc"></span><h4 class="translated">Alias a otros ABCs en <a class="reference internal" href="collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a><a class="headerlink" href="#aliases-to-other-abcs-in-collections-abc" title="Link to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.Iterable">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Iterable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterable" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Iterable" title="collections.abc.Iterable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterable</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-214"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Iterator">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Iterator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Iterable[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Iterator" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Iterator" title="collections.abc.Iterator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Iterator</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-215"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="typing.Callable">
<span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Callable</span></span><a class="headerlink" href="#typing.Callable" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a>.</p>
<p class="translated">Vea <a class="reference internal" href="#annotating-callables"><span class="std std-ref">Anotaciones en objetos invocables</span></a> para información detallada de cómo usar <a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> y <code class="docutils literal notranslate"><span class="pre">typing.Callable</span></code> en anotaciones de tipo.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Callable" title="collections.abc.Callable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Callable</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-216"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span><code class="docutils literal notranslate"><span class="pre">Callable</span></code> ahora es compatible con <a class="reference internal" href="#typing.ParamSpec" title="typing.ParamSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParamSpec</span></code></a> y <a class="reference internal" href="#typing.Concatenate" title="typing.Concatenate"><code class="xref py py-data docutils literal notranslate"><span class="pre">Concatenate</span></code></a>. Consulte <span class="target" id="index-217"></span><a class="pep reference external" href="https://peps.python.org/pep-0612/"><strong>PEP 612</strong></a> para obtener más información.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Generator">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Generator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Iterator[YieldType],</span> <span class="pre">Generic[YieldType,</span> <span class="pre">SendType,</span> <span class="pre">ReturnType]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Generator" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Generator</span></code></a>.</p>
<p class="untranslated">See <a class="reference internal" href="#annotating-generators-and-coroutines"><span class="std std-ref">Annotating generators and coroutines</span></a>
for details on using <a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Generator</span></code></a>
and <code class="docutils literal notranslate"><span class="pre">typing.Generator</span></code> in type annotations.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Generator" title="collections.abc.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Generator</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-218"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13: </span>Default values for the send and return types were added.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Hashable">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Hashable</span></span><a class="headerlink" href="#typing.Hashable" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Hashable</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.12: </span>Use directamente <a class="reference internal" href="collections.abc.html#collections.abc.Hashable" title="collections.abc.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Hashable</span></code></a> en su lugar.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Reversible">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Reversible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Iterable[T_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.Reversible" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="collections.abc.html#collections.abc.Reversible" title="collections.abc.Reversible"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Reversible</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-219"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.Sized">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">Sized</span></span><a class="headerlink" href="#typing.Sized" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="collections.abc.html#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sized</span></code></a>.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.12: </span>Use directamente <a class="reference internal" href="collections.abc.html#collections.abc.Sized" title="collections.abc.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sized</span></code></a> en su lugar.</p>
</div>
</dd></dl>

</section>
<section id="aliases-to-contextlib-abcs">
<span id="context-manager-types"></span><h4 class="translated">Alias de ABCs <a class="reference internal" href="contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a><a class="headerlink" href="#aliases-to-contextlib-abcs" title="Link to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="typing.ContextManager">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">ContextManager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co,</span> <span class="pre">ExitT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.ContextManager" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a>.</p>
<p class="untranslated">The first type parameter, <code class="docutils literal notranslate"><span class="pre">T_co</span></code>, represents the type returned by
the <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> method. The optional second type parameter, <code class="docutils literal notranslate"><span class="pre">ExitT_co</span></code>,
which defaults to <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">|</span> <span class="pre">None</span></code>, represents the type returned by the
<a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> method.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.4.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="contextlib.html#contextlib.AbstractContextManager" title="contextlib.AbstractContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractContextManager</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-220"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13: </span>Added the optional second type parameter, <code class="docutils literal notranslate"><span class="pre">ExitT_co</span></code>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="typing.AsyncContextManager">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">typing.</span></span><span class="sig-name descname"><span class="pre">AsyncContextManager</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">Generic[T_co,</span> <span class="pre">AExitT_co]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#typing.AsyncContextManager" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Alias obsoleto de <a class="reference internal" href="contextlib.html#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a>.</p>
<p class="untranslated">The first type parameter, <code class="docutils literal notranslate"><span class="pre">T_co</span></code>, represents the type returned by
the <a class="reference internal" href="../reference/datamodel.html#object.__aenter__" title="object.__aenter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code></a> method. The optional second type parameter, <code class="docutils literal notranslate"><span class="pre">AExitT_co</span></code>,
which defaults to <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">|</span> <span class="pre">None</span></code>, represents the type returned by the
<a class="reference internal" href="../reference/datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a> method.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.2.</span></p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.9: </span><a class="reference internal" href="contextlib.html#contextlib.AbstractAsyncContextManager" title="contextlib.AbstractAsyncContextManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.AbstractAsyncContextManager</span></code></a> ahora soporta subíndices (<code class="docutils literal notranslate"><span class="pre">[]</span></code>). Véase <span class="target" id="index-221"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a> y <a class="reference internal" href="stdtypes.html#types-genericalias"><span class="std std-ref">Tipo Alias Genérico</span></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13: </span>Added the optional second type parameter, <code class="docutils literal notranslate"><span class="pre">AExitT_co</span></code>.</p>
</div>
</dd></dl>

</section>
</section>
</section>
<section id="deprecation-timeline-of-major-features">
<h2 class="translated">Línea de tiempo de obsolescencia de características principales<a class="headerlink" href="#deprecation-timeline-of-major-features" title="Link to this heading">¶</a></h2>
<p class="translated">Algunas características de <code class="docutils literal notranslate"><span class="pre">typing</span></code> están obsoletas y podrán ser removidas en versiones futuras de Python. Lo que sigue es una tabla que resume las principales obsolescencias para su conveniencia. Ésto está sujeto a cambio y no todas las obsolescencias están representadas.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Característica</p></th>
<th class="head"><p class="translated">En desuso desde</p></th>
<th class="head"><p class="translated">Eliminación proyectada</p></th>
<th class="head"><p class="translated">PEP/issue</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated">Versiones <code class="docutils literal notranslate"><span class="pre">typing</span></code> de colecciones estándares</p></td>
<td><p class="translated">3.9</p></td>
<td><p class="translated">No decidido (ver <a class="reference internal" href="#deprecated-aliases"><span class="std std-ref">Alias obsoletos</span></a> para más información)</p></td>
<td><p class="translated"><span class="target" id="index-80"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a></p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#typing.ByteString" title="typing.ByteString"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.ByteString</span></code></a></p></td>
<td><p class="translated">3.9</p></td>
<td><p class="untranslated">3.17</p></td>
<td><p class="translated"><a class="reference external" href="https://github.com/python/cpython/issues/91896">gh-91896</a></p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#typing.Text" title="typing.Text"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.Text</span></code></a></p></td>
<td><p class="translated">3.11</p></td>
<td><p class="translated">No decidido</p></td>
<td><p class="translated"><a class="reference external" href="https://github.com/python/cpython/issues/92332">gh-92332</a></p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#typing.Hashable" title="typing.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Hashable</span></code></a> y <a class="reference internal" href="#typing.Sized" title="typing.Sized"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Sized</span></code></a></p></td>
<td><p class="translated">3.12</p></td>
<td><p class="translated">No decidido</p></td>
<td><p class="translated"><a class="reference external" href="https://github.com/python/cpython/issues/94309">gh-94309</a></p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#typing.TypeAlias" title="typing.TypeAlias"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.TypeAlias</span></code></a></p></td>
<td><p class="translated">3.12</p></td>
<td><p class="translated">No decidido</p></td>
<td><p class="translated"><span class="target" id="index-81"></span><a class="pep reference external" href="https://peps.python.org/pep-0695/"><strong>PEP 695</strong></a></p></td>
</tr>
<tr class="row-odd"><td><p class="untranslated"><a class="reference internal" href="#typing.no_type_check_decorator" title="typing.no_type_check_decorator"><code class="xref py py-func docutils literal notranslate"><span class="pre">&#64;typing.no_type_check_decorator</span></code></a></p></td>
<td><p class="translated">3.13</p></td>
<td><p class="untranslated">3.15</p></td>
<td><p class="untranslated"><a class="reference external" href="https://github.com/python/cpython/issues/106309">gh-106309</a></p></td>
</tr>
<tr class="row-even"><td><p class="untranslated"><a class="reference internal" href="#typing.AnyStr" title="typing.AnyStr"><code class="xref py py-data docutils literal notranslate"><span class="pre">typing.AnyStr</span></code></a></p></td>
<td><p class="translated">3.13</p></td>
<td><p class="untranslated">3.18</p></td>
<td><p class="untranslated"><a class="reference external" href="https://github.com/python/cpython/issues/105578">gh-105578</a></p></td>
</tr>
</tbody>
</table>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> — Support for type hints</a><ul>
<li><a class="reference internal" href="#specification-for-the-python-type-system">Specification for the Python Type System</a></li>
<li><a class="reference internal" href="#type-aliases">Alias de tipo</a></li>
<li><a class="reference internal" href="#newtype">NewType</a></li>
<li><a class="reference internal" href="#annotating-callable-objects">Anotaciones en objetos invocables</a></li>
<li><a class="reference internal" href="#generics">Genéricos</a></li>
<li><a class="reference internal" href="#annotating-tuples">Anotaciones en tuplas</a></li>
<li><a class="reference internal" href="#the-type-of-class-objects">El tipo de objetos de clase</a></li>
<li><a class="reference internal" href="#annotating-generators-and-coroutines">Annotating generators and coroutines</a></li>
<li><a class="reference internal" href="#user-defined-generic-types">Tipos genéricos definidos por el usuario</a></li>
<li><a class="reference internal" href="#the-any-type">El tipo <code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a></li>
<li><a class="reference internal" href="#nominal-vs-structural-subtyping">Subtipado nominal vs estructural</a></li>
<li><a class="reference internal" href="#module-contents">Contenido del módulo</a><ul>
<li><a class="reference internal" href="#special-typing-primitives">Primitivos especiales de tipado</a><ul>
<li><a class="reference internal" href="#special-types">Tipos especiales</a></li>
<li><a class="reference internal" href="#special-forms">Formas especiales</a></li>
<li><a class="reference internal" href="#building-generic-types-and-type-aliases">Creación de tipos genéricos y alias de tipos</a></li>
<li><a class="reference internal" href="#other-special-directives">Otras directivas especiales</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocols">Protocolos</a></li>
<li><a class="reference internal" href="#abcs-and-protocols-for-working-with-i-o">ABCs and Protocols for working with I/O</a></li>
<li><a class="reference internal" href="#functions-and-decorators">Funciones y decoradores</a></li>
<li><a class="reference internal" href="#introspection-helpers">Ayudas de introspección</a></li>
<li><a class="reference internal" href="#constant">Constantes</a></li>
<li><a class="reference internal" href="#deprecated-aliases">Alias obsoletos</a><ul>
<li><a class="reference internal" href="#aliases-to-built-in-types">Alias de tipos integrados</a></li>
<li><a class="reference internal" href="#aliases-to-types-in-collections">Alias de tipos en <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a></li>
<li><a class="reference internal" href="#aliases-to-other-concrete-types">Alias ​​a otros tipos concretos</a></li>
<li><a class="reference internal" href="#aliases-to-container-abcs-in-collections-abc">Alias de ABCs de contenedores en <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a></li>
<li><a class="reference internal" href="#aliases-to-asynchronous-abcs-in-collections-abc">Alias para ABCs asíncronos en <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a></li>
<li><a class="reference internal" href="#aliases-to-other-abcs-in-collections-abc">Alias a otros ABCs en <code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a></li>
<li><a class="reference internal" href="#aliases-to-contextlib-abcs">Alias de ABCs <code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#deprecation-timeline-of-major-features">Línea de tiempo de obsolescencia de características principales</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="development.html"
                          title="capítulo anterior">Herramientas de desarrollo</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="pydoc.html"
                          title="próximo capítulo"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code> — Documentation generator and online help system</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/typing.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Contraer barra lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="pydoc.html" title="pydoc — Documentation generator and online help system"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="development.html" title="Herramientas de desarrollo"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >La biblioteca estándar de Python</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="development.html" >Herramientas de desarrollo</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code> — Support for type hints</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Derechos de autor</a> 2001 Python Software Foundation.
    <br>
    Ésta página tiene la licencia Python Software Foundation Versión 2.
    <br>
    Ejemplos, guías, y otro código en la documentación están bajo la licencia adicional Zero Clause BSD.
    <br>
    
      Ver <a href="/license.html">Historia y Licencia</a> para más información.<br>
    
    
    <br>

    La Python Software Foundation es una corporación sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor dona.</a>
<br>
    <br>
      Última actualización en oct 06, 2025 (04:51 UTC).
    
      <a href="/bugs.html">Encontraste un bug</a>?
    
    <br>

    Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a>8.2.3.
    </div>

  </body>
</html>