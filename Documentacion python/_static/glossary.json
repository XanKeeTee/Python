{">>>": {"title": ">>>", "body": "<main>\n<dd><p class=\"untranslated\">The default Python prompt of the <a class=\"reference internal\" href=\"#term-interactive\"><span class=\"xref std std-term\">interactive</span></a> shell.  Often\nseen for code examples which can be executed interactively in the\ninterpreter.</p>\n</dd>\n</main>\n"}, "...": {"title": "...", "body": "<main>\n<dd><p class=\"translated\">Puede referirse a:</p>\n<ul class=\"simple\">\n<li><p class=\"untranslated\">The default Python prompt of the <a class=\"reference internal\" href=\"#term-interactive\"><span class=\"xref std std-term\">interactive</span></a> shell when entering the\ncode for an indented code block, when within a pair of matching left and\nright delimiters (parentheses, square brackets, curly braces or triple\nquotes), or after specifying a decorator.</p></li>\n</ul>\n<ul class=\"simple\" id=\"index-0\">\n<li><p class=\"untranslated\">The three dots form of the <a class=\"reference internal\" href=\"library/stdtypes.html#bltin-ellipsis-object\"><span class=\"std std-ref\">Ellipsis</span></a> object.</p></li>\n</ul>\n</dd>\n</main>\n"}, "clase base abstracta": {"title": "clase base abstracta", "body": "<main>\n<dd><p class=\"translated\">Las clases base abstractas (ABC, por sus siglas en ingl\u00e9s <cite>Abstract Base Class</cite>) complementan al <a class=\"reference internal\" href=\"#term-duck-typing\"><span class=\"xref std std-term\">duck-typing</span></a> brindando un forma de definir interfaces con t\u00e9cnicas como <a class=\"reference internal\" href=\"library/functions.html#hasattr\" title=\"hasattr\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">hasattr()</span></code></a> que ser\u00edan confusas o sutilmente err\u00f3neas (por ejemplo con <a class=\"reference internal\" href=\"reference/datamodel.html#special-lookup\"><span class=\"std std-ref\">magic methods</span></a>). Las ABC introduce subclases virtuales, las cuales son clases que no heredan desde una clase pero a\u00fan as\u00ed son reconocidas por <a class=\"reference internal\" href=\"library/functions.html#isinstance\" title=\"isinstance\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">isinstance()</span></code></a> y <a class=\"reference internal\" href=\"library/functions.html#issubclass\" title=\"issubclass\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">issubclass()</span></code></a>; vea la documentaci\u00f3n del m\u00f3dulo <a class=\"reference internal\" href=\"library/abc.html#module-abc\" title=\"abc: Abstract base classes according to :pep:`3119`.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">abc</span></code></a>. Python viene con muchas ABC incorporadas para las estructuras de datos( en el m\u00f3dulo <a class=\"reference internal\" href=\"library/collections.abc.html#module-collections.abc\" title=\"collections.abc: Abstract base classes for containers\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">collections.abc</span></code></a>), n\u00fameros (en el m\u00f3dulo <a class=\"reference internal\" href=\"library/numbers.html#module-numbers\" title=\"numbers: Numeric abstract base classes (Complex, Real, Integral, etc.).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">numbers</span></code></a> ) , flujos de datos (en el m\u00f3dulo <a class=\"reference internal\" href=\"library/io.html#module-io\" title=\"io: Core tools for working with streams.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">io</span></code></a> ) , buscadores y cargadores de importaciones (en el m\u00f3dulo <a class=\"reference internal\" href=\"library/importlib.html#module-importlib.abc\" title=\"importlib.abc: Abstract base classes related to import\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">importlib.abc</span></code></a> ) . Puede crear sus propios ABCs con el m\u00f3dulo <a class=\"reference internal\" href=\"library/abc.html#module-abc\" title=\"abc: Abstract base classes according to :pep:`3119`.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">abc</span></code></a>.</p>\n</dd>\n</main>\n"}, "annotate function": {"title": "annotate function", "body": "<main>\n<dd><p class=\"untranslated\">A function that can be called to retrieve the <a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotations</span></a>\nof an object. This function is accessible as the <a class=\"reference internal\" href=\"reference/datamodel.html#object.__annotate__\" title=\"object.__annotate__\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">__annotate__</span></code></a>\nattribute of functions, classes, and modules. Annotate functions are a\nsubset of <a class=\"reference internal\" href=\"#term-evaluate-function\"><span class=\"xref std std-term\">evaluate functions</span></a>.</p>\n</dd>\n</main>\n"}, "anotaci\u00f3n": {"title": "anotaci\u00f3n", "body": "<main>\n<dd><p class=\"translated\">Una etiqueta asociada a una variable, atributo de clase, par\u00e1metro de funci\u00f3n o valor de retorno, usado por convenci\u00f3n como un <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">type hint</span></a>.</p>\n<p class=\"untranslated\">Annotations of local variables cannot be accessed at runtime, but\nannotations of global variables, class attributes, and functions\ncan be retrieved by calling <a class=\"reference internal\" href=\"library/annotationlib.html#annotationlib.get_annotations\" title=\"annotationlib.get_annotations\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">annotationlib.get_annotations()</span></code></a>\non modules, classes, and functions, respectively.</p>\n<p class=\"untranslated\">See <a class=\"reference internal\" href=\"#term-variable-annotation\"><span class=\"xref std std-term\">variable annotation</span></a>, <a class=\"reference internal\" href=\"#term-function-annotation\"><span class=\"xref std std-term\">function annotation</span></a>, <span class=\"target\" id=\"index-1\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>,\n<span class=\"target\" id=\"index-2\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0526/\"><strong>PEP 526</strong></a>, and <span class=\"target\" id=\"index-3\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0649/\"><strong>PEP 649</strong></a>, which describe this functionality.\nAlso see <a class=\"reference internal\" href=\"howto/annotations.html#annotations-howto\"><span class=\"std std-ref\">Pr\u00e1cticas recomendadas para las anotaciones</span></a>\nfor best practices on working with annotations.</p>\n</dd>\n</main>\n"}, "argumento": {"title": "argumento", "body": "<main>\n<dd><p class=\"translated\">Un valor pasado a una <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">function</span></a> (o <a class=\"reference internal\" href=\"#term-method\"><span class=\"xref std std-term\">method</span></a>) cuando se llama a la funci\u00f3n. Hay dos clases de argumentos:</p>\n<ul>\n<li><p class=\"translated\"><em class=\"dfn\">argumento nombrado</em>: es un argumento precedido por un identificador (por ejemplo, <code class=\"docutils literal notranslate\"><span class=\"pre\">nombre=</span></code>) en una llamada a una funci\u00f3n o pasado como valor en un diccionario precedido por <code class=\"docutils literal notranslate\"><span class=\"pre\">**</span></code>. Por ejemplo <code class=\"docutils literal notranslate\"><span class=\"pre\">3</span></code> y <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code> son argumentos nombrados en las llamadas a <a class=\"reference internal\" href=\"library/functions.html#complex\" title=\"complex\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">complex()</span></code></a>:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nb\">complex</span><span class=\"p\">(</span><span class=\"n\">real</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">imag</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"nb\">complex</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"p\">{</span><span class=\"s1\">&#39;real&#39;</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"s1\">&#39;imag&#39;</span><span class=\"p\">:</span> <span class=\"mi\">5</span><span class=\"p\">})</span>\n</pre></div>\n</div>\n</li>\n<li><p class=\"translated\"><em class=\"dfn\">argumento posicional</em> son aquellos que no son nombrados. Los argumentos posicionales deben aparecer al principio de una lista de argumentos o ser pasados como elementos de un <a class=\"reference internal\" href=\"#term-iterable\"><span class=\"xref std std-term\">iterable</span></a> precedido por <code class=\"docutils literal notranslate\"><span class=\"pre\">*</span></code>. Por ejemplo, <code class=\"docutils literal notranslate\"><span class=\"pre\">3</span></code> y <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code> son argumentos posicionales en las siguientes llamadas:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nb\">complex</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"nb\">complex</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n</li>\n</ul>\n<p class=\"translated\">Los argumentos son asignados a las variables locales en el cuerpo de la funci\u00f3n. Vea en la secci\u00f3n <a class=\"reference internal\" href=\"reference/expressions.html#calls\"><span class=\"std std-ref\">Invocaciones</span></a> las reglas que rigen estas asignaciones. Sint\u00e1cticamente, cualquier expresi\u00f3n puede ser usada para representar un argumento; el valor evaluado es asignado a la variable local.</p>\n<p class=\"translated\">Vea tambi\u00e9n el <a class=\"reference internal\" href=\"#term-parameter\"><span class=\"xref std std-term\">parameter</span></a> en el glosario, la pregunta frecuente <a class=\"reference internal\" href=\"faq/programming.html#faq-argument-vs-parameter\"><span class=\"std std-ref\">la diferencia entre argumentos y par\u00e1metros</span></a>, y <span class=\"target\" id=\"index-70\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0362/\"><strong>PEP 362</strong></a>.</p>\n</dd>\n</main>\n"}, "administrador asincr\u00f3nico de contexto": {"title": "administrador asincr\u00f3nico de contexto", "body": "<main>\n<dd><p class=\"translated\">Un objeto que controla el entorno visible en un sentencia <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">with</span></code></a> al definir los m\u00e9todos <a class=\"reference internal\" href=\"reference/datamodel.html#object.__aenter__\" title=\"object.__aenter__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__aenter__()</span></code></a> y <a class=\"reference internal\" href=\"reference/datamodel.html#object.__aexit__\" title=\"object.__aexit__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__aexit__()</span></code></a>.  Introducido por <span class=\"target\" id=\"index-71\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "generador asincr\u00f3nico": {"title": "generador asincr\u00f3nico", "body": "<main>\n<dd><p class=\"translated\">Una funci\u00f3n que retorna un <a class=\"reference internal\" href=\"#term-asynchronous-generator-iterator\"><span class=\"xref std std-term\">asynchronous generator iterator</span></a>. Es similar a una funci\u00f3n corrutina definida con <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-def\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code></a> excepto que contiene expresiones <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> para producir series de variables usadas en un ciclo <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a>.</p>\n<p class=\"translated\">Usualmente se refiere a una funci\u00f3n generadora asincr\u00f3nica, pero puede referirse a un <em>iterador generador asincr\u00f3nico</em> en ciertos contextos. En aquellos casos en los que el significado no est\u00e1 claro, usar los t\u00e9rminos completos evita la ambig\u00fcedad.</p>\n<p class=\"translated\">Una funci\u00f3n generadora asincr\u00f3nica puede contener expresiones <a class=\"reference internal\" href=\"reference/expressions.html#await\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">await</span></code></a> as\u00ed como sentencias <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a>, y <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">with</span></code></a>.</p>\n</dd>\n</main>\n"}, "iterador generador asincr\u00f3nico": {"title": "iterador generador asincr\u00f3nico", "body": "<main>\n<dd><p class=\"untranslated\">An object created by an <a class=\"reference internal\" href=\"#term-asynchronous-generator\"><span class=\"xref std std-term\">asynchronous generator</span></a> function.</p>\n<p class=\"translated\">Este es un <a class=\"reference internal\" href=\"#term-asynchronous-iterator\"><span class=\"xref std std-term\">asynchronous iterator</span></a> el cual cuando es llamado usa el m\u00e9todo <a class=\"reference internal\" href=\"reference/datamodel.html#object.__anext__\" title=\"object.__anext__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code></a> retornando un objeto a la espera (<em>awaitable</em>) el cual ejecutar\u00e1 el cuerpo de la funci\u00f3n generadora asincr\u00f3nica hasta la siguiente expresi\u00f3n <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a>.</p>\n<p class=\"untranslated\">Each <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> temporarily suspends processing, remembering the\nexecution state (including local variables and pending\ntry-statements).  When the <em>asynchronous generator iterator</em> effectively\nresumes with another awaitable returned by <a class=\"reference internal\" href=\"reference/datamodel.html#object.__anext__\" title=\"object.__anext__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code></a>, it\npicks up where it left off.  See <span class=\"target\" id=\"index-6\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a> and <span class=\"target\" id=\"index-7\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0525/\"><strong>PEP 525</strong></a>.</p>\n</dd>\n</main>\n"}, "iterable asincr\u00f3nico": {"title": "iterable asincr\u00f3nico", "body": "<main>\n<dd><p class=\"translated\">Un objeto, que puede ser usado en una sentencia <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a>. Debe retornar un <a class=\"reference internal\" href=\"#term-asynchronous-iterator\"><span class=\"xref std std-term\">asynchronous iterator</span></a> de su m\u00e9todo <a class=\"reference internal\" href=\"reference/datamodel.html#object.__aiter__\" title=\"object.__aiter__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__aiter__()</span></code></a>. Introducido por <span class=\"target\" id=\"index-72\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "iterador asincr\u00f3nico": {"title": "iterador asincr\u00f3nico", "body": "<main>\n<dd><p class=\"translated\">Un objeto que implementa los m\u00e9todos <a class=\"reference internal\" href=\"reference/datamodel.html#object.__aiter__\" title=\"object.__aiter__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__aiter__()</span></code></a> y <a class=\"reference internal\" href=\"reference/datamodel.html#object.__anext__\" title=\"object.__anext__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code></a>. <a class=\"reference internal\" href=\"reference/datamodel.html#object.__anext__\" title=\"object.__anext__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code></a> debe retornar un objeto <a class=\"reference internal\" href=\"#term-awaitable\"><span class=\"xref std std-term\">awaitable</span></a>. <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a> resuelve los esperables retornados por un m\u00e9todo de iterador asincr\u00f3nico <a class=\"reference internal\" href=\"reference/datamodel.html#object.__anext__\" title=\"object.__anext__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code></a> hasta que lanza una excepci\u00f3n <a class=\"reference internal\" href=\"library/exceptions.html#StopAsyncIteration\" title=\"StopAsyncIteration\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">StopAsyncIteration</span></code></a>. Introducido por <span class=\"target\" id=\"index-73\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "attached thread state": {"title": "attached thread state", "body": "<main>\n<dd><p class=\"untranslated\">A <a class=\"reference internal\" href=\"#term-thread-state\"><span class=\"xref std std-term\">thread state</span></a> that is active for the current OS thread.</p>\n<p class=\"untranslated\">When a <a class=\"reference internal\" href=\"#term-thread-state\"><span class=\"xref std std-term\">thread state</span></a> is attached, the OS thread has\naccess to the full Python C API and can safely invoke the\nbytecode interpreter.</p>\n<p class=\"untranslated\">Unless a function explicitly notes otherwise, attempting to call\nthe C API without an attached thread state will result in a fatal\nerror or undefined behavior.  A thread state can be attached and detached\nexplicitly by the user through the C API, or implicitly by the runtime,\nincluding during blocking C calls and by the bytecode interpreter in between\ncalls.</p>\n<p class=\"untranslated\">On most builds of Python, having an attached thread state implies that the\ncaller holds the <a class=\"reference internal\" href=\"#term-GIL\"><span class=\"xref std std-term\">GIL</span></a> for the current interpreter, so only\none OS thread can have an attached thread state at a given moment. In\n<a class=\"reference internal\" href=\"#term-free-threading\"><span class=\"xref std std-term\">free-threaded</span></a> builds of Python, threads can concurrently\nhold an attached thread state, allowing for true parallelism of the bytecode\ninterpreter.</p>\n</dd>\n</main>\n"}, "atributo": {"title": "atributo", "body": "<main>\n<dd><p class=\"translated\">Un valor asociado a un objeto al que se suele hacer referencia por su nombre utilizando expresiones punteadas. Por ejemplo, si un objeto <em>o</em> tiene un atributo <em>a</em> se referenciar\u00eda como <em>o.a</em>.</p>\n<p class=\"translated\">Es posible dar a un objeto un atributo cuyo nombre no sea un identificador definido por <a class=\"reference internal\" href=\"reference/lexical_analysis.html#identifiers\"><span class=\"std std-ref\">Names (identifiers and keywords)</span></a>, por ejemplo usando <a class=\"reference internal\" href=\"library/functions.html#setattr\" title=\"setattr\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">setattr()</span></code></a>, si el objeto lo permite. Dicho atributo no ser\u00e1 accesible utilizando una expresi\u00f3n con puntos, y en su lugar deber\u00e1 ser recuperado con <a class=\"reference internal\" href=\"library/functions.html#getattr\" title=\"getattr\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">getattr()</span></code></a>.</p>\n</dd>\n</main>\n"}, "a la espera": {"title": "a la espera", "body": "<main>\n<dd><p class=\"translated\">Un objeto que puede utilizarse en una expresi\u00f3n <a class=\"reference internal\" href=\"reference/expressions.html#await\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">await</span></code></a>.  Puede ser una <a class=\"reference internal\" href=\"#term-coroutine\"><span class=\"xref std std-term\">corutina</span></a> o un objeto con un m\u00e9todo <a class=\"reference internal\" href=\"reference/datamodel.html#object.__await__\" title=\"object.__await__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__await__()</span></code></a>. V\u00e9ase tambi\u00e9n <span class=\"target\" id=\"index-74\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "bdfl": {"title": "BDFL", "body": "<main>\n<dd><p class=\"translated\">Sigla de <em>Benevolent Dictator For Life</em>, benevolente dictador vitalicio, es decir <a class=\"reference external\" href=\"https://gvanrossum.github.io/\">Guido van Rossum</a>, el creador de Python.</p>\n</dd>\n</main>\n"}, "archivo binario": {"title": "archivo binario", "body": "<main>\n<dd><p class=\"untranslated\">A <a class=\"reference internal\" href=\"#term-file-object\"><span class=\"xref std std-term\">file object</span></a> able to read and write\n<a class=\"reference internal\" href=\"#term-bytes-like-object\"><span class=\"xref std std-term\">bytes-like objects</span></a>.\nExamples of binary files are files opened in binary mode (<code class=\"docutils literal notranslate\"><span class=\"pre\">'rb'</span></code>,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">'wb'</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">'rb+'</span></code>), <a class=\"reference internal\" href=\"library/sys.html#sys.stdin\" title=\"sys.stdin\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdin.buffer</span></code></a>,\n<a class=\"reference internal\" href=\"library/sys.html#sys.stdout\" title=\"sys.stdout\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdout.buffer</span></code></a>, and instances of\n<a class=\"reference internal\" href=\"library/io.html#io.BytesIO\" title=\"io.BytesIO\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">io.BytesIO</span></code></a> and <a class=\"reference internal\" href=\"library/gzip.html#gzip.GzipFile\" title=\"gzip.GzipFile\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">gzip.GzipFile</span></code></a>.</p>\n<p class=\"translated\">Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-text-file\"><span class=\"xref std std-term\">text file</span></a> para un objeto archivo capaz de leer y escribir objetos <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a>.</p>\n</dd>\n</main>\n"}, "referencia prestada": {"title": "referencia prestada", "body": "<main>\n<dd><p class=\"translated\">En la API C de Python, una referencia prestada es una referencia a un objeto, donde el c\u00f3digo usando el objeto no posee la referencia. Se convierte en un puntero colgante si se destruye el objeto. Por ejemplo, una recolecci\u00f3n de basura puede eliminar el \u00faltimo <a class=\"reference internal\" href=\"#term-strong-reference\"><span class=\"xref std std-term\">strong reference</span></a> del objeto y as\u00ed destruirlo.</p>\n<p class=\"translated\">Se recomienda llamar a <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_INCREF\" title=\"Py_INCREF\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_INCREF()</span></code></a> en la <a class=\"reference internal\" href=\"#term-borrowed-reference\"><span class=\"xref std std-term\">referencia prestada</span></a> para convertirla en una <a class=\"reference internal\" href=\"#term-strong-reference\"><span class=\"xref std std-term\">referencia fuerte</span></a> in situ, excepto cuando el objeto no se puede destruir antes del \u00faltimo uso de la referencia prestada. La funci\u00f3n <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_NewRef\" title=\"Py_NewRef\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_NewRef()</span></code></a> se puede utilizar para crear una nueva <a class=\"reference internal\" href=\"#term-strong-reference\"><span class=\"xref std std-term\">referencia fuerte</span></a>.</p>\n</dd>\n</main>\n"}, "objetos tipo binarios": {"title": "objetos tipo binarios", "body": "<main>\n<dd><p class=\"translated\">Un objeto que soporta <a class=\"reference internal\" href=\"c-api/buffer.html#bufferobjects\"><span class=\"std std-ref\">Protocolo b\u00fafer</span></a>  y puede exportar un b\u00fafer C-<a class=\"reference internal\" href=\"#term-contiguous\"><span class=\"xref std std-term\">contiguous</span></a>. Esto incluye todas los objetos <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#bytearray\" title=\"bytearray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytearray</span></code></a>, y <a class=\"reference internal\" href=\"library/array.html#array.array\" title=\"array.array\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">array.array</span></code></a>, as\u00ed como muchos objetos comunes <a class=\"reference internal\" href=\"library/stdtypes.html#memoryview\" title=\"memoryview\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">memoryview</span></code></a>. Los objetos tipo binarios pueden ser usados para varias operaciones que usan datos binarios; \u00e9stas incluyen compresi\u00f3n, salvar a archivos binarios, y enviarlos a trav\u00e9s de un socket.</p>\n<p class=\"translated\">Algunas operaciones necesitan que los datos binarios sean mutables. La documentaci\u00f3n frecuentemente se refiere a \u00e9stos como \u00abobjetos tipo binario de lectura y escritura\u00bb. Ejemplos de objetos de b\u00fafer mutables incluyen a <a class=\"reference internal\" href=\"library/stdtypes.html#bytearray\" title=\"bytearray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytearray</span></code></a> y <a class=\"reference internal\" href=\"library/stdtypes.html#memoryview\" title=\"memoryview\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">memoryview</span></code></a> de la <a class=\"reference internal\" href=\"library/stdtypes.html#bytearray\" title=\"bytearray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytearray</span></code></a>. Otras operaciones que requieren datos binarios almacenados en objetos inmutables (\u00abobjetos tipo binario de s\u00f3lo lectura\u00bb); ejemplos de \u00e9stos incluyen <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a> y <a class=\"reference internal\" href=\"library/stdtypes.html#memoryview\" title=\"memoryview\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">memoryview</span></code></a> del objeto <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a>.</p>\n</dd>\n</main>\n"}, "bytecode": {"title": "bytecode", "body": "<main>\n<dd><p class=\"translated\">El c\u00f3digo fuente Python es compilado en <em>bytecode</em>, la representaci\u00f3n interna de un programa python en el int\u00e9rprete CPython. El <em>bytecode</em> tambi\u00e9n es guardado en cach\u00e9 en los archivos <cite>.pyc</cite> de tal forma que ejecutar el mismo archivo es m\u00e1s f\u00e1cil la segunda vez (la recompilaci\u00f3n desde el c\u00f3digo fuente a <em>bytecode</em> puede ser evitada). Este \u00ablenguaje intermedio\u00bb deber\u00e1 corren en una <a class=\"reference internal\" href=\"#term-virtual-machine\"><span class=\"xref std std-term\">virtual machine</span></a> que ejecute el c\u00f3digo de m\u00e1quina correspondiente a cada <em>bytecode</em>. Note que los <em>bytecodes</em> no tienen como requisito trabajar en las diversas m\u00e1quina virtuales de Python, ni de ser estable entre versiones Python.</p>\n<p class=\"translated\">Una lista de las instrucciones en <em>bytecode</em> est\u00e1 disponible en la documentaci\u00f3n de <a class=\"reference internal\" href=\"library/dis.html#bytecodes\"><span class=\"std std-ref\">el m\u00f3dulo dis</span></a>.</p>\n</dd>\n</main>\n"}, "callable": {"title": "callable", "body": "<main>\n<dd><p class=\"translated\">Un callable es un objeto que puede ser llamado, posiblemente con un conjunto de argumentos (v\u00e9ase <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a>), con la siguiente sintaxis:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nb\">callable</span><span class=\"p\">(</span><span class=\"n\">argument1</span><span class=\"p\">,</span> <span class=\"n\">argument2</span><span class=\"p\">,</span> <span class=\"n\">argumentN</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p class=\"translated\">Una <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">function</span></a>, y por extensi\u00f3n un <a class=\"reference internal\" href=\"#term-method\"><span class=\"xref std std-term\">method</span></a>, es un callable. Una instancia de una clase que implementa el m\u00e9todo <a class=\"reference internal\" href=\"reference/datamodel.html#object.__call__\" title=\"object.__call__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__call__()</span></code></a> tambi\u00e9n es un callable.</p>\n</dd>\n</main>\n"}, "retrollamada": {"title": "retrollamada", "body": "<main>\n<dd><p class=\"translated\">Una funci\u00f3n de subrutina que se pasa como un argumento para ejecutarse en alg\u00fan momento en el futuro.</p>\n</dd>\n</main>\n"}, "clase": {"title": "clase", "body": "<main>\n<dd><p class=\"translated\">Una plantilla para crear objetos definidos por el usuario. Las definiciones de clase normalmente contienen definiciones de m\u00e9todos que operan una instancia de la clase.</p>\n</dd>\n</main>\n"}, "variable de clase": {"title": "variable de clase", "body": "<main>\n<dd><p class=\"translated\">Una variable definida en una clase y prevista para ser modificada s\u00f3lo a nivel de clase (es decir, no en una instancia de la clase).</p>\n</dd>\n</main>\n"}, "closure variable": {"title": "closure variable", "body": "<main>\n<dd><p class=\"untranslated\">A <a class=\"reference internal\" href=\"#term-free-variable\"><span class=\"xref std std-term\">free variable</span></a> referenced from a <a class=\"reference internal\" href=\"#term-nested-scope\"><span class=\"xref std std-term\">nested scope</span></a> that is defined in an outer\nscope rather than being resolved at runtime from the globals or builtin namespaces.\nMay be explicitly defined with the <a class=\"reference internal\" href=\"reference/simple_stmts.html#nonlocal\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">nonlocal</span></code></a> keyword to allow write access,\nor implicitly defined if the variable is only being read.</p>\n<p class=\"untranslated\">For example, in the <code class=\"docutils literal notranslate\"><span class=\"pre\">inner</span></code> function in the following code, both <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">print</span></code> are\n<a class=\"reference internal\" href=\"#term-free-variable\"><span class=\"xref std std-term\">free variables</span></a>, but only <code class=\"docutils literal notranslate\"><span class=\"pre\">x</span></code> is a <em>closure variable</em>:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">outer</span><span class=\"p\">():</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">inner</span><span class=\"p\">():</span>\n        <span class=\"k\">nonlocal</span> <span class=\"n\">x</span>\n        <span class=\"n\">x</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">inner</span>\n</pre></div>\n</div>\n<p class=\"untranslated\">Due to the <a class=\"reference internal\" href=\"reference/datamodel.html#codeobject.co_freevars\" title=\"codeobject.co_freevars\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">codeobject.co_freevars</span></code></a> attribute (which, despite its name, only\nincludes the names of closure variables rather than listing all referenced free\nvariables), the more general <a class=\"reference internal\" href=\"#term-free-variable\"><span class=\"xref std std-term\">free variable</span></a> term is sometimes used even\nwhen the intended meaning is to refer specifically to closure variables.</p>\n</dd>\n</main>\n"}, "n\u00famero complejo": {"title": "n\u00famero complejo", "body": "<main>\n<dd><p class=\"translated\">Una extensi\u00f3n del sistema familiar de n\u00famero reales en el cual los n\u00fameros son expresados como la suma de una parte real y una parte imaginaria.  Los n\u00fameros imaginarios son m\u00faltiplos de la unidad imaginaria (la ra\u00edz cuadrada de <code class=\"docutils literal notranslate\"><span class=\"pre\">-1</span></code>), usualmente escrita como <code class=\"docutils literal notranslate\"><span class=\"pre\">i</span></code> en matem\u00e1ticas o <code class=\"docutils literal notranslate\"><span class=\"pre\">j</span></code> en ingenier\u00eda.  Python tiene soporte incorporado para n\u00fameros complejos, los cuales son escritos con la notaci\u00f3n mencionada al final.; la parte imaginaria es escrita con un sufijo <code class=\"docutils literal notranslate\"><span class=\"pre\">j</span></code>, por ejemplo, <code class=\"docutils literal notranslate\"><span class=\"pre\">3+1j</span></code>.  Para tener acceso a los equivalentes complejos del m\u00f3dulo <a class=\"reference internal\" href=\"library/math.html#module-math\" title=\"math: Mathematical functions (sin() etc.).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">math</span></code></a> module, use <a class=\"reference internal\" href=\"library/cmath.html#module-cmath\" title=\"cmath: Mathematical functions for complex numbers.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">cmath</span></code></a>.  El uso de n\u00fameros complejos es matem\u00e1tica bastante avanzada.  Si no le parecen necesarios, puede ignorarlos sin inconvenientes.</p>\n</dd>\n</main>\n"}, "context": {"title": "context", "body": "<main>\n<dd><p class=\"untranslated\">This term has different meanings depending on where and how it is used.\nSome common meanings:</p>\n<ul class=\"simple\">\n<li><p class=\"untranslated\">The temporary state or environment established by a <a class=\"reference internal\" href=\"#term-context-manager\"><span class=\"xref std std-term\">context\nmanager</span></a> via a <a class=\"reference internal\" href=\"reference/compound_stmts.html#with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">with</span></code></a> statement.</p></li>\n<li><p class=\"untranslated\">The collection of key\u00advalue bindings associated with a particular\n<a class=\"reference internal\" href=\"library/contextvars.html#contextvars.Context\" title=\"contextvars.Context\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">contextvars.Context</span></code></a> object and accessed via\n<a class=\"reference internal\" href=\"library/contextvars.html#contextvars.ContextVar\" title=\"contextvars.ContextVar\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ContextVar</span></code></a> objects.  Also see <a class=\"reference internal\" href=\"#term-context-variable\"><span class=\"xref std std-term\">context\nvariable</span></a>.</p></li>\n<li><p class=\"untranslated\">A <a class=\"reference internal\" href=\"library/contextvars.html#contextvars.Context\" title=\"contextvars.Context\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">contextvars.Context</span></code></a> object.  Also see <a class=\"reference internal\" href=\"#term-current-context\"><span class=\"xref std std-term\">current\ncontext</span></a>.</p></li>\n</ul>\n</dd>\n</main>\n"}, "context management protocol": {"title": "context management protocol", "body": "<main>\n<dd><p class=\"untranslated\">The <a class=\"reference internal\" href=\"reference/datamodel.html#object.__enter__\" title=\"object.__enter__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__enter__()</span></code></a> and <a class=\"reference internal\" href=\"reference/datamodel.html#object.__exit__\" title=\"object.__exit__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__exit__()</span></code></a> methods called\nby the <a class=\"reference internal\" href=\"reference/compound_stmts.html#with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">with</span></code></a> statement.  See <span class=\"target\" id=\"index-11\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0343/\"><strong>PEP 343</strong></a>.</p>\n</dd>\n</main>\n"}, "administrador de contextos": {"title": "administrador de contextos", "body": "<main>\n<dd><p class=\"untranslated\">An object which implements the <a class=\"reference internal\" href=\"#term-context-management-protocol\"><span class=\"xref std std-term\">context management protocol</span></a> and\ncontrols the environment seen in a <a class=\"reference internal\" href=\"reference/compound_stmts.html#with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">with</span></code></a> statement.  See\n<span class=\"target\" id=\"index-12\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0343/\"><strong>PEP 343</strong></a>.</p>\n</dd>\n</main>\n"}, "variable de contexto": {"title": "variable de contexto", "body": "<main>\n<dd><p class=\"untranslated\">A variable whose value depends on which context is the <a class=\"reference internal\" href=\"#term-current-context\"><span class=\"xref std std-term\">current\ncontext</span></a>.  Values are accessed via <a class=\"reference internal\" href=\"library/contextvars.html#contextvars.ContextVar\" title=\"contextvars.ContextVar\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">contextvars.ContextVar</span></code></a>\nobjects.  Context variables are primarily used to isolate state between\nconcurrent asynchronous tasks.</p>\n</dd>\n</main>\n"}, "contiguo": {"title": "contiguo", "body": "<main>\n<dd><p class=\"translated\" id=\"index-13\">Un b\u00fafer es considerado contiguo con precisi\u00f3n si es <em>C-contiguo</em> o <em>Fortran contiguo</em>. Los b\u00faferes cero dimensionales con C y Fortran contiguos. En los arreglos unidimensionales, los \u00edtems deben ser dispuestos en memoria uno siguiente al otro, ordenados por \u00edndices que comienzan en cero. En arreglos unidimensionales C-contiguos, el \u00faltimo \u00edndice var\u00eda m\u00e1s velozmente en el orden de las direcciones de memoria. Sin embargo, en arreglos Fortran contiguos, el primer \u00edndice ver\u00eda m\u00e1s r\u00e1pidamente.</p>\n</dd>\n</main>\n"}, "corrutina": {"title": "corrutina", "body": "<main>\n<dd><p class=\"translated\">Las corrutinas son una forma m\u00e1s generalizadas de las subrutinas. A las subrutinas se ingresa por un punto y se sale por otro punto. Las corrutinas pueden se iniciadas, finalizadas y reanudadas en muchos puntos diferentes. Pueden ser implementadas con la sentencia <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-def\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code></a>. Vea adem\u00e1s <span class=\"target\" id=\"index-75\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "funci\u00f3n corrutina": {"title": "funci\u00f3n corrutina", "body": "<main>\n<dd><p class=\"translated\">Un funci\u00f3n que retorna un objeto  <a class=\"reference internal\" href=\"#term-coroutine\"><span class=\"xref std std-term\">coroutine</span></a> . Una funci\u00f3n corrutina puede ser definida con la sentencia <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-def\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code></a>, y puede contener las palabras claves <a class=\"reference internal\" href=\"reference/expressions.html#await\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">await</span></code></a>, <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a>, y <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">with</span></code></a>. Las mismas son introducidas en <span class=\"target\" id=\"index-76\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "cpython": {"title": "CPython", "body": "<main>\n<dd><p class=\"translated\">La implementaci\u00f3n can\u00f3nica del lenguaje de programaci\u00f3n Python, como se distribuye en <a class=\"reference external\" href=\"https://www.python.org\">python.org</a>. El t\u00e9rmino \u00abCPython\u00bb es usado cuando es necesario distinguir esta implementaci\u00f3n de otras como <em>Jython</em> o <em>IronPython</em>.</p>\n</dd>\n</main>\n"}, "current context": {"title": "current context", "body": "<main>\n<dd><p class=\"untranslated\">The <a class=\"reference internal\" href=\"#term-context\"><span class=\"xref std std-term\">context</span></a> (<a class=\"reference internal\" href=\"library/contextvars.html#contextvars.Context\" title=\"contextvars.Context\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">contextvars.Context</span></code></a> object) that is\ncurrently used by <a class=\"reference internal\" href=\"library/contextvars.html#contextvars.ContextVar\" title=\"contextvars.ContextVar\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">ContextVar</span></code></a> objects to access (get\nor set) the values of <a class=\"reference internal\" href=\"#term-context-variable\"><span class=\"xref std std-term\">context variables</span></a>.  Each\nthread has its own current context.  Frameworks for executing asynchronous\ntasks (see <a class=\"reference internal\" href=\"library/asyncio.html#module-asyncio\" title=\"asyncio: Asynchronous I/O.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">asyncio</span></code></a>) associate each task with a context which\nbecomes the current context whenever the task starts or resumes execution.</p>\n</dd>\n</main>\n"}, "cyclic isolate": {"title": "cyclic isolate", "body": "<main>\n<dd><p class=\"untranslated\">A subgroup of one or more objects that reference each other in a reference\ncycle, but are not referenced by objects outside the group.  The goal of\nthe <a class=\"reference internal\" href=\"#term-garbage-collection\"><span class=\"xref std std-term\">cyclic garbage collector</span></a> is to identify these groups and break the reference\ncycles so that the memory can be reclaimed.</p>\n</dd>\n</main>\n"}, "decorador": {"title": "decorador", "body": "<main>\n<dd><p class=\"translated\">Una funci\u00f3n que retorna otra funci\u00f3n, usualmente aplicada como una funci\u00f3n de transformaci\u00f3n empleando la sintaxis <code class=\"docutils literal notranslate\"><span class=\"pre\">&#64;envoltorio</span></code>. Ejemplos comunes de decoradores son  <a class=\"reference internal\" href=\"library/functions.html#classmethod\" title=\"classmethod\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">classmethod()</span></code></a> y <a class=\"reference internal\" href=\"library/functions.html#staticmethod\" title=\"staticmethod\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">staticmethod()</span></code></a>.</p>\n<p class=\"translated\">La sintaxis del decorador es meramente az\u00facar sint\u00e1ctico, las definiciones de las siguientes dos funciones son sem\u00e1nticamente equivalentes:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n<span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"nb\">staticmethod</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@staticmethod</span>\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n</pre></div>\n</div>\n<p class=\"translated\">El mismo concepto existe para clases, pero son menos usadas. Vea la documentaci\u00f3n de <a class=\"reference internal\" href=\"reference/compound_stmts.html#function\"><span class=\"std std-ref\">function definitions</span></a> y <a class=\"reference internal\" href=\"reference/compound_stmts.html#class\"><span class=\"std std-ref\">class definitions</span></a> para mayor detalle sobre decoradores.</p>\n</dd>\n</main>\n"}, "descriptor": {"title": "descriptor", "body": "<main>\n<dd><p class=\"untranslated\">Any object which defines the methods <a class=\"reference internal\" href=\"reference/datamodel.html#object.__get__\" title=\"object.__get__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__get__()</span></code></a>,\n<a class=\"reference internal\" href=\"reference/datamodel.html#object.__set__\" title=\"object.__set__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__set__()</span></code></a>, or <a class=\"reference internal\" href=\"reference/datamodel.html#object.__delete__\" title=\"object.__delete__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__delete__()</span></code></a>.\nWhen a class attribute is a descriptor, its special\nbinding behavior is triggered upon attribute lookup.  Normally, using\n<em>a.b</em> to get, set or delete an attribute looks up the object named <em>b</em> in\nthe class dictionary for <em>a</em>, but if <em>b</em> is a descriptor, the respective\ndescriptor method gets called.  Understanding descriptors is a key to a\ndeep understanding of Python because they are the basis for many features\nincluding functions, methods, properties, class methods, static methods,\nand reference to super classes.</p>\n<p class=\"translated\">Para obtener m\u00e1s informaci\u00f3n sobre los m\u00e9todos de los descriptores, consulte <a class=\"reference internal\" href=\"reference/datamodel.html#descriptors\"><span class=\"std std-ref\">Implementando descriptores</span></a> o <a class=\"reference internal\" href=\"howto/descriptor.html#descriptorhowto\"><span class=\"std std-ref\">Gu\u00eda pr\u00e1ctica de uso de los descriptores</span></a>.</p>\n</dd>\n</main>\n"}, "diccionario": {"title": "diccionario", "body": "<main>\n<dd><p class=\"untranslated\">An associative array, where arbitrary keys are mapped to values.  The\nkeys can be any object with <a class=\"reference internal\" href=\"reference/datamodel.html#object.__hash__\" title=\"object.__hash__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__hash__()</span></code></a> and\n<a class=\"reference internal\" href=\"reference/datamodel.html#object.__eq__\" title=\"object.__eq__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__eq__()</span></code></a> methods.\nCalled a hash in Perl.</p>\n</dd>\n</main>\n"}, "comprensi\u00f3n de diccionarios": {"title": "comprensi\u00f3n de diccionarios", "body": "<main>\n<dd><p class=\"translated\">Una forma compacta de procesar todos o parte de los elementos en un iterable y retornar un diccionario con los resultados. <code class=\"docutils literal notranslate\"><span class=\"pre\">results</span> <span class=\"pre\">=</span> <span class=\"pre\">{n:</span> <span class=\"pre\">n</span> <span class=\"pre\">**</span> <span class=\"pre\">2</span> <span class=\"pre\">for</span> <span class=\"pre\">n</span> <span class=\"pre\">in</span> <span class=\"pre\">range(10)}</span></code> genera un diccionario que contiene la clave <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code> asignada al valor <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span> <span class=\"pre\">**</span> <span class=\"pre\">2</span></code>. Ver <a class=\"reference internal\" href=\"reference/expressions.html#comprehensions\"><span class=\"std std-ref\">Despliegues para listas, conjuntos y diccionarios</span></a>.</p>\n</dd>\n</main>\n"}, "vista de diccionario": {"title": "vista de diccionario", "body": "<main>\n<dd><p class=\"translated\">Los objetos retornados por los m\u00e9todos  <a class=\"reference internal\" href=\"library/stdtypes.html#dict.keys\" title=\"dict.keys\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">dict.keys()</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#dict.values\" title=\"dict.values\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">dict.values()</span></code></a>, y <a class=\"reference internal\" href=\"library/stdtypes.html#dict.items\" title=\"dict.items\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">dict.items()</span></code></a> son llamados vistas de diccionarios. Proveen una vista din\u00e1mica de las entradas de un diccionario, lo que significa que cuando el diccionario cambia, la vista refleja \u00e9stos cambios. Para forzar a la vista de diccionario a convertirse en una lista completa, use <code class=\"docutils literal notranslate\"><span class=\"pre\">list(dictview)</span></code>.  Vea <a class=\"reference internal\" href=\"library/stdtypes.html#dict-views\"><span class=\"std std-ref\">Objetos tipos vista de diccionario</span></a>.</p>\n</dd>\n</main>\n"}, "docstring": {"title": "docstring", "body": "<main>\n<dd><p class=\"untranslated\">A string literal which appears as the first expression in a class,\nfunction or module.  While ignored when the suite is executed, it is\nrecognized by the compiler and put into the <a class=\"reference internal\" href=\"library/stdtypes.html#definition.__doc__\" title=\"definition.__doc__\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">__doc__</span></code></a> attribute\nof the enclosing class, function or module.  Since it is available via\nintrospection, it is the canonical place for documentation of the\nobject.</p>\n</dd>\n</main>\n"}, "tipado de pato": {"title": "tipado de pato", "body": "<main>\n<dd><p class=\"translated\">Un estilo de programaci\u00f3n que no revisa el tipo del objeto para determinar si tiene la interfaz correcta; en vez de ello, el m\u00e9todo o atributo es simplemente llamado o usado (\u00abSi se ve como un pato y grazna como un pato, debe ser un pato\u00bb).  Enfatizando las interfaces en vez de hacerlo con los tipos espec\u00edficos, un c\u00f3digo bien dise\u00f1ado pues tener mayor flexibilidad permitiendo la sustituci\u00f3n polim\u00f3rfica.  El tipado de pato <em>duck-typing</em> evita usar pruebas llamando a <a class=\"reference internal\" href=\"library/functions.html#type\" title=\"type\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">type()</span></code></a> o <a class=\"reference internal\" href=\"library/functions.html#isinstance\" title=\"isinstance\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">isinstance()</span></code></a>.  (Nota: si embargo, el tipado de pato puede ser complementado con <a class=\"reference internal\" href=\"#term-abstract-base-class\"><span class=\"xref std std-term\">abstract base classes</span></a>. En su lugar, generalmente pregunta con <a class=\"reference internal\" href=\"library/functions.html#hasattr\" title=\"hasattr\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">hasattr()</span></code></a> o <a class=\"reference internal\" href=\"#term-EAFP\"><span class=\"xref std std-term\">EAFP</span></a>.</p>\n</dd>\n</main>\n"}, "dunder": {"title": "dunder", "body": "<main>\n<dd><p class=\"untranslated\">An informal short-hand for \u00abdouble underscore\u00bb, used when talking about a\n<a class=\"reference internal\" href=\"#term-special-method\"><span class=\"xref std std-term\">special method</span></a>. For example, <code class=\"docutils literal notranslate\"><span class=\"pre\">__init__</span></code> is often pronounced\n\u00abdunder init\u00bb.</p>\n</dd>\n</main>\n"}, "eafp": {"title": "EAFP", "body": "<main>\n<dd><p class=\"translated\">Del ingl\u00e9s <em>Easier to ask for forgiveness than permission</em>, es m\u00e1s f\u00e1cil pedir perd\u00f3n que pedir permiso.  Este estilo de codificaci\u00f3n com\u00fan en Python asume la existencia de claves o atributos v\u00e1lidos y atrapa las excepciones si esta suposici\u00f3n resulta falsa.  Este estilo r\u00e1pido y limpio est\u00e1 caracterizado por muchas sentencias <a class=\"reference internal\" href=\"reference/compound_stmts.html#try\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">try</span></code></a> y <a class=\"reference internal\" href=\"reference/compound_stmts.html#except\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">except</span></code></a>.  Esta t\u00e9cnica contrasta con estilo <a class=\"reference internal\" href=\"#term-LBYL\"><span class=\"xref std std-term\">LBYL</span></a> usual en otros lenguajes como C.</p>\n</dd>\n</main>\n"}, "evaluate function": {"title": "evaluate function", "body": "<main>\n<dd><p class=\"untranslated\">A function that can be called to evaluate a lazily evaluated attribute\nof an object, such as the value of type aliases created with the <a class=\"reference internal\" href=\"reference/simple_stmts.html#type\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">type</span></code></a>\nstatement.</p>\n</dd>\n</main>\n"}, "expresi\u00f3n": {"title": "expresi\u00f3n", "body": "<main>\n<dd><p class=\"translated\">Una construcci\u00f3n sint\u00e1ctica que puede ser evaluada, hasta dar un valor.  En otras palabras, una expresi\u00f3n es una acumulaci\u00f3n de elementos de expresi\u00f3n tales como literales, nombres, accesos a atributos, operadores o llamadas a funciones, todos ellos retornando valor.  A diferencia de otros lenguajes, no toda la sintaxis del lenguaje son expresiones. Tambi\u00e9n hay <a class=\"reference internal\" href=\"#term-statement\"><span class=\"xref std std-term\">statement</span></a>s que no pueden ser usadas como expresiones, como la <a class=\"reference internal\" href=\"reference/compound_stmts.html#while\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">while</span></code></a>.  Las asignaciones tambi\u00e9n son sentencias, no expresiones.</p>\n</dd>\n</main>\n"}, "m\u00f3dulo de extensi\u00f3n": {"title": "m\u00f3dulo de extensi\u00f3n", "body": "<main>\n<dd><p class=\"translated\">Un m\u00f3dulo escrito en C o C++, usando la API para C de Python para interactuar con el n\u00facleo y el c\u00f3digo del usuario.</p>\n</dd>\n</main>\n"}, "f-string": {"title": "f-string", "body": "<main>\n<dd><p class=\"untranslated\">String literals prefixed with <code class=\"docutils literal notranslate\"><span class=\"pre\">f</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">F</span></code> are commonly called\n\u00abf-strings\u00bb which is short for\n<a class=\"reference internal\" href=\"reference/lexical_analysis.html#f-strings\"><span class=\"std std-ref\">formatted string literals</span></a>.  See also <span class=\"target\" id=\"index-16\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0498/\"><strong>PEP 498</strong></a>.</p>\n</dd>\n</main>\n"}, "objeto archivo": {"title": "objeto archivo", "body": "<main>\n<dd><p class=\"untranslated\">An object exposing a file-oriented API (with methods such as\n<code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">read()</span></code> or <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">write()</span></code>) to an underlying resource.  Depending\non the way it was created, a file object can mediate access to a real\non-disk file or to another type of storage or communication device\n(for example standard input/output, in-memory buffers, sockets, pipes,\netc.).  File objects are also called <em class=\"dfn\">file-like objects</em> or\n<em class=\"dfn\">streams</em>.</p>\n<p class=\"translated\">Existen tres categor\u00edas de objetos archivo: crudos <em>raw</em> <a class=\"reference internal\" href=\"#term-binary-file\"><span class=\"xref std std-term\">archivos binarios</span></a>, con b\u00fafer <a class=\"reference internal\" href=\"#term-binary-file\"><span class=\"xref std std-term\">archivos binarios</span></a> y <a class=\"reference internal\" href=\"#term-text-file\"><span class=\"xref std std-term\">archivos de texto</span></a>.  Sus interfaces son definidas en el m\u00f3dulo <a class=\"reference internal\" href=\"library/io.html#module-io\" title=\"io: Core tools for working with streams.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">io</span></code></a>.  La forma can\u00f3nica de crear objetos archivo es usando la funci\u00f3n <a class=\"reference internal\" href=\"library/functions.html#open\" title=\"open\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">open()</span></code></a>.</p>\n</dd>\n</main>\n"}, "objetos tipo archivo": {"title": "objetos tipo archivo", "body": "<main>\n<dd><p class=\"translated\">Un sin\u00f3nimo de <a class=\"reference internal\" href=\"#term-file-object\"><span class=\"xref std std-term\">file object</span></a>.</p>\n</dd>\n</main>\n"}, "codificaci\u00f3n del sistema de archivos y manejador de errores": {"title": "codificaci\u00f3n del sistema de archivos y manejador de errores", "body": "<main>\n<dd><p class=\"translated\">Controlador de errores y codificaci\u00f3n utilizado por Python para decodificar bytes del sistema operativo y codificar Unicode en el sistema operativo.</p>\n<p class=\"translated\">La codificaci\u00f3n del sistema de archivos debe garantizar la decodificaci\u00f3n exitosa de todos los bytes por debajo de 128. Si la codificaci\u00f3n del sistema de archivos no proporciona esta garant\u00eda, las funciones de API pueden lanzar <a class=\"reference internal\" href=\"library/exceptions.html#UnicodeError\" title=\"UnicodeError\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">UnicodeError</span></code></a>.</p>\n<p class=\"translated\">Las funciones <a class=\"reference internal\" href=\"library/sys.html#sys.getfilesystemencoding\" title=\"sys.getfilesystemencoding\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sys.getfilesystemencoding()</span></code></a> y <a class=\"reference internal\" href=\"library/sys.html#sys.getfilesystemencodeerrors\" title=\"sys.getfilesystemencodeerrors\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sys.getfilesystemencodeerrors()</span></code></a> se pueden utilizar para obtener la codificaci\u00f3n del sistema de archivos y el controlador de errores.</p>\n<p class=\"translated\">La <a class=\"reference internal\" href=\"#term-filesystem-encoding-and-error-handler\"><span class=\"xref std std-term\">codificaci\u00f3n del sistema de archivos y el manejador de errores</span></a> se configuran al inicio de Python mediante la funci\u00f3n <a class=\"reference internal\" href=\"c-api/init_config.html#c.PyConfig_Read\" title=\"PyConfig_Read\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">PyConfig_Read()</span></code></a>: consulte los miembros <a class=\"reference internal\" href=\"c-api/init_config.html#c.PyConfig.filesystem_encoding\" title=\"PyConfig.filesystem_encoding\"><code class=\"xref c c-member docutils literal notranslate\"><span class=\"pre\">filesystem_encoding</span></code></a> y <a class=\"reference internal\" href=\"c-api/init_config.html#c.PyConfig.filesystem_errors\" title=\"PyConfig.filesystem_errors\"><code class=\"xref c c-member docutils literal notranslate\"><span class=\"pre\">filesystem_errors</span></code></a> de <a class=\"reference internal\" href=\"c-api/init_config.html#c.PyConfig\" title=\"PyConfig\"><code class=\"xref c c-type docutils literal notranslate\"><span class=\"pre\">PyConfig</span></code></a>.</p>\n<p class=\"translated\">Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-locale-encoding\"><span class=\"xref std std-term\">locale encoding</span></a>.</p>\n</dd>\n</main>\n"}, "buscador": {"title": "buscador", "body": "<main>\n<dd><p class=\"translated\">Un objeto que trata de encontrar el <a class=\"reference internal\" href=\"#term-loader\"><span class=\"xref std std-term\">loader</span></a> para el m\u00f3dulo que est\u00e1 siendo importado.</p>\n<p class=\"untranslated\">There are two types of finder: <a class=\"reference internal\" href=\"#term-meta-path-finder\"><span class=\"xref std std-term\">meta path finders</span></a> for use with <a class=\"reference internal\" href=\"library/sys.html#sys.meta_path\" title=\"sys.meta_path\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.meta_path</span></code></a>, and <a class=\"reference internal\" href=\"#term-path-entry-finder\"><span class=\"xref std std-term\">path\nentry finders</span></a> for use with <a class=\"reference internal\" href=\"library/sys.html#sys.path_hooks\" title=\"sys.path_hooks\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.path_hooks</span></code></a>.</p>\n<p class=\"untranslated\">See <a class=\"reference internal\" href=\"reference/import.html#finders-and-loaders\"><span class=\"std std-ref\">Buscadores y cargadores</span></a> and <a class=\"reference internal\" href=\"library/importlib.html#module-importlib\" title=\"importlib: The implementation of the import machinery.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">importlib</span></code></a> for much more detail.</p>\n</dd>\n</main>\n"}, "divisi\u00f3n entera a la baja": {"title": "divisi\u00f3n entera a la baja", "body": "<main>\n<dd><p class=\"translated\">Una divisi\u00f3n matem\u00e1tica que se redondea hacia el entero menor m\u00e1s cercano.  El operador de la divisi\u00f3n entera a la baja es <code class=\"docutils literal notranslate\"><span class=\"pre\">//</span></code>.  Por ejemplo, la expresi\u00f3n <code class=\"docutils literal notranslate\"><span class=\"pre\">11</span> <span class=\"pre\">//</span> <span class=\"pre\">4</span></code> eval\u00faa <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span></code> a diferencia del <code class=\"docutils literal notranslate\"><span class=\"pre\">2.75</span></code> retornado por la verdadera divisi\u00f3n de n\u00fameros flotantes.  Note que <code class=\"docutils literal notranslate\"><span class=\"pre\">(-11)</span> <span class=\"pre\">//</span> <span class=\"pre\">4</span></code> es <code class=\"docutils literal notranslate\"><span class=\"pre\">-3</span></code> porque es <code class=\"docutils literal notranslate\"><span class=\"pre\">-2.75</span></code> redondeado <em>para abajo</em>. Ver <span class=\"target\" id=\"index-77\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0238/\"><strong>PEP 238</strong></a>.</p>\n</dd>\n</main>\n"}, "free threading": {"title": "free threading", "body": "<main>\n<dd><p class=\"untranslated\">A threading model where multiple threads can run Python bytecode\nsimultaneously within the same interpreter.  This is in contrast to\nthe <a class=\"reference internal\" href=\"#term-global-interpreter-lock\"><span class=\"xref std std-term\">global interpreter lock</span></a> which allows only one thread to\nexecute Python bytecode at a time.  See <span class=\"target\" id=\"index-18\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0703/\"><strong>PEP 703</strong></a>.</p>\n</dd>\n</main>\n"}, "free variable": {"title": "free variable", "body": "<main>\n<dd><p class=\"untranslated\">Formally, as defined in the <a class=\"reference internal\" href=\"reference/executionmodel.html#bind-names\"><span class=\"std std-ref\">language execution model</span></a>, a free\nvariable is any variable used in a namespace which is not a local variable in that\nnamespace. See <a class=\"reference internal\" href=\"#term-closure-variable\"><span class=\"xref std std-term\">closure variable</span></a> for an example.\nPragmatically, due to the name of the <a class=\"reference internal\" href=\"reference/datamodel.html#codeobject.co_freevars\" title=\"codeobject.co_freevars\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">codeobject.co_freevars</span></code></a> attribute,\nthe term is also sometimes used as a synonym for <a class=\"reference internal\" href=\"#term-closure-variable\"><span class=\"xref std std-term\">closure variable</span></a>.</p>\n</dd>\n</main>\n"}, "funci\u00f3n": {"title": "funci\u00f3n", "body": "<main>\n<dd><p class=\"translated\">Una serie de sentencias que retornan un valor al que las llama.  Tambi\u00e9n se le puede pasar cero o m\u00e1s <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argumentos</span></a> los cuales pueden ser usados en la ejecuci\u00f3n de la misma. Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-parameter\"><span class=\"xref std std-term\">parameter</span></a>, <a class=\"reference internal\" href=\"#term-method\"><span class=\"xref std std-term\">method</span></a>, y la secci\u00f3n <a class=\"reference internal\" href=\"reference/compound_stmts.html#function\"><span class=\"std std-ref\">Definiciones de funciones</span></a>.</p>\n</dd>\n</main>\n"}, "anotaci\u00f3n de funci\u00f3n": {"title": "anotaci\u00f3n de funci\u00f3n", "body": "<main>\n<dd><p class=\"translated\">Una <a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotation</span></a> del par\u00e1metro de una funci\u00f3n o un valor de retorno.</p>\n<p class=\"translated\">Las anotaciones de funciones son usadas frecuentemente para <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">indicadores de tipo</span></a>, por ejemplo, se espera que una funci\u00f3n tome dos argumentos de clase <a class=\"reference internal\" href=\"library/functions.html#int\" title=\"int\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">int</span></code></a>  y tambi\u00e9n se espera que retorne dos valores <a class=\"reference internal\" href=\"library/functions.html#int\" title=\"int\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">int</span></code></a>:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">sum_two_numbers</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n   <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span>\n</pre></div>\n</div>\n<p class=\"translated\">La sintaxis de las anotaciones de funciones son explicadas en la secci\u00f3n <a class=\"reference internal\" href=\"reference/compound_stmts.html#function\"><span class=\"std std-ref\">Definiciones de funciones</span></a>.</p>\n<p class=\"translated\">Consulte <a class=\"reference internal\" href=\"#term-variable-annotation\"><span class=\"xref std std-term\">variable annotation</span></a> y <span class=\"target\" id=\"index-78\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>, que describen esta funcionalidad. Consulte tambi\u00e9n <a class=\"reference internal\" href=\"howto/annotations.html#annotations-howto\"><span class=\"std std-ref\">Pr\u00e1cticas recomendadas para las anotaciones</span></a> para conocer las mejores pr\u00e1cticas sobre c\u00f3mo trabajar con anotaciones.</p>\n</dd>\n</main>\n"}, "__future__": {"title": "__future__", "body": "<main>\n<dd><p class=\"translated\">Un <a class=\"reference internal\" href=\"reference/simple_stmts.html#future\"><span class=\"std std-ref\">future statement</span></a>, <code class=\"docutils literal notranslate\"><span class=\"pre\">from</span> <span class=\"pre\">__future__</span> <span class=\"pre\">import</span> <span class=\"pre\">&lt;feature&gt;</span></code>, indica al compilador que compile el m\u00f3dulo actual utilizando una sintaxis o sem\u00e1ntica que se convertir\u00e1 en est\u00e1ndar en una versi\u00f3n futura de Python. El m\u00f3dulo <a class=\"reference internal\" href=\"library/__future__.html#module-__future__\" title=\"__future__: Future statement definitions\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">__future__</span></code></a> documenta los posibles valores de <em>feature</em>. Al importar este m\u00f3dulo y evaluar sus variables, puede ver cu\u00e1ndo se agreg\u00f3 por primera vez una nueva caracter\u00edstica al lenguaje y cu\u00e1ndo se convertir\u00e1 (o se convirti\u00f3) en la predeterminada:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">__future__</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">__future__</span><span class=\"o\">.</span><span class=\"n\">division</span>\n<span class=\"go\">_Feature((2, 2, 0, &#39;alpha&#39;, 2), (3, 0, 0, &#39;alpha&#39;, 0), 8192)</span>\n</pre></div>\n</div>\n</dd>\n</main>\n"}, "recolecci\u00f3n de basura": {"title": "recolecci\u00f3n de basura", "body": "<main>\n<dd><p class=\"translated\">El proceso de liberar la memoria de lo que ya no est\u00e1 en uso.  Python realiza recolecci\u00f3n de basura (<em>garbage collection</em>) llevando la cuenta de las referencias, y el recogedor de basura c\u00edclico es capaz de detectar y romper las referencias c\u00edclicas.  El recogedor de basura puede ser controlado mediante el m\u00f3dulo <a class=\"reference internal\" href=\"library/gc.html#module-gc\" title=\"gc: Interface to the cycle-detecting garbage collector.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">gc</span></code></a> .</p>\n</dd>\n</main>\n"}, "generador": {"title": "generador", "body": "<main>\n<dd><p class=\"translated\">Una funci\u00f3n que retorna un <a class=\"reference internal\" href=\"#term-generator-iterator\"><span class=\"xref std std-term\">generator iterator</span></a>.  Luce como una funci\u00f3n normal excepto que contiene la expresi\u00f3n <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> para producir series de valores utilizables en un bucle <em>for</em> o que pueden ser obtenidas una por una con la funci\u00f3n <a class=\"reference internal\" href=\"library/functions.html#next\" title=\"next\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">next()</span></code></a>.</p>\n<p class=\"translated\">Usualmente se refiere a una funci\u00f3n generadora, pero puede referirse a un <em>iterador generador</em> en ciertos contextos.  En aquellos casos en los que el significado no est\u00e1 claro, usar los t\u00e9rminos completos  evita la ambig\u00fcedad.</p>\n</dd>\n</main>\n"}, "iterador generador": {"title": "iterador generador", "body": "<main>\n<dd><p class=\"translated\">Un objeto creado por una funci\u00f3n <a class=\"reference internal\" href=\"#term-generator\"><span class=\"xref std std-term\">generator</span></a>.</p>\n<p class=\"untranslated\">Each <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> temporarily suspends processing, remembering the\nexecution state (including local variables and pending\ntry-statements).  When the <em>generator iterator</em> resumes, it picks up where\nit left off (in contrast to functions which start fresh on every\ninvocation).</p>\n</dd>\n</main>\n"}, "expresi\u00f3n generadora": {"title": "expresi\u00f3n generadora", "body": "<main>\n<dd><p class=\"untranslated\">An <a class=\"reference internal\" href=\"#term-expression\"><span class=\"xref std std-term\">expression</span></a> that returns an <a class=\"reference internal\" href=\"#term-iterator\"><span class=\"xref std std-term\">iterator</span></a>.  It looks like a normal expression\nfollowed by a <code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code> clause defining a loop variable, range,\nand an optional <code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">if</span></code> clause.  The combined expression\ngenerates values for an enclosing function:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">*</span><span class=\"n\">i</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">))</span>         <span class=\"c1\"># sum of squares 0, 1, 4, ... 81</span>\n<span class=\"go\">285</span>\n</pre></div>\n</div>\n</dd>\n</main>\n"}, "funci\u00f3n gen\u00e9rica": {"title": "funci\u00f3n gen\u00e9rica", "body": "<main>\n<dd><p class=\"translated\">Una funci\u00f3n compuesta de muchas funciones que implementan la misma operaci\u00f3n para diferentes tipos. Qu\u00e9 implementaci\u00f3n deber\u00e1 ser usada durante la llamada a la misma es determinado por el algoritmo de despacho.</p>\n<p class=\"translated\">Vea tambi\u00e9n la entrada de glosario <a class=\"reference internal\" href=\"#term-single-dispatch\"><span class=\"xref std std-term\">single dispatch</span></a>, el decorador <a class=\"reference internal\" href=\"library/functools.html#functools.singledispatch\" title=\"functools.singledispatch\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">functools.singledispatch()</span></code></a>, y <span class=\"target\" id=\"index-79\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0443/\"><strong>PEP 443</strong></a>.</p>\n</dd>\n</main>\n"}, "tipos gen\u00e9ricos": {"title": "tipos gen\u00e9ricos", "body": "<main>\n<dd><p class=\"translated\">Un <a class=\"reference internal\" href=\"#term-type\"><span class=\"xref std std-term\">type</span></a> que se puede parametrizar; normalmente un <a class=\"reference internal\" href=\"reference/datamodel.html#sequence-types\"><span class=\"std std-ref\">container class</span></a> como <a class=\"reference internal\" href=\"library/stdtypes.html#list\" title=\"list\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">list</span></code></a> o <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a>. Usado para <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">type hints</span></a> y <a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotations</span></a>.</p>\n<p class=\"translated\">Para m\u00e1s detalles, v\u00e9ase <a class=\"reference internal\" href=\"library/stdtypes.html#types-genericalias\"><span class=\"std std-ref\">generic alias types</span></a>, <span class=\"target\" id=\"index-80\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0483/\"><strong>PEP 483</strong></a>, <span class=\"target\" id=\"index-81\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>, <span class=\"target\" id=\"index-82\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0585/\"><strong>PEP 585</strong></a>, y el m\u00f3dulo <a class=\"reference internal\" href=\"library/typing.html#module-typing\" title=\"typing: Support for type hints (see :pep:`484`).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">typing</span></code></a>.</p>\n</dd>\n</main>\n"}, "gil": {"title": "GIL", "body": "<main>\n<dd><p class=\"translated\">Vea <a class=\"reference internal\" href=\"#term-global-interpreter-lock\"><span class=\"xref std std-term\">global interpreter lock</span></a>.</p>\n</dd>\n</main>\n"}, "bloqueo global del int\u00e9rprete": {"title": "bloqueo global del int\u00e9rprete", "body": "<main>\n<dd><p class=\"translated\">Mecanismo empleado por el int\u00e9rprete <a class=\"reference internal\" href=\"#term-CPython\"><span class=\"xref std std-term\">CPython</span></a> para asegurar que s\u00f3lo un hilo ejecute el  <a class=\"reference internal\" href=\"#term-bytecode\"><span class=\"xref std std-term\">bytecode</span></a> Python por vez. Esto simplifica la implementaci\u00f3n de CPython haciendo que el modelo de objetos (incluyendo algunos cr\u00edticos como <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a>) est\u00e1n impl\u00edcitamente a salvo de acceso concurrente.  Bloqueando el int\u00e9rprete completo se simplifica hacerlo multi-hilos, a costa de mucho del paralelismo ofrecido por las m\u00e1quinas con m\u00faltiples procesadores.</p>\n<p class=\"translated\">Sin embargo, algunos m\u00f3dulos de extensi\u00f3n, tanto est\u00e1ndar como de terceros, est\u00e1n dise\u00f1ados para liberar el GIL cuando se realizan tareas computacionalmente intensivas como la compresi\u00f3n o el <em>hashing</em>.  Adem\u00e1s, el GIL siempre es liberado cuando se hace entrada/salida.</p>\n<p class=\"untranslated\">As of Python 3.13, the GIL can be disabled using the <a class=\"reference internal\" href=\"using/configure.html#cmdoption-disable-gil\"><code class=\"xref std std-option docutils literal notranslate\"><span class=\"pre\">--disable-gil</span></code></a>\nbuild configuration. After building Python with this option, code must be\nrun with <a class=\"reference internal\" href=\"using/cmdline.html#cmdoption-X\"><code class=\"xref std std-option docutils literal notranslate\"><span class=\"pre\">-X</span> <span class=\"pre\">gil=0</span></code></a> or after setting the <span class=\"target\" id=\"index-26\"></span><a class=\"reference internal\" href=\"using/cmdline.html#envvar-PYTHON_GIL\"><code class=\"xref std std-envvar docutils literal notranslate\"><span class=\"pre\">PYTHON_GIL=0</span></code></a>\nenvironment variable. This feature enables improved performance for\nmulti-threaded applications and makes it easier to use multi-core CPUs\nefficiently. For more details, see <span class=\"target\" id=\"index-27\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0703/\"><strong>PEP 703</strong></a>.</p>\n<p class=\"untranslated\">In prior versions of Python\u2019s C API, a function might declare that it\nrequires the GIL to be held in order to use it. This refers to having an\n<a class=\"reference internal\" href=\"#term-attached-thread-state\"><span class=\"xref std std-term\">attached thread state</span></a>.</p>\n</dd>\n</main>\n"}, "hash-based pyc": {"title": "hash-based pyc", "body": "<main>\n<dd><p class=\"translated\">Un archivo cache de <em>bytecode</em> que usa el <em>hash</em> en vez de usar el tiempo de la \u00faltima modificaci\u00f3n del archivo fuente correspondiente para determinar su validez. Vea <a class=\"reference internal\" href=\"reference/import.html#pyc-invalidation\"><span class=\"std std-ref\">Invalidaci\u00f3n del c\u00f3digo de bytes en cach\u00e9</span></a>.</p>\n</dd>\n</main>\n"}, "hashable": {"title": "hashable", "body": "<main>\n<dd><p class=\"untranslated\">An object is <em>hashable</em> if it has a hash value which never changes during\nits lifetime (it needs a <a class=\"reference internal\" href=\"reference/datamodel.html#object.__hash__\" title=\"object.__hash__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__hash__()</span></code></a> method), and can be\ncompared to other objects (it needs an <a class=\"reference internal\" href=\"reference/datamodel.html#object.__eq__\" title=\"object.__eq__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__eq__()</span></code></a> method).\nHashable objects which\ncompare equal must have the same hash value.</p>\n<p class=\"translated\">Ser <em>hashable</em> hace a un objeto utilizable como clave de un diccionario y miembro de un set, porque \u00e9stas estructuras de datos usan los valores de hash internamente.</p>\n<p class=\"translated\">La mayor\u00eda de los objetos inmutables incorporados en Python son <em>hashables</em>; los contenedores mutables (como las listas o los diccionarios) no lo son; los contenedores inmutables (como tuplas y conjuntos <em>frozensets</em>) son <em>hashables</em> si sus elementos son <em>hashables</em> .  Los objetos que son instancias de clases definidas por el usuario son <em>hashables</em> por defecto.  Todos se comparan como desiguales (excepto consigo mismos), y su valor de hash est\u00e1 derivado de su funci\u00f3n <a class=\"reference internal\" href=\"library/functions.html#id\" title=\"id\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">id()</span></code></a>.</p>\n</dd>\n</main>\n"}, "idle": {"title": "IDLE", "body": "<main>\n<dd><p class=\"translated\">Un Entorno Integrado de Desarrollo y Aprendizaje para Python. <a class=\"reference internal\" href=\"library/idle.html#idle\"><span class=\"std std-ref\">IDLE \u2014 Python editor and shell</span></a> es un editor b\u00e1sico y un entorno de int\u00e9rprete que se incluye con la distribuci\u00f3n est\u00e1ndar de Python.</p>\n</dd>\n</main>\n"}, "immortal": {"title": "immortal", "body": "<main>\n<dd><p class=\"untranslated\"><em>Immortal objects</em> are a CPython implementation detail introduced\nin <span class=\"target\" id=\"index-28\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0683/\"><strong>PEP 683</strong></a>.</p>\n<p class=\"untranslated\">If an object is immortal, its <a class=\"reference internal\" href=\"#term-reference-count\"><span class=\"xref std std-term\">reference count</span></a> is never modified,\nand therefore it is never deallocated while the interpreter is running.\nFor example, <a class=\"reference internal\" href=\"library/constants.html#True\" title=\"True\"><code class=\"xref py py-const docutils literal notranslate\"><span class=\"pre\">True</span></code></a> and <a class=\"reference internal\" href=\"library/constants.html#None\" title=\"None\"><code class=\"xref py py-const docutils literal notranslate\"><span class=\"pre\">None</span></code></a> are immortal in CPython.</p>\n<p class=\"untranslated\">Immortal objects can be identified via <a class=\"reference internal\" href=\"library/sys.html#sys._is_immortal\" title=\"sys._is_immortal\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sys._is_immortal()</span></code></a>, or\nvia <a class=\"reference internal\" href=\"c-api/object.html#c.PyUnstable_IsImmortal\" title=\"PyUnstable_IsImmortal\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">PyUnstable_IsImmortal()</span></code></a> in the C API.</p>\n</dd>\n</main>\n"}, "inmutable": {"title": "inmutable", "body": "<main>\n<dd><p class=\"translated\">Un objeto con un valor fijo.  Los objetos inmutables son n\u00fameros, cadenas y tuplas.  \u00c9stos objetos no pueden ser alterados.  Un nuevo objeto debe ser creado si un valor diferente ha de ser guardado.  Juegan un rol importante en lugares donde es necesario un valor de hash constante, por ejemplo como claves de un diccionario.</p>\n</dd>\n</main>\n"}, "ruta de importaci\u00f3n": {"title": "ruta de importaci\u00f3n", "body": "<main>\n<dd><p class=\"translated\">Una lista de las ubicaciones (o <a class=\"reference internal\" href=\"#term-path-entry\"><span class=\"xref std std-term\">entradas de ruta</span></a>) que son revisadas por <a class=\"reference internal\" href=\"#term-path-based-finder\"><span class=\"xref std std-term\">path based finder</span></a> al importar m\u00f3dulos. Durante la importaci\u00f3n, \u00e9sta lista de localizaciones usualmente viene de <a class=\"reference internal\" href=\"library/sys.html#sys.path\" title=\"sys.path\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.path</span></code></a>, pero para los subpaquetes tambi\u00e9n puede incluir al atributo <code class=\"docutils literal notranslate\"><span class=\"pre\">__path__</span></code> del paquete padre.</p>\n</dd>\n</main>\n"}, "importar": {"title": "importar", "body": "<main>\n<dd><p class=\"translated\">El proceso mediante el cual el c\u00f3digo Python dentro de un m\u00f3dulo se hace alcanzable desde otro c\u00f3digo Python en otro m\u00f3dulo.</p>\n</dd>\n</main>\n"}, "importador": {"title": "importador", "body": "<main>\n<dd><p class=\"translated\">Un objeto que buscan y lee un m\u00f3dulo; un objeto que es tanto <a class=\"reference internal\" href=\"#term-finder\"><span class=\"xref std std-term\">finder</span></a> como <a class=\"reference internal\" href=\"#term-loader\"><span class=\"xref std std-term\">loader</span></a>.</p>\n</dd>\n</main>\n"}, "interactivo": {"title": "interactivo", "body": "<main>\n<dd><p class=\"untranslated\">Python has an interactive interpreter which means you can enter\nstatements and expressions at the interpreter prompt, immediately\nexecute them and see their results.  Just launch <code class=\"docutils literal notranslate\"><span class=\"pre\">python</span></code> with no\narguments (possibly by selecting it from your computer\u2019s main\nmenu). It is a very powerful way to test out new ideas or inspect\nmodules and packages (remember <code class=\"docutils literal notranslate\"><span class=\"pre\">help(x)</span></code>). For more on interactive\nmode, see <a class=\"reference internal\" href=\"tutorial/appendix.html#tut-interac\"><span class=\"std std-ref\">Modo interactivo</span></a>.</p>\n</dd>\n</main>\n"}, "interpretado": {"title": "interpretado", "body": "<main>\n<dd><p class=\"translated\">Python es un lenguaje interpretado, a diferencia de uno compilado, a pesar de que la distinci\u00f3n puede ser difusa debido al compilador a <em>bytecode</em>.  Esto significa que los archivos fuente pueden ser corridos directamente, sin crear expl\u00edcitamente un ejecutable que es corrido luego. Los lenguajes interpretados t\u00edpicamente tienen ciclos de desarrollo y depuraci\u00f3n m\u00e1s cortos que los compilados, sin embargo sus programas suelen correr m\u00e1s lentamente.  Vea tambi\u00e9n  <a class=\"reference internal\" href=\"#term-interactive\"><span class=\"xref std std-term\">interactive</span></a>.</p>\n</dd>\n</main>\n"}, "apagado del int\u00e9rprete": {"title": "apagado del int\u00e9rprete", "body": "<main>\n<dd><p class=\"translated\">Cuando se le solicita apagarse, el int\u00e9rprete Python ingresa a un fase especial en la cual gradualmente libera todos los recursos reservados, como m\u00f3dulos y varias estructuras internas cr\u00edticas.  Tambi\u00e9n hace varias llamadas al <a class=\"reference internal\" href=\"#term-garbage-collection\"><span class=\"xref std std-term\">recolector de basura</span></a>.  Esto puede disparar la ejecuci\u00f3n de c\u00f3digo de destructores definidos por el usuario o <em>weakref callbacks</em>. El c\u00f3digo ejecutado durante la fase de apagado puede encontrar varias excepciones debido a que los recursos que necesita pueden no funcionar m\u00e1s (ejemplos comunes son los m\u00f3dulos de bibliotecas o los artefactos de advertencias <em>warnings machinery</em>)</p>\n<p class=\"translated\">La principal raz\u00f3n para el apagado del int\u00e9rpreter es que el m\u00f3dulo <code class=\"docutils literal notranslate\"><span class=\"pre\">__main__</span></code> o el script que estaba corriendo termine su ejecuci\u00f3n.</p>\n</dd>\n</main>\n"}, "iterable": {"title": "iterable", "body": "<main>\n<dd><p class=\"untranslated\">An object capable of returning its members one at a time. Examples of\niterables include all sequence types (such as <a class=\"reference internal\" href=\"library/stdtypes.html#list\" title=\"list\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">list</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a>,\nand <a class=\"reference internal\" href=\"library/stdtypes.html#tuple\" title=\"tuple\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">tuple</span></code></a>) and some non-sequence types like <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a>,\n<a class=\"reference internal\" href=\"#term-file-object\"><span class=\"xref std std-term\">file objects</span></a>, and objects of any classes you define\nwith an <a class=\"reference internal\" href=\"reference/datamodel.html#object.__iter__\" title=\"object.__iter__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__iter__()</span></code></a> method or with a\n<a class=\"reference internal\" href=\"reference/datamodel.html#object.__getitem__\" title=\"object.__getitem__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getitem__()</span></code></a> method\nthat implements <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">sequence</span></a> semantics.</p>\n<p class=\"untranslated\">Iterables can be\nused in a <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a> loop and in many other places where a sequence is\nneeded (<a class=\"reference internal\" href=\"library/functions.html#zip\" title=\"zip\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">zip()</span></code></a>, <a class=\"reference internal\" href=\"library/functions.html#map\" title=\"map\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">map()</span></code></a>, \u2026).  When an iterable object is passed\nas an argument to the built-in function <a class=\"reference internal\" href=\"library/functions.html#iter\" title=\"iter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">iter()</span></code></a>, it returns an\niterator for the object.  This iterator is good for one pass over the set\nof values.  When using iterables, it is usually not necessary to call\n<a class=\"reference internal\" href=\"library/functions.html#iter\" title=\"iter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">iter()</span></code></a> or deal with iterator objects yourself.  The <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a>\nstatement does that automatically for you, creating a temporary unnamed\nvariable to hold the iterator for the duration of the loop.  See also\n<a class=\"reference internal\" href=\"#term-iterator\"><span class=\"xref std std-term\">iterator</span></a>, <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">sequence</span></a>, and <a class=\"reference internal\" href=\"#term-generator\"><span class=\"xref std std-term\">generator</span></a>.</p>\n</dd>\n</main>\n"}, "iterador": {"title": "iterador", "body": "<main>\n<dd><p class=\"untranslated\">An object representing a stream of data.  Repeated calls to the iterator\u2019s\n<a class=\"reference internal\" href=\"library/stdtypes.html#iterator.__next__\" title=\"iterator.__next__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__next__()</span></code></a> method (or passing it to the built-in function\n<a class=\"reference internal\" href=\"library/functions.html#next\" title=\"next\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">next()</span></code></a>) return successive items in the stream.  When no more data\nare available a <a class=\"reference internal\" href=\"library/exceptions.html#StopIteration\" title=\"StopIteration\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">StopIteration</span></code></a> exception is raised instead.  At this\npoint, the iterator object is exhausted and any further calls to its\n<code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__next__()</span></code> method just raise <a class=\"reference internal\" href=\"library/exceptions.html#StopIteration\" title=\"StopIteration\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">StopIteration</span></code></a> again.  Iterators\nare required to have an <a class=\"reference internal\" href=\"library/stdtypes.html#iterator.__iter__\" title=\"iterator.__iter__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__iter__()</span></code></a> method that returns the iterator\nobject itself so every iterator is also iterable and may be used in most\nplaces where other iterables are accepted.  One notable exception is code\nwhich attempts multiple iteration passes.  A container object (such as a\n<a class=\"reference internal\" href=\"library/stdtypes.html#list\" title=\"list\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">list</span></code></a>) produces a fresh new iterator each time you pass it to the\n<a class=\"reference internal\" href=\"library/functions.html#iter\" title=\"iter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">iter()</span></code></a> function or use it in a <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a> loop.  Attempting this\nwith an iterator will just return the same exhausted iterator object used\nin the previous iteration pass, making it appear like an empty container.</p>\n<p class=\"translated\">Puede encontrar m\u00e1s informaci\u00f3n en <a class=\"reference internal\" href=\"library/stdtypes.html#typeiter\"><span class=\"std std-ref\">Tipos de iteradores</span></a>.</p>\n<div class=\"impl-detail compound\">\n<p class=\"untranslated\"><strong>Detalles de implementaci\u00f3n de CPython:</strong> CPython does not consistently apply the requirement that an iterator\ndefine <a class=\"reference internal\" href=\"library/stdtypes.html#iterator.__iter__\" title=\"iterator.__iter__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__iter__()</span></code></a>.\nAnd also please note that the free-threading CPython does not guarantee\nthe thread-safety of iterator operations.</p>\n</div>\n</dd>\n</main>\n"}, "funci\u00f3n clave": {"title": "funci\u00f3n clave", "body": "<main>\n<dd><p class=\"translated\">Una funci\u00f3n clave o una funci\u00f3n de colaci\u00f3n es un invocable que retorna un valor usado para el ordenamiento o clasificaci\u00f3n.  Por ejemplo, <a class=\"reference internal\" href=\"library/locale.html#locale.strxfrm\" title=\"locale.strxfrm\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">locale.strxfrm()</span></code></a> es usada para producir claves de ordenamiento que se adaptan a las convenciones espec\u00edficas de ordenamiento de un <em>locale</em>.</p>\n<p class=\"translated\">Cierta cantidad de herramientas de Python aceptan funciones clave para controlar como los elementos son ordenados o agrupados. Incluyendo a  <a class=\"reference internal\" href=\"library/functions.html#min\" title=\"min\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">min()</span></code></a>, <a class=\"reference internal\" href=\"library/functions.html#max\" title=\"max\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">max()</span></code></a>, <a class=\"reference internal\" href=\"library/functions.html#sorted\" title=\"sorted\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sorted()</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#list.sort\" title=\"list.sort\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">list.sort()</span></code></a>, <a class=\"reference internal\" href=\"library/heapq.html#heapq.merge\" title=\"heapq.merge\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">heapq.merge()</span></code></a>, <a class=\"reference internal\" href=\"library/heapq.html#heapq.nsmallest\" title=\"heapq.nsmallest\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">heapq.nsmallest()</span></code></a>, <a class=\"reference internal\" href=\"library/heapq.html#heapq.nlargest\" title=\"heapq.nlargest\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">heapq.nlargest()</span></code></a>, y <a class=\"reference internal\" href=\"library/itertools.html#itertools.groupby\" title=\"itertools.groupby\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">itertools.groupby()</span></code></a>.</p>\n<p class=\"translated\">Hay varias formas de crear una funci\u00f3n clave.  Por ejemplo, el m\u00e9todo <a class=\"reference internal\" href=\"library/stdtypes.html#str.lower\" title=\"str.lower\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">str.lower()</span></code></a> puede servir como funci\u00f3n clave para ordenamientos que no distingan may\u00fasculas de min\u00fasculas.  Como alternativa, una funci\u00f3n clave puede ser realizada con una expresi\u00f3n <a class=\"reference internal\" href=\"reference/expressions.html#lambda\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">lambda</span></code></a> como <code class=\"docutils literal notranslate\"><span class=\"pre\">lambda</span> <span class=\"pre\">r:</span> <span class=\"pre\">(r[0],</span> <span class=\"pre\">r[2])</span></code>.  Adem\u00e1s, <a class=\"reference internal\" href=\"library/operator.html#operator.attrgetter\" title=\"operator.attrgetter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">operator.attrgetter()</span></code></a>, <a class=\"reference internal\" href=\"library/operator.html#operator.itemgetter\" title=\"operator.itemgetter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">operator.itemgetter()</span></code></a> y <a class=\"reference internal\" href=\"library/operator.html#operator.methodcaller\" title=\"operator.methodcaller\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">operator.methodcaller()</span></code></a> son tres constructores de funciones clave.  Consulte <a class=\"reference internal\" href=\"howto/sorting.html#sortinghowto\"><span class=\"std std-ref\">Sorting HOW TO</span></a> para ver ejemplos de c\u00f3mo crear y utilizar funciones clave.</p>\n</dd>\n</main>\n"}, "argumento nombrado": {"title": "argumento nombrado", "body": "<main>\n<dd><p class=\"translated\">Vea <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a>.</p>\n</dd>\n</main>\n"}, "lambda": {"title": "lambda", "body": "<main>\n<dd><p class=\"translated\">Una funci\u00f3n an\u00f3nima de una l\u00ednea consistente en un sola <a class=\"reference internal\" href=\"#term-expression\"><span class=\"xref std std-term\">expression</span></a> que es evaluada cuando la funci\u00f3n es llamada.  La sintaxis para crear una funci\u00f3n lambda es <code class=\"docutils literal notranslate\"><span class=\"pre\">lambda</span> <span class=\"pre\">[parameters]:</span> <span class=\"pre\">expression</span></code></p>\n</dd>\n</main>\n"}, "lbyl": {"title": "LBYL", "body": "<main>\n<dd><p class=\"translated\">Del ingl\u00e9s <em>Look before you leap</em>, \u00abmira antes de saltar\u00bb.  Es un estilo de codificaci\u00f3n que prueba expl\u00edcitamente las condiciones previas antes de hacer llamadas o b\u00fasquedas.  Este estilo contrasta con la manera <a class=\"reference internal\" href=\"#term-EAFP\"><span class=\"xref std std-term\">EAFP</span></a> y est\u00e1 caracterizado por la presencia de muchas sentencias <a class=\"reference internal\" href=\"reference/compound_stmts.html#if\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">if</span></code></a>.</p>\n<p class=\"translated\">En entornos multi-hilos, el m\u00e9todo LBYL tiene el riesgo de introducir condiciones de carrera entre los hilos que est\u00e1n \u00abmirando\u00bb y los que est\u00e1n \u00absaltando\u00bb.  Por ejemplo, el c\u00f3digo, <code class=\"docutils literal notranslate\"><span class=\"pre\">if</span> <span class=\"pre\">key</span> <span class=\"pre\">in</span> <span class=\"pre\">mapping:</span> <span class=\"pre\">return</span> <span class=\"pre\">mapping[key]</span></code>  puede fallar si otro hilo remueve <em>key</em> de <em>mapping</em> despu\u00e9s del test, pero antes de retornar el valor.  Este problema puede ser resuelto usando bloqueos o empleando el m\u00e9todo EAFP.</p>\n</dd>\n</main>\n"}, "lexical analyzer": {"title": "lexical analyzer", "body": "<main>\n<dd><p class=\"untranslated\">Formal name for the <em>tokenizer</em>; see <a class=\"reference internal\" href=\"#term-token\"><span class=\"xref std std-term\">token</span></a>.</p>\n</dd>\n</main>\n"}, "lista": {"title": "lista", "body": "<main>\n<dd><p class=\"untranslated\">A built-in Python <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">sequence</span></a>.  Despite its name it is more akin\nto an array in other languages than to a linked list since access to\nelements is <em>O</em>(1).</p>\n</dd>\n</main>\n"}, "comprensi\u00f3n de listas": {"title": "comprensi\u00f3n de listas", "body": "<main>\n<dd><p class=\"translated\">Una forma compacta de procesar todos o parte de los elementos en una secuencia y retornar una lista como resultado.  <code class=\"docutils literal notranslate\"><span class=\"pre\">result</span> <span class=\"pre\">=</span> <span class=\"pre\">['{:#04x}'.format(x)</span> <span class=\"pre\">for</span> <span class=\"pre\">x</span> <span class=\"pre\">in</span> <span class=\"pre\">range(256)</span> <span class=\"pre\">if</span> <span class=\"pre\">x</span> <span class=\"pre\">%</span> <span class=\"pre\">2</span> <span class=\"pre\">==</span> <span class=\"pre\">0]</span></code> genera una lista de cadenas conteniendo n\u00fameros hexadecimales (0x..) entre 0 y 255. La cl\u00e1usula <a class=\"reference internal\" href=\"reference/compound_stmts.html#if\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">if</span></code></a> es opcional.  Si es omitida, todos los elementos en <code class=\"docutils literal notranslate\"><span class=\"pre\">range(256)</span></code> son procesados.</p>\n</dd>\n</main>\n"}, "cargador": {"title": "cargador", "body": "<main>\n<dd><p class=\"untranslated\">An object that loads a module.\nIt must define the <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">exec_module()</span></code> and <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">create_module()</span></code> methods\nto implement the <a class=\"reference internal\" href=\"library/importlib.html#importlib.abc.Loader\" title=\"importlib.abc.Loader\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">Loader</span></code></a> interface.\nA loader is typically returned by a <a class=\"reference internal\" href=\"#term-finder\"><span class=\"xref std std-term\">finder</span></a>.\nSee also:</p>\n<ul class=\"simple\">\n<li><p class=\"untranslated\"><a class=\"reference internal\" href=\"reference/import.html#finders-and-loaders\"><span class=\"std std-ref\">Buscadores y cargadores</span></a></p></li>\n<li><p class=\"untranslated\"><a class=\"reference internal\" href=\"library/importlib.html#importlib.abc.Loader\" title=\"importlib.abc.Loader\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">importlib.abc.Loader</span></code></a></p></li>\n<li><p class=\"untranslated\"><span class=\"target\" id=\"index-29\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0302/\"><strong>PEP 302</strong></a></p></li>\n</ul>\n</dd>\n</main>\n"}, "codificaci\u00f3n de la configuraci\u00f3n regional": {"title": "codificaci\u00f3n de la configuraci\u00f3n regional", "body": "<main>\n<dd><p class=\"translated\">En Unix, es la codificaci\u00f3n de la configuraci\u00f3n regional LC_CTYPE. Se puede configurar con <a class=\"reference internal\" href=\"library/locale.html#locale.setlocale\" title=\"locale.setlocale\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">locale.setlocale(locale.LC_CTYPE,</span> <span class=\"pre\">new_locale)</span></code></a>.</p>\n<p class=\"translated\">En Windows, es la p\u00e1gina de c\u00f3digos ANSI (por ejemplo, <code class=\"docutils literal notranslate\"><span class=\"pre\">&quot;cp1252&quot;</span></code>).</p>\n<p class=\"translated\">En Android y VxWorks, Python utiliza <code class=\"docutils literal notranslate\"><span class=\"pre\">&quot;utf-8&quot;</span></code> como codificaci\u00f3n regional.</p>\n<p class=\"untranslated\"><a class=\"reference internal\" href=\"library/locale.html#locale.getencoding\" title=\"locale.getencoding\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">locale.getencoding()</span></code></a> can be used to get the locale encoding.</p>\n<p class=\"translated\">Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-filesystem-encoding-and-error-handler\"><span class=\"xref std std-term\">filesystem encoding and error handler</span></a>.</p>\n</dd>\n</main>\n"}, "m\u00e9todo m\u00e1gico": {"title": "m\u00e9todo m\u00e1gico", "body": "<main>\n<dd><p class=\"translated\" id=\"index-30\">Una manera informal de llamar a un <a class=\"reference internal\" href=\"#term-special-method\"><span class=\"xref std std-term\">special method</span></a>.</p>\n</dd>\n</main>\n"}, "mapeado": {"title": "mapeado", "body": "<main>\n<dd><p class=\"translated\">Un objeto contenedor que permite recupero de claves arbitrarias y que implementa los m\u00e9todos especificados en la <a class=\"reference internal\" href=\"library/collections.abc.html#collections.abc.Mapping\" title=\"collections.abc.Mapping\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.abc.Mapping</span></code></a> o <a class=\"reference internal\" href=\"library/collections.abc.html#collections.abc.MutableMapping\" title=\"collections.abc.MutableMapping\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.abc.MutableMapping</span></code></a> <a class=\"reference internal\" href=\"library/collections.abc.html#collections-abstract-base-classes\"><span class=\"std std-ref\">abstract base classes</span></a>.  Por ejemplo, <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a>, <a class=\"reference internal\" href=\"library/collections.html#collections.defaultdict\" title=\"collections.defaultdict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.defaultdict</span></code></a>, <a class=\"reference internal\" href=\"library/collections.html#collections.OrderedDict\" title=\"collections.OrderedDict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.OrderedDict</span></code></a> y <a class=\"reference internal\" href=\"library/collections.html#collections.Counter\" title=\"collections.Counter\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.Counter</span></code></a>.</p>\n</dd>\n</main>\n"}, "meta buscadores de ruta": {"title": "meta buscadores de ruta", "body": "<main>\n<dd><p class=\"translated\">Un <a class=\"reference internal\" href=\"#term-finder\"><span class=\"xref std std-term\">finder</span></a> retornado por una b\u00fasqueda de <a class=\"reference internal\" href=\"library/sys.html#sys.meta_path\" title=\"sys.meta_path\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.meta_path</span></code></a>.  Los meta buscadores de ruta est\u00e1n relacionados a <a class=\"reference internal\" href=\"#term-path-entry-finder\"><span class=\"xref std std-term\">buscadores de entradas de rutas</span></a>, pero son algo diferente.</p>\n<p class=\"translated\">Vea en <a class=\"reference internal\" href=\"library/importlib.html#importlib.abc.MetaPathFinder\" title=\"importlib.abc.MetaPathFinder\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">importlib.abc.MetaPathFinder</span></code></a> los m\u00e9todos que los meta buscadores de ruta implementan.</p>\n</dd>\n</main>\n"}, "metaclase": {"title": "metaclase", "body": "<main>\n<dd><p class=\"translated\">La clase de una clase.  Las definiciones de clases crean nombres de clase, un diccionario de clase, y una lista de clases base.  Las metaclases son responsables de tomar estos tres argumentos y crear la clase.  La mayor\u00eda de los objetos de un lenguaje de programaci\u00f3n orientado a objetos provienen de una implementaci\u00f3n por defecto.  Lo que hace a Python especial que es posible crear metaclases a medida.  La mayor\u00eda de los usuario nunca necesitar\u00e1n esta herramienta, pero cuando la necesidad surge, las metaclases pueden brindar soluciones poderosas y elegantes.  Han sido usadas para <em>loggear</em> acceso de atributos, agregar seguridad a hilos, rastrear la creaci\u00f3n de objetos, implementar <em>singletons</em>, y muchas otras tareas.</p>\n<p class=\"translated\">M\u00e1s informaci\u00f3n hallar\u00e1 en <a class=\"reference internal\" href=\"reference/datamodel.html#metaclasses\"><span class=\"std std-ref\">Metaclases</span></a>.</p>\n</dd>\n</main>\n"}, "m\u00e9todo": {"title": "m\u00e9todo", "body": "<main>\n<dd><p class=\"translated\">Una funci\u00f3n que es definida dentro del cuerpo de una clase.  Si es llamada como un atributo de una instancia de otra clase, el m\u00e9todo tomar\u00e1 el objeto instanciado como su primer <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a> (el cual es usualmente denominado <cite>self</cite>). Vea <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">function</span></a> y <a class=\"reference internal\" href=\"#term-nested-scope\"><span class=\"xref std std-term\">nested scope</span></a>.</p>\n</dd>\n</main>\n"}, "orden de resoluci\u00f3n de m\u00e9todos": {"title": "orden de resoluci\u00f3n de m\u00e9todos", "body": "<main>\n<dd><p class=\"untranslated\">Method Resolution Order is the order in which base classes are searched\nfor a member during lookup. See <a class=\"reference internal\" href=\"howto/mro.html#python-2-3-mro\"><span class=\"std std-ref\">The Python 2.3 Method Resolution Order</span></a> for details of the\nalgorithm used by the Python interpreter since the 2.3 release.</p>\n</dd>\n</main>\n"}, "m\u00f3dulo": {"title": "m\u00f3dulo", "body": "<main>\n<dd><p class=\"translated\">Un objeto que sirve como unidad de organizaci\u00f3n del c\u00f3digo Python.  Los m\u00f3dulos tienen espacios de nombres conteniendo objetos Python arbitrarios.  Los m\u00f3dulos son cargados en Python por el proceso de <a class=\"reference internal\" href=\"#term-importing\"><span class=\"xref std std-term\">importing</span></a>.</p>\n<p class=\"translated\">Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-package\"><span class=\"xref std std-term\">package</span></a>.</p>\n</dd>\n</main>\n"}, "especificador de m\u00f3dulo": {"title": "especificador de m\u00f3dulo", "body": "<main>\n<dd><p class=\"translated\">Un espacio de nombres que contiene la informaci\u00f3n relacionada a la importaci\u00f3n usada al leer un m\u00f3dulo.  Una instancia de  <a class=\"reference internal\" href=\"library/importlib.html#importlib.machinery.ModuleSpec\" title=\"importlib.machinery.ModuleSpec\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">importlib.machinery.ModuleSpec</span></code></a>.</p>\n<p class=\"untranslated\">See also <a class=\"reference internal\" href=\"reference/import.html#module-specs\"><span class=\"std std-ref\">Module specs</span></a>.</p>\n</dd>\n</main>\n"}, "mro": {"title": "MRO", "body": "<main>\n<dd><p class=\"translated\">Vea <a class=\"reference internal\" href=\"#term-method-resolution-order\"><span class=\"xref std std-term\">method resolution order</span></a>.</p>\n</dd>\n</main>\n"}, "mutable": {"title": "mutable", "body": "<main>\n<dd><p class=\"translated\">Los objetos mutables pueden cambiar su valor pero mantener su <a class=\"reference internal\" href=\"library/functions.html#id\" title=\"id\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">id()</span></code></a>.  Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-immutable\"><span class=\"xref std std-term\">immutable</span></a>.</p>\n</dd>\n</main>\n"}, "tupla nombrada": {"title": "tupla nombrada", "body": "<main>\n<dd><p class=\"translated\">La denominaci\u00f3n \u00abtupla nombrada\u00bb se aplica a cualquier tipo o clase que hereda de una tupla y cuyos elementos indexables son tambi\u00e9n accesibles usando atributos nombrados. Este tipo o clase puede tener adem\u00e1s otras capacidades.</p>\n<p class=\"translated\">Varios tipos incorporados son tuplas nombradas, incluyendo los valores retornados por <a class=\"reference internal\" href=\"library/time.html#time.localtime\" title=\"time.localtime\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">time.localtime()</span></code></a> y <a class=\"reference internal\" href=\"library/os.html#os.stat\" title=\"os.stat\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.stat()</span></code></a>.  Otro ejemplo es <a class=\"reference internal\" href=\"library/sys.html#sys.float_info\" title=\"sys.float_info\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.float_info</span></code></a>:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">float_info</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>                   <span class=\"c1\"># indexed access</span>\n<span class=\"go\">1024</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">float_info</span><span class=\"o\">.</span><span class=\"n\">max_exp</span>              <span class=\"c1\"># named field access</span>\n<span class=\"go\">1024</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">float_info</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">)</span>   <span class=\"c1\"># kind of tuple</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n<p class=\"untranslated\">Some named tuples are built-in types (such as the above examples).\nAlternatively, a named tuple can be created from a regular class\ndefinition that inherits from <a class=\"reference internal\" href=\"library/stdtypes.html#tuple\" title=\"tuple\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">tuple</span></code></a> and that defines named\nfields.  Such a class can be written by hand, or it can be created by\ninheriting <a class=\"reference internal\" href=\"library/typing.html#typing.NamedTuple\" title=\"typing.NamedTuple\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">typing.NamedTuple</span></code></a>, or with the factory function\n<a class=\"reference internal\" href=\"library/collections.html#collections.namedtuple\" title=\"collections.namedtuple\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">collections.namedtuple()</span></code></a>.  The latter techniques also add some\nextra methods that may not be found in hand-written or built-in named\ntuples.</p>\n</dd>\n</main>\n"}, "espacio de nombres": {"title": "espacio de nombres", "body": "<main>\n<dd><p class=\"translated\">El lugar donde la variable es almacenada.  Los espacios de nombres son implementados como diccionarios.  Hay espacio de nombre local, global, e incorporado as\u00ed como espacios de nombres anidados en objetos (en m\u00e9todos).  Los espacios de nombres soportan modularidad previniendo conflictos de nombramiento.  Por ejemplo, las funciones <a class=\"reference internal\" href=\"library/functions.html#open\" title=\"open\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">builtins.open</span></code></a> y <a class=\"reference internal\" href=\"library/os.html#os.open\" title=\"os.open\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.open()</span></code></a> se distinguen por su espacio de nombres.  Los espacios de nombres tambi\u00e9n ayuda a la legibilidad y mantenibilidad dejando claro qu\u00e9 m\u00f3dulo implementa una funci\u00f3n.  Por ejemplo, escribiendo <a class=\"reference internal\" href=\"library/random.html#random.seed\" title=\"random.seed\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">random.seed()</span></code></a> o <a class=\"reference internal\" href=\"library/itertools.html#itertools.islice\" title=\"itertools.islice\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">itertools.islice()</span></code></a> queda claro que \u00e9stas funciones est\u00e1n implementadas en los m\u00f3dulos <a class=\"reference internal\" href=\"library/random.html#module-random\" title=\"random: Generate pseudo-random numbers with various common distributions.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">random</span></code></a> y <a class=\"reference internal\" href=\"library/itertools.html#module-itertools\" title=\"itertools: Functions creating iterators for efficient looping.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">itertools</span></code></a>, respectivamente.</p>\n</dd>\n</main>\n"}, "paquete de espacios de nombres": {"title": "paquete de espacios de nombres", "body": "<main>\n<dd><p class=\"untranslated\">A <a class=\"reference internal\" href=\"#term-package\"><span class=\"xref std std-term\">package</span></a> which serves only as a container for subpackages.\nNamespace packages may have no physical representation,\nand specifically are not like a <a class=\"reference internal\" href=\"#term-regular-package\"><span class=\"xref std std-term\">regular package</span></a> because they\nhave no <code class=\"docutils literal notranslate\"><span class=\"pre\">__init__.py</span></code> file.</p>\n<p class=\"untranslated\">Namespace packages allow several individually installable packages to have a common parent package.\nOtherwise, it is recommended to use a <a class=\"reference internal\" href=\"#term-regular-package\"><span class=\"xref std std-term\">regular package</span></a>.</p>\n<p class=\"untranslated\">For more information, see <span class=\"target\" id=\"index-31\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0420/\"><strong>PEP 420</strong></a> and <a class=\"reference internal\" href=\"reference/import.html#reference-namespace-package\"><span class=\"std std-ref\">Paquetes de espacio de nombres</span></a>.</p>\n<p class=\"translated\">Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-module\"><span class=\"xref std std-term\">module</span></a>.</p>\n</dd>\n</main>\n"}, "alcances anidados": {"title": "alcances anidados", "body": "<main>\n<dd><p class=\"translated\">La habilidad de referirse a una variable dentro de una definici\u00f3n encerrada.  Por ejemplo, una funci\u00f3n definida dentro de otra funci\u00f3n puede referir a variables en la funci\u00f3n externa.  Note que los alcances anidados por defecto s\u00f3lo funcionan para referencia y no para asignaci\u00f3n.  Las variables locales leen y escriben s\u00f3lo en el alcance m\u00e1s interno.  De manera semejante, las variables globales pueden leer y escribir en el espacio de nombres global.  Con <a class=\"reference internal\" href=\"reference/simple_stmts.html#nonlocal\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">nonlocal</span></code></a> se puede escribir en alcances exteriores.</p>\n</dd>\n</main>\n"}, "clase de nuevo estilo": {"title": "clase de nuevo estilo", "body": "<main>\n<dd><p class=\"untranslated\">Old name for the flavor of classes now used for all class objects.  In\nearlier Python versions, only new-style classes could use Python\u2019s newer,\nversatile features like <a class=\"reference internal\" href=\"reference/datamodel.html#object.__slots__\" title=\"object.__slots__\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">__slots__</span></code></a>, descriptors,\nproperties, <a class=\"reference internal\" href=\"reference/datamodel.html#object.__getattribute__\" title=\"object.__getattribute__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getattribute__()</span></code></a>, class methods, and static\nmethods.</p>\n</dd>\n</main>\n"}, "objeto": {"title": "objeto", "body": "<main>\n<dd><p class=\"translated\">Cualquier dato con estado (atributo o valor) y comportamiento definido (m\u00e9todos).  Tambi\u00e9n es la m\u00e1s b\u00e1sica clase base para cualquier <a class=\"reference internal\" href=\"#term-new-style-class\"><span class=\"xref std std-term\">new-style class</span></a>.</p>\n</dd>\n</main>\n"}, "optimized scope": {"title": "optimized scope", "body": "<main>\n<dd><p class=\"untranslated\">A scope where target local variable names are reliably known to the\ncompiler when the code is compiled, allowing optimization of read and\nwrite access to these names. The local namespaces for functions,\ngenerators, coroutines, comprehensions, and generator expressions are\noptimized in this fashion. Note: most interpreter optimizations are\napplied to all scopes, only those relying on a known set of local\nand nonlocal variable names are restricted to optimized scopes.</p>\n</dd>\n</main>\n"}, "paquete": {"title": "paquete", "body": "<main>\n<dd><p class=\"translated\">Un <a class=\"reference internal\" href=\"#term-module\"><span class=\"xref std std-term\">module</span></a> Python que puede contener subm\u00f3dulos o recursivamente, subpaquetes.  T\u00e9cnicamente, un paquete es un m\u00f3dulo Python con un atributo <code class=\"docutils literal notranslate\"><span class=\"pre\">__path__</span></code>.</p>\n<p class=\"translated\">Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-regular-package\"><span class=\"xref std std-term\">regular package</span></a> y <a class=\"reference internal\" href=\"#term-namespace-package\"><span class=\"xref std std-term\">namespace package</span></a>.</p>\n</dd>\n</main>\n"}, "par\u00e1metro": {"title": "par\u00e1metro", "body": "<main>\n<dd><p class=\"translated\">Una entidad nombrada en una definici\u00f3n de una <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">function</span></a> (o m\u00e9todo) que especifica un <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a> (o en algunos casos, varios argumentos) que la funci\u00f3n puede aceptar.  Existen cinco tipos de argumentos:</p>\n<ul>\n<li><p class=\"translated\"><em class=\"dfn\">posicional o nombrado</em>: especifica un argumento que puede ser pasado tanto como <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">posicional</span></a> o como <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">nombrado</span></a>.  Este es el tipo por defecto de par\u00e1metro, como <em>foo</em> y <em>bar</em> en el siguiente ejemplo:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">bar</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n</li>\n</ul>\n<ul id=\"positional-only-parameter\">\n<li><p class=\"translated\"><em class=\"dfn\">s\u00f3lo posicional</em>: especifica un argumento que puede ser pasado s\u00f3lo por posici\u00f3n.  Los par\u00e1metros s\u00f3lo posicionales pueden ser definidos incluyendo un car\u00e1cter <code class=\"docutils literal notranslate\"><span class=\"pre\">/</span></code> en la lista de par\u00e1metros de la funci\u00f3n despu\u00e9s de ellos, como <em>posonly1</em> y <em>posonly2</em> en el ejemplo que sigue:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">posonly1</span><span class=\"p\">,</span> <span class=\"n\">posonly2</span><span class=\"p\">,</span> <span class=\"o\">/</span><span class=\"p\">,</span> <span class=\"n\">positional_or_keyword</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n</li>\n</ul>\n<ul id=\"keyword-only-parameter\">\n<li><p class=\"translated\"><em class=\"dfn\">s\u00f3lo nombrado</em>: especifica un argumento que s\u00f3lo puede ser pasado por nombre.  Los par\u00e1metros s\u00f3lo por nombre pueden ser definidos incluyendo un par\u00e1metro posicional de una sola variable o un simple <code class=\"docutils literal notranslate\"><span class=\"pre\">*`</span></code> antes de ellos en la lista de par\u00e1metros en la definici\u00f3n de la funci\u00f3n, como <em>kw_only1</em> y <em>kw_only2</em> en el ejemplo siguiente:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"n\">kw_only1</span><span class=\"p\">,</span> <span class=\"n\">kw_only2</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n</li>\n<li><p class=\"translated\"><em class=\"dfn\">variable posicional</em>: especifica una secuencia arbitraria de argumentos posicionales que pueden ser brindados (adem\u00e1s de cualquier argumento posicional aceptado por otros par\u00e1metros).  Este par\u00e1metro puede ser definido anteponiendo al nombre del par\u00e1metro <code class=\"docutils literal notranslate\"><span class=\"pre\">*</span></code>, como a <em>args</em> en el siguiente ejemplo:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n</li>\n<li><p class=\"translated\"><em class=\"dfn\">variable nombrado</em>: especifica que arbitrariamente muchos argumentos nombrados pueden ser brindados (adem\u00e1s de cualquier argumento nombrado ya aceptado por cualquier otro par\u00e1metro).  Este par\u00e1metro puede ser definido anteponiendo al nombre del par\u00e1metro con <code class=\"docutils literal notranslate\"><span class=\"pre\">**</span></code>, como <em>kwargs</em> en el ejemplo precedente.</p></li>\n</ul>\n<p class=\"translated\">Los par\u00e1metros puede especificar tanto argumentos opcionales como requeridos, as\u00ed como valores por defecto para algunos argumentos opcionales.</p>\n<p class=\"translated\">Vea tambi\u00e9n el glosario de <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a>, la pregunta respondida en <a class=\"reference internal\" href=\"faq/programming.html#faq-argument-vs-parameter\"><span class=\"std std-ref\">la diferencia entre argumentos y par\u00e1metros</span></a>, la clase <a class=\"reference internal\" href=\"library/inspect.html#inspect.Parameter\" title=\"inspect.Parameter\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">inspect.Parameter</span></code></a>, la secci\u00f3n <a class=\"reference internal\" href=\"reference/compound_stmts.html#function\"><span class=\"std std-ref\">Definiciones de funciones</span></a> , y <span class=\"target\" id=\"index-83\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0362/\"><strong>PEP 362</strong></a>.</p>\n</dd>\n</main>\n"}, "entrada de ruta": {"title": "entrada de ruta", "body": "<main>\n<dd><p class=\"translated\">Una ubicaci\u00f3n \u00fanica en el <a class=\"reference internal\" href=\"#term-import-path\"><span class=\"xref std std-term\">import path</span></a> que el <a class=\"reference internal\" href=\"#term-path-based-finder\"><span class=\"xref std std-term\">path based finder</span></a> consulta para encontrar los m\u00f3dulos a importar.</p>\n</dd>\n</main>\n"}, "buscador de entradas de ruta": {"title": "buscador de entradas de ruta", "body": "<main>\n<dd><p class=\"translated\">Un <a class=\"reference internal\" href=\"#term-finder\"><span class=\"xref std std-term\">finder</span></a> retornado por un invocable en <a class=\"reference internal\" href=\"library/sys.html#sys.path_hooks\" title=\"sys.path_hooks\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.path_hooks</span></code></a> (esto es, un <a class=\"reference internal\" href=\"#term-path-entry-hook\"><span class=\"xref std std-term\">path entry hook</span></a>) que sabe c\u00f3mo localizar m\u00f3dulos dada una <a class=\"reference internal\" href=\"#term-path-entry\"><span class=\"xref std std-term\">path entry</span></a>.</p>\n<p class=\"translated\">Vea en <a class=\"reference internal\" href=\"library/importlib.html#importlib.abc.PathEntryFinder\" title=\"importlib.abc.PathEntryFinder\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">importlib.abc.PathEntryFinder</span></code></a> los m\u00e9todos que los buscadores de entradas de ruta implementan.</p>\n</dd>\n</main>\n"}, "gancho a entrada de ruta": {"title": "gancho a entrada de ruta", "body": "<main>\n<dd><p class=\"untranslated\">A callable on the <a class=\"reference internal\" href=\"library/sys.html#sys.path_hooks\" title=\"sys.path_hooks\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.path_hooks</span></code></a> list which returns a <a class=\"reference internal\" href=\"#term-path-entry-finder\"><span class=\"xref std std-term\">path\nentry finder</span></a> if it knows how to find modules on a specific <a class=\"reference internal\" href=\"#term-path-entry\"><span class=\"xref std std-term\">path\nentry</span></a>.</p>\n</dd>\n</main>\n"}, "buscador basado en ruta": {"title": "buscador basado en ruta", "body": "<main>\n<dd><p class=\"translated\">Uno de los <a class=\"reference internal\" href=\"#term-meta-path-finder\"><span class=\"xref std std-term\">meta buscadores de ruta</span></a> por defecto que busca un <a class=\"reference internal\" href=\"#term-import-path\"><span class=\"xref std std-term\">import path</span></a> para los m\u00f3dulos.</p>\n</dd>\n</main>\n"}, "objeto tipo ruta": {"title": "objeto tipo ruta", "body": "<main>\n<dd><p class=\"translated\">Un objeto que representa una ruta del sistema de archivos. Un objeto tipo ruta puede ser tanto una <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a> como un <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a> representando una ruta, o un objeto que implementa el protocolo <a class=\"reference internal\" href=\"library/os.html#os.PathLike\" title=\"os.PathLike\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">os.PathLike</span></code></a>. Un objeto que soporta el protocolo  <a class=\"reference internal\" href=\"library/os.html#os.PathLike\" title=\"os.PathLike\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">os.PathLike</span></code></a> puede ser convertido a ruta del sistema de archivo de clase <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a> o <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a> usando la funci\u00f3n <a class=\"reference internal\" href=\"library/os.html#os.fspath\" title=\"os.fspath\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.fspath()</span></code></a>; <a class=\"reference internal\" href=\"library/os.html#os.fsdecode\" title=\"os.fsdecode\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.fsdecode()</span></code></a> <a class=\"reference internal\" href=\"library/os.html#os.fsencode\" title=\"os.fsencode\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.fsencode()</span></code></a> pueden emplearse para garantizar que retorne respectivamente <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a> o <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a>. Introducido por <span class=\"target\" id=\"index-84\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0519/\"><strong>PEP 519</strong></a>.</p>\n</dd>\n</main>\n"}, "pep": {"title": "PEP", "body": "<main>\n<dd><p class=\"translated\">Propuesta de mejora de Python, del ingl\u00e9s <em>Python Enhancement Proposal</em>. Un PEP es un documento de dise\u00f1o que brinda informaci\u00f3n a la comunidad Python, o describe una nueva capacidad para Python, sus procesos o entorno. Los PEPs deber\u00edan dar una especificaci\u00f3n t\u00e9cnica concisa y una fundamentaci\u00f3n para las capacidades propuestas.</p>\n<p class=\"translated\">Los PEPs tienen como prop\u00f3sito ser los mecanismos primarios para proponer nuevas y mayores capacidad, para recoger la opini\u00f3n de la comunidad sobre un tema, y para documentar las decisiones de dise\u00f1o que se han hecho en Python. El autor del PEP es el responsable de lograr consenso con la comunidad y documentar las opiniones disidentes.</p>\n<p class=\"translated\">Vea <span class=\"target\" id=\"index-85\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0001/\"><strong>PEP 1</strong></a>.</p>\n</dd>\n</main>\n"}, "porci\u00f3n": {"title": "porci\u00f3n", "body": "<main>\n<dd><p class=\"translated\">Un conjunto de archivos en un \u00fanico directorio (posiblemente guardo en un archivo comprimido <em>zip</em>) que contribuye a un espacio de nombres de paquete, como est\u00e1 definido en <span class=\"target\" id=\"index-86\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0420/\"><strong>PEP 420</strong></a>.</p>\n</dd>\n</main>\n"}, "argumento posicional": {"title": "argumento posicional", "body": "<main>\n<dd><p class=\"translated\">Vea <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a>.</p>\n</dd>\n</main>\n"}, "api provisional": {"title": "API provisional", "body": "<main>\n<dd><p class=\"translated\">Una API provisoria es aquella que deliberadamente fue excluida de las garant\u00edas de compatibilidad hacia atr\u00e1s de la biblioteca est\u00e1ndar.  Aunque no se esperan cambios fundamentales en dichas interfaces, como est\u00e1n marcadas como provisionales, los cambios incompatibles hacia atr\u00e1s (incluso remover la misma interfaz) podr\u00edan ocurrir si los desarrolladores principales lo estiman.  Estos cambios no se hacen gratuitamente \u2013 solo ocurrir\u00e1n si fallas fundamentales y serias son descubiertas que no fueron vistas antes de la inclusi\u00f3n de la API.</p>\n<p class=\"translated\">Incluso para APIs provisorias, los cambios incompatibles hacia atr\u00e1s son vistos como una \u00absoluci\u00f3n de \u00faltimo recurso\u00bb - se intentar\u00e1 todo para encontrar una soluci\u00f3n compatible hacia atr\u00e1s para los problemas identificados.</p>\n<p class=\"translated\">Este proceso permite que la biblioteca est\u00e1ndar contin\u00fae evolucionando con el tiempo, sin bloquearse por errores de dise\u00f1o problem\u00e1ticos por per\u00edodos extensos de tiempo. Vea <span class=\"target\" id=\"index-87\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0411/\"><strong>PEP 411</strong></a> para m\u00e1s detalles.</p>\n</dd>\n</main>\n"}, "paquete provisorio": {"title": "paquete provisorio", "body": "<main>\n<dd><p class=\"translated\">Vea <a class=\"reference internal\" href=\"#term-provisional-API\"><span class=\"xref std std-term\">provisional API</span></a>.</p>\n</dd>\n</main>\n"}, "python 3000": {"title": "Python 3000", "body": "<main>\n<dd><p class=\"translated\">Apodo para la fecha de lanzamiento de Python 3.x (acu\u00f1ada en un tiempo cuando llegar a la versi\u00f3n 3 era algo distante en el futuro.)  Tambi\u00e9n se lo abrevi\u00f3 como <em>Py3k</em>.</p>\n</dd>\n</main>\n"}, "pyth\u00f3nico": {"title": "Pyth\u00f3nico", "body": "<main>\n<dd><p class=\"translated\">Una idea o pieza de c\u00f3digo que sigue ajustadamente la convenciones idiom\u00e1ticas comunes del lenguaje Python, en vez de implementar c\u00f3digo usando conceptos comunes a otros lenguajes.  Por ejemplo, una convenci\u00f3n com\u00fan en Python es hacer bucles sobre todos los elementos de un iterable con la sentencia <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a>.  Muchos otros lenguajes no tienen este tipo de construcci\u00f3n, as\u00ed que los que no est\u00e1n familiarizados con Python podr\u00edan usar contadores num\u00e9ricos:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">food</span><span class=\"p\">)):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">food</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n</pre></div>\n</div>\n<p class=\"translated\">En contraste, un m\u00e9todo Pyth\u00f3nico m\u00e1s limpio:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">for</span> <span class=\"n\">piece</span> <span class=\"ow\">in</span> <span class=\"n\">food</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">piece</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</dd>\n</main>\n"}, "nombre calificado": {"title": "nombre calificado", "body": "<main>\n<dd><p class=\"translated\">Un nombre con puntos mostrando la ruta desde el alcance global del m\u00f3dulo a la clase, funci\u00f3n o m\u00e9todo definido en dicho m\u00f3dulo, como se define en <span class=\"target\" id=\"index-88\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-3155/\"><strong>PEP 3155</strong></a>.  Para las funciones o clases de m\u00e1s alto nivel, el nombre calificado es el igual al nombre del objeto:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">C</span><span class=\"p\">:</span>\n<span class=\"gp\">... </span>    <span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">D</span><span class=\"p\">:</span>\n<span class=\"gp\">... </span>        <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">meth</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>            <span class=\"k\">pass</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">C</span><span class=\"o\">.</span><span class=\"vm\">__qualname__</span>\n<span class=\"go\">&#39;C&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">D</span><span class=\"o\">.</span><span class=\"vm\">__qualname__</span>\n<span class=\"go\">&#39;C.D&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">D</span><span class=\"o\">.</span><span class=\"n\">meth</span><span class=\"o\">.</span><span class=\"vm\">__qualname__</span>\n<span class=\"go\">&#39;C.D.meth&#39;</span>\n</pre></div>\n</div>\n<p class=\"translated\">Cuando es usado para referirse a los m\u00f3dulos, <em>nombre completamente calificado</em> significa la ruta con puntos completo al m\u00f3dulo, incluyendo cualquier paquete padre, por ejemplo, <code class=\"docutils literal notranslate\"><span class=\"pre\">email.mime.text</span></code>:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">email.mime.text</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">email</span><span class=\"o\">.</span><span class=\"n\">mime</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"o\">.</span><span class=\"vm\">__name__</span>\n<span class=\"go\">&#39;email.mime.text&#39;</span>\n</pre></div>\n</div>\n</dd>\n</main>\n"}, "contador de referencias": {"title": "contador de referencias", "body": "<main>\n<dd><p class=\"untranslated\">The number of references to an object.  When the reference count of an\nobject drops to zero, it is deallocated.  Some objects are\n<a class=\"reference internal\" href=\"#term-immortal\"><span class=\"xref std std-term\">immortal</span></a> and have reference counts that are never modified, and\ntherefore the objects are never deallocated.  Reference counting is\ngenerally not visible to Python code, but it is a key element of the\n<a class=\"reference internal\" href=\"#term-CPython\"><span class=\"xref std std-term\">CPython</span></a> implementation.  Programmers can call the\n<a class=\"reference internal\" href=\"library/sys.html#sys.getrefcount\" title=\"sys.getrefcount\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sys.getrefcount()</span></code></a> function to return the\nreference count for a particular object.</p>\n<p class=\"untranslated\">In <a class=\"reference internal\" href=\"#term-CPython\"><span class=\"xref std std-term\">CPython</span></a>, reference counts are not considered to be stable\nor well-defined values; the number of references to an object, and how\nthat number is affected by Python code, may be different between\nversions.</p>\n</dd>\n</main>\n"}, "paquete regular": {"title": "paquete regular", "body": "<main>\n<dd><p class=\"translated\">Un  <a class=\"reference internal\" href=\"#term-package\"><span class=\"xref std std-term\">package</span></a> tradicional, como aquellos con un directorio conteniendo el archivo <code class=\"docutils literal notranslate\"><span class=\"pre\">__init__.py</span></code>.</p>\n<p class=\"translated\">Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-namespace-package\"><span class=\"xref std std-term\">namespace package</span></a>.</p>\n</dd>\n</main>\n"}, "repl": {"title": "REPL", "body": "<main>\n<dd><p class=\"untranslated\">An acronym for the \u00abread\u2013eval\u2013print loop\u00bb, another name for the\n<a class=\"reference internal\" href=\"#term-interactive\"><span class=\"xref std std-term\">interactive</span></a> interpreter shell.</p>\n</dd>\n</main>\n"}, "__slots__": {"title": "__slots__", "body": "<main>\n<dd><p class=\"translated\">Es una declaraci\u00f3n dentro de una clase que ahorra memoria predeclarando espacio para las atributos de la instancia y eliminando diccionarios de la instancia.  Aunque es popular, esta t\u00e9cnica es algo dificultosa de lograr correctamente y es mejor reservarla para los casos raros en los que existen grandes cantidades de instancias en aplicaciones con uso cr\u00edtico de memoria.</p>\n</dd>\n</main>\n"}, "secuencia": {"title": "secuencia", "body": "<main>\n<dd><p class=\"untranslated\">An <a class=\"reference internal\" href=\"#term-iterable\"><span class=\"xref std std-term\">iterable</span></a> which supports efficient element access using integer\nindices via the <a class=\"reference internal\" href=\"reference/datamodel.html#object.__getitem__\" title=\"object.__getitem__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getitem__()</span></code></a> special method and defines a\n<a class=\"reference internal\" href=\"reference/datamodel.html#object.__len__\" title=\"object.__len__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__len__()</span></code></a> method that returns the length of the sequence.\nSome built-in sequence types are <a class=\"reference internal\" href=\"library/stdtypes.html#list\" title=\"list\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">list</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a>,\n<a class=\"reference internal\" href=\"library/stdtypes.html#tuple\" title=\"tuple\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">tuple</span></code></a>, and <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a>. Note that <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a> also\nsupports <a class=\"reference internal\" href=\"reference/datamodel.html#object.__getitem__\" title=\"object.__getitem__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getitem__()</span></code></a> and <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__len__()</span></code>, but is considered a\nmapping rather than a sequence because the lookups use arbitrary\n<a class=\"reference internal\" href=\"#term-hashable\"><span class=\"xref std std-term\">hashable</span></a> keys rather than integers.</p>\n<p class=\"untranslated\">The <a class=\"reference internal\" href=\"library/collections.abc.html#collections.abc.Sequence\" title=\"collections.abc.Sequence\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.abc.Sequence</span></code></a> abstract base class\ndefines a much richer interface that goes beyond just\n<a class=\"reference internal\" href=\"reference/datamodel.html#object.__getitem__\" title=\"object.__getitem__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getitem__()</span></code></a> and <a class=\"reference internal\" href=\"reference/datamodel.html#object.__len__\" title=\"object.__len__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__len__()</span></code></a>, adding\n<a class=\"reference internal\" href=\"library/stdtypes.html#sequence.count\" title=\"sequence.count\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">count()</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#sequence.index\" title=\"sequence.index\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">index()</span></code></a>,\n<a class=\"reference internal\" href=\"reference/datamodel.html#object.__contains__\" title=\"object.__contains__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__contains__()</span></code></a>, and <a class=\"reference internal\" href=\"reference/datamodel.html#object.__reversed__\" title=\"object.__reversed__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__reversed__()</span></code></a>.\nTypes that implement this expanded\ninterface can be registered explicitly using\n<a class=\"reference internal\" href=\"library/abc.html#abc.ABCMeta.register\" title=\"abc.ABCMeta.register\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">register()</span></code></a>. For more documentation on sequence\nmethods generally, see\n<a class=\"reference internal\" href=\"library/stdtypes.html#typesseq-common\"><span class=\"std std-ref\">Common Sequence Operations</span></a>.</p>\n</dd>\n</main>\n"}, "comprensi\u00f3n de conjuntos": {"title": "comprensi\u00f3n de conjuntos", "body": "<main>\n<dd><p class=\"translated\">Una forma compacta de procesar todos o parte de los elementos en un iterable y retornar un conjunto con los resultados. <code class=\"docutils literal notranslate\"><span class=\"pre\">results</span> <span class=\"pre\">=</span> <span class=\"pre\">{c</span> <span class=\"pre\">for</span> <span class=\"pre\">c</span> <span class=\"pre\">in</span> <span class=\"pre\">'abracadabra'</span> <span class=\"pre\">if</span> <span class=\"pre\">c</span> <span class=\"pre\">not</span> <span class=\"pre\">in</span> <span class=\"pre\">'abc'}</span></code> genera el conjunto de cadenas <code class=\"docutils literal notranslate\"><span class=\"pre\">{'r',</span> <span class=\"pre\">'d'}</span></code>. Ver <a class=\"reference internal\" href=\"reference/expressions.html#comprehensions\"><span class=\"std std-ref\">Despliegues para listas, conjuntos y diccionarios</span></a>.</p>\n</dd>\n</main>\n"}, "despacho \u00fanico": {"title": "despacho \u00fanico", "body": "<main>\n<dd><p class=\"translated\">Una forma de despacho de una <a class=\"reference internal\" href=\"#term-generic-function\"><span class=\"xref std std-term\">generic function</span></a> donde la implementaci\u00f3n es elegida a partir del tipo de un s\u00f3lo argumento.</p>\n</dd>\n</main>\n"}, "rebanada": {"title": "rebanada", "body": "<main>\n<dd><p class=\"translated\">Un objeto que contiene una porci\u00f3n de una <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">sequence</span></a>.  Una rebanada es creada usando la notaci\u00f3n de suscripto, <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code> con dos puntos entre los n\u00fameros cuando se ponen varios, como en <code class=\"docutils literal notranslate\"><span class=\"pre\">nombre_variable[1:3:5]</span></code>.  La notaci\u00f3n con corchete (suscrito) usa internamente objetos <a class=\"reference internal\" href=\"library/functions.html#slice\" title=\"slice\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">slice</span></code></a>.</p>\n</dd>\n</main>\n"}, "soft deprecated": {"title": "soft deprecated", "body": "<main>\n<dd><p class=\"untranslated\">A soft deprecated API should not be used in new code,\nbut it is safe for already existing code to use it.\nThe API remains documented and tested, but will not be enhanced further.</p>\n<p class=\"untranslated\">Soft deprecation, unlike normal deprecation, does not plan on removing the API\nand will not emit warnings.</p>\n<p class=\"untranslated\">See <a class=\"reference external\" href=\"https://peps.python.org/pep-0387/#soft-deprecation\">PEP 387: Soft Deprecation</a>.</p>\n</dd>\n</main>\n"}, "m\u00e9todo especial": {"title": "m\u00e9todo especial", "body": "<main>\n<dd><p class=\"translated\" id=\"index-38\">Un m\u00e9todo que es llamado impl\u00edcitamente por Python cuando ejecuta ciertas operaciones en un tipo, como la adici\u00f3n.  Estos m\u00e9todos tienen nombres que comienzan y terminan con doble barra baja.  Los m\u00e9todos especiales est\u00e1n documentados en <a class=\"reference internal\" href=\"reference/datamodel.html#specialnames\"><span class=\"std std-ref\">Nombres especiales de m\u00e9todo</span></a>.</p>\n</dd>\n</main>\n"}, "standard library": {"title": "standard library", "body": "<main>\n<dd><p class=\"untranslated\">The collection of <a class=\"reference internal\" href=\"#term-package\"><span class=\"xref std std-term\">packages</span></a>, <a class=\"reference internal\" href=\"#term-module\"><span class=\"xref std std-term\">modules</span></a>\nand <a class=\"reference internal\" href=\"#term-extension-module\"><span class=\"xref std std-term\">extension modules</span></a> distributed as a part\nof the official Python interpreter package.  The exact membership of the\ncollection may vary based on platform, available system libraries, or\nother criteria.  Documentation can be found at <a class=\"reference internal\" href=\"library/index.html#library-index\"><span class=\"std std-ref\">La biblioteca est\u00e1ndar de Python</span></a>.</p>\n<p class=\"untranslated\">See also <a class=\"reference internal\" href=\"library/sys.html#sys.stdlib_module_names\" title=\"sys.stdlib_module_names\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdlib_module_names</span></code></a> for a list of all possible\nstandard library module names.</p>\n</dd>\n</main>\n"}, "sentencia": {"title": "sentencia", "body": "<main>\n<dd><p class=\"translated\">Una sentencia es parte de un conjunto (un \u00abbloque\u00bb de c\u00f3digo).  Una sentencia tanto es una <a class=\"reference internal\" href=\"#term-expression\"><span class=\"xref std std-term\">expression</span></a>  como alguna de las varias sintaxis usando una palabra clave, como <a class=\"reference internal\" href=\"reference/compound_stmts.html#if\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">if</span></code></a>, <a class=\"reference internal\" href=\"reference/compound_stmts.html#while\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">while</span></code></a> o <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a>.</p>\n</dd>\n</main>\n"}, "static type checker": {"title": "static type checker", "body": "<main>\n<dd><p class=\"untranslated\">An external tool that reads Python code and analyzes it, looking for\nissues such as incorrect types. See also <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">type hints</span></a>\nand the <a class=\"reference internal\" href=\"library/typing.html#module-typing\" title=\"typing: Support for type hints (see :pep:`484`).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">typing</span></code></a> module.</p>\n</dd>\n</main>\n"}, "stdlib": {"title": "stdlib", "body": "<main>\n<dd><p class=\"untranslated\">An abbreviation of <a class=\"reference internal\" href=\"#term-standard-library\"><span class=\"xref std std-term\">standard library</span></a>.</p>\n</dd>\n</main>\n"}, "referencia fuerte": {"title": "referencia fuerte", "body": "<main>\n<dd><p class=\"translated\">En la API de C de Python, una referencia fuerte es una referencia a un objeto que es propiedad del c\u00f3digo que mantiene la referencia.  La referencia fuerte se toma llamando a <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_INCREF\" title=\"Py_INCREF\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_INCREF()</span></code></a> cuando se crea la referencia y se libera con <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_DECREF\" title=\"Py_DECREF\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_DECREF()</span></code></a> cuando se elimina la referencia.</p>\n<p class=\"translated\">La funci\u00f3n <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_NewRef\" title=\"Py_NewRef\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_NewRef()</span></code></a> se puede utilizar para crear una referencia fuerte a un objeto. Por lo general, se debe llamar a la funci\u00f3n <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_DECREF\" title=\"Py_DECREF\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_DECREF()</span></code></a> en la referencia fuerte antes de salir del alcance de la referencia fuerte, para evitar filtrar una referencia.</p>\n<p class=\"translated\">Consulte tambi\u00e9n <a class=\"reference internal\" href=\"#term-borrowed-reference\"><span class=\"xref std std-term\">borrowed reference</span></a>.</p>\n</dd>\n</main>\n"}, "t-string": {"title": "t-string", "body": "<main>\n<dd><p class=\"untranslated\">String literals prefixed with <code class=\"docutils literal notranslate\"><span class=\"pre\">t</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">T</span></code> are commonly called\n\u00abt-strings\u00bb which is short for\n<a class=\"reference internal\" href=\"reference/lexical_analysis.html#t-strings\"><span class=\"std std-ref\">template string literals</span></a>.</p>\n</dd>\n</main>\n"}, "codificaci\u00f3n de texto": {"title": "codificaci\u00f3n de texto", "body": "<main>\n<dd><p class=\"translated\">Una cadena de caracteres en Python es una secuencia de puntos de c\u00f3digo Unicode (en el rango <code class=\"docutils literal notranslate\"><span class=\"pre\">U+0000</span></code>\u2013<code class=\"docutils literal notranslate\"><span class=\"pre\">U+10FFFF</span></code>). Para almacenar o transferir una cadena de caracteres, es necesario serializarla como una secuencia de bytes.</p>\n<p class=\"translated\">La serializaci\u00f3n de una cadena de caracteres en una secuencia de bytes se conoce como \u00abcodificaci\u00f3n\u00bb, y la recreaci\u00f3n de la cadena de caracteres a partir de la secuencia de bytes se conoce como \u00abdecodificaci\u00f3n\u00bb.</p>\n<p class=\"translated\">Existe una gran variedad de serializaciones de texto <a class=\"reference internal\" href=\"library/codecs.html#standard-encodings\"><span class=\"std std-ref\">codecs</span></a>, que se denominan colectivamente \u00abcodificaciones de texto\u00bb.</p>\n</dd>\n</main>\n"}, "archivo de texto": {"title": "archivo de texto", "body": "<main>\n<dd><p class=\"translated\">Un <a class=\"reference internal\" href=\"#term-file-object\"><span class=\"xref std std-term\">file object</span></a> capaz de leer y escribir objetos <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a>. Frecuentemente, un archivo de texto tambi\u00e9n accede a un flujo de datos binario y maneja autom\u00e1ticamente el <a class=\"reference internal\" href=\"#term-text-encoding\"><span class=\"xref std std-term\">text encoding</span></a>. Ejemplos de archivos de texto que son abiertos en modo texto (<code class=\"docutils literal notranslate\"><span class=\"pre\">'r'</span></code> o <code class=\"docutils literal notranslate\"><span class=\"pre\">'w'</span></code>), <a class=\"reference internal\" href=\"library/sys.html#sys.stdin\" title=\"sys.stdin\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdin</span></code></a>, <a class=\"reference internal\" href=\"library/sys.html#sys.stdout\" title=\"sys.stdout\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdout</span></code></a>, y las instancias de <a class=\"reference internal\" href=\"library/io.html#io.StringIO\" title=\"io.StringIO\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">io.StringIO</span></code></a>.</p>\n<p class=\"translated\">Vea tambi\u00e9n <a class=\"reference internal\" href=\"#term-binary-file\"><span class=\"xref std std-term\">binary file</span></a> por objeto de archivos capaces de leer y escribir <a class=\"reference internal\" href=\"#term-bytes-like-object\"><span class=\"xref std std-term\">objeto tipo binario</span></a>.</p>\n</dd>\n</main>\n"}, "thread state": {"title": "thread state", "body": "<main>\n<dd><p class=\"untranslated\">The information used by the <a class=\"reference internal\" href=\"#term-CPython\"><span class=\"xref std std-term\">CPython</span></a> runtime to run in an OS thread.\nFor example, this includes the current exception, if any, and the\nstate of the bytecode interpreter.</p>\n<p class=\"untranslated\">Each thread state is bound to a single OS thread, but threads may have\nmany thread states available.  At most, one of them may be\n<a class=\"reference internal\" href=\"#term-attached-thread-state\"><span class=\"xref std std-term\">attached</span></a> at once.</p>\n<p class=\"untranslated\">An <a class=\"reference internal\" href=\"#term-attached-thread-state\"><span class=\"xref std std-term\">attached thread state</span></a> is required to call most\nof Python\u2019s C API, unless a function explicitly documents otherwise.\nThe bytecode interpreter only runs under an attached thread state.</p>\n<p class=\"untranslated\">Each thread state belongs to a single interpreter, but each interpreter\nmay have many thread states, including multiple for the same OS thread.\nThread states from multiple interpreters may be bound to the same\nthread, but only one can be <a class=\"reference internal\" href=\"#term-attached-thread-state\"><span class=\"xref std std-term\">attached</span></a> in\nthat thread at any given moment.</p>\n<p class=\"untranslated\">See <a class=\"reference internal\" href=\"c-api/init.html#threads\"><span class=\"std std-ref\">Thread State and the Global Interpreter Lock</span></a> for more\ninformation.</p>\n</dd>\n</main>\n"}, "token": {"title": "token", "body": "<main>\n<dd><p class=\"untranslated\">A small unit of source code, generated by the\n<a class=\"reference internal\" href=\"reference/lexical_analysis.html#lexical\"><span class=\"std std-ref\">lexical analyzer</span></a> (also called the <em>tokenizer</em>).\nNames, numbers, strings, operators,\nnewlines and similar are represented by tokens.</p>\n<p class=\"untranslated\">The <a class=\"reference internal\" href=\"library/tokenize.html#module-tokenize\" title=\"tokenize: Lexical scanner for Python source code.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">tokenize</span></code></a> module exposes Python\u2019s lexical analyzer.\nThe <a class=\"reference internal\" href=\"library/token.html#module-token\" title=\"token: Constants representing terminal nodes of the parse tree.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">token</span></code></a> module contains information on the various types\nof tokens.</p>\n</dd>\n</main>\n"}, "cadena con triple comilla": {"title": "cadena con triple comilla", "body": "<main>\n<dd><p class=\"translated\">Una cadena que est\u00e1 enmarcada por tres instancias de comillas (\u00bb) o apostrofes (\u201c).  Aunque no brindan ninguna funcionalidad que no est\u00e1 disponible usando cadenas con comillas simple, son \u00fatiles por varias razones.  Permiten incluir comillas simples o dobles sin escapar dentro de las cadenas y pueden abarcar m\u00faltiples l\u00edneas sin el uso de caracteres de continuaci\u00f3n, haci\u00e9ndolas particularmente \u00fatiles para escribir docstrings.</p>\n</dd>\n</main>\n"}, "tipo": {"title": "tipo", "body": "<main>\n<dd><p class=\"untranslated\">The type of a Python object determines what kind of object it is; every\nobject has a type.  An object\u2019s type is accessible as its\n<a class=\"reference internal\" href=\"reference/datamodel.html#object.__class__\" title=\"object.__class__\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">__class__</span></code></a> attribute or can be retrieved with\n<code class=\"docutils literal notranslate\"><span class=\"pre\">type(obj)</span></code>.</p>\n</dd>\n</main>\n"}, "alias de tipos": {"title": "alias de tipos", "body": "<main>\n<dd><p class=\"translated\">Un sin\u00f3nimo para un tipo, creado al asignar un tipo a un identificador.</p>\n<p class=\"translated\">Los alias de tipos son \u00fatiles para simplificar los <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">indicadores de tipo</span></a>. Por ejemplo:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">remove_gray_shades</span><span class=\"p\">(</span>\n        <span class=\"n\">colors</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]])</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]:</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p class=\"translated\">podr\u00eda ser m\u00e1s legible as\u00ed:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">Color</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>\n\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">remove_gray_shades</span><span class=\"p\">(</span><span class=\"n\">colors</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">Color</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">Color</span><span class=\"p\">]:</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p class=\"translated\">Vea <a class=\"reference internal\" href=\"library/typing.html#module-typing\" title=\"typing: Support for type hints (see :pep:`484`).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">typing</span></code></a> y <span class=\"target\" id=\"index-89\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>, que describen esta funcionalidad.</p>\n</dd>\n</main>\n"}, "indicador de tipo": {"title": "indicador de tipo", "body": "<main>\n<dd><p class=\"translated\">Una  <a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotation</span></a> que especifica el tipo esperado para una variable, un atributo de clase, un par\u00e1metro para una funci\u00f3n o un valor de retorno.</p>\n<p class=\"untranslated\">Type hints are optional and are not enforced by Python but\nthey are useful to <a class=\"reference internal\" href=\"#term-static-type-checker\"><span class=\"xref std std-term\">static type checkers</span></a>.\nThey can also aid IDEs with code completion and refactoring.</p>\n<p class=\"translated\">Los indicadores de tipo de las variables globales, atributos de clase, y funciones, no de variables locales, pueden ser accedidos usando <a class=\"reference internal\" href=\"library/typing.html#typing.get_type_hints\" title=\"typing.get_type_hints\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">typing.get_type_hints()</span></code></a>.</p>\n<p class=\"translated\">Vea <a class=\"reference internal\" href=\"library/typing.html#module-typing\" title=\"typing: Support for type hints (see :pep:`484`).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">typing</span></code></a> y <span class=\"target\" id=\"index-90\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>, que describen esta funcionalidad.</p>\n</dd>\n</main>\n"}, "saltos de l\u00edneas universales": {"title": "saltos de l\u00edneas universales", "body": "<main>\n<dd><p class=\"translated\">Una manera de interpretar flujos de texto en la cual son reconocidos como finales de l\u00ednea todas siguientes formas: la convenci\u00f3n de Unix para fin de l\u00ednea <code class=\"docutils literal notranslate\"><span class=\"pre\">'\\n'</span></code>, la convenci\u00f3n de Windows <code class=\"docutils literal notranslate\"><span class=\"pre\">'\\r\\n'</span></code>, y la vieja convenci\u00f3n de Macintosh <code class=\"docutils literal notranslate\"><span class=\"pre\">'\\r'</span></code>.  Vea <span class=\"target\" id=\"index-91\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0278/\"><strong>PEP 278</strong></a> y <span class=\"target\" id=\"index-92\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-3116/\"><strong>PEP 3116</strong></a>, adem\u00e1s de <a class=\"reference internal\" href=\"library/stdtypes.html#bytes.splitlines\" title=\"bytes.splitlines\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">bytes.splitlines()</span></code></a> para usos adicionales.</p>\n</dd>\n</main>\n"}, "anotaci\u00f3n de variable": {"title": "anotaci\u00f3n de variable", "body": "<main>\n<dd><p class=\"translated\">Una <a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotation</span></a> de una variable o un atributo de clase.</p>\n<p class=\"translated\">Cuando se anota una variable o un atributo de clase, la asignaci\u00f3n es opcional:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">C</span><span class=\"p\">:</span>\n    <span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"s1\">&#39;annotation&#39;</span>\n</pre></div>\n</div>\n<p class=\"translated\">Las anotaciones de variables son frecuentemente usadas para <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">type hints</span></a>: por ejemplo, se espera que esta variable tenga valores de clase <a class=\"reference internal\" href=\"library/functions.html#int\" title=\"int\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">int</span></code></a>:</p>\n<div class=\"untranslated highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n</pre></div>\n</div>\n<p class=\"translated\">La sintaxis de la anotaci\u00f3n de variables est\u00e1 explicada en la secci\u00f3n <a class=\"reference internal\" href=\"reference/simple_stmts.html#annassign\"><span class=\"std std-ref\">Declaraciones de asignaci\u00f3n anotadas</span></a>.</p>\n<p class=\"translated\">Consulte <a class=\"reference internal\" href=\"#term-function-annotation\"><span class=\"xref std std-term\">function annotation</span></a>, <span class=\"target\" id=\"index-93\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a> y <span class=\"target\" id=\"index-94\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0526/\"><strong>PEP 526</strong></a>, que describen esta funcionalidad. Consulte tambi\u00e9n <a class=\"reference internal\" href=\"howto/annotations.html#annotations-howto\"><span class=\"std std-ref\">Pr\u00e1cticas recomendadas para las anotaciones</span></a> para conocer las mejores pr\u00e1cticas sobre c\u00f3mo trabajar con anotaciones.</p>\n</dd>\n</main>\n"}, "entorno virtual": {"title": "entorno virtual", "body": "<main>\n<dd><p class=\"translated\">Un entorno cooperativamente aislado de ejecuci\u00f3n que permite a los usuarios de Python y a las aplicaciones instalar y actualizar paquetes de distribuci\u00f3n de Python sin interferir con el comportamiento de otras aplicaciones de Python en el mismo sistema.</p>\n<p class=\"translated\">Vea tambi\u00e9n <a class=\"reference internal\" href=\"library/venv.html#module-venv\" title=\"venv: Creation of virtual environments.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">venv</span></code></a>.</p>\n</dd>\n</main>\n"}, "m\u00e1quina virtual": {"title": "m\u00e1quina virtual", "body": "<main>\n<dd><p class=\"translated\">Una computadora definida enteramente por software.  La m\u00e1quina virtual de Python ejecuta el <a class=\"reference internal\" href=\"#term-bytecode\"><span class=\"xref std std-term\">bytecode</span></a> generado por el compilador de <em>bytecode</em>.</p>\n</dd>\n</main>\n"}, "walrus operator": {"title": "walrus operator", "body": "<main>\n<dd><p class=\"untranslated\">A light-hearted way to refer to the <a class=\"reference internal\" href=\"reference/expressions.html#assignment-expressions\"><span class=\"std std-ref\">assignment expression</span></a> operator <code class=\"docutils literal notranslate\"><span class=\"pre\">:=</span></code> because it looks a bit like a\nwalrus if you turn your head.</p>\n</dd>\n</main>\n"}, "zen de python": {"title": "Zen de Python", "body": "<main>\n<dd><p class=\"translated\">Un listado de los principios de dise\u00f1o y la filosof\u00eda de Python que son \u00fatiles para entender y usar el lenguaje.  El listado puede encontrarse ingresando  \u00ab<code class=\"docutils literal notranslate\"><span class=\"pre\">import</span> <span class=\"pre\">this</span></code>\u00bb en la consola interactiva.</p>\n</dd>\n</main>\n"}}