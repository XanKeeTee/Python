<!DOCTYPE html>

<html lang="es" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="5. El sistema de importación" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/reference/import.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="El código Python en un módulo obtiene acceso al código en otro módulo por el proceso de importarlo. La instrucción import es la forma más común de invocar la maquinaria de importación, pero no es l..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.15/es/_images/social_previews/summary_reference_import_1c37d28a.png" />
<meta property="og:image:alt" content="El código Python en un módulo obtiene acceso al código en otro módulo por el proceso de importarlo. La instrucción import es la forma más común de invocar la maquinaria de importación, pero no es l..." />
<meta name="description" content="El código Python en un módulo obtiene acceso al código en otro módulo por el proceso de importarlo. La instrucción import es la forma más común de invocar la maquinaria de importación, pero no es l..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>5. El sistema de importación &#8212; documentación de Python - 3.15.0a0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=bf1f176d"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f85f4cfb"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.15.0a0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Derechos de autor" href="../copyright.html" />
    <link rel="next" title="6. Expresiones" href="expressions.html" />
    <link rel="prev" title="4. Modelo de ejecución" href="executionmodel.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/reference/import.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menú">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">5. El sistema de importación</a><ul>
<li><a class="reference internal" href="#importlib">5.1. <code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a></li>
<li><a class="reference internal" href="#packages">5.2. Paquetes</a><ul>
<li><a class="reference internal" href="#regular-packages">5.2.1. Paquetes regulares</a></li>
<li><a class="reference internal" href="#namespace-packages">5.2.2. Paquetes de espacio de nombres</a></li>
</ul>
</li>
<li><a class="reference internal" href="#searching">5.3. Buscando</a><ul>
<li><a class="reference internal" href="#the-module-cache">5.3.1. La caché del módulo</a></li>
<li><a class="reference internal" href="#finders-and-loaders">5.3.2. Buscadores y cargadores</a></li>
<li><a class="reference internal" href="#import-hooks">5.3.3. Ganchos de importación</a></li>
<li><a class="reference internal" href="#the-meta-path">5.3.4. La meta ruta (<em>path</em>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#loading">5.4. Cargando</a><ul>
<li><a class="reference internal" href="#loaders">5.4.1. Cargadores</a></li>
<li><a class="reference internal" href="#submodules">5.4.2. Submódulos</a></li>
<li><a class="reference internal" href="#module-specs">5.4.3. Module specs</a></li>
<li><a class="reference internal" href="#path-attributes-on-modules">5.4.4. __path__ attributes on modules</a></li>
<li><a class="reference internal" href="#module-reprs">5.4.5. Representación (<em>Reprs</em>) de módulos</a></li>
<li><a class="reference internal" href="#cached-bytecode-invalidation">5.4.6. Invalidación del código de bytes en caché</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-path-based-finder">5.5. El buscador basado en rutas</a><ul>
<li><a class="reference internal" href="#path-entry-finders">5.5.1. Buscadores de entradas de ruta</a></li>
<li><a class="reference internal" href="#path-entry-finder-protocol">5.5.2. Buscadores de entradas de ruta</a></li>
</ul>
</li>
<li><a class="reference internal" href="#replacing-the-standard-import-system">5.6. Reemplazando el sistema de importación estándar</a></li>
<li><a class="reference internal" href="#package-relative-imports">5.7. Paquete Importaciones relativas</a></li>
<li><a class="reference internal" href="#special-considerations-for-main">5.8. Consideraciones especiales para __main__</a><ul>
<li><a class="reference internal" href="#main-spec">5.8.1. __main__.__spec__</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">5.9. Referencias</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="executionmodel.html"
                          title="capítulo anterior"><span class="section-number">4. </span>Modelo de ejecución</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="expressions.html"
                          title="próximo capítulo"><span class="section-number">6. </span>Expresiones</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/import.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. Expresiones"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. Modelo de ejecución"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Referencia del Lenguaje Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5. </span>El sistema de importación</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="the-import-system">
<span id="importsystem"></span><h1 class="translated"><span class="section-number">5. </span>El sistema de importación<a class="headerlink" href="#the-import-system" title="Link to this heading">¶</a></h1>
<p class="translated" id="index-0">El código Python en un <a class="reference internal" href="../glossary.html#term-module"><span class="xref std std-term">módulo</span></a> obtiene acceso al código en otro módulo por el proceso de <a class="reference internal" href="../glossary.html#term-importing"><span class="xref std std-term">importarlo</span></a>.  La instrucción <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> es la forma más común de invocar la maquinaria de importación, pero no es la única manera.  Funciones como <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> y built-in <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> también se pueden utilizar para invocar la maquinaria de importación.</p>
<p class="translated">La instrucción <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> combina dos operaciones; busca el módulo con nombre y, a continuación, enlaza los resultados de esa búsqueda a un nombre en el ámbito local.  La operación de búsqueda de la instrucción <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> se define como una llamada a la función <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>, con los argumentos adecuados. El valor retornado de <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> se utiliza para realizar la operación de enlace de nombre de la instrucción <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code>.  Consulte la instrucción <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> para obtener los detalles exactos de esa operación de enlace de nombres.</p>
<p class="translated">Una llamada directa a <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> realiza solo la búsqueda del módulo y, si se encuentra, la operación de creación del módulo.  Aunque pueden producirse ciertos efectos secundarios, como la importación de paquetes primarios y la actualización de varias memorias caché (incluidas <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>), solo la instrucción <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> realiza una operación de enlace de nombres.</p>
<p class="translated">Cuando se ejecuta una instrucción <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>, se llama a la función estándar incorporada <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>. Otros mecanismos para invocar el sistema de importación (como <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a>) pueden optar por omitir <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> y utilizar sus propias soluciones para implementar la semántica de importación.</p>
<p class="translated">Cuando se importa un módulo por primera vez, Python busca el módulo y, si se encuentra, crea un objeto de módulo <a class="footnote-reference brackets" href="#fnmo" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, inicializándolo.  Si no se encuentra el módulo con nombre, se genera un <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a>.  Python implementa varias estrategias para buscar el módulo con nombre cuando se invoca la maquinaria de importación.  Estas estrategias se pueden modificar y ampliar mediante el uso de varios ganchos descritos en las secciones siguientes.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>El sistema de importación se ha actualizado para aplicar plenamente la segunda fase de <span class="target" id="index-35"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a>. Ya no hay ninguna maquinaria de importación implícita: todo el sistema de importación se expone a través de <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>. Además, se ha implementado la compatibilidad con paquetes de espacio de nombres nativos (consulte <span class="target" id="index-36"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a>).</p>
</div>
<section id="importlib">
<h2 class="translated"><span class="section-number">5.1. </span><a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a><a class="headerlink" href="#importlib" title="Link to this heading">¶</a></h2>
<p class="translated">El módulo <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> proporciona una API enriquecida para interactuar con el sistema de importación.  Por ejemplo <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> proporciona una API recomendada y más sencilla que la integrada <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> para invocar la maquinaria de importación.  Consulte la documentación de la biblioteca <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> para obtener más detalles.</p>
</section>
<section id="packages">
<h2 class="translated"><span class="section-number">5.2. </span>Paquetes<a class="headerlink" href="#packages" title="Link to this heading">¶</a></h2>
<p class="translated" id="index-3">Python sólo tiene un tipo de objeto módulo, y todos los módulos son de este tipo, independientemente de si el módulo está implementado en Python, C, o en cualquier otro lenguaje.  Para ayudar a organizar los módulos y proporcionar una jerarquía de nombres, Python tiene un concepto de <a class="reference internal" href="../glossary.html#term-package"><span class="xref std std-term">paquete</span></a>.</p>
<p class="translated">Puedes pensar en los paquetes como los directorios de un sistema de archivos y en los módulos como archivos dentro de los directorios, pero no te tomes esta analogía demasiado literalmente, ya que los paquetes y los módulos no tienen por qué originarse en el sistema de archivos.  Para los propósitos de esta documentación, usaremos esta conveniente analogía de directorios y archivos.  Al igual que los directorios del sistema de archivos, los paquetes están organizados de forma jerárquica, y los paquetes pueden contener subpaquetes, así como módulos regulares.</p>
<p class="translated">Es importante tener en cuenta que todos los paquetes son módulos, pero no todos los módulos son paquetes.  O dicho de otro modo, los paquetes son sólo un tipo especial de módulo. Específicamente, cualquier módulo que contenga un atributo <code class="docutils literal notranslate"><span class="pre">__path__</span></code> se considera un paquete.</p>
<p class="translated">Todos los módulos tienen un nombre. Los nombres de los subpaquetes están separados de su nombre de paquete principal por un punto, similar a la sintaxis de acceso de atributo estándar de Python. Por lo tanto, podría tener un paquete llamado <a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a>, que a su vez tiene un subpaquete llamado <a class="reference internal" href="../library/email.mime.html#module-email.mime" title="email.mime: Build MIME messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.mime</span></code></a> y un módulo dentro de ese subpaquete llamado <a class="reference internal" href="../library/email.mime.html#module-email.mime.text" title="email.mime.text"><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.mime.text</span></code></a>.</p>
<section id="regular-packages">
<h3 class="translated"><span class="section-number">5.2.1. </span>Paquetes regulares<a class="headerlink" href="#regular-packages" title="Link to this heading">¶</a></h3>
<p class="translated" id="index-4">Python define dos tipos de paquetes, <a class="reference internal" href="../glossary.html#term-regular-package"><span class="xref std std-term">paquetes regulares</span></a> y <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">paquetes de espacio de nombres</span></a>.  Los paquetes regulares son los paquetes tradicionales tal y como existían en Python 3.2 y anteriores. Un paquete regular se implementa típicamente como un directorio que contiene un archivo <code class="docutils literal notranslate"><span class="pre">init__.py</span></code>.  Cuando se importa un paquete regular, este archivo <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> se ejecuta implícitamente, y los objetos que define están vinculados a nombres en el espacio de nombres del paquete.  El archivo <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> puede contener el mismo código Python que puede contener cualquier otro módulo, y Python añadirá algunos atributos adicionales al módulo cuando se importe.</p>
<p class="translated">Por ejemplo, la siguiente disposición del sistema de archivos define un paquete <code class="docutils literal notranslate"><span class="pre">parent</span></code> de nivel superior con tres subpaquetes:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">parent</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">one</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">two</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">three</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p class="translated">Importando <code class="docutils literal notranslate"><span class="pre">parent.one</span></code> se ejecutará implícitamente <code class="docutils literal notranslate"><span class="pre">parent/__init__.py</span></code> y <code class="docutils literal notranslate"><span class="pre">parent/one/__init__.py</span></code>.  La importación posterior de <code class="docutils literal notranslate"><span class="pre">parent.two</span></code> o <code class="docutils literal notranslate"><span class="pre">parent.three</span></code> ejecutará <code class="docutils literal notranslate"><span class="pre">parent/two/__init__.py</span></code> y <code class="docutils literal notranslate"><span class="pre">parent/three/__init__.py</span></code> respectivamente.</p>
</section>
<section id="namespace-packages">
<span id="reference-namespace-package"></span><h3 class="translated"><span class="section-number">5.2.2. </span>Paquetes de espacio de nombres<a class="headerlink" href="#namespace-packages" title="Link to this heading">¶</a></h3>
<p class="translated" id="index-5">Un paquete de espacio de nombres es un compuesto de varias <a class="reference internal" href="../glossary.html#term-portion"><span class="xref std std-term">porciones</span></a>, donde cada porción contribuye con un subpaquete al paquete padre.  Las porciones pueden residir en diferentes lugares del sistema de archivos.  Las porciones también pueden encontrarse en archivos zip, en la red, o en cualquier otro lugar que Python busque durante la importación.  Los paquetes de espacios de nombres pueden corresponder o no directamente a objetos del sistema de archivos; pueden ser módulos virtuales que no tienen una representación concreta.</p>
<p class="translated">Los paquetes de espacios de nombres no usan una lista ordinaria para su atributo <code class="docutils literal notranslate"><span class="pre">__path__</span></code>. En su lugar utilizan un tipo iterable personalizado que realizará automáticamente una nueva búsqueda de porciones de paquete en el siguiente intento de importación dentro de ese paquete si la ruta de su paquete padre (o <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path`</span></code> para un paquete de nivel superior) cambia.</p>
<p class="translated">Con los paquetes de espacio de nombres, no hay ningún archivo <code class="docutils literal notranslate"><span class="pre">parent/__init__.py</span></code>.  De hecho, puede haber varios directorios <code class="docutils literal notranslate"><span class="pre">padre</span></code> encontrados durante la búsqueda de importación, donde cada uno de ellos es proporcionado por una parte diferente.  Por lo tanto, <code class="docutils literal notranslate"><span class="pre">padre/one</span></code> no puede estar físicamente situado junto a <code class="docutils literal notranslate"><span class="pre">padre/two</span></code>.  En este caso, Python creará un paquete de espacio de nombres para el paquete <code class="docutils literal notranslate"><span class="pre">parent</span></code> de nivel superior siempre que se importe él o uno de sus subpaquetes.</p>
<p class="translated">Consulte también <span class="target" id="index-37"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> para conocer la especificación del paquete de espacio de nombres.</p>
</section>
</section>
<section id="searching">
<h2 class="translated"><span class="section-number">5.3. </span>Buscando<a class="headerlink" href="#searching" title="Link to this heading">¶</a></h2>
<p class="translated">Para comenzar la búsqueda, Python necesita el nombre <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">totalmente calificado</span></a> del módulo (o paquete, pero para los fines de esta discusión, la diferencia es irrelevante) que se está importando.  Este nombre puede provenir de varios argumentos a la instrucción <a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>, o de los parámetros de las funciones <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> o <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>.</p>
<p class="translated">Este nombre se utilizará en varias fases de la búsqueda de importación, y puede ser la ruta de acceso punteada a un submódulo, por ejemplo, <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>.  En este caso, Python primero intenta importar <code class="docutils literal notranslate"><span class="pre">foo</span></code>, luego <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code>, y finalmente <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>. Si se produce un error en cualquiera de las importaciones intermedias, se genera un <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a>.</p>
<section id="the-module-cache">
<h3 class="translated"><span class="section-number">5.3.1. </span>La caché del módulo<a class="headerlink" href="#the-module-cache" title="Link to this heading">¶</a></h3>
<p class="translated" id="index-7">El primer lugar comprobado durante la búsqueda de importación es <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>.  Esta asignación sirve como caché de todos los módulos que se han importado previamente, incluidas las rutas intermedias.  Por lo tanto, si <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> se importó previamente, <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> contendrá entradas para <code class="docutils literal notranslate"><span class="pre">foo</span></code>, <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code>, y <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>.  Cada clave tendrá como valor el objeto de módulo correspondiente.</p>
<p class="translated">Durante la importación, el nombre del módulo se busca en <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> y si está presente, el valor asociado es el módulo que satisface la importación y el proceso se completa.  Sin embargo, si el valor es <code class="docutils literal notranslate"><span class="pre">None</span></code>, se genera un <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a>.  Si falta el nombre del módulo, Python continuará buscando el módulo.</p>
<p class="translated"><a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> se puede escribir.  La eliminación de una clave no puede destruir el módulo asociado (ya que otros módulos pueden contener referencias a él), pero invalidará la entrada de caché para el módulo con nombre, lo que hará que Python busque de nuevo el módulo con nombre en su próxima importación. La clave también se puede asignar a <code class="docutils literal notranslate"><span class="pre">None</span></code>, lo que obliga a la siguiente importación del módulo a dar como resultado un <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a>.</p>
<p class="translated">Tenga cuidado, sin embargo, como si mantiene una referencia al objeto module, invalide su entrada de caché en <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> y, a continuación, vuelva a importar el módulo con nombre, los dos objetos de módulo <em>no</em> serán los mismos. Por el contrario, <a class="reference internal" href="../library/importlib.html#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.reload()</span></code></a> reutilizará el objeto de módulo <em>same</em> y simplemente reinicializará el contenido del módulo volviendo a ejecutar el código del módulo.</p>
</section>
<section id="finders-and-loaders">
<span id="id2"></span><h3 class="translated"><span class="section-number">5.3.2. </span>Buscadores y cargadores<a class="headerlink" href="#finders-and-loaders" title="Link to this heading">¶</a></h3>
<p class="translated" id="index-8">Si el módulo con nombre no se encuentra en <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, se invoca el protocolo de importación de Python para buscar y cargar el módulo.  Este protocolo consta de dos objetos conceptuales, <a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">buscadores</span></a> y <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">cargadores</span></a>. El trabajo de un buscador es determinar si puede encontrar el módulo con nombre utilizando cualquier estrategia que conozca. Los objetos que implementan ambas interfaces se conocen como <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importadores</span></a> se retornan a sí mismos cuando descubren que pueden cargar el módulo solicitado.</p>
<p class="translated">Python incluye una serie de buscadores e importadores predeterminados.  El primero sabe cómo localizar módulos integrados, y el segundo sabe cómo localizar módulos congelados.  Un tercer buscador predeterminado busca módulos en <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">import path</span></a>.  El <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">import path</span></a> es una lista de ubicaciones que pueden nombrar rutas del sistema de archivos o archivos zip.  También se puede ampliar para buscar cualquier recurso localizable, como los identificados por las direcciones URL.</p>
<p class="translated">La maquinaria de importación es extensible, por lo que se pueden añadir nuevos buscadores para ampliar el alcance y el alcance de la búsqueda de módulos.</p>
<p class="translated">En realidad, los buscadores no cargan módulos.  Si pueden encontrar el módulo con nombre, retornan un <em class="dfn">module spec</em>, una encapsulación de la información relacionada con la importación del módulo, que la maquinaria de importación utiliza al cargar el módulo.</p>
<p class="translated">En las secciones siguientes se describe el protocolo para buscadores y cargadores con más detalle, incluido cómo puede crear y registrar otros nuevos para ampliar la maquinaria de importación.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>En versiones anteriores de Python, los buscadores retornaban <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">cargadores</span></a> directamente, mientras que ahora retornen especificaciones de módulo que <em>contienen</em> cargadores. Los cargadores todavía se utilizan durante la importación, pero tienen menos responsabilidades.</p>
</div>
</section>
<section id="import-hooks">
<h3 class="translated"><span class="section-number">5.3.3. </span>Ganchos de importación<a class="headerlink" href="#import-hooks" title="Link to this heading">¶</a></h3>
<p class="translated" id="index-9">La maquinaria de importación está diseñada para ser extensible; el mecanismo principal para esto son los <em>ganchos de importación</em> (import hooks).  Hay dos tipos de ganchos de importación: <em>meta hooks</em> (meta ganchos) y <em>import path hooks</em> (ganchos de ruta de acceso de importación).</p>
<p class="translated">Los meta ganchos se llaman al inicio del procesamiento de importación, antes de que se haya producido cualquier otro procesamiento de importación, que no sea búsqueda de caché de <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>. Esto permite que los metaganchos reemplacen el procesamiento de <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>, módulos congelados o incluso módulos integrados.  Los meta ganchos se registran agregando nuevos objetos de buscador a <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>, como se describe a continuación.</p>
<p class="translated">Los ganchos de ruta de acceso de importación se invocan como parte del procesamiento <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> (o <code class="docutils literal notranslate"><span class="pre">package.__path__</span></code>), en el punto donde se encuentra su elemento de ruta de acceso asociado. Los ganchos de ruta de acceso de importación se registran agregando nuevos invocables a <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> como se describe a continuación.</p>
</section>
<section id="the-meta-path">
<h3 class="translated"><span class="section-number">5.3.4. </span>La meta ruta (<em>path</em>)<a class="headerlink" href="#the-meta-path" title="Link to this heading">¶</a></h3>
<p class="untranslated" id="index-10">When the named module is not found in <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, Python next
searches <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>, which contains a list of meta path finder
objects.  These finders are queried in order to see if they know how to handle
the named module.  Meta path finders must implement a method called
<a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> which takes three arguments:
a name, an import path, and (optionally) a target module.  The meta path
finder can use any strategy it wants to determine whether it can handle
the named module or not.</p>
<p class="translated">Si el buscador de metarutas sabe cómo controlar el módulo con nombre, retorna un objeto de especificación.  Si no puede controlar el módulo con nombre, retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>.  Si el procesamiento de <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> llega al final de su lista sin retornar una especificación, se genera un <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a>.  Cualquier otra excepción provocada simplemente se propaga hacia arriba, anulando el proceso de importación.</p>
<p class="untranslated">The <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> method of meta path
finders is called with two or three arguments.  The first is the fully
qualified name of the module being imported, for example <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code>.
The second argument is the path entries to use for the module search.  For
top-level modules, the second argument is <code class="docutils literal notranslate"><span class="pre">None</span></code>, but for submodules or
subpackages, the second argument is the value of the parent package’s
<code class="docutils literal notranslate"><span class="pre">__path__</span></code> attribute. If the appropriate <code class="docutils literal notranslate"><span class="pre">__path__</span></code> attribute cannot
be accessed, a <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> is raised.  The third argument
is an existing module object that will be the target of loading later.
The import system passes in a target module only during reload.</p>
<p class="translated">La metaruta se puede recorrer varias veces para una sola solicitud de importación. Por ejemplo, suponiendo que ninguno de los módulos implicados ya se haya almacenado en caché, la importación de <code class="docutils literal notranslate"><span class="pre">foo.bar.baz</span></code> realizará primero una importación de nivel superior, llamando a <code class="docutils literal notranslate"><span class="pre">mpf.find_spec(&quot;foo&quot;,</span> <span class="pre">None,</span> <span class="pre">None)</span></code> en cada buscador de metarutas (<code class="docutils literal notranslate"><span class="pre">mpf</span></code>). Después de importar <code class="docutils literal notranslate"><span class="pre">foo</span></code> , <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> se importará atravesando la meta ruta por segunda vez, llamando a <code class="docutils literal notranslate"><span class="pre">mpf.find_spec(&quot;foo.bar&quot;,</span> <span class="pre">foo.__path__,</span> <span class="pre">None)</span></code>. Una vez importado <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code>, el recorrido final llamará a <code class="docutils literal notranslate"><span class="pre">mpf.find_spec(&quot;foo.bar.baz&quot;,</span> <span class="pre">foo.bar.__path__,</span> <span class="pre">None)</span></code>.</p>
<p class="translated">Algunos buscadores de metarutas solo admiten importaciones de nivel superior. Estos importadores siempre retornarán <code class="docutils literal notranslate"><span class="pre">None</span></code> cuando se pase algo distinto de <code class="docutils literal notranslate"><span class="pre">None</span></code> como segundo argumento.</p>
<p class="translated">El valor predeterminado de Python <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> tiene tres buscadores de metarutas, uno que sabe cómo importar módulos integrados, uno que sabe cómo importar módulos congelados y otro que sabe cómo importar módulos desde un <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">import path</span></a> (es decir, el <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">path based finder</span></a>).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>The <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> method of meta path
finders replaced <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code>, which
is now deprecated.  While it will continue to work without change, the
import machinery will try it only if the finder does not implement
<a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Use of <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code> by the import system
now raises <a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code> has been removed.
Use <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> instead.</p>
</div>
</section>
</section>
<section id="loading">
<h2 class="translated"><span class="section-number">5.4. </span>Cargando<a class="headerlink" href="#loading" title="Link to this heading">¶</a></h2>
<p class="translated">Si se encuentra una especificación de módulo, la maquinaria de importación la utilizará (y el cargador que contiene) al cargar el módulo.  Aquí está una aproximación de lo que sucede durante la porción de carga de la importación:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">,</span> <span class="s1">&#39;create_module&#39;</span><span class="p">):</span>
    <span class="c1"># It is assumed &#39;exec_module&#39; will also be defined on the loader.</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">create_module</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
<span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">ModuleType</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># The import-related module attributes get set here:</span>
<span class="n">_init_module_attrs</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">module</span><span class="p">)</span>

<span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># unsupported</span>
    <span class="k">raise</span> <span class="ne">ImportError</span>
<span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">spec</span><span class="o">.</span><span class="n">submodule_search_locations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># namespace package</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
<span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="p">,</span> <span class="s1">&#39;exec_module&#39;</span><span class="p">):</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">raise</span>
<span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">spec</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
</pre></div>
</div>
<p class="translated">Tenga en cuenta los siguientes detalles:</p>
<ul class="simple">
<li><p class="translated">Si hay un objeto de módulo existente con el nombre dado en <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, la importación ya lo habrá retornado.</p></li>
<li><p class="translated">El módulo existirá en <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> antes de que el cargador ejecute el código del módulo.  Esto es crucial porque el código del módulo puede (directa o indirectamente) importarse a sí mismo; agregándolo a <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> de antemano evita la recursividad sin límites en el peor de los casos y la carga múltiple en el mejor.</p></li>
<li><p class="translated">Si se produce un error en la carga, el módulo con errores – y solo el módulo con errores – se elimina de <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>.  Cualquier módulo que ya esté en la caché de <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> y cualquier módulo que se haya cargado correctamente como efecto secundario, debe permanecer en la memoria caché.  Esto contrasta con la recarga donde incluso el módulo que falla se deja en <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>.</p></li>
<li><p class="translated">Después de crear el módulo pero antes de la ejecución, la maquinaria de importación establece los atributos del módulo relacionados con la importación («_init_module_attrs» en el ejemplo de pseudocódigo anterior), como se resume en una <a class="reference internal" href="datamodel.html#import-mod-attrs"><span class="std std-ref">sección posterior</span></a>.</p></li>
<li><p class="translated">La ejecución del módulo es el momento clave de la carga en el que se rellena el espacio de nombres del módulo.  La ejecución se delega por completo en el cargador, lo que llega a decidir qué se rellena y cómo.</p></li>
<li><p class="translated">El módulo creado durante la carga y pasado a exec_module() puede no ser el que se retorna al final de la importación <a class="footnote-reference brackets" href="#fnlo" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>El sistema de importación se ha hecho cargo de las responsabilidades reutilizables de los cargadores.  Estos fueron realizados previamente por el método <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code></a>.</p>
</div>
<section id="loaders">
<h3 class="translated"><span class="section-number">5.4.1. </span>Cargadores<a class="headerlink" href="#loaders" title="Link to this heading">¶</a></h3>
<p class="translated">Los cargadores de módulos proporcionan la función crítica de carga: ejecución del módulo. La maquinaria de importación llama al método <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a> con un único argumento, el objeto module que se va a ejecutar.  Se omite cualquier valor retornado de <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>.</p>
<p class="translated">Los cargadores deben cumplir los siguientes requisitos:</p>
<ul class="simple">
<li><p class="translated">Si el módulo es un módulo Python (a diferencia de un módulo integrado o una extensión cargada dinámicamente), el cargador debe ejecutar el código del módulo en el espacio de nombres global del módulo (<code class="docutils literal notranslate"><span class="pre">module.__dict__</span></code>).</p></li>
<li><p class="translated">Si el cargador no puede ejecutar el módulo, debe generar un <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>, aunque se propagará cualquier otra excepción provocada durante <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a>.</p></li>
</ul>
<p class="translated">En muchos casos, el buscador y el cargador pueden ser el mismo objeto; en tales casos, el método <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> simplemente retornaría una especificación con el cargador establecido en <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p class="translated">Los cargadores de módulos pueden optar por crear el objeto de módulo durante la carga mediante la implementación de un método <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>. Toma un argumento, la especificación del módulo, y retorna el nuevo objeto de módulo que se usará durante la carga.  <code class="docutils literal notranslate"><span class="pre">create_module()</span></code> no necesita establecer ningún atributo en el objeto module.  Si el método retorna <code class="docutils literal notranslate"><span class="pre">None</span></code>, la maquinaria de importación creará el nuevo módulo en sí.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4: </span>El método de cargadores <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.create_module" title="importlib.abc.Loader.create_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>El método <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.load_module" title="importlib.abc.Loader.load_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_module()</span></code></a> fue reemplazado por <a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code></a> y la maquinaria de importación asumió todas las responsabilidades reutilizables de la carga.</p>
<p class="translated">Para la compatibilidad con los cargadores existentes, la maquinaria de importación utilizará el método de cargadores <code class="docutils literal notranslate"><span class="pre">load_module()</span></code> si existe y el cargador no implementa también <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code>.  Sin embargo, <code class="docutils literal notranslate"><span class="pre">load_module()</span></code> ha quedado obsoleto y los cargadores deben implementar <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code> en su lugar.</p>
<p class="translated">El método <code class="docutils literal notranslate"><span class="pre">load_module()</span></code> debe implementar toda la funcionalidad de carga reutilizable descrita anteriormente, además de ejecutar el módulo.  Se aplican todas las mismas restricciones, con algunas aclaraciones adicionales:</p>
<ul class="simple">
<li><p class="translated">Si hay un objeto de módulo existente con el nombre dado en <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, el cargador debe utilizar ese módulo existente. (De lo contrario, <a class="reference internal" href="../library/importlib.html#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.reload()</span></code></a> no funcionará correctamente.)  Si el módulo con nombre no existe en <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, el cargador debe crear un nuevo objeto de módulo y agregarlo a <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>.</p></li>
<li><p class="translated">El módulo <em>debe</em> existir en <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a> antes de que el cargador ejecute el código del módulo, para evitar la recursividad sin límites o la carga múltiple.</p></li>
<li><p class="translated">Si se produce un error en la carga, el cargador debe quitar los módulos que ha insertado en <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>, pero debe quitar <strong>solo</strong> los módulos con errores, y solo si el propio cargador ha cargado los módulos explícitamente.</p></li>
</ul>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>A <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> se genera cuando se define <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code> pero <code class="docutils literal notranslate"><span class="pre">create_module()</span></code> no lo es.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>Un <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> se genera cuando <code class="docutils literal notranslate"><span class="pre">exec_module()</span></code> está definido, pero <code class="docutils literal notranslate"><span class="pre">create_module()</span></code> no lo es.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>El uso de <code class="docutils literal notranslate"><span class="pre">load_module()</span></code> lanzará <a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a>.</p>
</div>
</section>
<section id="submodules">
<h3 class="translated"><span class="section-number">5.4.2. </span>Submódulos<a class="headerlink" href="#submodules" title="Link to this heading">¶</a></h3>
<p class="translated">Cuando se carga un submódulo mediante cualquier mecanismo (por ejemplo, API <code class="docutils literal notranslate"><span class="pre">importlib</span></code>, las instrucciones <code class="docutils literal notranslate"><span class="pre">import</span></code> o <code class="docutils literal notranslate"><span class="pre">import-from</span></code>, o <code class="docutils literal notranslate"><span class="pre">__import__()</span></code>) integradas, se coloca un enlace en el espacio de nombres del módulo primario al objeto submodule. Por ejemplo, si el paquete <code class="docutils literal notranslate"><span class="pre">spam</span></code> tiene un submódulo <code class="docutils literal notranslate"><span class="pre">foo</span></code>, después de importar <code class="docutils literal notranslate"><span class="pre">spam.foo</span></code>, <code class="docutils literal notranslate"><span class="pre">spam</span></code> tendrá un atributo <code class="docutils literal notranslate"><span class="pre">foo</span></code> que está enlazado al submódulo.  Supongamos que tiene la siguiente estructura de directorios:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">spam</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">foo</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p class="translated">y <code class="docutils literal notranslate"><span class="pre">spam/__init__.py</span></code> tiene la siguiente línea:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">.foo</span><span class="w"> </span><span class="kn">import</span> <span class="n">Foo</span>
</pre></div>
</div>
<p class="translated">a continuación, la ejecución de lo siguiente pone un nombre vinculante para <code class="docutils literal notranslate"><span class="pre">foo</span></code> y <code class="docutils literal notranslate"><span class="pre">Foo</span></code> en el módulo <code class="docutils literal notranslate"><span class="pre">spam</span></code>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">spam</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="n">foo</span>
<span class="go">&lt;module &#39;spam.foo&#39; from &#39;/tmp/imports/spam/foo.py&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spam</span><span class="o">.</span><span class="n">Foo</span>
<span class="go">&lt;class &#39;spam.foo.Foo&#39;&gt;</span>
</pre></div>
</div>
<p class="translated">Dadas las reglas de enlace de nombres familiares de Python, esto puede parecer sorprendente, pero en realidad es una característica fundamental del sistema de importación.  La retención invariable es que si tiene <code class="docutils literal notranslate"><span class="pre">sys.modules[`spam`]</span></code> y <code class="docutils literal notranslate"><span class="pre">sys.modules[`spam.foo`]</span></code> (como lo haría después de la importación anterior), este último debe aparecer como el atributo <code class="docutils literal notranslate"><span class="pre">foo</span></code> de la primera.</p>
</section>
<section id="module-specs">
<span id="id4"></span><h3 class="untranslated"><span class="section-number">5.4.3. </span>Module specs<a class="headerlink" href="#module-specs" title="Link to this heading">¶</a></h3>
<p class="translated">La maquinaria de importación utiliza una variedad de información sobre cada módulo durante la importación, especialmente antes de la carga.  La mayor parte de la información es común a todos los módulos.  El propósito de las especificaciones de un módulo es encapsular esta información relacionada con la importación por módulo.</p>
<p class="translated">El uso de una especificación durante la importación permite transferir el estado entre los componentes del sistema de importación, por ejemplo, entre el buscador que crea la especificación del módulo y el cargador que la ejecuta.  Lo más importante es que permite a la maquinaria de importación realizar las operaciones de caldera de carga, mientras que sin una especificación de módulo el cargador tenía esa responsabilidad.</p>
<p class="untranslated">The module’s spec is exposed as <a class="reference internal" href="datamodel.html#module.__spec__" title="module.__spec__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__spec__</span></code></a>. Setting
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__</span></code> appropriately applies equally to
<a class="reference internal" href="toplevel_components.html#programs"><span class="std std-ref">modules initialized during interpreter startup</span></a>.
The one exception is <code class="docutils literal notranslate"><span class="pre">__main__</span></code>, where <code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__</span></code> is
<a class="reference internal" href="#main-spec"><span class="std std-ref">set to None in some cases</span></a>.</p>
<p class="untranslated">See <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModuleSpec</span></code></a> for details on the contents of
the module spec.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</section>
<section id="path-attributes-on-modules">
<span id="package-path-rules"></span><h3 class="untranslated"><span class="section-number">5.4.4. </span>__path__ attributes on modules<a class="headerlink" href="#path-attributes-on-modules" title="Link to this heading">¶</a></h3>
<p class="untranslated">The <a class="reference internal" href="datamodel.html#module.__path__" title="module.__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> attribute should be a (possibly empty)
<a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a> of strings enumerating the locations where the package’s
submodules will be found. By definition, if a module has a <code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code>
attribute, it is a <a class="reference internal" href="../glossary.html#term-package"><span class="xref std std-term">package</span></a>.</p>
<p class="untranslated">A package’s <a class="reference internal" href="datamodel.html#module.__path__" title="module.__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a> attribute is used during imports of its
subpackages.
Within the import machinery, it functions much the same as <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>,
i.e. providing a list of locations to search for modules during import.
However, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code> is typically much more constrained than
<code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code>.</p>
<p class="untranslated">The same rules used for <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> also apply to a package’s
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code>. <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> (described below) are
consulted when traversing a package’s <code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code>.</p>
<p class="untranslated">A package’s <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file may set or alter the package’s
<a class="reference internal" href="datamodel.html#module.__path__" title="module.__path__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code></a>
attribute, and this was typically the way namespace packages were implemented
prior to <span class="target" id="index-11"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a>.  With the adoption of <span class="target" id="index-12"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a>, namespace packages no
longer need to supply <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> files containing only <code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code>
manipulation code; the import machinery automatically sets <code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code>
correctly for the namespace package.</p>
</section>
<section id="module-reprs">
<h3 class="translated"><span class="section-number">5.4.5. </span>Representación (<em>Reprs</em>) de módulos<a class="headerlink" href="#module-reprs" title="Link to this heading">¶</a></h3>
<p class="translated">De forma predeterminada, todos los módulos tienen un repr utilizable, sin embargo, dependiendo de los atributos establecidos anteriormente, y en las especificaciones del módulo, puede controlar más explícitamente el repr de los objetos de módulo.</p>
<p class="translated">Si el módulo tiene una especificación (<code class="docutils literal notranslate"><span class="pre">__spec__</span></code>), la maquinaria de importación intentará generar un repr a partir de él.  Si eso falla o no hay ninguna especificación, el sistema de importación creará un repr predeterminado usando cualquier información disponible en el módulo.  Intentará utilizar el <code class="docutils literal notranslate"><span class="pre">module.__name__</span></code>, <code class="docutils literal notranslate"><span class="pre">module.__file__</span></code> y <code class="docutils literal notranslate"><span class="pre">module.__loader__</span></code> como entrada en el repr, con valores predeterminados para cualquier información que falte.</p>
<p class="translated">Aquí están las reglas exactas utilizadas:</p>
<ul class="simple">
<li><p class="translated">Si el módulo tiene un atributo <code class="docutils literal notranslate"><span class="pre">__spec__</span></code>, la información de la especificación se utiliza para generar el repr.  Se consultan los atributos «name», «loader», «origin» y «has_location».</p></li>
<li><p class="translated">Si el módulo tiene un atributo <code class="docutils literal notranslate"><span class="pre">__file__</span></code>, se utiliza como parte del repr del módulo.</p></li>
<li><p class="translated">Si el módulo no tiene <code class="docutils literal notranslate"><span class="pre">__file__</span></code> pero tiene un <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> que no es <code class="docutils literal notranslate"><span class="pre">None</span></code>, entonces el repr del cargador se utiliza como parte del repr del módulo.</p></li>
<li><p class="translated">De lo contrario, sólo tiene que utilizar el <code class="docutils literal notranslate"><span class="pre">__name__</span></code> del módulo en el repr.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>El uso de <code class="xref py py-meth docutils literal notranslate"><span class="pre">module_repr()</span></code>, al ser obsoleto desde Python 3.4, fue eliminado en Python 3.12 y no es llamado durante la resolución de la representación (repr) de un módulo.</p>
</div>
</section>
<section id="cached-bytecode-invalidation">
<span id="pyc-invalidation"></span><h3 class="translated"><span class="section-number">5.4.6. </span>Invalidación del código de bytes en caché<a class="headerlink" href="#cached-bytecode-invalidation" title="Link to this heading">¶</a></h3>
<p class="translated">Antes de que Python cargue el código de bytes en caché de un archivo <code class="docutils literal notranslate"><span class="pre">.pyc</span></code>, verifica si el caché está actualizado con el archivo <code class="docutils literal notranslate"><span class="pre">.py</span></code> de origen. De forma predeterminada, Python hace esto almacenando la marca de tiempo y el tamaño de la última modificación de la fuente en el archivo de caché al escribirlo. En tiempo de ejecución, el sistema de importación valida el archivo de caché comprobando los metadatos almacenados en el archivo de caché con los metadatos de la fuente.</p>
<p class="translated">Python también admite archivos de caché «basados en hash», que almacenan un hash del contenido del archivo de origen en lugar de sus metadatos. Hay dos variantes de archivos <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> basados en hash: marcados y desmarcados. Para los archivos <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> marcados basados en hash, Python valida el archivo de caché mediante el hash del archivo de origen y la comparación del hash resultante con el hash en el archivo de caché. Si se encuentra que un archivo de caché basado en hash comprobado no es válido, Python lo regenera y escribe un nuevo archivo de caché basado en hash comprobado. Para los archivos <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> sin marcar en hash, Python simplemente asume que el archivo de caché es válido si existe. El comportamiento de validación de archivos basado en hash <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> se puede invalidar con el indicador <a class="reference internal" href="../using/cmdline.html#cmdoption-check-hash-based-pycs"><code class="xref std std-option docutils literal notranslate"><span class="pre">--check-hash-based-pycs</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Se han añadido archivos <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> basados en hash. Anteriormente, Python solo admitía la invalidación basada en la marca de tiempo de la caché del código de bytes.</p>
</div>
</section>
</section>
<section id="the-path-based-finder">
<h2 class="translated"><span class="section-number">5.5. </span>El buscador basado en rutas<a class="headerlink" href="#the-path-based-finder" title="Link to this heading">¶</a></h2>
<p class="translated" id="index-13">Como se mencionó anteriormente, Python viene con varios buscadores de meta rutas predeterminados. Uno de ellos, llamado el buscador <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">path based finder</span></a> (<a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder" title="importlib.machinery.PathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathFinder</span></code></a>), busca una <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">import path</span></a>, que contiene una lista de <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">entradas de ruta</span></a>. Cada entrada de ruta de acceso nombra una ubicación para buscar módulos.</p>
<p class="translated">El buscador basado en rutas en sí no sabe cómo importar nada. En su lugar, atraviesa las entradas de ruta individuales, asociando cada una de ellas con un buscador de entrada de ruta que sabe cómo manejar ese tipo particular de ruta de acceso.</p>
<p class="translated">El conjunto predeterminado de buscadores de entradas de ruta implementa toda la semántica para encontrar módulos en el sistema de archivos, controlando tipos de archivos especiales como el código fuente de Python (archivos <code class="docutils literal notranslate"><span class="pre">`.py</span></code>), el código de bytes de Python (archivos <code class="docutils literal notranslate"><span class="pre">.pyc</span></code>) y las bibliotecas compartidas (por ejemplo, archivos <code class="docutils literal notranslate"><span class="pre">.so`</span></code>). Cuando es compatible con el módulo <a class="reference internal" href="../library/zipimport.html#module-zipimport" title="zipimport: Support for importing Python modules from ZIP archives."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipimport</span></code></a> en la biblioteca estándar, los buscadores de entradas de ruta de acceso predeterminados también controlan la carga de todos estos tipos de archivo (excepto las bibliotecas compartidas) desde zipfiles.</p>
<p class="translated">Las entradas de ruta de acceso no deben limitarse a las ubicaciones del sistema de archivos.  Pueden hacer referencia a direcciones URL, consultas de base de datos o cualquier otra ubicación que se pueda especificar como una cadena.</p>
<p class="translated">El buscador basado en rutas proporciona enlaces y protocolos adicionales para que pueda ampliar y personalizar los tipos de entradas de ruta de acceso que se pueden buscar.  Por ejemplo, si desea admitir entradas de ruta de acceso como direcciones URL de red, podría escribir un enlace que implemente la semántica HTTP para buscar módulos en la web.  Este gancho (un al que se puede llamar) retornaría un <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> compatible con el protocolo descrito a continuación, que luego se utilizó para obtener un cargador para el módulo de la web.</p>
<p class="translated">Una palabra de advertencia: esta sección y la anterior utilizan el término <em>finder</em>, distinguiendo entre ellos utilizando los términos <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a> y <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>.  Estos dos tipos de buscadores son muy similares, admiten protocolos similares y funcionan de maneras similares durante el proceso de importación, pero es importante tener en cuenta que son sutilmente diferentes. En particular, los buscadores de meta path operan al principio del proceso de importación, como se indica en el recorrido <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>.</p>
<p class="translated">Por el contrario, los buscadores de entradas de ruta son en cierto sentido un detalle de implementación del buscador basado en rutas y, de hecho, si el buscador basado en rutas se eliminara de <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>, no se invocaría ninguna semántica del buscador de entradas de ruta.</p>
<section id="path-entry-finders">
<h3 class="translated"><span class="section-number">5.5.1. </span>Buscadores de entradas de ruta<a class="headerlink" href="#path-entry-finders" title="Link to this heading">¶</a></h3>
<p class="translated" id="index-14">El <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">path based finder</span></a> es responsable de encontrar y cargar módulos y paquetes de Python cuya ubicación se especifica con una cadena <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">path entry</span></a>.  La mayoría de las ubicaciones de nombres de entradas de ruta de acceso en el sistema de archivos, pero no es necesario limitarlas a esto.</p>
<p class="translated">Como buscador de meta rutas, el buscador <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">path based finder</span></a> implementa el protocolo <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> descrito anteriormente, sin embargo, expone enlaces adicionales que se pueden usar para personalizar cómo se encuentran y cargan los módulos desde la ruta <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">import path</span></a>.</p>
<p class="translated">Tres variables son usadas por <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">path based finder</span></a>, <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>, <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> y <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>.  También se utilizan los atributos <code class="docutils literal notranslate"><span class="pre">__path__</span></code> en los objetos de paquete.  Estos proporcionan formas adicionales de personalizar la maquinaria de importación.</p>
<p class="untranslated"><a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> contains a list of strings providing search locations for
modules and packages.  It is initialized from the <span class="target" id="index-15"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code></a>
environment variable and various other installation- and
implementation-specific defaults.  Entries in <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> can name
directories on the file system, zip files, and potentially other «locations»
(see the <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> module) that should be searched for modules, such as
URLs, or database queries.  Only strings should be present on
<a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>; all other data types are ignored.</p>
<p class="translated">El buscador <a class="reference internal" href="../glossary.html#term-path-based-finder"><span class="xref std std-term">path based finder</span></a> es un <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a>, por lo que la maquinaria de importación comienza la búsqueda <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">import path</span></a> llamando al método <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> basado en la ruta de acceso, tal como se describió anteriormente.  Cuando se proporciona el argumento <code class="docutils literal notranslate"><span class="pre">path</span></code> a <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a>, será una lista de rutas de acceso de cadena para recorrer - normalmente el atributo <code class="docutils literal notranslate"><span class="pre">__path__</span></code> de un paquete para una importación dentro de ese paquete.  Si el argumento <code class="docutils literal notranslate"><span class="pre">path</span></code> es <code class="docutils literal notranslate"><span class="pre">None</span></code>, esto indica una importación de nivel superior y se utiliza <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>.</p>
<p class="untranslated">The path based finder iterates over every entry in the search path, and
for each of these, looks for an appropriate <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>
(<a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathEntryFinder</span></code></a>) for the
path entry.  Because this can be an expensive operation (e.g. there may be
<code class="docutils literal notranslate"><span class="pre">stat()</span></code> call overheads for this search), the path based finder maintains
a cache mapping path entries to path entry finders.  This cache is maintained
in <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> (despite the name, this cache actually
stores finder objects rather than being limited to <a class="reference internal" href="../glossary.html#term-importer"><span class="xref std std-term">importer</span></a> objects).
In this way, the expensive search for a particular <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">path entry</span></a>
location’s <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> need only be done once.  User code is
free to remove cache entries from <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> forcing
the path based finder to perform the path entry search again.</p>
<p class="translated">Si la entrada de ruta de acceso no está presente en la memoria caché, el buscador basado en rutas de acceso recorre en iteración cada llamada que se puede llamar en <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>.  Cada uno de los enlaces de <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">ganchos de rutas de entrada</span></a> en esta lista se llama con un solo argumento, la entrada de ruta de acceso que se va a buscar.  Esta invocable puede retornar un <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> que puede controlar la entrada de ruta de acceso, o puede generar <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>.  Un <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> es utilizado por el buscador basado en ruta para indicar que el gancho no puede encontrar un <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> para eso <a class="reference internal" href="../glossary.html#term-path-entry"><span class="xref std std-term">entrada de ruta</span></a>.  Se omite la excepción y la iteración <a class="reference internal" href="../glossary.html#term-import-path"><span class="xref std std-term">import path</span></a> continúa.  El enlace debe esperar un objeto de rutas o bytes; la codificación de objetos bytes está hasta el enlace (por ejemplo, puede ser una codificación del sistema de archivos, UTF-8, o algo más), y si el gancho no puede decodificar el argumento, debe generar <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>.</p>
<p class="translated">Si la iteración <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> termina sin que se retorne ningún valor <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a>, a continuación, el método de búsqueda basado en la ruta de acceso <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> almacenará <code class="docutils literal notranslate"><span class="pre">None</span></code> en <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> (para indicar que no hay ningún buscador para esta entrada de ruta) y retornará <code class="docutils literal notranslate"><span class="pre">None</span></code>, lo que indica que este <a class="reference internal" href="../glossary.html#term-meta-path-finder"><span class="xref std std-term">meta path finder</span></a> no pudo encontrar el módulo.</p>
<p class="translated">Si un <a class="reference internal" href="../glossary.html#term-path-entry-finder"><span class="xref std std-term">path entry finder</span></a> <em>is</em> retornado por uno de los <a class="reference internal" href="../glossary.html#term-path-entry-hook"><span class="xref std std-term">path entry hook</span></a> invocables en <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>, entonces el siguiente protocolo se utiliza para pedir al buscador una especificación de módulo, que luego se utiliza al cargar el módulo.</p>
<p class="untranslated">The current working directory – denoted by an empty string – is handled
slightly differently from other entries on <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>. First, if the
current working directory cannot be determined or is found not to exist, no
value is stored in <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a>. Second, the value for the
current working directory is looked up fresh for each module lookup. Third,
the path used for <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> and returned by
<a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder.find_spec()</span></code></a> will be the actual current
working directory and not the empty string.</p>
</section>
<section id="path-entry-finder-protocol">
<h3 class="translated"><span class="section-number">5.5.2. </span>Buscadores de entradas de ruta<a class="headerlink" href="#path-entry-finder-protocol" title="Link to this heading">¶</a></h3>
<p class="translated">Para admitir las importaciones de módulos y paquetes inicializados y también para contribuir con partes a paquetes de espacio de nombres, los buscadores de entradas de ruta de acceso deben implementar el método <a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder.find_spec()</span></code></a>.</p>
<p class="translated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder.find_spec`()</span></code> toma dos argumentos: el nombre completo del módulo que se va a importar y el módulo de destino (opcional).  <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> retorna una especificación completamente poblada para el módulo. Esta especificación siempre tendrá «cargador» establecido (con una excepción).</p>
<p class="untranslated">To indicate to the import machinery that the spec represents a namespace
<a class="reference internal" href="../glossary.html#term-portion"><span class="xref std std-term">portion</span></a>, the path entry finder sets <code class="docutils literal notranslate"><span class="pre">submodule_search_locations</span></code> to
a list containing the portion.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span><a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> replaced
<code class="xref py py-meth docutils literal notranslate"><span class="pre">find_loader()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code>, both of which
are now deprecated, but will be used if <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> is not defined.</p>
<p class="translated">Los buscadores de entradas de ruta más antiguos pueden implementar uno de estos dos métodos en desuso en lugar de <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code>.  Los métodos todavía se respetan en aras de la compatibilidad con versiones anteriores.  Sin embargo, si <code class="docutils literal notranslate"><span class="pre">find_spec()</span></code> se implementa en el buscador de entrada de ruta, se omiten los métodos heredados.</p>
<p class="untranslated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_loader()</span></code> takes one argument, the
fully qualified name of the module being imported.  <code class="docutils literal notranslate"><span class="pre">find_loader()</span></code>
returns a 2-tuple where the first item is the loader and the second item
is a namespace <a class="reference internal" href="../glossary.html#term-portion"><span class="xref std std-term">portion</span></a>.</p>
<p class="translated">Para la compatibilidad con versiones anteriores con otras implementaciones del protocolo de importación, muchos buscadores de entradas de ruta de acceso también admiten el mismo método tradicional <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> que admiten los buscadores de rutas de acceso meta. Sin embargo, nunca se llama a los métodos del buscador de entradas de ruta <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> con un argumento <code class="docutils literal notranslate"><span class="pre">path</span></code> (se espera que registren la información de ruta adecuada desde la llamada inicial al enlace de ruta).</p>
<p class="translated">El método <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> en los buscadores de entrada de ruta está en desuso, ya que no permite que el buscador de entradas de ruta de acceso aporte partes a paquetes de espacio de nombres.  Si existen tanto <code class="docutils literal notranslate"><span class="pre">find_loader()</span></code> como <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> en un buscador de entrada de ruta, el sistema de importación siempre llamará a <code class="docutils literal notranslate"><span class="pre">find_loader()</span></code> en lugar de <code class="docutils literal notranslate"><span class="pre">find_module()</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span>Calls to <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">find_loader()</span></code> by the import
system will raise <a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>Los métodos <code class="docutils literal notranslate"><span class="pre">find_module()</span></code> y <code class="docutils literal notranslate"><span class="pre">find_loader()</span></code> fueron eliminados.</p>
</div>
</section>
</section>
<section id="replacing-the-standard-import-system">
<h2 class="translated"><span class="section-number">5.6. </span>Reemplazando el sistema de importación estándar<a class="headerlink" href="#replacing-the-standard-import-system" title="Link to this heading">¶</a></h2>
<p class="translated">El mecanismo más confiable para reemplazar todo el sistema de importación es eliminar el contenido predeterminado de <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>, sustituyéndolos por completo por un enlace de meta path personalizado.</p>
<p class="translated">Si es aceptable alterar únicamente el comportamiento de las declaraciones de importación sin afectar a otras API que acceden al sistema de importación, puede ser suficiente reemplazar la función incorporada <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>. Esta técnica también puede emplearse a nivel de módulo para alterar únicamente el comportamiento de las declaraciones de importación dentro de ese módulo.</p>
<p class="translated">Para evitar selectivamente la importación de algunos módulos de un enlace al principio de la meta path (en lugar de deshabilitar completamente el sistema de importación estándar), es suficiente elevar <a class="reference internal" href="../library/exceptions.html#ModuleNotFoundError" title="ModuleNotFoundError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code></a> directamente desde <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_spec()</span></code></a> en lugar de retornar <code class="docutils literal notranslate"><span class="pre">None</span></code>. Este último indica que la búsqueda de meta path debe continuar, mientras que la generación de una excepción termina inmediatamente.</p>
</section>
<section id="package-relative-imports">
<span id="relativeimports"></span><h2 class="translated"><span class="section-number">5.7. </span>Paquete Importaciones relativas<a class="headerlink" href="#package-relative-imports" title="Link to this heading">¶</a></h2>
<p class="translated">Las importaciones relativas utilizan puntos iniciales. Un único punto inicial indica una importación relativa, empezando por el paquete actual. Dos o más puntos iniciales indican una importación relativa a los elementos primarios del paquete actual, un nivel por punto después del primero. Por ejemplo, dado el siguiente diseño de paquete:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">package</span><span class="o">/</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">subpackage1</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
        <span class="n">moduleX</span><span class="o">.</span><span class="n">py</span>
        <span class="n">moduleY</span><span class="o">.</span><span class="n">py</span>
    <span class="n">subpackage2</span><span class="o">/</span>
        <span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
        <span class="n">moduleZ</span><span class="o">.</span><span class="n">py</span>
    <span class="n">moduleA</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p class="translated">En <code class="docutils literal notranslate"><span class="pre">subpackage1/moduleX.py</span></code> o <code class="docutils literal notranslate"><span class="pre">subpackage1/__init__.py</span></code>, las siguientes son importaciones relativas válidas:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">.moduleY</span><span class="w"> </span><span class="kn">import</span> <span class="n">spam</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.moduleY</span><span class="w"> </span><span class="kn">import</span> <span class="n">spam</span> <span class="k">as</span> <span class="n">ham</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">moduleY</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..subpackage1</span><span class="w"> </span><span class="kn">import</span> <span class="n">moduleY</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..subpackage2.moduleZ</span><span class="w"> </span><span class="kn">import</span> <span class="n">eggs</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..moduleA</span><span class="w"> </span><span class="kn">import</span> <span class="n">foo</span>
</pre></div>
</div>
<p class="translated">Las importaciones absolutas pueden utilizar la sintaxis <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">&lt;&gt;</span></code> o <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">&lt;&gt;</span> <span class="pre">import</span> <span class="pre">&lt;&gt;</span></code>, pero las importaciones relativas solo pueden usar el segundo formulario; la razón de esto es que:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">XXX.YYY.ZZZ</span>
</pre></div>
</div>
<p class="translated">debe exponer <code class="docutils literal notranslate"><span class="pre">XXX.</span> <span class="pre">Yyy.</span> <span class="pre">ZZZ</span></code> como una expresión utilizable, pero .moduleY no es una expresión válida.</p>
</section>
<section id="special-considerations-for-main">
<span id="import-dunder-main"></span><h2 class="translated"><span class="section-number">5.8. </span>Consideraciones especiales para __main__<a class="headerlink" href="#special-considerations-for-main" title="Link to this heading">¶</a></h2>
<p class="translated">El módulo <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> es un caso especial relativo al sistema de importación de Python. Como se señaló <a class="reference internal" href="toplevel_components.html#programs"><span class="std std-ref">elsewhere</span></a>, el módulo <code class="docutils literal notranslate"><span class="pre">__main__</span></code> se inicializa directamente al inicio del intérprete, al igual que <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> y <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>. Sin embargo, a diferencia de esos dos, no califica estrictamente como un módulo integrado. Esto se debe a que la forma en que se inicializa <code class="docutils literal notranslate"><span class="pre">__main__</span></code> depende de las marcas y otras opciones con las que se invoca el intérprete.</p>
<section id="main-spec">
<span id="id5"></span><h3 class="translated"><span class="section-number">5.8.1. </span>__main__.__spec__<a class="headerlink" href="#main-spec" title="Link to this heading">¶</a></h3>
<p class="translated">Dependiendo de cómo se inicializa <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a>, <code class="docutils literal notranslate"><span class="pre">__main__.__spec__</span></code> se establece correctamente o en <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p class="translated">Cuando Python se inicia con la opción <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a>, <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> se establece en la especificación de módulo del módulo o paquete correspondiente. <code class="docutils literal notranslate"><span class="pre">__spec__</span></code> también se rellena cuando el módulo <code class="docutils literal notranslate"><span class="pre">__main__</span></code> se carga como parte de la ejecución de un directorio, zipfile u otro <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> entrada.</p>
<p class="translated">En <a class="reference internal" href="../using/cmdline.html#using-on-interface-options"><span class="std std-ref">los casos restantes</span></a> <code class="docutils literal notranslate"><span class="pre">__main__.__spec__</span></code> se establece en <code class="docutils literal notranslate"><span class="pre">None</span></code>, ya que el código utilizado para rellenar el <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> no se corresponde directamente con un módulo importable:</p>
<ul class="simple">
<li><p class="translated">mensaje interactivo</p></li>
<li><p class="translated">opción <a class="reference internal" href="../using/cmdline.html#cmdoption-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c</span></code></a></p></li>
<li><p class="translated">ejecutando desde stdin</p></li>
<li><p class="translated">que se ejecuta directamente desde un archivo de código fuente o de código de bytes</p></li>
</ul>
<p class="translated">Tenga en cuenta que <code class="docutils literal notranslate"><span class="pre">__main__.__spec__</span></code> siempre es <code class="docutils literal notranslate"><span class="pre">None</span></code> en el último caso, <em>incluso si</em> el archivo técnicamente podría importarse directamente como un módulo en su lugar. Utilice el modificador <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> si se desean metadatos de módulo válidos en <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a>.</p>
<p class="translated">Tenga en cuenta también que incluso cuando <code class="docutils literal notranslate"><span class="pre">__main__</span></code> corresponde a un módulo importable y <code class="docutils literal notranslate"><span class="pre">__main__.__spec__</span></code> se establece en consecuencia, todavía se consideran módulos <em>distinct</em>. Esto se debe al hecho de que los bloques protegidos por las comprobaciones <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">&quot;__main__&quot;:</span></code> solo se ejecutan cuando el módulo se utiliza para rellenar el espacio de nombres <code class="docutils literal notranslate"><span class="pre">__main__</span></code>, y no durante la importación normal.</p>
</section>
</section>
<section id="references">
<h2 class="translated"><span class="section-number">5.9. </span>Referencias<a class="headerlink" href="#references" title="Link to this heading">¶</a></h2>
<p class="translated">La maquinaria de importación ha evolucionado considerablemente desde los primeros días de Python.  La <a class="reference external" href="https://www.python.org/doc/essays/packages/">especificación original para paquetes</a> todavía está disponible para leer, aunque algunos detalles han cambiado desde la escritura de ese documento.</p>
<p class="translated">La especificación original de <a class="reference internal" href="../library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a> era <span class="target" id="index-38"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a>, con posterior extensión en <span class="target" id="index-39"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a>.</p>
<p class="untranslated"><span class="target" id="index-18"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> introduced <a class="reference internal" href="../glossary.html#term-namespace-package"><span class="xref std std-term">namespace packages</span></a> for
Python 3.3.  <span class="target" id="index-19"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> also introduced the <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_loader()</span></code> protocol as an
alternative to <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code>.</p>
<p class="translated"><span class="target" id="index-40"></span><a class="pep reference external" href="https://peps.python.org/pep-0366/"><strong>PEP 366</strong></a> describe la adición del atributo <code class="docutils literal notranslate"><span class="pre">__package__</span></code> para las importaciones relativas explícitas en los módulos principales.</p>
<p class="translated"><span class="target" id="index-41"></span><a class="pep reference external" href="https://peps.python.org/pep-0328/"><strong>PEP 328</strong></a> introdujo importaciones relativas absolutas y explícitas e inicialmente propuestas <code class="docutils literal notranslate"><span class="pre">__name__</span></code> para la semántica <span class="target" id="index-42"></span><a class="pep reference external" href="https://peps.python.org/pep-0366/"><strong>PEP 366</strong></a> eventualmente especificaría para <code class="docutils literal notranslate"><span class="pre">__package__</span></code>.</p>
<p class="translated"><span class="target" id="index-43"></span><a class="pep reference external" href="https://peps.python.org/pep-0338/"><strong>PEP 338</strong></a> define la ejecución de módulos como scripts.</p>
<p class="translated"><span class="target" id="index-44"></span><a class="pep reference external" href="https://peps.python.org/pep-0451/"><strong>PEP 451</strong></a> agrega la encapsulación del estado de importación por módulo en los objetos de especificación. También descargara la mayoría de las responsabilidades de los cargadores en la maquinaria de importación. Estos cambios permiten el desuso de varias API en el sistema de importación y también la adición de nuevos métodos a los buscadores y cargadores.</p>
<p class="translated rubric">Notas al Pie de Pagina</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="fnmo" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p class="translated">Véase <code class="xref py py-class docutils literal notranslate"><span class="pre">types.</span> <span class="pre">ModuleType</span></code>.</p>
</aside>
<aside class="footnote brackets" id="fnlo" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p class="translated">La implementación de importlib evita usar el valor retornado directamente. En su lugar, obtiene el objeto module buscando el nombre del módulo en <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>.  El efecto indirecto de esto es que un módulo importado puede sustituirse a sí mismo en <a class="reference internal" href="../library/sys.html#sys.modules" title="sys.modules"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.modules</span></code></a>.  Este es un comportamiento específico de la implementación que no se garantiza que funcione en otras implementaciones de Python.</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">5. El sistema de importación</a><ul>
<li><a class="reference internal" href="#importlib">5.1. <code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a></li>
<li><a class="reference internal" href="#packages">5.2. Paquetes</a><ul>
<li><a class="reference internal" href="#regular-packages">5.2.1. Paquetes regulares</a></li>
<li><a class="reference internal" href="#namespace-packages">5.2.2. Paquetes de espacio de nombres</a></li>
</ul>
</li>
<li><a class="reference internal" href="#searching">5.3. Buscando</a><ul>
<li><a class="reference internal" href="#the-module-cache">5.3.1. La caché del módulo</a></li>
<li><a class="reference internal" href="#finders-and-loaders">5.3.2. Buscadores y cargadores</a></li>
<li><a class="reference internal" href="#import-hooks">5.3.3. Ganchos de importación</a></li>
<li><a class="reference internal" href="#the-meta-path">5.3.4. La meta ruta (<em>path</em>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#loading">5.4. Cargando</a><ul>
<li><a class="reference internal" href="#loaders">5.4.1. Cargadores</a></li>
<li><a class="reference internal" href="#submodules">5.4.2. Submódulos</a></li>
<li><a class="reference internal" href="#module-specs">5.4.3. Module specs</a></li>
<li><a class="reference internal" href="#path-attributes-on-modules">5.4.4. __path__ attributes on modules</a></li>
<li><a class="reference internal" href="#module-reprs">5.4.5. Representación (<em>Reprs</em>) de módulos</a></li>
<li><a class="reference internal" href="#cached-bytecode-invalidation">5.4.6. Invalidación del código de bytes en caché</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-path-based-finder">5.5. El buscador basado en rutas</a><ul>
<li><a class="reference internal" href="#path-entry-finders">5.5.1. Buscadores de entradas de ruta</a></li>
<li><a class="reference internal" href="#path-entry-finder-protocol">5.5.2. Buscadores de entradas de ruta</a></li>
</ul>
</li>
<li><a class="reference internal" href="#replacing-the-standard-import-system">5.6. Reemplazando el sistema de importación estándar</a></li>
<li><a class="reference internal" href="#package-relative-imports">5.7. Paquete Importaciones relativas</a></li>
<li><a class="reference internal" href="#special-considerations-for-main">5.8. Consideraciones especiales para __main__</a><ul>
<li><a class="reference internal" href="#main-spec">5.8.1. __main__.__spec__</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">5.9. Referencias</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="executionmodel.html"
                          title="capítulo anterior"><span class="section-number">4. </span>Modelo de ejecución</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="expressions.html"
                          title="próximo capítulo"><span class="section-number">6. </span>Expresiones</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/import.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Contraer barra lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="expressions.html" title="6. Expresiones"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. Modelo de ejecución"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Referencia del Lenguaje Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5. </span>El sistema de importación</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Derechos de autor</a> 2001 Python Software Foundation.
    <br>
    Ésta página tiene la licencia Python Software Foundation Versión 2.
    <br>
    Ejemplos, guías, y otro código en la documentación están bajo la licencia adicional Zero Clause BSD.
    <br>
    
      Ver <a href="/license.html">Historia y Licencia</a> para más información.<br>
    
    
    <br>

    La Python Software Foundation es una corporación sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor dona.</a>
<br>
    <br>
      Última actualización en oct 06, 2025 (04:51 UTC).
    
      <a href="/bugs.html">Encontraste un bug</a>?
    
    <br>

    Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a>8.2.3.
    </div>

  </body>
</html>