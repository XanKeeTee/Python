<!DOCTYPE html>

<html lang="es" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="3. Modelo de datos" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/reference/datamodel.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Objetos, valores y tipos: Objects son la abstracción de Python para los datos. Todos los datos en un programa Python están representados por objetos o por relaciones entre objetos. (En cierto senti..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.15/es/_images/social_previews/summary_reference_datamodel_ff9f8213.png" />
<meta property="og:image:alt" content="Objetos, valores y tipos: Objects son la abstracción de Python para los datos. Todos los datos en un programa Python están representados por objetos o por relaciones entre objetos. (En cierto senti..." />
<meta name="description" content="Objetos, valores y tipos: Objects son la abstracción de Python para los datos. Todos los datos en un programa Python están representados por objetos o por relaciones entre objetos. (En cierto senti..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>3. Modelo de datos &#8212; documentación de Python - 3.15.0a0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=bf1f176d"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f85f4cfb"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.15.0a0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Derechos de autor" href="../copyright.html" />
    <link rel="next" title="4. Modelo de ejecución" href="executionmodel.html" />
    <link rel="prev" title="2. Análisis léxico" href="lexical_analysis.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/reference/datamodel.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menú">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">3. Modelo de datos</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. Objetos, valores y tipos</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. Jerarquía de tipos estándar</a><ul>
<li><a class="reference internal" href="#none">3.2.1. None</a></li>
<li><a class="reference internal" href="#notimplemented">3.2.2. NotImplemented</a></li>
<li><a class="reference internal" href="#ellipsis">3.2.3. Elipsis</a></li>
<li><a class="reference internal" href="#numbers-number">3.2.4. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a><ul>
<li><a class="reference internal" href="#numbers-integral">3.2.4.1. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a></li>
<li><a class="reference internal" href="#numbers-real-float">3.2.4.2. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>)</a></li>
<li><a class="reference internal" href="#numbers-complex-complex">3.2.4.3. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code> (<code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequences">3.2.5. Secuencias</a><ul>
<li><a class="reference internal" href="#immutable-sequences">3.2.5.1. Secuencias inmutables</a></li>
<li><a class="reference internal" href="#mutable-sequences">3.2.5.2. Secuencias mutables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#set-types">3.2.6. Tipos de conjuntos</a></li>
<li><a class="reference internal" href="#mappings">3.2.7. Mapeos</a><ul>
<li><a class="reference internal" href="#dictionaries">3.2.7.1. Diccionarios</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callable-types">3.2.8. Tipos invocables</a><ul>
<li><a class="reference internal" href="#user-defined-functions">3.2.8.1. Funciones definidas por el usuario</a><ul>
<li><a class="reference internal" href="#special-read-only-attributes">3.2.8.1.1. Special read-only attributes</a></li>
<li><a class="reference internal" href="#special-writable-attributes">3.2.8.1.2. Special writable attributes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#instance-methods">3.2.8.2. Métodos de instancia</a></li>
<li><a class="reference internal" href="#generator-functions">3.2.8.3. Funciones generadoras</a></li>
<li><a class="reference internal" href="#coroutine-functions">3.2.8.4. Funciones de corrutina</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">3.2.8.5. Funciones generadoras asincrónicas</a></li>
<li><a class="reference internal" href="#built-in-functions">3.2.8.6. Funciones incorporadas</a></li>
<li><a class="reference internal" href="#built-in-methods">3.2.8.7. Métodos incorporados</a></li>
<li><a class="reference internal" href="#classes">3.2.8.8. Clases</a></li>
<li><a class="reference internal" href="#class-instances">3.2.8.9. Instancias de clases</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modules">3.2.9. Módulos</a><ul>
<li><a class="reference internal" href="#import-related-attributes-on-module-objects">3.2.9.1. Import-related attributes on module objects</a></li>
<li><a class="reference internal" href="#other-writable-attributes-on-module-objects">3.2.9.2. Other writable attributes on module objects</a></li>
<li><a class="reference internal" href="#module-dictionaries">3.2.9.3. Module dictionaries</a></li>
</ul>
</li>
<li><a class="reference internal" href="#custom-classes">3.2.10. Clases personalizadas</a><ul>
<li><a class="reference internal" href="#special-attributes">3.2.10.1. Special attributes</a></li>
<li><a class="reference internal" href="#special-methods">3.2.10.2. Special methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">3.2.11. Instancias de clase</a><ul>
<li><a class="reference internal" href="#id5">3.2.11.1. Special attributes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#i-o-objects-also-known-as-file-objects">3.2.12. Objetos E/S (también conocidos como objetos de archivo)</a></li>
<li><a class="reference internal" href="#internal-types">3.2.13. Tipos internos</a><ul>
<li><a class="reference internal" href="#code-objects">3.2.13.1. Objetos de código</a><ul>
<li><a class="reference internal" href="#index-64">3.2.13.1.1. Special read-only attributes</a></li>
<li><a class="reference internal" href="#methods-on-code-objects">3.2.13.1.2. Methods on code objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#frame-objects">3.2.13.2. Objetos de marco</a><ul>
<li><a class="reference internal" href="#index-70">3.2.13.2.1. Special read-only attributes</a></li>
<li><a class="reference internal" href="#index-71">3.2.13.2.2. Special writable attributes</a></li>
<li><a class="reference internal" href="#frame-object-methods">3.2.13.2.3. Frame object methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#traceback-objects">3.2.13.3. Objetos de seguimiento de pila (traceback)</a></li>
<li><a class="reference internal" href="#slice-objects">3.2.13.4. Objetos de segmento (Slice objects)</a></li>
<li><a class="reference internal" href="#static-method-objects">3.2.13.5. Objetos de método estático</a></li>
<li><a class="reference internal" href="#class-method-objects">3.2.13.6. Objetos de método de clase</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#special-method-names">3.3. Nombres especiales de método</a><ul>
<li><a class="reference internal" href="#basic-customization">3.3.1. Personalización básica</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.3.2. Personalizando acceso a atributos</a><ul>
<li><a class="reference internal" href="#customizing-module-attribute-access">3.3.2.1. Personalizando acceso a atributos de módulo</a></li>
<li><a class="reference internal" href="#implementing-descriptors">3.3.2.2. Implementando descriptores</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.3.2.3. Invocando descriptores</a></li>
<li><a class="reference internal" href="#slots">3.3.2.4. __slots__</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.3.3. Personalización de creación de clases</a><ul>
<li><a class="reference internal" href="#metaclasses">3.3.3.1. Metaclases</a></li>
<li><a class="reference internal" href="#resolving-mro-entries">3.3.3.2. Resolviendo entradas de la Orden de Resolución de Métodos (MRU)</a></li>
<li><a class="reference internal" href="#determining-the-appropriate-metaclass">3.3.3.3. Determinando la metaclase adecuada</a></li>
<li><a class="reference internal" href="#preparing-the-class-namespace">3.3.3.4. Preparando el espacio de nombres de la clase</a></li>
<li><a class="reference internal" href="#executing-the-class-body">3.3.3.5. Ejecutando el cuerpo de la clase</a></li>
<li><a class="reference internal" href="#creating-the-class-object">3.3.3.6. Creando el objeto de clase</a></li>
<li><a class="reference internal" href="#uses-for-metaclasses">3.3.3.7. Usos para metaclases</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.3.4. Personalizando revisiones de instancia y subclase</a></li>
<li><a class="reference internal" href="#emulating-generic-types">3.3.5. Emulando tipos genéricos</a><ul>
<li><a class="reference internal" href="#the-purpose-of-class-getitem">3.3.5.1. El propósito de <em>__class_getitem__</em></a></li>
<li><a class="reference internal" href="#class-getitem-versus-getitem">3.3.5.2. <em>__class_getitem__</em> frente a <em>__getitem__</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#emulating-callable-objects">3.3.6. Emulando objetos que se pueden llamar</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.3.7. Emulando tipos de contenedores</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.3.8. Emulando tipos numéricos</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.3.9. Gestores de Contexto en la Declaración <em>with</em></a></li>
<li><a class="reference internal" href="#customizing-positional-arguments-in-class-pattern-matching">3.3.10. Personalización de argumentos posicionales en la coincidencia de patrones de clase</a></li>
<li><a class="reference internal" href="#emulating-buffer-types">3.3.11. Emulando tipos de búfer</a></li>
<li><a class="reference internal" href="#annotations">3.3.12. Annotations</a></li>
<li><a class="reference internal" href="#special-method-lookup">3.3.13. Búsqueda de método especial</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coroutines">3.4. Corrutinas</a><ul>
<li><a class="reference internal" href="#awaitable-objects">3.4.1. Objetos esperables</a></li>
<li><a class="reference internal" href="#coroutine-objects">3.4.2. Objetos de corrutina</a></li>
<li><a class="reference internal" href="#asynchronous-iterators">3.4.3. Iteradores asíncronos</a></li>
<li><a class="reference internal" href="#asynchronous-context-managers">3.4.4. Gestores de contexto asíncronos</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="lexical_analysis.html"
                          title="capítulo anterior"><span class="section-number">2. </span>Análisis léxico</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="executionmodel.html"
                          title="próximo capítulo"><span class="section-number">4. </span>Modelo de ejecución</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/datamodel.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. Modelo de ejecución"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. Análisis léxico"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Referencia del Lenguaje Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3. </span>Modelo de datos</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="data-model">
<span id="datamodel"></span><h1 class="translated"><span class="section-number">3. </span>Modelo de datos<a class="headerlink" href="#data-model" title="Link to this heading">¶</a></h1>
<section id="objects-values-and-types">
<span id="objects"></span><h2 class="translated"><span class="section-number">3.1. </span>Objetos, valores y tipos<a class="headerlink" href="#objects-values-and-types" title="Link to this heading">¶</a></h2>
<p class="translated" id="index-0"><em class="dfn">Objects</em> son la abstracción de Python para los datos. Todos los datos en un programa Python están representados por objetos o por relaciones entre objetos. (En cierto sentido y de conformidad con el modelo de Von Neumann de una «programa almacenado de computadora», el código también está representado por objetos.)</p>
<span class="target" id="index-1"></span><p class="untranslated">Every object has an identity, a type and a value.  An object’s <em>identity</em> never
changes once it has been created; you may think of it as the object’s address in
memory.  The <a class="reference internal" href="expressions.html#is"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">is</span></code></a> operator compares the identity of two objects; the
<a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> function returns an integer representing its identity.</p>
<div class="impl-detail compound">
<p class="translated">Para CPython, <code class="docutils literal notranslate"><span class="pre">id(x)</span></code> es la dirección de memoria donde se almacena <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</div>
<p class="translated">El tipo de un objeto determina las operaciones que admite el objeto (por ejemplo, «¿tiene una longitud?») y también define los posibles valores para los objetos de ese tipo. La función <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> retorna el tipo de un objeto (que es un objeto en sí mismo). Al igual que su identidad, también el <em class="dfn">type</em> de un objeto es inmutable. <a class="footnote-reference brackets" href="#id20" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<p class="translated">El <em>valor</em> de algunos objetos puede cambiar. Se dice que los objetos cuyo valor puede cambiar son <em>mutables</em>; Los objetos cuyo valor no se puede modificar una vez que se crean se denominan <em>inmutables</em>. (El valor de un objeto contenedor inmutable que contiene una referencia a un objeto mutable puede cambiar cuando se cambia el valor de este último; sin embargo, el contenedor todavía se considera inmutable, porque la colección de objetos que contiene no se puede cambiar. Por lo tanto, la inmutabilidad no es estrictamente lo mismo que tener un valor inmutable, es más sutil). La mutabilidad de un objeto está determinada por su tipo; por ejemplo, los números, las cadenas de caracteres y las tuplas son inmutables, mientras que los diccionarios y las listas son mutables.</p>
<p class="translated" id="index-2">Los objetos nunca se destruyen explícitamente; sin embargo, cuando se vuelven inalcanzables, se pueden recolectar basura. Se permite a una implementación posponer la recolección de basura u omitirla por completo; es una cuestión de calidad de la implementación cómo se implementa la recolección de basura, siempre que no se recolecten objetos que todavía sean accesibles.</p>
<div class="impl-detail compound">
<p class="translated">CPython actualmente utiliza un esquema de conteo de referencias con detección retardada (opcional) de basura enlazada cíclicamente, que recolecta la mayoría de los objetos tan pronto como se vuelven inalcanzables, pero no se garantiza que recolecte basura que contenga referencias circulares. Vea la documentación del módulo <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> para información sobre el control de la recolección de basura cíclica. Otras implementaciones actúan de manera diferente y CPython puede cambiar. No dependa de la finalización inmediata de los objetos cuando se vuelvan inalcanzables (por lo que siempre debe cerrar los archivos explícitamente).</p>
</div>
<p class="untranslated">Note that the use of the implementation’s tracing or debugging facilities may
keep objects alive that would normally be collectable. Also note that catching
an exception with a <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>…<a class="reference internal" href="compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> statement may keep
objects alive.</p>
<p class="untranslated">Some objects contain references to «external» resources such as open files or
windows.  It is understood that these resources are freed when the object is
garbage-collected, but since garbage collection is not guaranteed to happen,
such objects also provide an explicit way to release the external resource,
usually a <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> method. Programs are strongly recommended to explicitly
close such objects.  The <a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>…<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> statement
and the <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> statement provide convenient ways to do this.</p>
<p class="translated" id="index-3">Algunos objetos contienen referencias a otros objetos; estos se llaman <em>contenedores</em>. Ejemplos de contenedores son tuplas, listas y diccionarios. Las referencias son parte del valor de un contenedor. En la mayoría de los casos, cuando hablamos del valor de un contenedor, implicamos los valores, no las identidades de los objetos contenidos; sin embargo, cuando hablamos de la mutabilidad de un contenedor, solo se implican las identidades de los objetos contenidos inmediatamente. Entonces, si un contenedor inmutable (como una tupla) contiene una referencia a un objeto mutable, su valor cambia si se cambia ese objeto mutable.</p>
<p class="untranslated">Types affect almost all aspects of object behavior.  Even the importance of
object identity is affected in some sense: for immutable types, operations that
compute new values may actually return a reference to any existing object with
the same type and value, while for mutable objects this is not allowed.
For example, after <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">1</span></code>, <em>a</em> and <em>b</em> may or may not refer to
the same object with the value one, depending on the implementation.
This is because <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> is an immutable type, so the reference to <code class="docutils literal notranslate"><span class="pre">1</span></code>
can be reused. This behaviour depends on the implementation used, so should
not be relied upon, but is something to be aware of when making use of object
identity tests.
However, after <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">=</span> <span class="pre">[];</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">[]</span></code>, <em>c</em> and <em>d</em> are guaranteed to refer to two
different, unique, newly created empty lists. (Note that <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">[]</span></code> assigns
the <em>same</em> object to both <em>e</em> and <em>f</em>.)</p>
</section>
<section id="the-standard-type-hierarchy">
<span id="types"></span><h2 class="translated"><span class="section-number">3.2. </span>Jerarquía de tipos estándar<a class="headerlink" href="#the-standard-type-hierarchy" title="Link to this heading">¶</a></h2>
<p class="translated" id="index-4">A continuación se muestra una lista de los tipos integrados en Python. Los módulos de extensión (escritos en C, Java u otros lenguajes, dependiendo de la implementación) pueden definir tipos adicionales. Las versiones futuras de Python pueden agregar tipos a la jerarquía de tipos (por ejemplo, números racionales, matrices de enteros almacenados de manera eficiente, etc.), aunque tales adiciones a menudo se proporcionarán a través de la biblioteca estándar.</p>
<p class="translated" id="index-5">Algunas de las descripciones de tipos a continuación contienen un párrafo que enumera “atributos especiales”. Estos son atributos que proporcionan acceso a la implementación y no están destinados para uso general. Su definición puede cambiar en el futuro.</p>
<section id="none">
<h3 class="translated"><span class="section-number">3.2.1. </span>None<a class="headerlink" href="#none" title="Link to this heading">¶</a></h3>
<p class="translated" id="index-6">Este tipo tiene un solo valor. Hay un solo objeto con este valor. Se accede a este objeto a través del nombre incorporado <code class="docutils literal notranslate"><span class="pre">None</span></code>. Se utiliza para indicar la ausencia de un valor en muchas situaciones, por ejemplo, se retorna desde funciones que no retornan nada explícitamente. Su valor de verdad es falso.</p>
</section>
<section id="notimplemented">
<h3 class="translated"><span class="section-number">3.2.2. </span>NotImplemented<a class="headerlink" href="#notimplemented" title="Link to this heading">¶</a></h3>
<p class="untranslated" id="index-7">This type has a single value.  There is a single object with this value. This
object is accessed through the built-in name <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>. Numeric methods
and rich comparison methods should return this value if they do not implement the
operation for the operands provided.  (The interpreter will then try the
reflected operation, or some other fallback, depending on the operator.)  It
should not be evaluated in a boolean context.</p>
<p class="translated">Vea <a class="reference internal" href="../library/numbers.html#implementing-the-arithmetic-operations"><span class="std std-ref">Implementar operaciones aritméticas</span></a> para más detalles.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.9: </span>Evaluating <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> in a boolean context was deprecated.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.14: </span>Evaluating <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> in a boolean context now raises a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.
It previously evaluated to <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> and emitted a <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>
since Python 3.9.</p>
</div>
</section>
<section id="ellipsis">
<h3 class="translated"><span class="section-number">3.2.3. </span>Elipsis<a class="headerlink" href="#ellipsis" title="Link to this heading">¶</a></h3>
<p class="translated" id="index-8">Este tipo tiene un solo valor. Hay un solo objeto con este valor. Se accede a este objeto a través del literal <code class="docutils literal notranslate"><span class="pre">...</span></code> o el nombre incorporado <code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code>. Su valor de verdad es verdadero.</p>
</section>
<section id="numbers-number">
<h3 class="translated"><span class="section-number">3.2.4. </span><a class="reference internal" href="../library/numbers.html#numbers.Number" title="numbers.Number"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a><a class="headerlink" href="#numbers-number" title="Link to this heading">¶</a></h3>
<p class="translated" id="index-9">Estos son creados por literales numéricos y retornados como resultados por operadores aritméticos y funciones aritméticas integradas. Los objetos numéricos son inmutables; una vez creado su valor nunca cambia. Los números de Python están, por supuesto, fuertemente relacionados con los números matemáticos, pero están sujetos a las limitaciones de la representación numérica en las computadoras.</p>
<p class="translated">Las representaciones de cadena de caracteres de las clases numéricas, calculadas por <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> y <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>, tienen las siguientes propiedades:</p>
<ul class="simple">
<li><p class="translated">Son literales numéricos válidos que, cuando se pasan a su constructor de clase, producen un objeto que tiene el valor del numérico original.</p></li>
<li><p class="translated">La representación está en base 10, cuando sea posible.</p></li>
<li><p class="translated">Los ceros iniciales, posiblemente excepto un solo cero antes de un punto decimal, no se muestran.</p></li>
<li><p class="translated">Los ceros finales, posiblemente excepto un solo cero después de un punto decimal, no se muestran.</p></li>
<li><p class="translated">Solo se muestra un signo cuando el número es negativo.</p></li>
</ul>
<p class="untranslated">Python distinguishes between integers, floating-point numbers, and complex
numbers:</p>
<section id="numbers-integral">
<h4 class="translated"><span class="section-number">3.2.4.1. </span><a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a><a class="headerlink" href="#numbers-integral" title="Link to this heading">¶</a></h4>
<p class="translated" id="index-10">Estos representan elementos del conjunto matemático de números enteros (positivo y negativo).</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated" id="index-11">Las reglas para la representación de enteros están destinadas a dar la interpretación más significativa de las operaciones de cambio y máscara que involucran enteros negativos.</p>
</div>
<p class="translated">Hay dos tipos de números enteros:</p>
<dl>
<dt class="translated">Enteros (<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>)</dt><dd><p class="translated">Estos representan números en un rango ilimitado, sujetos solo a la memoria (virtual) disponible. Para las operaciones de desplazamiento y máscara, se asume una representación binaria, y los números negativos se representan en una variante del complemento de 2 que da la ilusión de una cadena de caracteres infinita de bits con signo que se extiende hacia la izquierda.</p>
</dd>
<dt class="translated">Booleanos (<a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>)</dt><dd><p class="translated" id="index-12">Estos representan los valores de verdad Falso y Verdadero. Los dos objetos que representan los valores <code class="docutils literal notranslate"><span class="pre">False</span></code> y <code class="docutils literal notranslate"><span class="pre">True</span></code> son los únicos objetos booleanos. El tipo booleano es un subtipo del tipo entero y los valores booleanos se comportan como los valores 0 y 1 respectivamente, en casi todos los contextos, con la excepción de que cuando se convierten en una cadena de caracteres, las cadenas de caracteres <code class="docutils literal notranslate"><span class="pre">&quot;False&quot;</span></code> o <code class="docutils literal notranslate"><span class="pre">&quot;True&quot;</span></code> son retornadas respectivamente.</p>
</dd>
</dl>
</section>
<section id="numbers-real-float">
<span id="datamodel-float"></span><h4 class="translated"><span class="section-number">3.2.4.2. </span><a class="reference internal" href="../library/numbers.html#numbers.Real" title="numbers.Real"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code></a> (<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>)<a class="headerlink" href="#numbers-real-float" title="Link to this heading">¶</a></h4>
<p class="untranslated" id="index-13">These represent machine-level double precision floating-point numbers. You are
at the mercy of the underlying machine architecture (and C or Java
implementation) for the accepted range and handling of overflow. Python does not
support single-precision floating-point numbers; the savings in processor and
memory usage that are usually the reason for using these are dwarfed by the
overhead of using objects in Python, so there is no reason to complicate the
language with two kinds of floating-point numbers.</p>
</section>
<section id="numbers-complex-complex">
<h4 class="translated"><span class="section-number">3.2.4.3. </span><a class="reference internal" href="../library/numbers.html#numbers.Complex" title="numbers.Complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code></a> (<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a>)<a class="headerlink" href="#numbers-complex-complex" title="Link to this heading">¶</a></h4>
<p class="untranslated" id="index-14">These represent complex numbers as a pair of machine-level double precision
floating-point numbers.  The same caveats apply as for floating-point numbers.
The real and imaginary parts of a complex number <code class="docutils literal notranslate"><span class="pre">z</span></code> can be retrieved through
the read-only attributes <code class="docutils literal notranslate"><span class="pre">z.real</span></code> and <code class="docutils literal notranslate"><span class="pre">z.imag</span></code>.</p>
</section>
</section>
<section id="sequences">
<h3 class="translated"><span class="section-number">3.2.5. </span>Secuencias<a class="headerlink" href="#sequences" title="Link to this heading">¶</a></h3>
<p class="untranslated" id="index-15">These represent finite ordered sets indexed by non-negative numbers. The
built-in function <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> returns the number of items of a sequence. When
the length of a sequence is <em>n</em>, the index set contains the numbers 0, 1,
…, <em>n</em>-1.  Item <em>i</em> of sequence <em>a</em> is selected by <code class="docutils literal notranslate"><span class="pre">a[i]</span></code>. Some sequences,
including built-in sequences, interpret negative subscripts by adding the
sequence length. For example, <code class="docutils literal notranslate"><span class="pre">a[-2]</span></code> equals <code class="docutils literal notranslate"><span class="pre">a[n-2]</span></code>, the second to last
item of sequence a with length <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p class="untranslated" id="index-16">Sequences also support slicing: <code class="docutils literal notranslate"><span class="pre">a[i:j]</span></code> selects all items with index <em>k</em> such
that <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>k</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em>.  When used as an expression, a slice is a
sequence of the same type. The comment above about negative indexes also applies
to negative slice positions.</p>
<p class="translated">Algunas secuencias también admiten «segmentación extendida» con un tercer parámetro «paso» : <code class="docutils literal notranslate"><span class="pre">a[i:j:k]</span></code> selecciona todos los elementos de <em>a</em> con índice <em>x</em> donde <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">i</span> <span class="pre">+</span> <span class="pre">n*k</span></code>, <em>n</em> <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> <code class="docutils literal notranslate"><span class="pre">0</span></code> y <em>i</em> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <em>x</em> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <em>j</em>.</p>
<p class="translated">Las secuencias se distinguen según su mutabilidad:</p>
<section id="immutable-sequences">
<h4 class="translated"><span class="section-number">3.2.5.1. </span>Secuencias inmutables<a class="headerlink" href="#immutable-sequences" title="Link to this heading">¶</a></h4>
<p class="translated" id="index-17">Un objeto de un tipo de secuencia inmutable no puede cambiar una vez que se crea. (Si el objeto contiene referencias a otros objetos, estos otros objetos pueden ser mutables y pueden cambiarse; sin embargo, la colección de objetos a los que hace referencia directamente un objeto inmutable no puede cambiar).</p>
<p class="translated">Los siguientes tipos son secuencias inmutables:</p>
<dl id="index-18">
<dt class="translated">Cadenas de caracteres</dt><dd><p class="translated" id="index-19">Una cadena es una secuencia de valores que representan puntos de código Unicode. Todos los puntos de código en el rango <code class="docutils literal notranslate"><span class="pre">U+0000</span> <span class="pre">-</span> <span class="pre">U+10FFFF</span></code> se pueden representar en una cadena. Python no tiene un tipo <span class="c-expr sig sig-inline c"><span class="kt">char</span></span>; en su lugar, cada punto de código de la cadena se representa como un objeto de cadena con una longitud <code class="docutils literal notranslate"><span class="pre">1</span></code>. La función integrada <a class="reference internal" href="../library/functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord()</span></code></a> convierte un punto de código de su forma de cadena a un entero en el rango <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code>; <a class="reference internal" href="../library/functions.html#chr" title="chr"><code class="xref py py-func docutils literal notranslate"><span class="pre">chr()</span></code></a> convierte un entero en el rango <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">-</span> <span class="pre">10FFFF</span></code> al objeto de cadena <code class="docutils literal notranslate"><span class="pre">1</span></code> de longitud correspondiente. <a class="reference internal" href="../library/stdtypes.html#str.encode" title="str.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.encode()</span></code></a> se puede usar para convertir un <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> a <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> usando la codificación de texto dada, y <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bytes.decode()</span></code></a> se puede usar para lograr lo contrario.</p>
</dd>
<dt class="translated">Tuplas</dt><dd><p class="translated" id="index-20">Los elementos de una tupla son objetos arbitrarios de Python. Las tuplas de dos o más elementos están formadas por listas de expresiones separadas por comas. Se puede formar una tupla de un elemento (un “singleton”) al colocar una coma en una expresión (una expresión en sí misma no crea una tupla, ya que los paréntesis deben ser utilizables para agrupar expresiones). Una tupla vacía puede estar formada por un par de paréntesis vacío.</p>
</dd>
<dt class="translated">Bytes</dt><dd><p class="untranslated" id="index-21">A bytes object is an immutable array.  The items are 8-bit bytes,
represented by integers in the range 0 &lt;= x &lt; 256.  Bytes literals
(like <code class="docutils literal notranslate"><span class="pre">b'abc'</span></code>) and the built-in <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes()</span></code></a> constructor
can be used to create bytes objects.  Also, bytes objects can be
decoded to strings via the <a class="reference internal" href="../library/stdtypes.html#bytes.decode" title="bytes.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> method.</p>
</dd>
</dl>
</section>
<section id="mutable-sequences">
<h4 class="translated"><span class="section-number">3.2.5.2. </span>Secuencias mutables<a class="headerlink" href="#mutable-sequences" title="Link to this heading">¶</a></h4>
<p class="translated" id="index-22">Las secuencias mutables se pueden cambiar después de su creación. Las anotaciones de suscripción y segmentación se pueden utilizar como el objetivo de asignaciones y declaraciones <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a> (eliminar).</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated" id="index-24"><span id="index-23"></span>Los módulos <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> y <a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> proporcionan ejemplos adicionales de tipos de secuencias mutables.</p>
</div>
<p class="translated">Actualmente hay dos tipos intrínsecos de secuencias mutable:</p>
<dl>
<dt class="translated">Listas</dt><dd><p class="translated" id="index-25">Los elementos de una lista son objetos de Python arbitrarios.  Las listas se forman colocando una lista de expresiones separadas por comas entre corchetes. (Tome en cuenta que no hay casos especiales necesarios para formar listas de longitud 0 o 1.)</p>
</dd>
<dt class="translated">Colecciones de bytes</dt><dd><p class="translated" id="index-26">Un objeto bytearray es una colección mutable. Son creados por el constructor incorporado <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytearray()</span></code></a>.  Además de ser mutables (y, por lo tanto, inquebrantable), las colecciones de bytes proporcionan la misma interfaz y funcionalidad que los objetos inmutables <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd>
</dl>
</section>
</section>
<section id="set-types">
<h3 class="translated"><span class="section-number">3.2.6. </span>Tipos de conjuntos<a class="headerlink" href="#set-types" title="Link to this heading">¶</a></h3>
<p class="translated" id="index-27">Estos representan conjuntos finitos no ordenados de objetos únicos e inmutables. Como tal, no pueden ser indexados por ningún <em>subscript</em>. Sin embargo, pueden repetirse y la función incorporada <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> retorna el número de elementos en un conjunto. Los usos comunes de los conjuntos son pruebas rápidas de membresía, eliminación de duplicados de una secuencia y cálculo de operaciones matemáticas como intersección, unión, diferencia y diferencia simétrica.</p>
<p class="translated">Para elementos del conjunto, se aplican las mismas reglas de inmutabilidad que para las claves de diccionario. Tenga en cuenta que los tipos numéricos obedecen las reglas normales para la comparación numérica: si dos números se comparan igual (por ejemplo, <code class="docutils literal notranslate"><span class="pre">1</span></code> y <code class="docutils literal notranslate"><span class="pre">1.0</span></code>), solo uno de ellos puede estar contenido en un conjunto.</p>
<p class="translated">Actualmente hay dos tipos de conjuntos intrínsecos:</p>
<dl>
<dt class="translated">Conjuntos</dt><dd><p class="untranslated" id="index-28">These represent a mutable set. They are created by the built-in <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal notranslate"><span class="pre">set()</span></code></a>
constructor and can be modified afterwards by several methods, such as
<a class="reference internal" href="../library/stdtypes.html#frozenset.add" title="frozenset.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add</span></code></a>.</p>
</dd>
<dt class="translated">Conjuntos congelados</dt><dd><p class="translated" id="index-29">Estos representan un conjunto inmutable. Son creados por el  constructor incorporado <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-func docutils literal notranslate"><span class="pre">frozenset()</span></code></a>. Como un conjunto congelado es inmutable y <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a>, se puede usar nuevamente como un elemento de otro conjunto o como una clave de un diccionario.</p>
</dd>
</dl>
</section>
<section id="mappings">
<h3 class="translated"><span class="section-number">3.2.7. </span>Mapeos<a class="headerlink" href="#mappings" title="Link to this heading">¶</a></h3>
<p class="translated" id="index-30">Estos representan conjuntos finitos de objetos indexados por conjuntos de índices arbitrarios. La notación de subíndice <code class="docutils literal notranslate"><span class="pre">a[k]</span></code> selecciona el elemento indexado por <code class="docutils literal notranslate"><span class="pre">k</span></code> del mapeo <code class="docutils literal notranslate"><span class="pre">a</span></code>; esto se puede usar en expresiones y como el objetivo de asignaciones o declaraciones <a class="reference internal" href="simple_stmts.html#del"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">del</span></code></a>. La función incorporada <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> retorna el número de elementos en un mapeo.</p>
<p class="translated">Actualmente hay un único tipo de mapeo intrínseco:</p>
<section id="dictionaries">
<h4 class="translated"><span class="section-number">3.2.7.1. </span>Diccionarios<a class="headerlink" href="#dictionaries" title="Link to this heading">¶</a></h4>
<p class="translated" id="index-31">Estos representan conjuntos finitos de objetos indexados por valores casi arbitrarios. Los únicos tipos de valores no aceptables como claves son valores que contienen listas o diccionarios u otros tipos mutables que se comparan por valor en lugar de por identidad de objeto, la razón es que la implementación eficiente de los diccionarios requiere que el valor <em>hash</em> de una clave permanezca constante. Los tipos numéricos utilizados para las claves obedecen las reglas normales para la comparación numérica: si dos números se comparan igual (por ejemplo, <code class="docutils literal notranslate"><span class="pre">1</span></code> y <code class="docutils literal notranslate"><span class="pre">1.0</span></code>) entonces se pueden usar indistintamente para indexar la misma entrada del diccionario.</p>
<p class="translated">Los diccionarios conservan el orden de inserción, lo que significa que las claves se mantendrán en el mismo orden en que se agregaron secuencialmente sobre el diccionario. Reemplazar una clave existente no cambia el orden, sin embargo, eliminar una clave y volver a insertarla la agregará al final en lugar de mantener su lugar anterior.</p>
<p class="untranslated">Dictionaries are mutable; they can be created by the <code class="docutils literal notranslate"><span class="pre">{}</span></code> notation (see
section <a class="reference internal" href="expressions.html#dict"><span class="std std-ref">Despliegues de diccionario</span></a>).</p>
<p class="translated" id="index-32">Los módulos de extensión <a class="reference internal" href="../library/dbm.html#module-dbm.ndbm" title="dbm.ndbm: The New Database Manager (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.ndbm</span></code></a> y <a class="reference internal" href="../library/dbm.html#module-dbm.gnu" title="dbm.gnu: GNU database manager (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dbm.gnu</span></code></a> proporcionan ejemplos adicionales de tipos de mapeo, al igual que el módulo <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Los diccionarios no conservaban el orden de inserción en las versiones de Python anteriores a 3.6. En CPython 3.6, el orden de inserción se conserva, pero se consideró un detalle de implementación en ese momento en lugar de una garantía de idioma.</p>
</div>
</section>
</section>
<section id="callable-types">
<h3 class="translated"><span class="section-number">3.2.8. </span>Tipos invocables<a class="headerlink" href="#callable-types" title="Link to this heading">¶</a></h3>
<p class="translated" id="index-33">Estos son los tipos a los que la operación de llamada de función (vea la sección <a class="reference internal" href="expressions.html#calls"><span class="std std-ref">Invocaciones</span></a>) puede ser aplicado:</p>
<section id="user-defined-functions">
<span id="user-defined-funcs"></span><h4 class="translated"><span class="section-number">3.2.8.1. </span>Funciones definidas por el usuario<a class="headerlink" href="#user-defined-functions" title="Link to this heading">¶</a></h4>
<p class="translated" id="index-34">Un objeto función definido por el usuario, es creado por un definición de función (vea la sección <a class="reference internal" href="compound_stmts.html#function"><span class="std std-ref">Definiciones de funciones</span></a>). Debe llamarse con una lista de argumentos que contenga el mismo número de elementos que la lista de parámetros formales de la función.</p>
<section id="special-read-only-attributes">
<h5 class="untranslated"><span class="section-number">3.2.8.1.1. </span>Special read-only attributes<a class="headerlink" href="#special-read-only-attributes" title="Link to this heading">¶</a></h5>
<table class="docutils align-default" id="index-35">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Atributo</p></th>
<th class="head"><p class="translated">Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__globals__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__globals__</span></span><a class="headerlink" href="#function.__globals__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A reference to the <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a> that holds the function’s
<a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">global variables</span></a> – the global namespace of the module
in which the function was defined.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__closure__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__closure__</span></span><a class="headerlink" href="#function.__closure__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated"><code class="docutils literal notranslate"><span class="pre">None</span></code> or a <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of cells that contain bindings for the names specified
in the <a class="reference internal" href="#codeobject.co_freevars" title="codeobject.co_freevars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_freevars</span></code></a> attribute of the function’s
<a class="reference internal" href="#function.__code__" title="function.__code__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">code</span> <span class="pre">object</span></code></a>.</p>
<p class="translated">Un objeto de celda tiene el atributo <code class="docutils literal notranslate"><span class="pre">cell_contents</span></code>. Esto se puede usar para obtener el valor de la celda, así como para establecer el valor.</p>
</td>
</tr>
</tbody>
</table>
</section>
<section id="special-writable-attributes">
<h5 class="untranslated"><span class="section-number">3.2.8.1.2. </span>Special writable attributes<a class="headerlink" href="#special-writable-attributes" title="Link to this heading">¶</a></h5>
<p class="untranslated" id="index-36">Most of these attributes check the type of the assigned value:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Atributo</p></th>
<th class="head"><p class="translated">Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__doc__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__doc__</span></span><a class="headerlink" href="#function.__doc__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The function’s documentation string, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if unavailable.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__name__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#function.__name__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The function’s name.
See also: <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span> <span class="pre">attributes</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__qualname__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__qualname__</span></span><a class="headerlink" href="#function.__qualname__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The function’s <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">qualified name</span></a>.
See also: <a class="reference internal" href="../library/stdtypes.html#definition.__qualname__" title="definition.__qualname__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__qualname__</span> <span class="pre">attributes</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.3.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__module__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__module__</span></span><a class="headerlink" href="#function.__module__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">El nombre del módulo en el que se definió la función, o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no está disponible.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__defaults__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__defaults__</span></span><a class="headerlink" href="#function.__defaults__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing default <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameter</span></a> values
for those parameters that have defaults,
or <code class="docutils literal notranslate"><span class="pre">None</span></code> if no parameters have a default value.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__code__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__code__</span></span><a class="headerlink" href="#function.__code__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The <a class="reference internal" href="#code-objects"><span class="std std-ref">code object</span></a> representing
the compiled function body.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__dict__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__dict__</span></span><a class="headerlink" href="#function.__dict__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The namespace supporting arbitrary function attributes.
See also: <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span> <span class="pre">attributes</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__annotations__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__annotations__</span></span><a class="headerlink" href="#function.__annotations__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a> containing annotations of
<a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameters</span></a>.
The keys of the dictionary are the parameter names,
and <code class="docutils literal notranslate"><span class="pre">'return'</span></code> for the return annotation, if provided.
See also: <a class="reference internal" href="#object.__annotations__" title="object.__annotations__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">object.__annotations__</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.14: </span>Annotations are now <a class="reference internal" href="executionmodel.html#lazy-evaluation"><span class="std std-ref">lazily evaluated</span></a>.
See <span class="target" id="index-37"></span><a class="pep reference external" href="https://peps.python.org/pep-0649/"><strong>PEP 649</strong></a>.</p>
</div>
</td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__annotate__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__annotate__</span></span><a class="headerlink" href="#function.__annotate__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The <a class="reference internal" href="../glossary.html#term-annotate-function"><span class="xref std std-term">annotate function</span></a> for this function, or <code class="docutils literal notranslate"><span class="pre">None</span></code>
if the function has no annotations. See <a class="reference internal" href="#object.__annotate__" title="object.__annotate__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">object.__annotate__</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__kwdefaults__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__kwdefaults__</span></span><a class="headerlink" href="#function.__kwdefaults__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a> containing defaults for keyword-only
<a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameters</span></a>.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="function.__type_params__">
<span class="sig-prename descclassname"><span class="pre">function.</span></span><span class="sig-name descname"><span class="pre">__type_params__</span></span><a class="headerlink" href="#function.__type_params__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the <a class="reference internal" href="compound_stmts.html#type-params"><span class="std std-ref">type parameters</span></a> of
a <a class="reference internal" href="compound_stmts.html#generic-functions"><span class="std std-ref">generic function</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</td>
</tr>
</tbody>
</table>
<p class="untranslated">Function objects also support getting and setting arbitrary attributes, which
can be used, for example, to attach metadata to functions.  Regular attribute
dot-notation is used to get and set such attributes.</p>
<div class="impl-detail compound">
<p class="untranslated"><strong>Detalles de implementación de CPython:</strong> CPython’s current implementation only supports function attributes
on user-defined functions. Function attributes on
<a class="reference internal" href="#builtin-functions"><span class="std std-ref">built-in functions</span></a> may be supported in the
future.</p>
</div>
<p class="untranslated">Additional information about a function’s definition can be retrieved from its
<a class="reference internal" href="#code-objects"><span class="std std-ref">code object</span></a>
(accessible via the <a class="reference internal" href="#function.__code__" title="function.__code__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__code__</span></code></a> attribute).</p>
</section>
</section>
<section id="instance-methods">
<span id="id2"></span><h4 class="translated"><span class="section-number">3.2.8.2. </span>Métodos de instancia<a class="headerlink" href="#instance-methods" title="Link to this heading">¶</a></h4>
<p class="translated" id="index-38">Un objeto de método de instancia combina una clase, una instancia de clase y cualquier objeto invocable (normalmente una función definida por el usuario).</p>
<p class="untranslated" id="index-39">Special read-only attributes:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="method.__self__">
<span class="sig-prename descclassname"><span class="pre">method.</span></span><span class="sig-name descname"><span class="pre">__self__</span></span><a class="headerlink" href="#method.__self__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">Refers to the class instance object to which the method is
<a class="reference internal" href="#method-binding"><span class="std std-ref">bound</span></a></p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="method.__func__">
<span class="sig-prename descclassname"><span class="pre">method.</span></span><span class="sig-name descname"><span class="pre">__func__</span></span><a class="headerlink" href="#method.__func__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">Refers to the original <a class="reference internal" href="#user-defined-funcs"><span class="std std-ref">function object</span></a></p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="method.__doc__">
<span class="sig-prename descclassname"><span class="pre">method.</span></span><span class="sig-name descname"><span class="pre">__doc__</span></span><a class="headerlink" href="#method.__doc__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The method’s documentation
(same as <a class="reference internal" href="#function.__doc__" title="function.__doc__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method.__func__.__doc__</span></code></a>).
A <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">string</span></code></a> if the original function had a docstring, else
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="method.__name__">
<span class="sig-prename descclassname"><span class="pre">method.</span></span><span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#method.__name__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The name of the method
(same as <a class="reference internal" href="#function.__name__" title="function.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method.__func__.__name__</span></code></a>)</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="method.__module__">
<span class="sig-prename descclassname"><span class="pre">method.</span></span><span class="sig-name descname"><span class="pre">__module__</span></span><a class="headerlink" href="#method.__module__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The name of the module the method was defined in, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if
unavailable.</p></td>
</tr>
</tbody>
</table>
<p class="untranslated">Methods also support accessing (but not setting) the arbitrary function
attributes on the underlying <a class="reference internal" href="#user-defined-funcs"><span class="std std-ref">function object</span></a>.</p>
<p class="untranslated">User-defined method objects may be created when getting an attribute of a
class (perhaps via an instance of that class), if that attribute is a
user-defined <a class="reference internal" href="#user-defined-funcs"><span class="std std-ref">function object</span></a> or a
<a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a> object.</p>
<p class="untranslated" id="method-binding">When an instance method object is created by retrieving a user-defined
<a class="reference internal" href="#user-defined-funcs"><span class="std std-ref">function object</span></a> from a class via one of its
instances, its <a class="reference internal" href="#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a> attribute is the instance, and the
method object is said to be <em>bound</em>.  The new method’s <a class="reference internal" href="#method.__func__" title="method.__func__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code></a>
attribute is the original function object.</p>
<p class="untranslated">When an instance method object is created by retrieving a <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a>
object from a class or instance, its <a class="reference internal" href="#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a> attribute is the
class itself, and its <a class="reference internal" href="#method.__func__" title="method.__func__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code></a> attribute is the function object
underlying the class method.</p>
<p class="untranslated">When an instance method object is called, the underlying function
(<a class="reference internal" href="#method.__func__" title="method.__func__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code></a>) is called, inserting the class instance
(<a class="reference internal" href="#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a>) in front of the argument list.  For instance, when
<code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> is a class which contains a definition for a function
<code class="xref py py-meth docutils literal notranslate"><span class="pre">f()</span></code>, and <code class="docutils literal notranslate"><span class="pre">x</span></code> is an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, calling <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> is
equivalent to calling <code class="docutils literal notranslate"><span class="pre">C.f(x,</span> <span class="pre">1)</span></code>.</p>
<p class="untranslated">When an instance method object is derived from a <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></a> object, the
«class instance» stored in <a class="reference internal" href="#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a> will actually be the class
itself, so that calling either <code class="docutils literal notranslate"><span class="pre">x.f(1)</span></code> or <code class="docutils literal notranslate"><span class="pre">C.f(1)</span></code> is equivalent to
calling <code class="docutils literal notranslate"><span class="pre">f(C,1)</span></code> where <code class="docutils literal notranslate"><span class="pre">f</span></code> is the underlying function.</p>
<p class="untranslated">It is important to note that user-defined functions
which are attributes of a class instance are not converted to bound
methods; this <em>only</em> happens when the function is an attribute of the
class.</p>
</section>
<section id="generator-functions">
<h4 class="translated"><span class="section-number">3.2.8.3. </span>Funciones generadoras<a class="headerlink" href="#generator-functions" title="Link to this heading">¶</a></h4>
<p class="translated" id="index-40">Una función o método que utiliza la instrucción <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> (consulte la sección <a class="reference internal" href="simple_stmts.html#yield"><span class="std std-ref">La declaración yield</span></a>) se denomina <em class="dfn">función generadora</em>. Una función de este tipo, cuando se llama, siempre retorna un objeto <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> que se puede usar para ejecutar el cuerpo de la función: llamar al método <a class="reference internal" href="../library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterator.__next__()</span></code></a> del iterador hará que la función se ejecute hasta que proporcione un valor usando la instrucción <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code>. Cuando la función ejecuta una instrucción <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> o se sale del final, se genera una excepción <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> y el iterador habrá llegado al final del conjunto de valores que se retornarán.</p>
</section>
<section id="coroutine-functions">
<h4 class="translated"><span class="section-number">3.2.8.4. </span>Funciones de corrutina<a class="headerlink" href="#coroutine-functions" title="Link to this heading">¶</a></h4>
<p class="translated" id="index-41">Una función o método que es definido utilizando <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> se llama <em class="dfn">coroutine function</em>.  Dicha función, cuando es invocada, retorna un objeto <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a>.  Éste puede contener expresiones <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>, así como declaraciones <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> y <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>. Ver también la sección <a class="reference internal" href="#coroutine-objects"><span class="std std-ref">Objetos de corrutina</span></a>.</p>
</section>
<section id="asynchronous-generator-functions">
<h4 class="translated"><span class="section-number">3.2.8.5. </span>Funciones generadoras asincrónicas<a class="headerlink" href="#asynchronous-generator-functions" title="Link to this heading">¶</a></h4>
<p class="translated" id="index-42">Una función o método que se define usando <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> y que usa la declaración <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> se llama <em class="dfn">función generadora asíncrona</em>. Una función de este tipo, cuando se llama, retorna un objeto <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> que se puede utilizar en una instrucción <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> para ejecutar el cuerpo de la función.</p>
<p class="translated">Llamar al método <a class="reference internal" href="#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aiterator.__anext__</span></code></a> del iterador asíncrono retornará un <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> que, cuando se espere, se ejecutará hasta que proporcione un valor utilizando la expresión <a class="reference internal" href="simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>. Cuando la función ejecuta una instrucción <a class="reference internal" href="simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> vacía o se sale del final, se genera una excepción <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> y el iterador asincrónico habrá llegado al final del conjunto de valores que se generarán.</p>
</section>
<section id="built-in-functions">
<span id="builtin-functions"></span><h4 class="translated"><span class="section-number">3.2.8.6. </span>Funciones incorporadas<a class="headerlink" href="#built-in-functions" title="Link to this heading">¶</a></h4>
<p class="untranslated" id="index-43">A built-in function object is a wrapper around a C function.  Examples of
built-in functions are <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> and <a class="reference internal" href="../library/math.html#math.sin" title="math.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.sin()</span></code></a> (<a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> is a
standard built-in module). The number and type of the arguments are
determined by the C function. Special read-only attributes:</p>
<ul class="simple">
<li><p class="untranslated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code> is the function’s documentation string, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if
unavailable. See <a class="reference internal" href="#function.__doc__" title="function.__doc__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">function.__doc__</span></code></a>.</p></li>
<li><p class="untranslated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code> is the function’s name. See <a class="reference internal" href="#function.__name__" title="function.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">function.__name__</span></code></a>.</p></li>
<li><p class="untranslated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> is set to <code class="docutils literal notranslate"><span class="pre">None</span></code> (but see the next item).</p></li>
<li><p class="untranslated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code> is the name of
the module the function was defined in or <code class="docutils literal notranslate"><span class="pre">None</span></code> if unavailable.
See <a class="reference internal" href="#function.__module__" title="function.__module__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">function.__module__</span></code></a>.</p></li>
</ul>
</section>
<section id="built-in-methods">
<span id="builtin-methods"></span><h4 class="translated"><span class="section-number">3.2.8.7. </span>Métodos incorporados<a class="headerlink" href="#built-in-methods" title="Link to this heading">¶</a></h4>
<p class="untranslated" id="index-44">This is really a different disguise of a built-in function, this time containing
an object passed to the C function as an implicit extra argument.  An example of
a built-in method is <code class="docutils literal notranslate"><span class="pre">alist.append()</span></code>, assuming <em>alist</em> is a list object. In
this case, the special read-only attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code> is set to the object
denoted by <em>alist</em>. (The attribute has the same semantics as it does with
<a class="reference internal" href="#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">other</span> <span class="pre">instance</span> <span class="pre">methods</span></code></a>.)</p>
</section>
<section id="classes">
<span id="id3"></span><h4 class="translated"><span class="section-number">3.2.8.8. </span>Clases<a class="headerlink" href="#classes" title="Link to this heading">¶</a></h4>
<p class="untranslated">Classes are callable.  These objects normally act as factories for new
instances of themselves, but variations are possible for class types that
override <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a>.  The arguments of the call are passed to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code> and, in the typical case, to <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> to
initialize the new instance.</p>
</section>
<section id="class-instances">
<h4 class="translated"><span class="section-number">3.2.8.9. </span>Instancias de clases<a class="headerlink" href="#class-instances" title="Link to this heading">¶</a></h4>
<p class="translated">Las instancias de clases arbitrarias se pueden hacer invocables definiendo un método <a class="reference internal" href="#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> en su clase.</p>
</section>
</section>
<section id="modules">
<span id="module-objects"></span><h3 class="translated"><span class="section-number">3.2.9. </span>Módulos<a class="headerlink" href="#modules" title="Link to this heading">¶</a></h3>
<p class="untranslated" id="index-45">Modules are a basic organizational unit of Python code, and are created by
the <a class="reference internal" href="import.html#importsystem"><span class="std std-ref">import system</span></a> as invoked either by the
<a class="reference internal" href="simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> statement, or by calling
functions such as <a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.import_module()</span></code></a> and built-in
<a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a>.  A module object has a namespace implemented by a
<a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a> object (this is the dictionary referenced by the
<a class="reference internal" href="#function.__globals__" title="function.__globals__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__globals__</span></code></a>
attribute of functions defined in the module).  Attribute references are
translated to lookups in this dictionary, e.g., <code class="docutils literal notranslate"><span class="pre">m.x</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">m.__dict__[&quot;x&quot;]</span></code>. A module object does not contain the code object used
to initialize the module (since it isn’t needed once the initialization is
done).</p>
<p class="translated">La asignación de atributos actualiza el diccionario de espacio de nombres del módulo, p. ej., <code class="docutils literal notranslate"><span class="pre">m.x</span> <span class="pre">=</span> <span class="pre">1</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">m.__dict__[“x”]</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
<section id="import-related-attributes-on-module-objects">
<span id="import-mod-attrs"></span><span id="index-46"></span><h4 class="untranslated"><span class="section-number">3.2.9.1. </span>Import-related attributes on module objects<a class="headerlink" href="#import-related-attributes-on-module-objects" title="Link to this heading">¶</a></h4>
<p class="untranslated">Module objects have the following attributes that relate to the
<a class="reference internal" href="import.html#importsystem"><span class="std std-ref">import system</span></a>. When a module is created using the machinery associated
with the import system, these attributes are filled in based on the module’s
<a class="reference internal" href="../glossary.html#term-module-spec"><span class="xref std std-term">spec</span></a>, before the <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> executes and loads the
module.</p>
<p class="untranslated">To create a module dynamically rather than using the import system,
it’s recommended to use <a class="reference internal" href="../library/importlib.html#importlib.util.module_from_spec" title="importlib.util.module_from_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_from_spec()</span></code></a>,
which will set the various import-controlled attributes to appropriate values.
It’s also possible to use the <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> constructor to create
modules directly, but this technique is more error-prone, as most attributes
must be manually set on the module object after it has been created when using
this approach.</p>
<div class="admonition caution">
<p class="admonition-title">Prudencia</p>
<p class="untranslated">With the exception of <a class="reference internal" href="#module.__name__" title="module.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a>, it is <strong>strongly</strong>
recommended that you rely on <a class="reference internal" href="#module.__spec__" title="module.__spec__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__</span></code></a> and its attributes
instead of any of the other individual attributes listed in this subsection.
Note that updating an attribute on <code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__</span></code> will not update the
corresponding attribute on the module itself:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">typing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typing</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">name</span>
<span class="go">(&#39;typing&#39;, &#39;typing&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typing</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;spelling&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typing</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">name</span>
<span class="go">(&#39;typing&#39;, &#39;spelling&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typing</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s1">&#39;keyboard_smashing&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">typing</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">typing</span><span class="o">.</span><span class="n">__spec__</span><span class="o">.</span><span class="n">name</span>
<span class="go">(&#39;keyboard_smashing&#39;, &#39;spelling&#39;)</span>
</pre></div>
</div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="module.__name__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#module.__name__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The name used to uniquely identify the module in the import system.
For a directly executed module, this will be set to <code class="docutils literal notranslate"><span class="pre">&quot;__main__&quot;</span></code>.</p>
<p class="untranslated">This attribute must be set to the fully qualified name of the module.
It is expected to match the value of
<a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec.name" title="importlib.machinery.ModuleSpec.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__spec__.name</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="module.__spec__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__spec__</span></span><a class="headerlink" href="#module.__spec__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A record of the module’s import-system-related state.</p>
<p class="untranslated">Set to the <a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">module</span> <span class="pre">spec</span></code></a> that was
used when importing the module. See <a class="reference internal" href="import.html#module-specs"><span class="std std-ref">Module specs</span></a> for more details.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="module.__package__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__package__</span></span><a class="headerlink" href="#module.__package__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The <a class="reference internal" href="../glossary.html#term-package"><span class="xref std std-term">package</span></a> a module belongs to.</p>
<p class="untranslated">If the module is top-level (that is, not a part of any specific package)
then the attribute should be set to <code class="docutils literal notranslate"><span class="pre">''</span></code> (the empty string). Otherwise,
it should be set to the name of the module’s package (which can be equal to
<a class="reference internal" href="#module.__name__" title="module.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__name__</span></code></a> if the module itself is a package). See <span class="target" id="index-47"></span><a class="pep reference external" href="https://peps.python.org/pep-0366/"><strong>PEP 366</strong></a>
for further details.</p>
<p class="untranslated">This attribute is used instead of <a class="reference internal" href="#module.__name__" title="module.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> to calculate
explicit relative imports for main modules. It defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code> for
modules created dynamically using the <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> constructor;
use <a class="reference internal" href="../library/importlib.html#importlib.util.module_from_spec" title="importlib.util.module_from_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_from_spec()</span></code></a> instead to ensure the attribute
is set to a <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
<p class="untranslated">It is <strong>strongly</strong> recommended that you use
<a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec.parent" title="importlib.machinery.ModuleSpec.parent"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__spec__.parent</span></code></a>
instead of <code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__package__</span></code>. <a class="reference internal" href="#module.__package__" title="module.__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> is now only used
as a fallback if <code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__.parent</span></code> is not set, and this fallback
path is deprecated.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>This attribute now defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code> for modules created dynamically
using the <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> constructor.
Previously the attribute was optional.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.6: </span>The value of <code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code> is expected to be the same as
<a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec.parent" title="importlib.machinery.ModuleSpec.parent"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__.parent</span></code></a>.
<a class="reference internal" href="#module.__package__" title="module.__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> is now only used as a fallback during import
resolution if <code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__.parent</span></code> is not defined.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.10: </span><a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a> is raised if an import resolution falls back to
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code> instead of
<a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec.parent" title="importlib.machinery.ModuleSpec.parent"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__.parent</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>Raise <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> instead of <a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a> when
falling back to <code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code> during import resolution.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified removed">Deprecated since version 3.13, removed in version 3.15: </span><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code> will cease to be set or taken into consideration
by the import system or standard library.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="module.__loader__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__loader__</span></span><a class="headerlink" href="#module.__loader__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> object that the import machinery used to load the module.</p>
<p class="untranslated">This attribute is mostly useful for introspection, but can be used for
additional loader-specific functionality, for example getting data
associated with a loader.</p>
<p class="untranslated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code> defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code> for modules created dynamically
using the <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> constructor;
use <a class="reference internal" href="../library/importlib.html#importlib.util.module_from_spec" title="importlib.util.module_from_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_from_spec()</span></code></a> instead to ensure the attribute
is set to a <a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> object.</p>
<p class="untranslated">It is <strong>strongly</strong> recommended that you use
<a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec.loader" title="importlib.machinery.ModuleSpec.loader"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__spec__.loader</span></code></a>
instead of <code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__loader__</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>This attribute now defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code> for modules created dynamically
using the <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a> constructor.
Previously the attribute was optional.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.16: </span>Setting <code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code> on a module while failing to set
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__.loader</span></code> is deprecated. In Python 3.16,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code> will cease to be set or taken into consideration by
the import system or the standard library.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="module.__path__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__path__</span></span><a class="headerlink" href="#module.__path__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A (possibly empty) <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a> of strings enumerating the locations
where the package’s submodules will be found. Non-package modules should
not have a <code class="xref py py-attr docutils literal notranslate"><span class="pre">__path__</span></code> attribute. See <a class="reference internal" href="import.html#package-path-rules"><span class="std std-ref">__path__ attributes on modules</span></a> for
more details.</p>
<p class="untranslated">It is <strong>strongly</strong> recommended that you use
<a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec.submodule_search_locations" title="importlib.machinery.ModuleSpec.submodule_search_locations"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__spec__.submodule_search_locations</span></code></a>
instead of <code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__path__</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="module.__file__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__file__</span></span><a class="headerlink" href="#module.__file__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="module.__cached__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__cached__</span></span><a class="headerlink" href="#module.__cached__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code> are both optional attributes that
may or may not be set. Both attributes should be a <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> when they
are available.</p>
<p class="untranslated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code> indicates the pathname of the file from which the module
was loaded (if loaded from a file), or the pathname of the shared library
file for extension modules loaded dynamically from a shared library.
It might be missing for certain types of modules, such as C modules that are
statically linked into the interpreter, and the
<a class="reference internal" href="import.html#importsystem"><span class="std std-ref">import system</span></a> may opt to leave it unset if it
has no semantic meaning (for example, a module loaded from a database).</p>
<p class="untranslated">If <code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code> is set then the <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code> attribute might
also be set,  which is the path to any compiled version of
the code (for example, a byte-compiled file). The file does not need to exist
to set this attribute; the path can simply point to where the
compiled file <em>would</em> exist (see <span class="target" id="index-48"></span><a class="pep reference external" href="https://peps.python.org/pep-3147/"><strong>PEP 3147</strong></a>).</p>
<p class="untranslated">Note that <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code> may be set even if <code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code> is not
set.  However, that scenario is quite atypical.  Ultimately, the
<a class="reference internal" href="../glossary.html#term-loader"><span class="xref std std-term">loader</span></a> is what makes use of the module spec provided by the
<a class="reference internal" href="../glossary.html#term-finder"><span class="xref std std-term">finder</span></a> (from which <code class="xref py py-attr docutils literal notranslate"><span class="pre">__file__</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code> are
derived).  So if a loader can load from a cached module but otherwise does
not load from a file, that atypical scenario may be appropriate.</p>
<p class="untranslated">It is <strong>strongly</strong> recommended that you use
<a class="reference internal" href="../library/importlib.html#importlib.machinery.ModuleSpec.cached" title="importlib.machinery.ModuleSpec.cached"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__spec__.cached</span></code></a>
instead of <code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__cached__</span></code>.</p>
<div class="deprecated-removed">
<p><span class="versionmodified removed">Deprecated since version 3.13, removed in version 3.15: </span>Setting <code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code> on a module while failing to set
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__spec__.cached</span></code> is deprecated. In Python 3.15,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__cached__</span></code> will cease to be set or taken into consideration by
the import system or standard library.</p>
</div>
</dd></dl>

</section>
<section id="other-writable-attributes-on-module-objects">
<h4 class="untranslated"><span class="section-number">3.2.9.2. </span>Other writable attributes on module objects<a class="headerlink" href="#other-writable-attributes-on-module-objects" title="Link to this heading">¶</a></h4>
<p class="untranslated">As well as the import-related attributes listed above, module objects also have
the following writable attributes:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="module.__doc__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__doc__</span></span><a class="headerlink" href="#module.__doc__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The module’s documentation string, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if unavailable.
See also: <a class="reference internal" href="../library/stdtypes.html#definition.__doc__" title="definition.__doc__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span> <span class="pre">attributes</span></code></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="module.__annotations__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__annotations__</span></span><a class="headerlink" href="#module.__annotations__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A dictionary containing <a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">variable annotations</span></a>
collected during module body execution.  For best practices on working with
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code>, see <a class="reference internal" href="../library/annotationlib.html#module-annotationlib" title="annotationlib: Functionality for introspecting annotations"><code class="xref py py-mod docutils literal notranslate"><span class="pre">annotationlib</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.14: </span>Annotations are now <a class="reference internal" href="executionmodel.html#lazy-evaluation"><span class="std std-ref">lazily evaluated</span></a>.
See <span class="target" id="index-49"></span><a class="pep reference external" href="https://peps.python.org/pep-0649/"><strong>PEP 649</strong></a>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="module.__annotate__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__annotate__</span></span><a class="headerlink" href="#module.__annotate__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The <a class="reference internal" href="../glossary.html#term-annotate-function"><span class="xref std std-term">annotate function</span></a> for this module, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if the module has
no annotations. See also: <a class="reference internal" href="#object.__annotate__" title="object.__annotate__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotate__</span></code></a> attributes.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

</section>
<section id="module-dictionaries">
<h4 class="untranslated"><span class="section-number">3.2.9.3. </span>Module dictionaries<a class="headerlink" href="#module-dictionaries" title="Link to this heading">¶</a></h4>
<p class="untranslated">Module objects also have the following special read-only attribute:</p>
<dl class="py attribute" id="index-50">
<dt class="sig sig-object py" id="module.__dict__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__dict__</span></span><a class="headerlink" href="#module.__dict__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The module’s namespace as a dictionary object. Uniquely among the attributes
listed here, <code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code> cannot be accessed as a global variable from
within a module; it can only be accessed as an attribute on module objects.</p>
<div class="impl-detail compound">
<p class="translated">Debido a la manera en la que CPython limpia los diccionarios de módulo, el diccionario de módulo será limpiado cuando el módulo se encuentra fuera de alcance, incluso si el diccionario aún tiene referencias existentes.  Para evitar esto, copie el diccionario o mantenga el módulo cerca mientras usa el diccionario directamente.</p>
</div>
</dd></dl>

</section>
</section>
<section id="custom-classes">
<span id="class-attrs-and-methods"></span><h3 class="translated"><span class="section-number">3.2.10. </span>Clases personalizadas<a class="headerlink" href="#custom-classes" title="Link to this heading">¶</a></h3>
<p class="untranslated">Custom class types are typically created by class definitions (see section
<a class="reference internal" href="compound_stmts.html#class"><span class="std std-ref">Definiciones de clase</span></a>).  A class has a namespace implemented by a dictionary object.
Class attribute references are translated to lookups in this dictionary, e.g.,
<code class="docutils literal notranslate"><span class="pre">C.x</span></code> is translated to <code class="docutils literal notranslate"><span class="pre">C.__dict__[&quot;x&quot;]</span></code> (although there are a number of
hooks which allow for other means of locating attributes). When the attribute
name is not found there, the attribute search continues in the base classes.
This search of the base classes uses the C3 method resolution order which
behaves correctly even in the presence of “diamond” inheritance structures
where there are multiple inheritance paths leading back to a common ancestor.
Additional details on the C3 MRO used by Python can be found at
<a class="reference internal" href="../howto/mro.html#python-2-3-mro"><span class="std std-ref">The Python 2.3 Method Resolution Order</span></a>.</p>
<p class="untranslated" id="index-51">When a class attribute reference (for class <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, say) would yield a
class method object, it is transformed into an instance method object whose
<a class="reference internal" href="#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a> attribute is <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>.
When it would yield a <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">staticmethod</span></code></a> object,
it is transformed into the object wrapped by the static method
object. See section <a class="reference internal" href="#descriptors"><span class="std std-ref">Implementando descriptores</span></a> for another way in which attributes
retrieved from a class may differ from those actually contained in its
<a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>.</p>
<p class="translated" id="index-52">Las asignaciones de atributos de clase actualizan el diccionario de la clase, nunca el diccionario de la clase base.</p>
<p class="translated" id="index-53">Un objeto de clase puede ser invocado (ver arriba) para producir una instancia de clase (ver a continuación).</p>
<section id="special-attributes">
<h4 class="untranslated"><span class="section-number">3.2.10.1. </span>Special attributes<a class="headerlink" href="#special-attributes" title="Link to this heading">¶</a></h4>
<table class="docutils align-default" id="index-54">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">Atributo</p></th>
<th class="head"><p class="translated">Significado</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__name__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__name__</span></span><a class="headerlink" href="#type.__name__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The class’s name.
See also: <a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span> <span class="pre">attributes</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__qualname__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__qualname__</span></span><a class="headerlink" href="#type.__qualname__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The class’s <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">qualified name</span></a>.
See also: <a class="reference internal" href="../library/stdtypes.html#definition.__qualname__" title="definition.__qualname__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__qualname__</span> <span class="pre">attributes</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__module__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__module__</span></span><a class="headerlink" href="#type.__module__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="translated">El nombre del módulo en el que se definió la clase.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__dict__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__dict__</span></span><a class="headerlink" href="#type.__dict__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A <a class="reference internal" href="../library/types.html#types.MappingProxyType" title="types.MappingProxyType"><code class="xref py py-class docutils literal notranslate"><span class="pre">mapping</span> <span class="pre">proxy</span></code></a>
providing a read-only view of the class’s namespace.
See also: <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span> <span class="pre">attributes</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__bases__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__bases__</span></span><a class="headerlink" href="#type.__bases__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the class’s bases.
In most cases, for a class defined as <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">X(A,</span> <span class="pre">B,</span> <span class="pre">C)</span></code>,
<code class="docutils literal notranslate"><span class="pre">X.__bases__</span></code> will be exactly equal to <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">B,</span> <span class="pre">C)</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__doc__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__doc__</span></span><a class="headerlink" href="#type.__doc__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The class’s documentation string, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if undefined.
Not inherited by subclasses.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__annotations__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__annotations__</span></span><a class="headerlink" href="#type.__annotations__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A dictionary containing
<a class="reference internal" href="../glossary.html#term-variable-annotation"><span class="xref std std-term">variable annotations</span></a>
collected during class body execution. See also:
<a class="reference internal" href="#object.__annotations__" title="object.__annotations__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span> <span class="pre">attributes</span></code></a>.</p>
<p class="untranslated">For best practices on working with <a class="reference internal" href="#object.__annotations__" title="object.__annotations__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></a>,
please see <a class="reference internal" href="../library/annotationlib.html#module-annotationlib" title="annotationlib: Functionality for introspecting annotations"><code class="xref py py-mod docutils literal notranslate"><span class="pre">annotationlib</span></code></a>. Use
<a class="reference internal" href="../library/annotationlib.html#annotationlib.get_annotations" title="annotationlib.get_annotations"><code class="xref py py-func docutils literal notranslate"><span class="pre">annotationlib.get_annotations()</span></code></a> instead of accessing this
attribute directly.</p>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p class="untranslated">Accessing the <code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code> attribute directly
on a class object may return annotations for the wrong class, specifically
in certain cases where the class, its base class, or a metaclass
is defined under <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code>.
See <span class="target" id="index-55"></span><a class="pep reference external" href="https://peps.python.org/pep-0749/#pep749-metaclasses"><strong>749</strong></a> for details.</p>
<p class="untranslated">This attribute does not exist on certain builtin classes. On
user-defined classes without <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code>, it is an
empty dictionary.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.14: </span>Annotations are now <a class="reference internal" href="executionmodel.html#lazy-evaluation"><span class="std std-ref">lazily evaluated</span></a>.
See <span class="target" id="index-56"></span><a class="pep reference external" href="https://peps.python.org/pep-0649/"><strong>PEP 649</strong></a>.</p>
</div>
</td>
</tr>
<tr class="row-odd"><td><dl class="py method">
<dt class="sig sig-object py" id="type.__annotate__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__annotate__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#type.__annotate__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The <a class="reference internal" href="../glossary.html#term-annotate-function"><span class="xref std std-term">annotate function</span></a> for this class, or <code class="docutils literal notranslate"><span class="pre">None</span></code>
if the class has no annotations.
See also: <a class="reference internal" href="#object.__annotate__" title="object.__annotate__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotate__</span> <span class="pre">attributes</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__type_params__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__type_params__</span></span><a class="headerlink" href="#type.__type_params__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the <a class="reference internal" href="compound_stmts.html#type-params"><span class="std std-ref">type parameters</span></a> of
a <a class="reference internal" href="compound_stmts.html#generic-classes"><span class="std std-ref">generic class</span></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__static_attributes__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__static_attributes__</span></span><a class="headerlink" href="#type.__static_attributes__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing names of attributes of this class which are
assigned through <code class="docutils literal notranslate"><span class="pre">self.X</span></code> from any function in its body.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__firstlineno__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__firstlineno__</span></span><a class="headerlink" href="#type.__firstlineno__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The line number of the first line of the class definition,
including decorators.
Setting the <a class="reference internal" href="#type.__module__" title="type.__module__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code></a> attribute removes the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">__firstlineno__</span></code> item from the type’s dictionary.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="type.__mro__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__mro__</span></span><a class="headerlink" href="#type.__mro__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of classes that are considered when looking for
base classes during method resolution.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="special-methods">
<h4 class="untranslated"><span class="section-number">3.2.10.2. </span>Special methods<a class="headerlink" href="#special-methods" title="Link to this heading">¶</a></h4>
<p class="untranslated">In addition to the special attributes described above, all Python classes also
have the following two methods available:</p>
<dl class="py method">
<dt class="sig sig-object py" id="type.mro">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">mro</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#type.mro" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">This method can be overridden by a metaclass to customize the method
resolution order for its instances.  It is called at class instantiation,
and its result is stored in <a class="reference internal" href="#type.__mro__" title="type.__mro__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__mro__</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="type.__subclasses__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__subclasses__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#type.__subclasses__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Each class keeps a list of weak references to its immediate subclasses. This
method returns a list of all those references still alive. The list is in
definition order. Example:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">:</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()</span>
<span class="go">[&lt;class &#39;B&#39;&gt;]</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="id4">
<h3 class="translated"><span class="section-number">3.2.11. </span>Instancias de clase<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h3>
<p class="untranslated" id="index-57">A class instance is created by calling a class object (see above).  A class
instance has a namespace implemented as a dictionary which is the first place
in which attribute references are searched.  When an attribute is not found
there, and the instance’s class has an attribute by that name, the search
continues with the class attributes.  If a class attribute is found that is a
user-defined function object, it is transformed into an instance method
object whose <a class="reference internal" href="#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a> attribute is the instance.  Static method and
class method objects are also transformed; see above under «Classes».  See
section <a class="reference internal" href="#descriptors"><span class="std std-ref">Implementando descriptores</span></a> for another way in which attributes of a class
retrieved via its instances may differ from the objects actually stored in
the class’s <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>.  If no class attribute is found, and the
object’s class has a <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> method, that is called to satisfy
the lookup.</p>
<p class="translated" id="index-58">Las asignaciones y eliminaciones de atributos actualizan el diccionario de la instancia, nunca el diccionario de una clase. Si la clase tiene un método <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> o <a class="reference internal" href="#object.__delattr__" title="object.__delattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delattr__()</span></code></a>, se llama a este en lugar de actualizar el diccionario de instancia directamente.</p>
<p class="translated" id="index-59">Instancias de clases pueden pretender ser números, secuencias o mapeos si tienen métodos con ciertos nombres especiales.  Ver sección <a class="reference internal" href="#specialnames"><span class="std std-ref">Nombres especiales de método</span></a>.</p>
<section id="id5">
<h4 class="untranslated"><span class="section-number">3.2.11.1. </span>Special attributes<a class="headerlink" href="#id5" title="Link to this heading">¶</a></h4>
<dl class="py attribute" id="index-60">
<dt class="sig sig-object py" id="object.__class__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__class__</span></span><a class="headerlink" href="#object.__class__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The class to which a class instance belongs.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="object.__dict__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__dict__</span></span><a class="headerlink" href="#object.__dict__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">A dictionary or other mapping object used to store an object’s (writable)
attributes. Not all instances have a <code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code> attribute; see the
section on <a class="reference internal" href="#slots"><span class="std std-ref">__slots__</span></a> for more details.</p>
</dd></dl>

</section>
</section>
<section id="i-o-objects-also-known-as-file-objects">
<h3 class="translated"><span class="section-number">3.2.12. </span>Objetos E/S (también conocidos como objetos de archivo)<a class="headerlink" href="#i-o-objects-also-known-as-file-objects" title="Link to this heading">¶</a></h3>
<p class="translated" id="index-61">Un <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> representa un archivo abierto.  Diversos accesos directos se encuentran disponibles para crear objetos de archivo: la función incorporada <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>, así como <a class="reference internal" href="../library/os.html#os.popen" title="os.popen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.popen()</span></code></a>, <a class="reference internal" href="../library/os.html#os.fdopen" title="os.fdopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fdopen()</span></code></a>, y el método de objetos socket <code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code> (y quizás por otras funciones y métodos proporcionados por módulos de extensión).</p>
<p class="translated">Los objetos <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> y <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> son iniciados a objetos de archivos correspondientes a la entrada y salida estándar del intérprete, así como flujos de error; todos ellos están abiertos en el modo de texto y por lo tanto siguen la interface definida por la clase abstracta <a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a>.</p>
</section>
<section id="internal-types">
<h3 class="translated"><span class="section-number">3.2.13. </span>Tipos internos<a class="headerlink" href="#internal-types" title="Link to this heading">¶</a></h3>
<p class="translated" id="index-62">Algunos tipos utilizados internamente por el intérprete son expuestos al usuario. Sus definiciones pueden cambiar en futuras versiones del intérprete, pero son mencionadas aquí para complementar.</p>
<section id="code-objects">
<span id="id6"></span><h4 class="translated"><span class="section-number">3.2.13.1. </span>Objetos de código<a class="headerlink" href="#code-objects" title="Link to this heading">¶</a></h4>
<p class="translated" id="index-63">Los objetos de código representan código de Python ejecutable <em>compilado por bytes</em>, o <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>. La diferencia entre un objeto de código y un objeto de función es que el objeto de función contiene una referencia explícita a los globales de la función (el módulo en el que fue definido), mientras el objeto de código no contiene contexto; de igual manera los valores por defecto de los argumentos son almacenados en el objeto de función, no en el objeto de código (porque representan valores calculados en tiempo de ejecución).  A diferencia de objetos de función, los objetos de código son inmutables y no contienen referencias (directas o indirectas) a objetos mutables.</p>
<section id="index-64">
<span id="id7"></span><h5 class="untranslated"><span class="section-number">3.2.13.1.1. </span>Special read-only attributes<a class="headerlink" href="#index-64" title="Link to this heading">¶</a></h5>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_name">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_name</span></span><a class="headerlink" href="#codeobject.co_name" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The function name</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_qualname">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_qualname</span></span><a class="headerlink" href="#codeobject.co_qualname" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The fully qualified function name</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_argcount">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_argcount</span></span><a class="headerlink" href="#codeobject.co_argcount" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The total number of positional <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameters</span></a>
(including positional-only parameters and parameters with default values)
that the function has</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_posonlyargcount">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_posonlyargcount</span></span><a class="headerlink" href="#codeobject.co_posonlyargcount" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The number of positional-only <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameters</span></a>
(including arguments with default values) that the function has</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_kwonlyargcount">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_kwonlyargcount</span></span><a class="headerlink" href="#codeobject.co_kwonlyargcount" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The number of keyword-only <a class="reference internal" href="../glossary.html#term-parameter"><span class="xref std std-term">parameters</span></a>
(including arguments with default values) that the function has</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_nlocals">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_nlocals</span></span><a class="headerlink" href="#codeobject.co_nlocals" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The number of <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">local variables</span></a> used by the function
(including parameters)</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_varnames">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_varnames</span></span><a class="headerlink" href="#codeobject.co_varnames" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the names of the local variables in the
function (starting with the parameter names)</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_cellvars">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_cellvars</span></span><a class="headerlink" href="#codeobject.co_cellvars" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the names of <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">local variables</span></a>
that are referenced from at least one <a class="reference internal" href="../glossary.html#term-nested-scope"><span class="xref std std-term">nested scope</span></a> inside the function</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_freevars">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_freevars</span></span><a class="headerlink" href="#codeobject.co_freevars" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the names of
<a class="reference internal" href="../glossary.html#term-closure-variable"><span class="xref std std-term">free (closure) variables</span></a> that a <a class="reference internal" href="../glossary.html#term-nested-scope"><span class="xref std std-term">nested scope</span></a>
references in an outer scope. See also <a class="reference internal" href="#function.__closure__" title="function.__closure__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">function.__closure__</span></code></a>.</p>
<p class="untranslated">Note: references to global and builtin names are <em>not</em> included.</p>
</td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_code">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_code</span></span><a class="headerlink" href="#codeobject.co_code" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A string representing the sequence of <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> instructions in
the function</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_consts">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_consts</span></span><a class="headerlink" href="#codeobject.co_consts" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the literals used by the <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> in
the function</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_names">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_names</span></span><a class="headerlink" href="#codeobject.co_names" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> containing the names used by the <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> in
the function</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_filename">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_filename</span></span><a class="headerlink" href="#codeobject.co_filename" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The name of the file from which the code was compiled</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_firstlineno">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_firstlineno</span></span><a class="headerlink" href="#codeobject.co_firstlineno" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The line number of the first line of the function</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_lnotab">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_lnotab</span></span><a class="headerlink" href="#codeobject.co_lnotab" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">A string encoding the mapping from <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> offsets to line
numbers. For details, see the source code of the interpreter.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Obsoleto desde la versión 3.12: </span>This attribute of code objects is deprecated, and may be removed in
Python 3.15.</p>
</div>
</td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_stacksize">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_stacksize</span></span><a class="headerlink" href="#codeobject.co_stacksize" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The required stack size of the code object</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="codeobject.co_flags">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_flags</span></span><a class="headerlink" href="#codeobject.co_flags" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">An <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">integer</span></code></a> encoding a number of flags for the
interpreter.</p></td>
</tr>
</tbody>
</table>
<p class="untranslated" id="index-65">The following flag bits are defined for <a class="reference internal" href="#codeobject.co_flags" title="codeobject.co_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code></a>:
bit <code class="docutils literal notranslate"><span class="pre">0x04</span></code> is set if
the function uses the <code class="docutils literal notranslate"><span class="pre">*arguments</span></code> syntax to accept an arbitrary number of
positional arguments; bit <code class="docutils literal notranslate"><span class="pre">0x08</span></code> is set if the function uses the
<code class="docutils literal notranslate"><span class="pre">**keywords</span></code> syntax to accept arbitrary keyword arguments; bit <code class="docutils literal notranslate"><span class="pre">0x20</span></code> is set
if the function is a generator. See <a class="reference internal" href="../library/inspect.html#inspect-module-co-flags"><span class="std std-ref">Objetos de código Bit Flags</span></a> for details
on the semantics of each flags that might be present.</p>
<p class="untranslated">Future feature declarations (for example, <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>) also use bits
in <a class="reference internal" href="#codeobject.co_flags" title="codeobject.co_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code></a> to indicate whether a code object was compiled with a
particular feature enabled. See <a class="reference internal" href="../library/__future__.html#future__._Feature.compiler_flag" title="__future__._Feature.compiler_flag"><code class="xref py py-attr docutils literal notranslate"><span class="pre">compiler_flag</span></code></a>.</p>
<p class="untranslated">Other bits in <a class="reference internal" href="#codeobject.co_flags" title="codeobject.co_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code></a> are reserved for internal use.</p>
<p class="untranslated" id="index-66">If a code object represents a function and has a docstring,
the <a class="reference internal" href="../library/inspect.html#inspect.CO_HAS_DOCSTRING" title="inspect.CO_HAS_DOCSTRING"><code class="xref py py-data docutils literal notranslate"><span class="pre">CO_HAS_DOCSTRING</span></code></a> bit is set in <a class="reference internal" href="#codeobject.co_flags" title="codeobject.co_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_flags</span></code></a>
and the first item in <a class="reference internal" href="#codeobject.co_consts" title="codeobject.co_consts"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_consts</span></code></a> is
the docstring of the function.</p>
</section>
<section id="methods-on-code-objects">
<h5 class="untranslated"><span class="section-number">3.2.13.1.2. </span>Methods on code objects<a class="headerlink" href="#methods-on-code-objects" title="Link to this heading">¶</a></h5>
<dl class="py method">
<dt class="sig sig-object py" id="codeobject.co_positions">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_positions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codeobject.co_positions" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Returns an iterable over the source code positions of each <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>
instruction in the code object.</p>
<p class="untranslated">The iterator returns <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>s containing the <code class="docutils literal notranslate"><span class="pre">(start_line,</span> <span class="pre">end_line,</span>
<span class="pre">start_column,</span> <span class="pre">end_column)</span></code>. The <em>i-th</em> tuple corresponds to the
position of the source code that compiled to the <em>i-th</em> code unit.
Column information is 0-indexed utf-8 byte offsets on the given source
line.</p>
<p class="translated">Esta información posicional puede faltar. Una lista no exhaustiva de casos en los que esto puede suceder:</p>
<ul class="simple">
<li><p class="translated">Ejecutando el intérprete con <a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a> <code class="docutils literal notranslate"><span class="pre">no_debug_ranges</span></code>.</p></li>
<li><p class="translated">Cargando un archivo pyc compilado usando <a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a> <code class="docutils literal notranslate"><span class="pre">no_debug_ranges</span></code>.</p></li>
<li><p class="translated">Tuplas de posición correspondientes a instrucciones artificiales.</p></li>
<li><p class="translated">Números de línea y columna que no se pueden representar debido a limitaciones específicas de la implementación.</p></li>
</ul>
<p class="translated">Cuando esto ocurre, algunos o todos los elementos de la tupla pueden ser <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Esta función requiere el almacenamiento de posiciones de columna en objetos de código, lo que puede resultar en un pequeño aumento del uso del disco de archivos de Python compilados o del uso de la memoria del intérprete. Para evitar almacenar la información extra y/o desactivar la impresión de la información extra de seguimiento, se puede usar el indicador de línea de comando <a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a> <code class="docutils literal notranslate"><span class="pre">no_debug_ranges</span></code> o la variable de entorno <span class="target" id="index-131"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONNODEBUGRANGES"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONNODEBUGRANGES</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codeobject.co_lines">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">co_lines</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codeobject.co_lines" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Returns an iterator that yields information about successive ranges of
<a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>s. Each item yielded is a <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">end,</span> <span class="pre">lineno)</span></code>
<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>:</p>
<ul class="simple">
<li><p class="untranslated"><code class="docutils literal notranslate"><span class="pre">start</span></code> (an <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) represents the offset (inclusive) of the start
of the <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> range</p></li>
<li><p class="untranslated"><code class="docutils literal notranslate"><span class="pre">end</span></code> (an <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) represents the offset (exclusive) of the end of
the <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> range</p></li>
<li><p class="untranslated"><code class="docutils literal notranslate"><span class="pre">lineno</span></code> is an <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> representing the line number of the
<a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> range, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if the bytecodes in the given range
have no line number</p></li>
</ul>
<p class="untranslated">The items yielded will have the following properties:</p>
<ul class="simple">
<li><p class="untranslated">The first range yielded will have a <code class="docutils literal notranslate"><span class="pre">start</span></code> of 0.</p></li>
<li><p class="untranslated">The <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">end)</span></code> ranges will be non-decreasing and consecutive. That
is, for any pair of <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>s, the <code class="docutils literal notranslate"><span class="pre">start</span></code> of the second will be
equal to the <code class="docutils literal notranslate"><span class="pre">end</span></code> of the first.</p></li>
<li><p class="untranslated">No range will be backwards: <code class="docutils literal notranslate"><span class="pre">end</span> <span class="pre">&gt;=</span> <span class="pre">start</span></code> for all triples.</p></li>
<li><p class="untranslated">The last <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> yielded will have <code class="docutils literal notranslate"><span class="pre">end</span></code> equal to the size of the
<a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a>.</p></li>
</ul>
<p class="untranslated">Zero-width ranges, where <code class="docutils literal notranslate"><span class="pre">start</span> <span class="pre">==</span> <span class="pre">end</span></code>, are allowed. Zero-width ranges
are used for lines that are present in the source code, but have been
eliminated by the <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> compiler.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="untranslated"><span class="target" id="index-68"></span><a class="pep reference external" href="https://peps.python.org/pep-0626/"><strong>PEP 626</strong></a> - Precise line numbers for debugging and other tools.</dt><dd><p class="untranslated">The PEP that introduced the <code class="xref py py-meth docutils literal notranslate"><span class="pre">co_lines()</span></code> method.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="codeobject.replace">
<span class="sig-prename descclassname"><span class="pre">codeobject.</span></span><span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#codeobject.replace" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Return a copy of the code object with new values for the specified fields.</p>
<p class="untranslated">Code objects are also supported by the generic function <a class="reference internal" href="../library/copy.html#copy.replace" title="copy.replace"><code class="xref py py-func docutils literal notranslate"><span class="pre">copy.replace()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

</section>
</section>
<section id="frame-objects">
<span id="id8"></span><h4 class="translated"><span class="section-number">3.2.13.2. </span>Objetos de marco<a class="headerlink" href="#frame-objects" title="Link to this heading">¶</a></h4>
<p class="untranslated" id="index-69">Frame objects represent execution frames.  They may occur in
<a class="reference internal" href="#traceback-objects"><span class="std std-ref">traceback objects</span></a>,
and are also passed to registered trace functions.</p>
<section id="index-70">
<span id="id9"></span><h5 class="untranslated"><span class="section-number">3.2.13.2.1. </span>Special read-only attributes<a class="headerlink" href="#index-70" title="Link to this heading">¶</a></h5>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_back">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_back</span></span><a class="headerlink" href="#frame.f_back" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">Points to the previous stack frame (towards the caller),
or <code class="docutils literal notranslate"><span class="pre">None</span></code> if this is the bottom stack frame</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_code">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_code</span></span><a class="headerlink" href="#frame.f_code" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The <a class="reference internal" href="#code-objects"><span class="std std-ref">code object</span></a> being executed in this frame.
Accessing this attribute raises an <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">auditing event</span></a>
<code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> with arguments <code class="docutils literal notranslate"><span class="pre">obj</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;f_code&quot;</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_locals">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_locals</span></span><a class="headerlink" href="#frame.f_locals" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The mapping used by the frame to look up
<a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">local variables</span></a>.
If the frame refers to an <a class="reference internal" href="../glossary.html#term-optimized-scope"><span class="xref std std-term">optimized scope</span></a>,
this may return a write-through proxy object.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13: </span>Return a proxy for optimized scopes.</p>
</div>
</td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_globals">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_globals</span></span><a class="headerlink" href="#frame.f_globals" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The dictionary used by the frame to look up
<a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">global variables</span></a></p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_builtins">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_builtins</span></span><a class="headerlink" href="#frame.f_builtins" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The dictionary used by the frame to look up
<a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">built-in (intrinsic) names</span></a></p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_lasti">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_lasti</span></span><a class="headerlink" href="#frame.f_lasti" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The «precise instruction» of the frame object
(this is an index into the <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> string of the
<a class="reference internal" href="#code-objects"><span class="std std-ref">code object</span></a>)</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_generator">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_generator</span></span><a class="headerlink" href="#frame.f_generator" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a> or <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">coroutine</span></a> object that owns this frame,
or <code class="docutils literal notranslate"><span class="pre">None</span></code> if the frame is a normal function.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</td>
</tr>
</tbody>
</table>
</section>
<section id="index-71">
<span id="id10"></span><h5 class="untranslated"><span class="section-number">3.2.13.2.2. </span>Special writable attributes<a class="headerlink" href="#index-71" title="Link to this heading">¶</a></h5>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_trace">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_trace</span></span><a class="headerlink" href="#frame.f_trace" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">If not <code class="docutils literal notranslate"><span class="pre">None</span></code>, this is a function called for various events during
code execution (this is used by debuggers). Normally an event is
triggered for each new source line (see <a class="reference internal" href="#frame.f_trace_lines" title="frame.f_trace_lines"><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_lines</span></code></a>).</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_trace_lines">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_trace_lines</span></span><a class="headerlink" href="#frame.f_trace_lines" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">Set this attribute to <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> to disable triggering a tracing
event for each source line.</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_trace_opcodes">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_trace_opcodes</span></span><a class="headerlink" href="#frame.f_trace_opcodes" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">Set this attribute to <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> to allow per-opcode events to be
requested. Note that this may lead to
undefined interpreter behaviour if exceptions raised by the trace
function escape to the function being traced.</p></td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="frame.f_lineno">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">f_lineno</span></span><a class="headerlink" href="#frame.f_lineno" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">The current line number of the frame – writing to this
from within a trace function jumps to the given line (only for the bottom-most
frame).  A debugger can implement a Jump command (aka Set Next Statement)
by writing to this attribute.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="frame-object-methods">
<h5 class="untranslated"><span class="section-number">3.2.13.2.3. </span>Frame object methods<a class="headerlink" href="#frame-object-methods" title="Link to this heading">¶</a></h5>
<p class="translated">Objetos de marco soportan un método:</p>
<dl class="py method">
<dt class="sig sig-object py" id="frame.clear">
<span class="sig-prename descclassname"><span class="pre">frame.</span></span><span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#frame.clear" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">This method clears all references to <a class="reference internal" href="executionmodel.html#naming"><span class="std std-ref">local variables</span></a> held by the
frame.  Also, if the frame belonged to a <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>, the generator
is finalized.  This helps break reference cycles involving frame
objects (for example when catching an <a class="reference internal" href="../library/exceptions.html#bltin-exceptions"><span class="std std-ref">exception</span></a>
and storing its <a class="reference internal" href="#traceback-objects"><span class="std std-ref">traceback</span></a> for later use).</p>
<p class="untranslated"><a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> is raised if the frame is currently executing
or suspended.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.13: </span>Attempting to clear a suspended frame raises <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>
(as has always been the case for executing frames).</p>
</div>
</dd></dl>

</section>
</section>
<section id="traceback-objects">
<span id="id11"></span><h4 class="translated"><span class="section-number">3.2.13.3. </span>Objetos de seguimiento de pila (traceback)<a class="headerlink" href="#traceback-objects" title="Link to this heading">¶</a></h4>
<p class="untranslated" id="index-72">Traceback objects represent the stack trace of an <a class="reference internal" href="../tutorial/errors.html#tut-errors"><span class="std std-ref">exception</span></a>.
A traceback object
is implicitly created when an exception occurs, and may also be explicitly
created by calling <a class="reference internal" href="../library/types.html#types.TracebackType" title="types.TracebackType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.TracebackType</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Traceback objects can now be explicitly instantiated from Python code.</p>
</div>
<p class="untranslated">For implicitly created tracebacks, when the search for an exception handler
unwinds the execution stack, at each unwound level a traceback object is
inserted in front of the current traceback.  When an exception handler is
entered, the stack trace is made available to the program. (See section
<a class="reference internal" href="compound_stmts.html#try"><span class="std std-ref">La sentencia try</span></a>.) It is accessible as the third item of the
tuple returned by <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a>, and as the
<a class="reference internal" href="../library/exceptions.html#BaseException.__traceback__" title="BaseException.__traceback__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__traceback__</span></code></a> attribute
of the caught exception.</p>
<p class="untranslated">When the program contains no suitable
handler, the stack trace is written (nicely formatted) to the standard error
stream; if the interpreter is interactive, it is also made available to the user
as <a class="reference internal" href="../library/sys.html#sys.last_traceback" title="sys.last_traceback"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.last_traceback</span></code></a>.</p>
<p class="untranslated">For explicitly created tracebacks, it is up to the creator of the traceback
to determine how the <a class="reference internal" href="#traceback.tb_next" title="traceback.tb_next"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_next</span></code></a> attributes should be linked to
form a full stack trace.</p>
<p class="untranslated" id="index-73">Special read-only attributes:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="traceback.tb_frame">
<span class="sig-prename descclassname"><span class="pre">traceback.</span></span><span class="sig-name descname"><span class="pre">tb_frame</span></span><a class="headerlink" href="#traceback.tb_frame" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">Points to the execution <a class="reference internal" href="#frame-objects"><span class="std std-ref">frame</span></a> of the current
level.</p>
<p class="untranslated">Accessing this attribute raises an
<a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">auditing event</span></a> <code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> with arguments
<code class="docutils literal notranslate"><span class="pre">obj</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;tb_frame&quot;</span></code>.</p>
</td>
</tr>
<tr class="row-even"><td><dl class="py attribute">
<dt class="sig sig-object py" id="traceback.tb_lineno">
<span class="sig-prename descclassname"><span class="pre">traceback.</span></span><span class="sig-name descname"><span class="pre">tb_lineno</span></span><a class="headerlink" href="#traceback.tb_lineno" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">Gives the line number where the exception occurred</p></td>
</tr>
<tr class="row-odd"><td><dl class="py attribute">
<dt class="sig sig-object py" id="traceback.tb_lasti">
<span class="sig-prename descclassname"><span class="pre">traceback.</span></span><span class="sig-name descname"><span class="pre">tb_lasti</span></span><a class="headerlink" href="#traceback.tb_lasti" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</td>
<td><p class="untranslated">Indicates the «precise instruction».</p></td>
</tr>
</tbody>
</table>
<p class="untranslated">The line number and last instruction in the traceback may differ from the
line number of its <a class="reference internal" href="#frame-objects"><span class="std std-ref">frame object</span></a> if the exception
occurred in a
<a class="reference internal" href="compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> statement with no matching except clause or with a
<a class="reference internal" href="compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> clause.</p>
<dl class="py attribute" id="index-74">
<dt class="sig sig-object py" id="traceback.tb_next">
<span class="sig-prename descclassname"><span class="pre">traceback.</span></span><span class="sig-name descname"><span class="pre">tb_next</span></span><a class="headerlink" href="#traceback.tb_next" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The special writable attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">tb_next</span></code> is the next level in the
stack trace (towards the frame where the exception occurred), or <code class="docutils literal notranslate"><span class="pre">None</span></code> if
there is no next level.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>This attribute is now writable</p>
</div>
</dd></dl>

</section>
<section id="slice-objects">
<h4 class="translated"><span class="section-number">3.2.13.4. </span>Objetos de segmento (Slice objects)<a class="headerlink" href="#slice-objects" title="Link to this heading">¶</a></h4>
<p class="translated" id="index-75">Los objetos de sector se utilizan para representar sectores para métodos <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>. También son creados por la función integrada <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-func docutils literal notranslate"><span class="pre">slice()</span></code></a>.</p>
<p class="translated" id="index-76">Atributos especiales de solo lectura: <a class="reference internal" href="../library/functions.html#slice.start" title="slice.start"><code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code></a> es el límite inferior; <a class="reference internal" href="../library/functions.html#slice.stop" title="slice.stop"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code></a> es el límite superior; <a class="reference internal" href="../library/functions.html#slice.step" title="slice.step"><code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code></a> es el valor de paso; cada uno es <code class="docutils literal notranslate"><span class="pre">None</span></code> si es omitido. Estos atributos pueden ser de cualquier tipo.</p>
<p class="translated">Los objetos de segmento soportan un método:</p>
<dl class="py method">
<dt class="sig sig-object py" id="slice.indices">
<span class="sig-prename descclassname"><span class="pre">slice.</span></span><span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#slice.indices" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Este método toma un argumento <em>length</em> de entero simple y calcula información relacionada con el segmento que el mismo describiría si fuera aplicado a una secuencia de elementos <em>length</em>. Retorna una tupla de tres enteros; respectivamente estos son los índices <em>start</em> y <em>stop</em> y el <em>step</em> o longitud del paso del segmento. Índices faltantes o fuera de los límites son manipulados de manera consistente con segmentos regulares.</p>
</dd></dl>

</section>
<section id="static-method-objects">
<h4 class="translated"><span class="section-number">3.2.13.5. </span>Objetos de método estático<a class="headerlink" href="#static-method-objects" title="Link to this heading">¶</a></h4>
<p class="translated">Los objetos de método estático proveen una forma de anular la transformación de objetos de función a objetos de método descritos anteriormente. Un objeto de método estático es una envoltura (<em>wrapper</em>) alrededor de cualquier otro objeto, usualmente un objeto de método definido por usuario. Cuando un objeto de método estático es obtenido desde una clase o una instancia de clase, usualmente el objeto retornado es el objeto envuelto, el cual no está objeto a ninguna transformación adicional. Los objetos de método estático también pueden ser llamados. Los objetos de método estático son creados por el constructor incorporado <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>.</p>
</section>
<section id="class-method-objects">
<h4 class="translated"><span class="section-number">3.2.13.6. </span>Objetos de método de clase<a class="headerlink" href="#class-method-objects" title="Link to this heading">¶</a></h4>
<p class="untranslated">A class method object, like a static method object, is a wrapper around another
object that alters the way in which that object is retrieved from classes and
class instances. The behaviour of class method objects upon such retrieval is
described above, under <a class="reference internal" href="#instance-methods"><span class="std std-ref">«instance methods»</span></a>. Class method objects are created
by the built-in <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> constructor.</p>
</section>
</section>
</section>
<section id="special-method-names">
<span id="specialnames"></span><h2 class="translated"><span class="section-number">3.3. </span>Nombres especiales de método<a class="headerlink" href="#special-method-names" title="Link to this heading">¶</a></h2>
<p class="translated" id="index-77">Una clase puede implementar ciertas operaciones que se invocan mediante una sintaxis especial (como operaciones aritméticas o subíndices y divisiones) definiendo métodos con nombres especiales. Este es el enfoque de Python para <em class="dfn">sobrecarga de operadores</em>, permitiendo a las clases definir su propio comportamiento con respecto a los operadores del lenguaje. Por ejemplo, si una clase define un método denominado <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> y <code class="docutils literal notranslate"><span class="pre">x</span></code> es una instancia de esta clase, entonces <code class="docutils literal notranslate"><span class="pre">x[i]</span></code> es aproximadamente equivalente a <code class="docutils literal notranslate"><span class="pre">type(x).__getitem__(x,</span> <span class="pre">i)</span></code>. Excepto donde se mencione, los intentos de ejecutar una operación generan una excepción cuando no se define ningún método apropiado (normalmente <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> o <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>).</p>
<p class="translated">Establecer un método especial en <code class="docutils literal notranslate"><span class="pre">None</span></code> indica que la operación correspondiente no está disponible. Por ejemplo, si una clase establece <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> en <code class="docutils literal notranslate"><span class="pre">None</span></code>, la clase no es iterable, por lo que llamar a <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> en sus instancias generará un <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> (sin recurrir a <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>). <a class="footnote-reference brackets" href="#id21" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p>
<p class="untranslated">When implementing a class that emulates any built-in type, it is important that
the emulation only be implemented to the degree that it makes sense for the
object being modelled.  For example, some sequences may work well with retrieval
of individual elements, but extracting a slice may not make sense.
(One example of this is the <a class="reference internal" href="../library/xml.dom.html#dom-nodelist-objects"><span class="std std-ref">NodeList</span></a> interface
in the W3C’s Document Object Model.)</p>
<section id="basic-customization">
<span id="customization"></span><h3 class="translated"><span class="section-number">3.3.1. </span>Personalización básica<a class="headerlink" href="#basic-customization" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="object.__new__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__new__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__new__" title="Link to this definition">¶</a></dt>
<dd><p class="translated" id="index-78">Es llamado para crear una nueva instancia de clase <em>cls</em>. <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> es un método estático (como un caso especial, así que no se necesita declarar como tal) que toma la clase de donde fue solicitada una instancia como su primer argumento. Los argumentos restantes son aquellos que se pasan a la expresión del constructor de objetos (para llamar a la clase). El valor retornado de <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> deberá ser la nueva instancia de objeto (normalmente una instancia de <em>cls</em>).</p>
<p class="translated">Las implementaciones típicas crean una nueva instancia de la clase invocando el método <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> de la superclase usando <code class="docutils literal notranslate"><span class="pre">super().__new__(cls[,</span> <span class="pre">...])</span></code> con los argumentos apropiados y luego modificando la instancia recién creada según sea necesario antes de retornarla.</p>
<p class="translated">Si <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> es invocado durante la construcción del objeto y éste retorna una instancia de <em>cls</em>, entonces el nuevo método <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> de la instancia será invocado como <code class="docutils literal notranslate"><span class="pre">__init__(self[,</span> <span class="pre">…])</span></code>, donde <em>self</em> es la nueva instancia y los argumentos restantes son iguales a como fueron pasados hacia el constructor de objetos.</p>
<p class="translated">Si <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> no retorna una instancia de <em>cls</em>, entonces el nuevo método <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> de la instancia no será invocado.</p>
<p class="translated"><a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> es destinado principalmente para permitir a subclases de tipos inmutables (como int, str, o tuple) personalizar la creación de instancias. También es comúnmente anulado en metaclases personalizadas con el fin de personalizar la creación de clase.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__init__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__init__" title="Link to this definition">¶</a></dt>
<dd><p class="translated" id="index-79">Llamado después de que la instancia ha sido creada (por <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a>), pero antes es retornada a quien produce la llamada. Los argumentos son aquellos pasados a la expresión del constructor de la clase. Si una clase base tiene un método <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>, el método <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> de clase derivada, de existir, debe llamarlo explícitamente para asegurar la inicialización apropiada de la clase base que es parte de la instancia; por ejemplo: <code class="docutils literal notranslate"><span class="pre">super().__init__([args…])</span></code>.</p>
<p class="translated">Debido a que <a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> y <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> trabajan juntos construyendo objetos (<a class="reference internal" href="#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> para crearlo y <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> para personalizarlo), ningún valor distinto a <code class="docutils literal notranslate"><span class="pre">None</span></code> puede ser retornado por <a class="reference internal" href="#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>; hacer esto puede causar que se lance una excepción <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> en tiempo de ejecución.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__del__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__del__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__del__" title="Link to this definition">¶</a></dt>
<dd><p class="translated" id="index-80">Llamado cuando la instancia es a punto de ser destruida. Esto también es llamado finalizador o (indebidamente) destructor. Si una clase base tiene un método <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> el método <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> de la clase derivada, de existir, debe llamarlo explícitamente para asegurar la eliminación adecuada de la parte de la clase base de la instancia.</p>
<p class="translated">Es posible (¡aunque no recomendable!) para el método <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> posponer la destrucción de la instancia al crear una nueva referencia hacia ésta. Esto es llamado <em>resurrección</em> de objeto. Es dependiente de la implementación si <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> es llamado una segunda vez cuando un objeto resucitado está por ser destruido; la implementación <a class="reference internal" href="../glossary.html#term-CPython"><span class="xref std std-term">CPython</span></a> actual únicamente lo llama una vez.</p>
<p class="untranslated">It is not guaranteed that <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> methods are called for objects
that still exist when the interpreter exits.
<a class="reference internal" href="../library/weakref.html#weakref.finalize" title="weakref.finalize"><code class="xref py py-class docutils literal notranslate"><span class="pre">weakref.finalize</span></code></a> provides a straightforward way to register
a cleanup function to be called when an object is garbage collected.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">x</span></code> no llama directamente <code class="docutils literal notranslate"><span class="pre">x.__del__()</span></code> — el primero disminuye el conteo de referencia para <code class="docutils literal notranslate"><span class="pre">x</span></code> uno por uno, y el segundo es llamado únicamente cuando el conteo de referencias de <code class="docutils literal notranslate"><span class="pre">x</span></code> llega a cero.</p>
</div>
<div class="impl-detail compound">
<p class="translated">Es posible que un ciclo de referencia evite que el recuento de referencia de un objeto llegue a cero. En este caso, el ciclo será posteriormente detectado y eliminado por el <a class="reference internal" href="../glossary.html#term-garbage-collection"><span class="xref std std-term">cyclic garbage collector</span></a>. Una causa común de los ciclos de referencia es cuando se detecta una excepción en una variable local. Luego, los locales del marco hacen referencia a la excepción, que hace referencia a su propio rastreo, que hace referencia a los locales de todos los marcos capturados en el rastreo.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="translated">Documentación para el módulo <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a>.</p>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Advertencia</p>
<p class="translated">Debido a las circunstancias inciertas bajo las que los métodos <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> son invocados, las excepciones que ocurren durante su ejecución son ignoradas, y una advertencia es mostrada hacia <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>. En particular:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> puede ser invocado cuando código arbitrario es ejecutado, incluyendo el de cualquier hilo arbitrario. Si <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> necesita realizar un cierre de exclusión mutua (<em>lock</em>) o invocar cualquier otro recurso que lo esté bloqueando, podría provocar un bloqueo muto (<em>deadlock</em>) ya que el recurso podría estar siendo utilizado por el código que se interrumpe al ejecutar <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>.</p></li>
<li><p class="translated"><a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> puede ser ejecutado durante el cierre del intérprete. Como consecuencia, las variables globales que necesita para acceder (incluyendo otros módulos) podrían haber sido borradas o establecidas a <code class="docutils literal notranslate"><span class="pre">None</span></code>. Python garantiza que los globales cuyo nombre comienza con un guión bajo simple sean borrados de su módulo antes que los globales sean borrados; si no existen otras referencias a dichas globales, esto puede ayudar asegurando que los módulos importados aún se encuentren disponibles al momento de llamar al método <a class="reference internal" href="#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a>.</p></li>
</ul>
</div>
<span class="target" id="index-81"></span></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__repr__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__repr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__repr__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Llamado por la función incorporada <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> para calcular la cadena “oficial” de representación de un objeto. Si es posible, esto debería verse como una expresión de Python válida que puede ser utilizada para recrear un objeto con el mismo valor (bajo el ambiente adecuado). Si no es posible, una cadena con la forma <code class="docutils literal notranslate"><span class="pre">&lt;…some</span> <span class="pre">useful</span> <span class="pre">description…&gt;</span></code> debe ser retornada. El valor de retorno debe ser un objeto de cadena (<em>string</em>). Si una clase define <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> pero no <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>, entonces <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> también es utilizado cuando una cadena “informal” de representación de instancias de esas clases son requeridas.</p>
<p class="untranslated">This is typically used for debugging, so it is important that the representation
is information-rich and unambiguous. A default implementation is provided by the
<a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> class itself.</p>
<span class="target" id="index-82"></span></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__str__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__str__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Called by <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str(object)</span></code></a>, the default <a class="reference internal" href="#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a> implementation,
and the built-in function <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a>, to compute the «informal» or nicely
printable string representation of an object.  The return value must be a
<a class="reference internal" href="../library/stdtypes.html#textseq"><span class="std std-ref">str</span></a> object.</p>
<p class="translated">Este método difiere de <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a> en que no hay expectativas de que <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a> retorne una expresión de Python válida: una representación más conveniente o concisa pueda ser utilizada.</p>
<p class="translated">La implementación por defecto definida por el tipo incorporado <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> llama a <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__repr__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__bytes__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__bytes__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bytes__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated" id="index-83">Called by <a class="reference internal" href="../library/functions.html#func-bytes"><span class="std std-ref">bytes</span></a> to compute a byte-string representation
of an object. This should return a <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> object. The <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>
class itself does not provide this method.</p>
<span class="target" id="index-84"></span></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__format__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__format__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_spec</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__format__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Llamado por la función incorporada <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a>, y por extensión, la evaluación de <a class="reference internal" href="lexical_analysis.html#f-strings"><span class="std std-ref">formatted string literals</span></a> y el método <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a>, para producir la representación “formateada” de un objeto. El argumento <em>format_spec</em> es una cadena que contiene una descripción de las opciones de formato deseadas. La interpretación del argumento <em>format_spec</em> depende del tipo que implementa <a class="reference internal" href="#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a>, sin embargo, ya sea que la mayoría de las clases deleguen el formato a uno de los tipos incorporados, o utilicen una sintaxis de opción de formato similar.</p>
<p class="translated">Ver <a class="reference internal" href="../library/string.html#formatspec"><span class="std std-ref">Especificación de formato Mini-Lenguaje</span></a> para una descripción de la sintaxis de formato estándar.</p>
<p class="translated">El valor de retorno debe ser un objeto de cadena.</p>
<p class="untranslated">The default implementation by the <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> class should be given
an empty <em>format_spec</em> string. It delegates to <a class="reference internal" href="#object.__str__" title="object.__str__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code></a>.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.4: </span>El método __format__ del mismo <code class="docutils literal notranslate"><span class="pre">object</span></code> lanza un <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> si se la pasa una cadena no vacía.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span><code class="docutils literal notranslate"><span class="pre">object.__format__(x,</span> <span class="pre">‘’)</span></code> es ahora equivalente a <code class="docutils literal notranslate"><span class="pre">str(x)</span></code> en lugar de <code class="docutils literal notranslate"><span class="pre">format(str(self),</span> <span class="pre">‘’)</span></code>.</p>
</div>
</dd></dl>

<dl class="py method" id="richcmpfuncs">
<dt class="sig sig-object py" id="object.__lt__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__lt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lt__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__le__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__le__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__le__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__eq__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__eq__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ne__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ne__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ne__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__gt__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__gt__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__gt__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ge__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ge__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ge__" title="Link to this definition">¶</a></dt>
<dd><p class="translated" id="index-85">Estos son los llamados métodos de comparación <em>rich</em>. La correspondencia entre símbolos de operador y los nombres de método es de la siguiente manera: <code class="docutils literal notranslate"><span class="pre">x&lt;y</span></code> llama <code class="docutils literal notranslate"><span class="pre">x.__lt__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code> llama <code class="docutils literal notranslate"><span class="pre">x.__le__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x==y</span></code> llama <code class="docutils literal notranslate"><span class="pre">x.__eq__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x!=y</span></code> llama <code class="docutils literal notranslate"><span class="pre">x.__ne__(y)</span></code>, <code class="docutils literal notranslate"><span class="pre">x&gt;y</span></code> llama <code class="docutils literal notranslate"><span class="pre">x.__gt__(y)</span></code>, y <code class="docutils literal notranslate"><span class="pre">x&gt;=y</span></code> llama <code class="docutils literal notranslate"><span class="pre">x.__ge__(y)</span></code>.</p>
<p class="untranslated">A rich comparison method may return the singleton <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> if it does
not implement the operation for a given pair of arguments. By convention,
<code class="docutils literal notranslate"><span class="pre">False</span></code> and <code class="docutils literal notranslate"><span class="pre">True</span></code> are returned for a successful comparison. However, these
methods can return any value, so if the comparison operator is used in a Boolean
context (e.g., in the condition of an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement), Python will call
<a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-func docutils literal notranslate"><span class="pre">bool()</span></code></a> on the value to determine if the result is true or false.</p>
<p class="untranslated">By default, <code class="docutils literal notranslate"><span class="pre">object</span></code> implements <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> by using <code class="docutils literal notranslate"><span class="pre">is</span></code>, returning
<a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> in the case of a false comparison:
<code class="docutils literal notranslate"><span class="pre">True</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span> <span class="pre">else</span> <span class="pre">NotImplemented</span></code>. For <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a>, by default it
delegates to <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> and inverts the result unless it is
<code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code>.  There are no other implied relationships among the
comparison operators or default implementations; for example, the truth of
<code class="docutils literal notranslate"><span class="pre">(x&lt;y</span> <span class="pre">or</span> <span class="pre">x==y)</span></code> does not imply <code class="docutils literal notranslate"><span class="pre">x&lt;=y</span></code>. To automatically generate ordering
operations from a single root operation, see <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.total_ordering()</span></code></a>.</p>
<p class="untranslated">By default, the <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> class provides implementations consistent
with <a class="reference internal" href="expressions.html#expressions-value-comparisons"><span class="std std-ref">Comparaciones de valor</span></a>: equality compares according to
object identity, and order comparisons raise <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. Each default
method may generate these results directly, but may also return
<a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>.</p>
<p class="translated">Ver el párrafo sobre <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> para más notas importantes sobre la creación de objetos <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> que soportan operaciones de comparación personalizadas y son utilizables como llaves de diccionario.</p>
<p class="untranslated">There are no swapped-argument versions of these methods (to be used when the
left argument does not support the operation but the right argument does);
rather, <a class="reference internal" href="#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a> and <a class="reference internal" href="#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> are each other’s reflection,
<a class="reference internal" href="#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a> and <a class="reference internal" href="#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> are each other’s reflection, and
<a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> and <a class="reference internal" href="#object.__ne__" title="object.__ne__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ne__()</span></code></a> are their own reflection.
If the operands are of different types, and the right operand’s type is
a direct or indirect subclass of the left operand’s type,
the reflected method of the right operand has priority, otherwise
the left operand’s method has priority.  Virtual subclassing is
not considered.</p>
<p class="untranslated">When no appropriate method returns any value other than <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>, the
<code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code> operators will fall back to <code class="docutils literal notranslate"><span class="pre">is</span></code> and <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span></code>, respectively.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__hash__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__hash__" title="Link to this definition">¶</a></dt>
<dd><p class="translated" id="index-86">Lo llama la función integrada <a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> y para operaciones en miembros de colecciones hash, incluidas <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> y <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>. El método <code class="docutils literal notranslate"><span class="pre">__hash__()</span></code> debería retornar un número entero. La única propiedad requerida es que los objetos que se comparan iguales tengan el mismo valor hash; Se recomienda mezclar los valores hash de los componentes del objeto que también desempeñan un papel en la comparación de objetos empaquetándolos en una tupla y aplicando hash a la tupla. Ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nick</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated"><a class="reference internal" href="../library/functions.html#hash" title="hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">hash()</span></code></a> trunca el valor retornado del método personalizado <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> del objeto al tamaño de <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>. Esto normalmente son 8 bytes en estructuras de 64-bits y 4 bytes en estructuras de 32 bits. Si el <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> de un objeto debe interoperar en estructuras de tamaños de bits diferentes, asegúrese de revisar la amplitud en todas las estructuras soportadas. Una forma fácil de hacer esto es con <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-c</span> <span class="pre">“import</span> <span class="pre">sys;</span> <span class="pre">print(sys.hash_info.width)”</span></code>.</p>
</div>
<p class="translated">Si una clase no define un método <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> tampoco debería definir una operación <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>; si define <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> pero no <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, sus instancias no se podrán utilizar como elementos en colecciones hash. Si una clase define objetos mutables e implementa un método <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a>, no debería implementar <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, ya que la implementación de colecciones <a class="reference internal" href="../glossary.html#term-hashable"><span class="xref std std-term">hashable</span></a> requiere que el valor hash de una clave sea inmutable (si el valor hash del objeto cambia, estará en el depósito hash incorrecto).</p>
<p class="untranslated">User-defined classes have <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> and <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> methods
by default (inherited from the <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> class); with them, all objects compare
unequal (except with themselves) and <code class="docutils literal notranslate"><span class="pre">x.__hash__()</span></code> returns an appropriate
value such that <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code> implies both that <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">is</span> <span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">hash(x)</span> <span class="pre">==</span> <span class="pre">hash(y)</span></code>.</p>
<p class="translated">Una clase que anula <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> y no define <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> tendrá implícito su <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> establecido a <code class="docutils literal notranslate"><span class="pre">None</span></code>. Cuando el método <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> de una clase es <code class="docutils literal notranslate"><span class="pre">None</span></code>, instancias de la clase lanzarán un <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> cuando el programa intente obtener el valor del hash, y también será correctamente identificado como de hash no calculable cuando se verifique <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code>.</p>
<p class="translated">Si una clase que anula <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> necesita conservar la implementación de <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> de una clase padre, al intérprete se le debe informar explícitamente estableciendo <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">&lt;ParentClass&gt;.__hash__</span></code>.</p>
<p class="translated">Si una clase que no anula <a class="reference internal" href="#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> desea eliminar el soporte de <em>hash</em>, debe incluir <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> en la definición de clase. Una clase que define su propio <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> y que explícitamente lanza un <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> será identificado de manera incorrecta como de hash calculable por una llamada <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">collections.abc.Hashable)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Por defecto los valores de objetos str y bytes de <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> son “salados” con un valor aleatorio impredecible. Aunque se mantienen constantes dentro de un proceso Python particular, no son predecibles entre invocaciones repetidas de Python.</p>
<p class="untranslated">This is intended to provide protection against a denial-of-service caused
by carefully chosen inputs that exploit the worst case performance of a
dict insertion, <em>O</em>(<em>n</em><sup>2</sup>) complexity.  See
<a class="reference external" href="http://ocert.org/advisories/ocert-2011-003.html">http://ocert.org/advisories/ocert-2011-003.html</a> for details.</p>
<p class="translated">Cambiar los valores hash afectan el orden de la iteración de los sets. Python nunca ha dado garantías en relación a este orden (y típicamente varía entre estructuras de 32-bits y 64-bits).</p>
<p class="translated">Ver también <span class="target" id="index-132"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.3: </span>La aleatorización de hash es habilitada por defecto.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__bool__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__bool__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__bool__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated" id="index-88">Called to implement truth value testing and the built-in operation
<code class="docutils literal notranslate"><span class="pre">bool()</span></code>; should return <code class="docutils literal notranslate"><span class="pre">False</span></code> or <code class="docutils literal notranslate"><span class="pre">True</span></code>.  When this method is not
defined, <a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> is called, if it is defined, and the object is
considered true if its result is nonzero.  If a class defines neither
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code> nor <code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code> (which is true of the <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>
class itself), all its instances are considered true.</p>
</dd></dl>

</section>
<section id="customizing-attribute-access">
<span id="attribute-access"></span><h3 class="translated"><span class="section-number">3.3.2. </span>Personalizando acceso a atributos<a class="headerlink" href="#customizing-attribute-access" title="Link to this heading">¶</a></h3>
<p class="translated">Los siguientes métodos pueden ser definidos para personalizar el significado de acceso a atributos (uso de, asignación a, o borrado de <code class="docutils literal notranslate"><span class="pre">x.name</span></code>) para instancias de clase.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__getattr__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattr__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Called when the default attribute access fails with an <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>
(either <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> raises an <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> because
<em>name</em> is not an instance attribute or an attribute in the class tree
for <code class="docutils literal notranslate"><span class="pre">self</span></code>; or <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> of a <em>name</em> property raises
<a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>).  This method should either return the (computed)
attribute value or raise an <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> exception.
The <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> class itself does not provide this method.</p>
<p class="untranslated">Note that if the attribute is found through the normal mechanism,
<a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> is not called.  (This is an intentional asymmetry between
<a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> and <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a>.) This is done both for efficiency
reasons and because otherwise <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> would have no way to access
other attributes of the instance.  Note that at least for instance variables,
you can take total control by not inserting any values in the instance attribute
dictionary (but instead inserting them in another object).  See the
<a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> method below for a way to actually get total control
over attribute access.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__getattribute__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getattribute__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getattribute__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Es llamado incondicionalmente para implementar acceso de atributo por instancias de clase. Si la clase también define <a class="reference internal" href="#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>, éste no será llamado a menos que <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> lo llame de manera explícita o lance una excepción <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Este método deberá retornar el valor de atributo (calculado) o lanzar una excepción <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Para evitar la recursividad infinita en este método, su implementación deberá siempre llamar al método de la clase base con el mismo nombre para acceder cualquier atributo que necesite, por ejemplo, <code class="docutils literal notranslate"><span class="pre">object.__getattribute__(self,</span> <span class="pre">name)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">This method may still be bypassed when looking up special methods as the
result of implicit invocation via language syntax or
<a class="reference internal" href="#builtin-functions"><span class="std std-ref">built-in functions</span></a>.
See <a class="reference internal" href="#special-lookup"><span class="std std-ref">Búsqueda de método especial</span></a>.</p>
</div>
<p class="audit-hook translated">Para ciertos accesos a atributos sensibles, lanza un <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoría</span></a> <code class="docutils literal notranslate"><span class="pre">object.__getattr__</span></code> con los argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code> y <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__setattr__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__setattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setattr__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Es llamado cuando se intenta la asignación de atributos. Éste es llamado en lugar del mecanismo normal (p. ej. guardar el valor en el diccionario de instancias). <em>name</em> es el nombre de atributo, <em>value</em> es el valor que se le asigna.</p>
<p class="translated">Si <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> quiere asignar a un atributo de instancia, debe llamar al método de la clase base con el mismo nombre, por ejemplo, <code class="docutils literal notranslate"><span class="pre">object.__setattr__(self,</span> <span class="pre">name,</span> <span class="pre">value)</span></code>.</p>
<p class="audit-hook translated">Para ciertas asignaciones de atributos sensibles, lanza un <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoría</span></a> <code class="docutils literal notranslate"><span class="pre">object.__setattr__</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__delattr__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__delattr__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delattr__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Al igual que <a class="reference internal" href="#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> pero para borrado de atributos en lugar de establecerlos. Esto solo de ser implementado si <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">obj.name</span></code> es significativo para el objeto.</p>
<p class="audit-hook translated">Para ciertas eliminaciones de atributos sensibles, lanza un <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">evento de auditoría</span></a> <code class="docutils literal notranslate"><span class="pre">object.__delattr__</span></code> con argumentos <code class="docutils literal notranslate"><span class="pre">obj</span></code> y <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__dir__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__dir__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__dir__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Called when <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> is called on the object. An iterable must be
returned. <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> converts the returned iterable to a list and sorts it.</p>
</dd></dl>

<section id="customizing-module-attribute-access">
<h4 class="translated"><span class="section-number">3.3.2.1. </span>Personalizando acceso a atributos de módulo<a class="headerlink" href="#customizing-module-attribute-access" title="Link to this heading">¶</a></h4>
<dl class="py method" id="index-89">
<dt class="sig sig-object py" id="module.__getattr__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__getattr__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#module.__getattr__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="module.__dir__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__dir__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#module.__dir__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p class="translated">Nombres especiales <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> y <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> también pueden ser utilizados para personalizar acceso a atributos de módulo. La función <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> a nivel del módulo debe aceptar un argumento que es el nombre del atributo y retornar el valor calculado o lanzar una excepción <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Si un atributo no es encontrado en el objeto de módulo a través de una búsqueda normal, p. ej. <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__getattribute__()</span></code></a>, entonces <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> es buscado en el módulo <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> antes de lanzar una excepción <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Si es encontrado, es llamado con el nombre de atributo y el resultado es retornado.</p>
<p class="untranslated">The <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> function should accept no arguments, and return an iterable of
strings that represents the names accessible on module. If present, this
function overrides the standard <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> search on a module.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="module.__class__">
<span class="sig-prename descclassname"><span class="pre">module.</span></span><span class="sig-name descname"><span class="pre">__class__</span></span><a class="headerlink" href="#module.__class__" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<p class="translated">Para una personalización más precisa sobre el comportamiento del módulo (estableciendo atributos, propiedades, etc.), se puede establecer el atributo <code class="docutils literal notranslate"><span class="pre">__class__</span></code> de un objeto de módulo a una subclase de <a class="reference internal" href="../library/types.html#types.ModuleType" title="types.ModuleType"><code class="xref py py-class docutils literal notranslate"><span class="pre">types.ModuleType</span></code></a>. Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">types</span><span class="w"> </span><span class="kn">import</span> <span class="n">ModuleType</span>

<span class="k">class</span><span class="w"> </span><span class="nc">VerboseModule</span><span class="p">(</span><span class="n">ModuleType</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Verbose </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Setting </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">VerboseModule</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Definiendo un módulo <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> y estableciendo un módulo <code class="docutils literal notranslate"><span class="pre">__class__</span></code> solo afecta búsquedas que utilizan la sintaxis de acceso a atributo – acceder directamente a las globales del módulo (ya sea por código dentro del módulo, o a través de una referencia al diccionario de globales del módulo) no se ve afectado.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5: </span>El atributo de módulo <code class="docutils literal notranslate"><span class="pre">__class__</span></code> es ahora escribible.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7: </span>Atributos de módulo <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> y <code class="docutils literal notranslate"><span class="pre">__dir__</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-133"></span><a class="pep reference external" href="https://peps.python.org/pep-0562/"><strong>PEP 562</strong></a> - Módulos __getattr__ y __dir__</dt><dd><p class="translated">Describe las funciones <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> y <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> en módulos.</p>
</dd>
</dl>
</div>
</section>
<section id="implementing-descriptors">
<span id="descriptors"></span><h4 class="translated"><span class="section-number">3.3.2.2. </span>Implementando descriptores<a class="headerlink" href="#implementing-descriptors" title="Link to this heading">¶</a></h4>
<p class="untranslated">The following methods only apply when an instance of the class containing the
method (a so-called <em>descriptor</em> class) appears in an <em>owner</em> class (the
descriptor must be in either the owner’s class dictionary or in the class
dictionary for one of its parents).  In the examples below, «the attribute»
refers to the attribute whose name is the key of the property in the owner
class” <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>.  The <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> class itself does not
implement any of these protocols.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__get__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__get__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">owner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__get__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Es llamado para obtener el atributo de la clase propietaria (acceso a atributos de clase) o de una instancia de dicha clase (acceso a atributos de instancia). El argumento opcional <em>owner</em> es la clase propietaria, mientras que <em>instance</em> es la instancia a través de la cual el atributo fue accedido, o <code class="docutils literal notranslate"><span class="pre">None</span></code> cuando el atributo es accedido a través de <em>owner</em>.</p>
<p class="translated">Este método debe retornar el valor de atributo calculado o lanzar una excepción <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>.</p>
<p class="translated"><span class="target" id="index-134"></span><a class="pep reference external" href="https://peps.python.org/pep-0252/"><strong>PEP 252</strong></a> especifica que <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a> puede ser llamado con uno o dos argumentos. Los propios descriptores incorporados de Python soportan esta especificación; sin embargo, es probable que algunas herramientas de terceros tengan descriptores que requieran ambos argumentos. La propia implementación de <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> en Python siempre pasa ambos argumentos si son requeridos o no.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__set__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__set__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Es llamado para establecer el atributo en una instancia <em>instance</em> de la clase propietaria a un nuevo valor <em>value</em>.</p>
<p class="translated">Nota, agregar <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> o <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a> cambia el tipo de descriptor a un “descriptor de datos”. Ver <a class="reference internal" href="#descriptor-invocation"><span class="std std-ref">Invocando descriptores</span></a> para más detalles.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__delete__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__delete__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delete__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Es llamado para borrar el atributo en una instancia <em>instance</em> de la clase propietaria.</p>
</dd></dl>

<p class="untranslated">Instances of descriptors may also have the <code class="xref py py-attr docutils literal notranslate"><span class="pre">__objclass__</span></code> attribute
present:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="object.__objclass__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__objclass__</span></span><a class="headerlink" href="#object.__objclass__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">The attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">__objclass__</span></code> is interpreted by the <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> module
as specifying the class where this object was defined (setting this
appropriately can assist in runtime introspection of dynamic class attributes).
For callables, it may indicate that an instance of the given type (or a
subclass) is expected or required as the first positional argument (for example,
CPython sets this attribute for unbound methods that are implemented in C).</p>
</dd></dl>

</section>
<section id="invoking-descriptors">
<span id="descriptor-invocation"></span><h4 class="translated"><span class="section-number">3.3.2.3. </span>Invocando descriptores<a class="headerlink" href="#invoking-descriptors" title="Link to this heading">¶</a></h4>
<p class="translated">En general, un descriptor es un atributo de objeto con «comportamiento vinculante», uno cuyo acceso al atributo ha sido anulado por métodos en el protocolo del descriptor: <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> y <a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>. Si alguno de esos métodos está definido para un objeto, se dice que es un descriptor.</p>
<p class="translated">El comportamiento por defecto para atributos de acceso es obtener (<em>get</em>), establecer (<em>set</em>) o borrar (<em>delete</em>) el atributo del diccionario del objeto. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">a.x</span></code> tiene una cadena de búsqueda que comienza con <code class="docutils literal notranslate"><span class="pre">a.__dict__[‘x’]</span></code>, luego <code class="docutils literal notranslate"><span class="pre">type(a).__dict__[‘x’]</span></code>, y continúa por las clases base de <code class="docutils literal notranslate"><span class="pre">type(a)</span></code> excluyendo metaclases.</p>
<p class="translated">Sin embargo, si el valor buscado es un objeto definiendo uno de los métodos del descriptor, entonces Python puede anular el comportamiento por defecto e invocar al método del descriptor en su lugar. Dónde ocurre esto en la cadena de precedencia depende de qué métodos de descriptor fueron definidos y cómo son llamados.</p>
<p class="translated">El punto de inicio por invocación de descriptor es un enlace <code class="docutils literal notranslate"><span class="pre">a.x</span></code>. Cómo los argumentos son ensamblados dependen de <code class="docutils literal notranslate"><span class="pre">a</span></code>:</p>
<dl class="simple">
<dt class="translated">Llamado directo</dt><dd><p class="translated">El llamado más simple y menos común es cuando el código de usuario invoca directamente un método descriptor: <code class="docutils literal notranslate"><span class="pre">x.__get__(a)</span></code>.</p>
</dd>
<dt class="translated">Enlace de instancia</dt><dd><p class="translated">Al enlazar a una instancia de objeto, <code class="docutils literal notranslate"><span class="pre">a</span></code> es transformado en un llamado: <code class="docutils literal notranslate"><span class="pre">type(a).__dict__[‘x’].__get__(a,</span> <span class="pre">type(a))</span></code>.</p>
</dd>
<dt class="translated">Enlace de clase</dt><dd><p class="translated">Al enlazar a una clase, <code class="docutils literal notranslate"><span class="pre">A.x</span></code> es transformado en un llamado: <code class="docutils literal notranslate"><span class="pre">A.__dict__[‘x’].__get__(None,</span> <span class="pre">A)</span></code>.</p>
</dd>
<dt class="translated">Súper enlace</dt><dd><p class="translated">Una búsqueda punteada como <code class="docutils literal notranslate"><span class="pre">super(A,</span> <span class="pre">a).x</span></code> busca en <code class="docutils literal notranslate"><span class="pre">a.__class__.__mro__</span></code> una clase base <code class="docutils literal notranslate"><span class="pre">B</span></code> después de <code class="docutils literal notranslate"><span class="pre">A</span></code> y luego retorna <code class="docutils literal notranslate"><span class="pre">B.__dict__['x'].__get__(a,</span> <span class="pre">A)</span></code>. Si no es un descriptor, <code class="docutils literal notranslate"><span class="pre">x</span></code> se retorna sin cambios.</p>
</dd>
</dl>
<p class="untranslated">For instance bindings, the precedence of descriptor invocation depends on
which descriptor methods are defined.  A descriptor can define any combination
of <a class="reference internal" href="#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>, <a class="reference internal" href="#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a> and
<a class="reference internal" href="#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>.  If it does not
define <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code>, then accessing the attribute will return the descriptor
object itself unless there is a value in the object’s instance dictionary.  If
the descriptor defines <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code> and/or <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code>, it is a data
descriptor; if it defines neither, it is a non-data descriptor.  Normally, data
descriptors define both <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code>, while non-data
descriptors have just the <code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> method.  Data descriptors with
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code> (and/or <code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code>) defined
always override a redefinition in an
instance dictionary.  In contrast, non-data descriptors can be overridden by
instances.</p>
<p class="untranslated">Python methods (including those decorated with
<a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-deco docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code></a> and <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-deco docutils literal notranslate"><span class="pre">&#64;classmethod</span></code></a>) are
implemented as non-data descriptors.  Accordingly, instances can redefine and
override methods.  This allows individual instances to acquire behaviors that
differ from other instances of the same class.</p>
<p class="translated">La función <a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-func docutils literal notranslate"><span class="pre">property()</span></code></a> es implementada como un descriptor de datos. Por lo tanto, las instancias no pueden anular el comportamiento de una propiedad.</p>
</section>
<section id="slots">
<span id="id13"></span><h4 class="translated"><span class="section-number">3.3.2.4. </span>__slots__<a class="headerlink" href="#slots" title="Link to this heading">¶</a></h4>
<p class="translated"><em>__slots__</em> nos permite declarar explícitamente miembros de datos (como propiedades) y denegar la creación de <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> y <em>__weakref__</em> (a menos que se declare explícitamente en <em>__slots__</em> o esté disponible en un padre).</p>
<p class="translated">El espacio ahorrado al usar <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> puede ser significativo. La velocidad de búsqueda de atributos también se puede mejorar significativamente.</p>
<dl class="py data">
<dt class="sig sig-object py" id="object.__slots__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__slots__</span></span><a class="headerlink" href="#object.__slots__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">A esta variable de clase se le puede asignar una cadena, un iterable o una secuencia de cadenas con nombres de variables utilizados por las instancias. <em>__slots__</em> reserva espacio para las variables declaradas y evita la creación automática de <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> y <em>__weakref__</em> para cada instancia.</p>
</dd></dl>

<p class="translated" id="datamodel-note-slots">Notas sobre el uso de  <em>__slots__</em></p>
<ul class="simple">
<li><p class="translated">Al heredar de una clase sin <em>__slots__</em>, los atributos <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> y <em>__weakref__</em> de las instancias siempre estarán accesibles.</p></li>
<li><p class="translated">Sin una variable <a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>, a las instancias no se les pueden asignar nuevas variables que no figuran en la definición <em>__slots__</em>. Los intentos de asignar un nombre de variable no listado generan <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Si desea una asignación dinámica de nuevas variables, agregue <code class="docutils literal notranslate"><span class="pre">'__dict__'</span></code> a la secuencia de cadenas en la declaración <em>__slots__</em>.</p></li>
<li><p class="translated">Sin una variable <em>__weakref__</em> para cada instancia, las clases que definen <em>__slots__</em> no admiten <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weak</span> <span class="pre">references</span></code></a> en sus instancias. Si se necesita soporte de referencia débil, agregue <code class="docutils literal notranslate"><span class="pre">'__weakref__'</span></code> a la secuencia de cadenas en la declaración <em>__slots__</em>.</p></li>
<li><p class="translated"><em>__slots__</em> se implementa a nivel de clase creando <a class="reference internal" href="#descriptors"><span class="std std-ref">descriptors</span></a> para cada nombre de variable. Como resultado, los atributos de clase no se pueden utilizar para establecer valores predeterminados, por ejemplo, variables definidas por <em>__slots__</em>; de lo contrario, el atributo de clase sobrescribiría la asignación del descriptor.</p></li>
<li><p class="untranslated">The action of a <em>__slots__</em> declaration is not limited to the class
where it is defined.  <em>__slots__</em> declared in parents are available in
child classes. However, instances of a child subclass will get a
<a class="reference internal" href="#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> and <em>__weakref__</em> unless the subclass also defines
<em>__slots__</em> (which should only contain names of any <em>additional</em> slots).</p></li>
<li><p class="translated">Si una clase define un espacio (<em>slot</em>) también definido en una clase base, la variable de instancia definida por el espacio de la clase base es inaccesible (excepto al obtener su descriptor directamente de la clase base). Esto hace que el significado del programa sea indefinido. En el futuro se podría agregar una verificación para prevenir esto.</p></li>
<li><p class="translated"><a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> se generará si se definen <em>__slots__</em> no vacíos para una clase derivada de un <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_itemsize" title="PyTypeObject.tp_itemsize"><code class="xref c c-member docutils literal notranslate"><span class="pre">&quot;variable-length&quot;</span> <span class="pre">built-in</span> <span class="pre">type</span></code></a> como <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> y <a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>.</p></li>
<li><p class="translated">Cualquier <a class="reference internal" href="../glossary.html#term-iterable"><span class="xref std std-term">iterable</span></a> que no sea una cadena se puede asignar a <em>__slots__</em>.</p></li>
<li><p class="translated">Si se utiliza un <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a> para asignar <em>__slots__</em>, las claves del diccionario se utilizarán como nombres de ranura. Los valores del diccionario se pueden usar para proporcionar cadenas de documentos por atributo que <a class="reference internal" href="../library/inspect.html#inspect.getdoc" title="inspect.getdoc"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getdoc()</span></code></a> reconocerá y mostrará en la salida de <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a>.</p></li>
<li><p class="untranslated"><a class="reference internal" href="#object.__class__" title="object.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> assignment works only if both classes have the
same <em>__slots__</em>.</p></li>
<li><p class="untranslated"><a class="reference internal" href="compound_stmts.html#multiple-inheritance"><span class="std std-ref">Multiple inheritance</span></a> with multiple slotted parent
classes can be used,
but only one parent is allowed to have attributes created by slots
(the other bases must have empty slot layouts) - violations raise
<a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p></li>
<li><p class="translated">Si se utiliza un <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> para <em>__slots__</em>, entonces se crea un <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a> para cada uno de los valores del iterador. Sin embargo, el atributo <em>__slots__</em> será un iterador vacío.</p></li>
</ul>
</section>
</section>
<section id="customizing-class-creation">
<span id="class-customization"></span><h3 class="translated"><span class="section-number">3.3.3. </span>Personalización de creación de clases<a class="headerlink" href="#customizing-class-creation" title="Link to this heading">¶</a></h3>
<p class="translated">Siempre que una clase hereda de otra clase, se llama a <a class="reference internal" href="#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> en la clase principal. De esta forma, es posible escribir clases que cambien el comportamiento de las subclases. Esto está estrechamente relacionado con los decoradores de clases, pero mientras los decoradores de clases solo afectan la clase específica a la que se aplican, <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> solo se aplica a futuras subclases de la clase que define el método.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__init_subclass__">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__init_subclass__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__init_subclass__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Este método es llamado siempre que la clase que lo contiene sea heredada. <em>cls</em> es entonces, la nueva subclase. Si se define como un método de instancia normal, éste es convertido de manera implícita a un método de clase.</p>
<p class="untranslated">Keyword arguments which are given to a new class are passed to
the parent class’s <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>. For compatibility with
other classes using <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>, one should take out the
needed keyword arguments and pass the others over to the base
class, as in:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Philosopher</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">default_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">default_name</span> <span class="o">=</span> <span class="n">default_name</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AustralianPhilosopher</span><span class="p">(</span><span class="n">Philosopher</span><span class="p">,</span> <span class="n">default_name</span><span class="o">=</span><span class="s2">&quot;Bruce&quot;</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p class="translated">La implementación por defecto <code class="docutils literal notranslate"><span class="pre">object.__init_subclass__</span></code> no hace nada, pero lanza un error si es llamado con cualquier argumento.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">La sugerencia de metaclase <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> es consumido por el resto de la maquinaria de tipos, y nunca se pasa a las implementaciones <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>. La clase meta actual (más que la sugerencia explícita) puede ser accedida como <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<p class="untranslated">When a class is created, <code class="xref py py-meth docutils literal notranslate"><span class="pre">type.__new__()</span></code> scans the class variables
and makes callbacks to those with a <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> hook.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__set_name__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__set_name__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">owner</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__set_name__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Llamado automáticamente al momento en el que se crea la clase propietaria <em>owner</em>. El objeto es asignado a <em>name</em> en esa clase:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>  <span class="c1"># Automatically calls: x.__set_name__(A, &#39;x&#39;)</span>
</pre></div>
</div>
<p class="translated">Si la variable de clase se asigna después de crear la clase, <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> no se llamará automáticamente. Si es necesario, <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a> se puede llamar directamente:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">:</span>
   <span class="k">pass</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="n">A</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">c</span>                  <span class="c1"># The hook is not called</span>
<span class="n">c</span><span class="o">.</span><span class="n">__set_name__</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>   <span class="c1"># Manually invoke the hook</span>
</pre></div>
</div>
<p class="translated">Ver <a class="reference internal" href="#class-object-creation"><span class="std std-ref">Creando el objeto de clase</span></a> para más detalles.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<section id="metaclasses">
<span id="id14"></span><h4 class="translated"><span class="section-number">3.3.3.1. </span>Metaclases<a class="headerlink" href="#metaclasses" title="Link to this heading">¶</a></h4>
<p class="translated" id="index-92">Por defecto, las clases son construidas usando <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a>. El cuerpo de la clase es ejecutado en un nuevo espacio de nombres y el nombre de la clase es ligado de forma local al resultado de <code class="docutils literal notranslate"><span class="pre">type(name,</span> <span class="pre">bases,</span> <span class="pre">namespace)</span></code>.</p>
<p class="translated">El proceso de creación de clase puede ser personalizado pasando el argumento de palabra clave <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> en la línea de definición de la clase, o al heredar de una clase existente que incluya dicho argumento. En el siguiente ejemplo, ambos <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> y <code class="docutils literal notranslate"><span class="pre">MySubclass</span></code> son instancias de <code class="docutils literal notranslate"><span class="pre">Meta</span></code>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MySubclass</span><span class="p">(</span><span class="n">MyClass</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p class="translated">Cualquier otro argumento de palabra clave que sea especificado en la definición de clase es pasado mediante todas las operaciones de metaclase descritas a continuación.</p>
<p class="translated">Cuando una definición de clase es ejecutada, los siguientes pasos ocurren:</p>
<ul class="simple">
<li><p class="translated">Entradas de la orden de resolución de método (MRU) son resueltas;</p></li>
<li><p class="translated">se determina la metaclase adecuada;</p></li>
<li><p class="translated">se prepara el espacio de nombres de clase;</p></li>
<li><p class="translated">se ejecuta el cuerpo de la clase;</p></li>
<li><p class="translated">se crea el objeto de clase.</p></li>
</ul>
</section>
<section id="resolving-mro-entries">
<h4 class="translated"><span class="section-number">3.3.3.2. </span>Resolviendo entradas de la Orden de Resolución de Métodos (MRU)<a class="headerlink" href="#resolving-mro-entries" title="Link to this heading">¶</a></h4>
<dl class="py method">
<dt class="sig sig-object py" id="object.__mro_entries__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__mro_entries__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mro_entries__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Si una base que aparece en una definición de clase no es una instancia de <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>, entonces se busca un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__mro_entries__()</span></code> en la base. Si se encuentra un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__mro_entries__()</span></code>, la base se sustituye por el resultado de una llamada a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__mro_entries__()</span></code> al crear la clase. El método se llama con la tupla de bases original pasada al parámetro <em>bases</em> y debe retornar una tupla de clases que se utilizará en lugar de la base. La tupla retornada puede estar vacía: en estos casos, se ignora la base original.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><a class="reference internal" href="../library/types.html#types.resolve_bases" title="types.resolve_bases"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.resolve_bases()</span></code></a></dt><dd><p class="translated">Resuelva dinámicamente bases que no sean instancias de <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
</dd>
<dt class="translated"><a class="reference internal" href="../library/types.html#types.get_original_bases" title="types.get_original_bases"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.get_original_bases()</span></code></a></dt><dd><p class="translated">Recupera las «bases originales» de una clase antes de las modificaciones realizadas por <a class="reference internal" href="#object.__mro_entries__" title="object.__mro_entries__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mro_entries__()</span></code></a>.</p>
</dd>
<dt class="translated"><span class="target" id="index-93"></span><a class="pep reference external" href="https://peps.python.org/pep-0560/"><strong>PEP 560</strong></a></dt><dd><p class="translated">Soporte principal para módulos de escritura y tipos genéricos.</p>
</dd>
</dl>
</div>
</section>
<section id="determining-the-appropriate-metaclass">
<span id="metaclass-determination"></span><h4 class="translated"><span class="section-number">3.3.3.3. </span>Determinando la metaclase adecuada<a class="headerlink" href="#determining-the-appropriate-metaclass" title="Link to this heading">¶</a></h4>
<p class="translated" id="index-94">La metaclase adecuada para la definición de una clase es determinada de la siguiente manera:</p>
<ul class="simple">
<li><p class="translated">si no se dan bases ni metaclases explícitas, entonces se utiliza <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a>;</p></li>
<li><p class="translated">si se da una metaclase explícita y <em>no</em> es una instancia de <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a>, entonces se utiliza directamente como la metaclase;</p></li>
<li><p class="translated">si se da una instancia de <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> como la metaclase explícita, o se definen bases, entonces se utiliza la metaclase más derivada.</p></li>
</ul>
<p class="translated">La metaclase más derivada es elegida de la metaclase especificada explícitamente (si existe) y de la metaclase (p. ej. <code class="docutils literal notranslate"><span class="pre">type(cls)</span></code>) de todas las clases base especificadas.</p>
</section>
<section id="preparing-the-class-namespace">
<span id="prepare"></span><h4 class="translated"><span class="section-number">3.3.3.4. </span>Preparando el espacio de nombres de la clase<a class="headerlink" href="#preparing-the-class-namespace" title="Link to this heading">¶</a></h4>
<p class="translated" id="index-95">Una vez que se ha identificado la metaclase adecuada, se prepara el espacio de nombres de la clase. Si la metaclase tiene un atributo <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code>, se llama <code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">=</span> <span class="pre">metaclass.__prepare__(name,</span> <span class="pre">bases,</span> <span class="pre">**kwds)</span></code> (donde los argumentos de palabras clave adicionales, si los hay, provienen de la definición de clase). El método <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> debe implementarse como <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod</span></code></a>. El espacio de nombres retornado por <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code> se pasa a <code class="docutils literal notranslate"><span class="pre">__new__</span></code>, pero cuando se crea el objeto de clase final, el espacio de nombres se copia en un nuevo <code class="docutils literal notranslate"><span class="pre">dict</span></code>.</p>
<p class="translated">Si la metaclase no tiene atributo <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code>, entonces el espacio de nombres de clase es iniciado como un mapeo vacío ordenado.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-135"></span><a class="pep reference external" href="https://peps.python.org/pep-3115/"><strong>PEP 3115</strong></a> - Metaclases en Python 3000</dt><dd><p class="translated">Introduce el enlace de espacio de nombres <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code></p>
</dd>
</dl>
</div>
</section>
<section id="executing-the-class-body">
<h4 class="translated"><span class="section-number">3.3.3.5. </span>Ejecutando el cuerpo de la clase<a class="headerlink" href="#executing-the-class-body" title="Link to this heading">¶</a></h4>
<p class="translated" id="index-97">El cuerpo de la clase es ejecutado como <code class="docutils literal notranslate"><span class="pre">exec(body,</span> <span class="pre">globals(),</span> <span class="pre">namespace)</span></code> (aproximadamente). La diferencia clave con un llamado normal a <a class="reference internal" href="../library/functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> es que el alcance léxico permite que el cuerpo de la clase (incluyendo cualquier método) haga referencia a nombres de los alcances actuales y externos cuando la definición de clase sucede dentro de la función.</p>
<p class="translated">Sin embargo, aún cuando la definición de clase sucede dentro de la función, los métodos definidos dentro de la clase aún no pueden ver nombres definidos dentro del alcance de la clase. Variables de clase deben ser accedidas a través del primer parámetro de instancia o métodos de clase, o a través de la referencia al léxico implícito <code class="docutils literal notranslate"><span class="pre">__class__</span></code> descrita en la siguiente sección.</p>
</section>
<section id="creating-the-class-object">
<span id="class-object-creation"></span><h4 class="translated"><span class="section-number">3.3.3.6. </span>Creando el objeto de clase<a class="headerlink" href="#creating-the-class-object" title="Link to this heading">¶</a></h4>
<p class="translated" id="index-98">Una vez que el espacio de nombres de la clase ha sido poblado al ejecutar el cuerpo de la clase, el objeto de clase es creado al llamar <code class="docutils literal notranslate"><span class="pre">metaclass(name,</span> <span class="pre">bases,</span> <span class="pre">namespace,</span> <span class="pre">**kwds)</span></code> (las palabras clave adicionales que se pasan aquí, son las mismas que aquellas pasadas en <code class="docutils literal notranslate"><span class="pre">__prepare__</span></code>).</p>
<p class="translated">Este objeto de clase es el que será referenciado por la forma sin argumentos de <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>. <code class="docutils literal notranslate"><span class="pre">__class__</span></code> es una referencia de cierre implícita creada por el compilador si cualquier método en el cuerpo de una clase se refiere tanto a <code class="docutils literal notranslate"><span class="pre">__class__</span></code> o <code class="docutils literal notranslate"><span class="pre">super</span></code>. Esto permite que la forma sin argumentos de <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> identifique correctamente la clase definida en base al alcance léxico, mientras la clase o instancia que fue utilizada para hacer el llamado actual es identificado en base al primer argumento que se pasa al método.</p>
<div class="impl-detail compound">
<p class="translated">En CPython 3.6 y posterior, la celda <code class="docutils literal notranslate"><span class="pre">__class__</span></code> se pasa a la metaclase como una entrada <code class="docutils literal notranslate"><span class="pre">__classcell__</span></code> en el espacio de nombres de la clase. En caso de existir, esto debe ser propagado hacia el llamado <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> para que la clase se inicie correctamente. No hacerlo resultará en un error <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> en Python 3.8.</p>
</div>
<p class="translated">Cuando se utiliza la metaclase por defecto <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a>, o cualquier metaclase que finalmente llama a <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code>, los siguientes pasos de personalización adicional son invocados después de crear el objeto de clase:</p>
<ol class="arabic simple">
<li><p class="translated">El método <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code> recolecta todos los atributos en el espacio de nombres de la clase que definen un método <a class="reference internal" href="#object.__set_name__" title="object.__set_name__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set_name__()</span></code></a>;</p></li>
<li><p class="translated">Esos métodos <code class="docutils literal notranslate"><span class="pre">__set_name__</span></code> son llamados con la clase siendo definida y el nombre de ese atributo particular asignado;</p></li>
<li><p class="translated">El gancho <a class="reference internal" href="#object.__init_subclass__" title="object.__init_subclass__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init_subclass__()</span></code></a> llama al padre inmediato de la nueva clase en su orden de resolución del método.</p></li>
</ol>
<p class="translated">Después de que el objeto de clase es creado, se pasa al decorador de clase incluido en su definición (si existe) y el objeto resultante es enlazado en el espacio de nombres local como la clase definida.</p>
<p class="untranslated">When a new class is created by <code class="docutils literal notranslate"><span class="pre">type.__new__</span></code>, the object provided as the
namespace parameter is copied to a new ordered mapping and the original
object is discarded. The new copy is wrapped in a read-only proxy, which
becomes the <a class="reference internal" href="#type.__dict__" title="type.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> attribute of the class object.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-136"></span><a class="pep reference external" href="https://peps.python.org/pep-3135/"><strong>PEP 3135</strong></a> - Nuevo súper</dt><dd><p class="translated">Describe la referencia de cierre implícita <code class="docutils literal notranslate"><span class="pre">__class__</span></code></p>
</dd>
</dl>
</div>
</section>
<section id="uses-for-metaclasses">
<h4 class="translated"><span class="section-number">3.3.3.7. </span>Usos para metaclases<a class="headerlink" href="#uses-for-metaclasses" title="Link to this heading">¶</a></h4>
<p class="translated">Los usos potenciales para metaclases son ilimitados. Algunas ideas que ya han sido exploradas incluyen enumeración, registros, revisión de interface, delegación automática, creación de propiedades automática, proxy, infraestructuras, y bloqueo/sincronización automática de recursos.</p>
</section>
</section>
<section id="customizing-instance-and-subclass-checks">
<h3 class="translated"><span class="section-number">3.3.4. </span>Personalizando revisiones de instancia y subclase<a class="headerlink" href="#customizing-instance-and-subclass-checks" title="Link to this heading">¶</a></h3>
<p class="translated">Los siguientes métodos son utilizados para anular el comportamiento por defecto de las funciones incorporadas <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> y <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>.</p>
<p class="translated">En particular, la metaclase <a class="reference internal" href="../library/abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABCMeta</span></code></a> implementa estos métodos para permitir la adición de Clases Base Abstractas (ABCs, por su nombre en inglés <em>Abstract Base Clases</em>) como “clases base virtuales” a cualquier clase o tipo (incluyendo tipos incorporados), incluyendo otros ABCs.</p>
<dl class="py method">
<dt class="sig sig-object py" id="type.__instancecheck__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__instancecheck__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">instance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#type.__instancecheck__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna <em>true</em> si la instancia <em>instance</em> debe ser considerada una instancia (directa o indirecta) de clase <em>class</em>. De ser definida, es llamado para implementar <code class="docutils literal notranslate"><span class="pre">isinstance(instance,</span> <span class="pre">class)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="type.__subclasscheck__">
<span class="sig-prename descclassname"><span class="pre">type.</span></span><span class="sig-name descname"><span class="pre">__subclasscheck__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subclass</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#type.__subclasscheck__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retorna <em>true</em> si la subclase <em>subclass</em> debe ser considerada una subclase (directa o indirecta) de clase <em>class</em>. De ser definida, es llamado para implementar <code class="docutils literal notranslate"><span class="pre">issubclass(subclass,</span> <span class="pre">class)</span></code>.</p>
</dd></dl>

<p class="translated">Tome en cuenta que estos métodos son buscados en el tipo (metaclase) de una clase. No pueden ser definidos como métodos de clase en la clase actual. Esto es consistente con la búsqueda de métodos especiales que son llamados en instancias, solo en este caso la instancia es por sí misma una clase.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-137"></span><a class="pep reference external" href="https://peps.python.org/pep-3119/"><strong>PEP 3119</strong></a> - Introducción a Clases Base Abstractas (<em>Abstract Base Classes</em>)</dt><dd><p class="untranslated">Includes the specification for customizing <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> and
<a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> behavior through <a class="reference internal" href="#type.__instancecheck__" title="type.__instancecheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__instancecheck__()</span></code></a> and
<a class="reference internal" href="#type.__subclasscheck__" title="type.__subclasscheck__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__subclasscheck__()</span></code></a>, with motivation for this functionality
in the context of adding Abstract Base Classes (see the <a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>
module) to the language.</p>
</dd>
</dl>
</div>
</section>
<section id="emulating-generic-types">
<h3 class="translated"><span class="section-number">3.3.5. </span>Emulando tipos genéricos<a class="headerlink" href="#emulating-generic-types" title="Link to this heading">¶</a></h3>
<p class="translated">Cuando se usa <a class="reference internal" href="../glossary.html#term-annotation"><span class="xref std std-term">type annotations</span></a>, a menudo es útil <em>parameterize</em> a <a class="reference internal" href="../glossary.html#term-generic-type"><span class="xref std std-term">generic type</span></a> usando la notación de corchetes de Python. Por ejemplo, la anotación <code class="docutils literal notranslate"><span class="pre">list[int]</span></code> podría usarse para indicar un <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> en el que todos los elementos son del tipo <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-138"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> - Sugerencias de tipo</dt><dd><p class="translated">Presentamos el marco de trabajo de Python para las anotaciones de tipo</p>
</dd>
<dt class="translated"><a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">Generic Alias Types</span></a></dt><dd><p class="translated">Documentación para objetos que representan clases genéricas parametrizadas</p>
</dd>
<dt class="translated"><a class="reference internal" href="../library/typing.html#generics"><span class="std std-ref">Genéricos</span></a>, <a class="reference internal" href="../library/typing.html#user-defined-generics"><span class="std std-ref">user-defined generics</span></a> y <a class="reference internal" href="../library/typing.html#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a></dt><dd><p class="translated">Documentación sobre cómo implementar clases genéricas que se pueden parametrizar en tiempo de ejecución y que los verificadores de tipos estáticos pueden entender.</p>
</dd>
</dl>
</div>
<p class="translated">Una clase <em>generally</em> solo se puede parametrizar si define el método de clase especial <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__class_getitem__">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__class_getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__class_getitem__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Retornar un objeto representando la especialización de una clase genérica por argumentos de tipo encontrados en <em>key</em>.</p>
<p class="untranslated">When defined on a class, <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> is automatically a class
method. As such, there is no need for it to be decorated with
<a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-deco docutils literal notranslate"><span class="pre">&#64;classmethod</span></code></a> when it is defined.</p>
</dd></dl>

<section id="the-purpose-of-class-getitem">
<h4 class="translated"><span class="section-number">3.3.5.1. </span>El propósito de <em>__class_getitem__</em><a class="headerlink" href="#the-purpose-of-class-getitem" title="Link to this heading">¶</a></h4>
<p class="translated">El propósito de <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> es permitir la parametrización en tiempo de ejecución de clases genéricas de biblioteca estándar para aplicar <a class="reference internal" href="../glossary.html#term-type-hint"><span class="xref std std-term">type hints</span></a> a estas clases con mayor facilidad.</p>
<p class="translated">Para implementar clases genéricas personalizadas que se puedan parametrizar en tiempo de ejecución y que los verificadores de tipos estáticos las entiendan, los usuarios deben heredar de una clase de biblioteca estándar que ya implementa <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>, o heredar de <a class="reference internal" href="../library/typing.html#typing.Generic" title="typing.Generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.Generic</span></code></a>, que tiene su propia implementación de <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code>.</p>
<p class="translated">Es posible que los verificadores de tipos de terceros, como mypy, no entiendan las implementaciones personalizadas de <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> en clases definidas fuera de la biblioteca estándar. Se desaconseja el uso de <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> en cualquier clase para fines distintos a la sugerencia de tipo.</p>
</section>
<section id="class-getitem-versus-getitem">
<span id="classgetitem-versus-getitem"></span><h4 class="translated"><span class="section-number">3.3.5.2. </span><em>__class_getitem__</em> frente a <em>__getitem__</em><a class="headerlink" href="#class-getitem-versus-getitem" title="Link to this heading">¶</a></h4>
<p class="translated">Por lo general, el <a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscription</span></a> de un objeto que usa corchetes llamará al método de instancia <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> definido en la clase del objeto. Sin embargo, si el objeto que se suscribe es en sí mismo una clase, se puede llamar al método de clase <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> en su lugar. <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> debería retornar un objeto <a class="reference internal" href="../library/stdtypes.html#types-genericalias"><span class="std std-ref">GenericAlias</span></a> si está definido correctamente.</p>
<p class="translated">Presentado con el <a class="reference internal" href="../glossary.html#term-expression"><span class="xref std std-term">expression</span></a> <code class="docutils literal notranslate"><span class="pre">obj[x]</span></code>, el intérprete de Python sigue un proceso similar al siguiente para decidir si se debe llamar a <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> o <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">inspect</span><span class="w"> </span><span class="kn">import</span> <span class="n">isclass</span>

<span class="k">def</span><span class="w"> </span><span class="nf">subscribe</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the result of the expression &#39;obj[x]&#39;&quot;&quot;&quot;</span>

    <span class="n">class_of_obj</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="c1"># If the class of obj defines __getitem__,</span>
    <span class="c1"># call class_of_obj.__getitem__(obj, x)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">class_of_obj</span><span class="p">,</span> <span class="s1">&#39;__getitem__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">class_of_obj</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Else, if obj is a class and defines __class_getitem__,</span>
    <span class="c1"># call obj.__class_getitem__(x)</span>
    <span class="k">elif</span> <span class="n">isclass</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__class_getitem__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">__class_getitem__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Else, raise an exception</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">class_of_obj</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; object is not subscriptable&quot;</span>
        <span class="p">)</span>
</pre></div>
</div>
<p class="translated">En Python, todas las clases son en sí mismas instancias de otras clases. La clase de una clase se conoce como <a class="reference internal" href="../glossary.html#term-metaclass"><span class="xref std std-term">metaclass</span></a> de esa clase, y la mayoría de las clases tienen la clase <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> como su metaclase. <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-class docutils literal notranslate"><span class="pre">type</span></code></a> no define <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, lo que significa que expresiones como <code class="docutils literal notranslate"><span class="pre">list[int]</span></code>, <code class="docutils literal notranslate"><span class="pre">dict[str,</span> <span class="pre">float]</span></code> y <code class="docutils literal notranslate"><span class="pre">tuple[str,</span> <span class="pre">bytes]</span></code> dan como resultado que se llame a <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># list has class &quot;type&quot; as its metaclass, like most classes:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="go">&lt;class &#39;type&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">tuple</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># &quot;list[int]&quot; calls &quot;list.__class_getitem__(int)&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
<span class="go">list[int]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># list.__class_getitem__ returns a GenericAlias object:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span>
<span class="go">&lt;class &#39;types.GenericAlias&#39;&gt;</span>
</pre></div>
</div>
<p class="translated">Sin embargo, si una clase tiene una metaclase personalizada que define <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, la suscripción de la clase puede generar un comportamiento diferente. Un ejemplo de esto se puede encontrar en el módulo <a class="reference internal" href="../library/enum.html#module-enum" title="enum: Implementation of an enumeration class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">enum</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Menu</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="gp">... </span><span class="w">    </span><span class="sd">&quot;&quot;&quot;A breakfast menu&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="n">SPAM</span> <span class="o">=</span> <span class="s1">&#39;spam&#39;</span>
<span class="gp">... </span>    <span class="n">BACON</span> <span class="o">=</span> <span class="s1">&#39;bacon&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Enum classes have a custom metaclass:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Menu</span><span class="p">)</span>
<span class="go">&lt;class &#39;enum.EnumMeta&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># EnumMeta defines __getitem__,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># so __class_getitem__ is not called,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># and the result is not a GenericAlias object:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Menu</span><span class="p">[</span><span class="s1">&#39;SPAM&#39;</span><span class="p">]</span>
<span class="go">&lt;Menu.SPAM: &#39;spam&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">Menu</span><span class="p">[</span><span class="s1">&#39;SPAM&#39;</span><span class="p">])</span>
<span class="go">&lt;enum &#39;Menu&#39;&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-139"></span><a class="pep reference external" href="https://peps.python.org/pep-0560/"><strong>PEP 560</strong></a>: soporte principal para módulo de escritura y tipos genéricos</dt><dd><p class="translated">Presentamos <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> y describimos cuándo un <a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscription</span></a> da como resultado que se llame a <code class="docutils literal notranslate"><span class="pre">__class_getitem__()</span></code> en lugar de <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a></p>
</dd>
</dl>
</div>
</section>
</section>
<section id="emulating-callable-objects">
<span id="id15"></span><h3 class="translated"><span class="section-number">3.3.6. </span>Emulando objetos que se pueden llamar<a class="headerlink" href="#emulating-callable-objects" title="Link to this heading">¶</a></h3>
<dl class="py method">
<dt class="sig sig-object py" id="object.__call__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">args...</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__call__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated" id="index-103">Called when the instance is «called» as a function; if this method is defined,
<code class="docutils literal notranslate"><span class="pre">x(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> roughly translates to <code class="docutils literal notranslate"><span class="pre">type(x).__call__(x,</span> <span class="pre">arg1,</span> <span class="pre">...)</span></code>.
The <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> class itself does not provide this method.</p>
</dd></dl>

</section>
<section id="emulating-container-types">
<span id="sequence-types"></span><h3 class="translated"><span class="section-number">3.3.7. </span>Emulando tipos de contenedores<a class="headerlink" href="#emulating-container-types" title="Link to this heading">¶</a></h3>
<p class="untranslated">The following methods can be defined to implement container objects. None of them
are provided by the <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> class itself. Containers usually are
<a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequences</span></a> (such as <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">lists</span></code></a> or
<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuples</span></code></a>) or <a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mappings</span></a> (like
<a class="reference internal" href="../glossary.html#term-dictionary"><span class="xref std std-term">dictionaries</span></a>),
but can represent other containers as well.  The first set of methods is used
either to emulate a sequence or to emulate a mapping; the difference is that for
a sequence, the allowable keys should be the integers <em>k</em> for which <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span>
<span class="pre">N</span></code> where <em>N</em> is the length of the sequence, or <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> objects, which define a
range of items.  It is also recommended that mappings provide the methods
<code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">setdefault()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code>, and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> behaving similar to those for Python’s standard <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dictionary</span></code></a>
objects.  The <a class="reference internal" href="../library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> module provides a
<a class="reference internal" href="../library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code></a>
<a class="reference internal" href="../glossary.html#term-abstract-base-class"><span class="xref std std-term">abstract base class</span></a> to help create those methods from a base set of
<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>,
<a class="reference internal" href="#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a>, and <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>.</p>
<p class="untranslated">Mutable sequences should provide methods
<a class="reference internal" href="../library/stdtypes.html#sequence.append" title="sequence.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#sequence.clear" title="sequence.clear"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#sequence.count" title="sequence.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code></a>,
<a class="reference internal" href="../library/stdtypes.html#sequence.extend" title="sequence.extend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#sequence.index" title="sequence.index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#sequence.insert" title="sequence.insert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code></a>,
<a class="reference internal" href="../library/stdtypes.html#sequence.pop" title="sequence.pop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#sequence.remove" title="sequence.remove"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code></a>, and <a class="reference internal" href="../library/stdtypes.html#sequence.reverse" title="sequence.reverse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse()</span></code></a>,
like Python standard <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> objects.
Finally, sequence types should implement addition (meaning concatenation) and
multiplication (meaning repetition) by defining the methods
<a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>, <a class="reference internal" href="#object.__radd__" title="object.__radd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__radd__()</span></code></a>, <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a>,
<a class="reference internal" href="#object.__mul__" title="object.__mul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mul__()</span></code></a>, <a class="reference internal" href="#object.__rmul__" title="object.__rmul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rmul__()</span></code></a> and <a class="reference internal" href="#object.__imul__" title="object.__imul__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__imul__()</span></code></a>
described below; they should not define other numerical
operators.</p>
<p class="untranslated">It is recommended that both mappings and sequences implement the
<a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> method to allow efficient use of the <code class="docutils literal notranslate"><span class="pre">in</span></code>
operator; for
mappings, <code class="docutils literal notranslate"><span class="pre">in</span></code> should search the mapping’s keys; for sequences, it should
search through the values.  It is further recommended that both mappings and
sequences implement the <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method to allow efficient iteration
through the container; for mappings, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> should iterate
through the object’s keys; for sequences, it should iterate through the values.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__len__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__len__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__len__" title="Link to this definition">¶</a></dt>
<dd><p class="translated" id="index-104">Llamado para implementar la función incorporada <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>. Debería retornar la longitud del objeto, un número entero <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0. Además, un objeto que no define un método <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a> y cuyo método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code> retorna cero se considera falso en un contexto booleano.</p>
<div class="impl-detail compound">
<p class="translated">En CPython, se requiere que la longitud sea como máximo <a class="reference internal" href="../library/sys.html#sys.maxsize" title="sys.maxsize"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code></a>. Si la longitud es mayor que <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.maxsize</span></code>, algunas funciones (como <a class="reference internal" href="../library/functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a>) pueden generar <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>. Para evitar que se genere <code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code> mediante pruebas de valor de verdad, un objeto debe definir un método <a class="reference internal" href="#object.__bool__" title="object.__bool__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bool__()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__length_hint__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__length_hint__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__length_hint__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Called to implement <a class="reference internal" href="../library/operator.html#operator.length_hint" title="operator.length_hint"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.length_hint()</span></code></a>. Should return an estimated
length for the object (which may be greater or less than the actual length).
The length must be an integer <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> 0. The return value may also be
<a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>, which is treated the same as if the
<code class="docutils literal notranslate"><span class="pre">__length_hint__</span></code> method didn’t exist at all. This method is purely an
optimization and is never required for correctness.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<div class="admonition note" id="index-105">
<p class="admonition-title">Nota</p>
<p class="translated">La segmentación se hace exclusivamente con los siguientes tres métodos. Un llamado como</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p class="translated">es traducido a</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">=</span> <span class="n">b</span>
</pre></div>
</div>
<p class="translated">etcétera. Elementos faltantes de segmentos siempre son llenados con <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="object.__getitem__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__getitem__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Called to implement evaluation of <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. For <a class="reference internal" href="../glossary.html#term-sequence"><span class="xref std std-term">sequence</span></a> types,
the accepted keys should be integers. Optionally, they may support
<a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> objects as well.  Negative index support is also optional.
If <em>key</em> is
of an inappropriate type, <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> may be raised; if <em>key</em> is a value
outside the set of indexes for the sequence (after any special
interpretation of negative values), <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> should be raised. For
<a class="reference internal" href="../glossary.html#term-mapping"><span class="xref std std-term">mapping</span></a> types, if <em>key</em> is missing (not in the container),
<a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> should be raised.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">ciclos <a class="reference internal" href="compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> esperan que una excepción <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> sea lanzada para que índices ilegales permitan la detección adecuada del fin de una secuencia.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Cuando <a class="reference internal" href="expressions.html#subscriptions"><span class="std std-ref">subscripting</span></a> a <em>class</em>, se puede llamar al método de clase especial <a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> en lugar de <code class="docutils literal notranslate"><span class="pre">__getitem__()</span></code>. Ver <a class="reference internal" href="#classgetitem-versus-getitem"><span class="std std-ref">__class_getitem__ frente a __getitem__</span></a> para más detalles.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__setitem__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__setitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setitem__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Es llamado para implementar la asignación a <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. Lo mismo con respecto a <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>. Esto solo debe ser implementado para mapeos si los objetos permiten cambios a los valores de las llaves, o si nuevas llaves pueden ser añadidas, o para secuencias si los elementos pueden ser reemplazados. Las mismas excepciones deben ser lanzadas para valores de <em>key</em> inadecuados con respecto al método <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__delitem__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__delitem__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__delitem__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Es llamado para implementar el borrado de <code class="docutils literal notranslate"><span class="pre">self[key]</span></code>. Lo mismo con respecto a <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>. Esto solo debe ser implementado para mapeos si los objetos permiten el borrado de llaves, o para secuencias si los elementos pueden ser eliminados de la secuencia. Las mismas excepciones deben ser lanzadas por valores de <em>key</em> inapropiados con respecto al método <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__missing__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__missing__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__missing__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Es llamado por <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>.<a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> para implementar <code class="docutils literal notranslate"><span class="pre">self[key]</span></code> para subclases de diccionarios cuando la llave no se encuentra en el diccionario.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__iter__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iter__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Se llama a este método cuando se requiere un <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a> para un contenedor. Este método debería retornar un nuevo objeto iterador que pueda iterar sobre todos los objetos del contenedor. Para las asignaciones, debe iterar sobre las claves del contenedor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__reversed__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__reversed__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__reversed__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Es llamado (si existe) por la función incorporada <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> para implementar una interacción invertida. Debe retornar un nuevo objeto iterador que itere sobre todos los objetos en el contenedor en orden inverso.</p>
<p class="translated">Si el método <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> no es proporcionado, la función incorporada <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> recurrirá a utilizar el protocolo de secuencia (<a class="reference internal" href="#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> y <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>). Objetos que permiten el protocolo de secuencia deben únicamente proporcionar <a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a> si no pueden proporcionar una implementación que sea más eficiente que la proporcionada por <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a>.</p>
</dd></dl>

<p class="translated">Los operadores de prueba de pertenencia (<a class="reference internal" href="expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> and <a class="reference internal" href="expressions.html#not-in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code></a>) son normalmente implementados como una iteración sobre un contenedor. Sin embargo, los objetos de contenedor pueden proveer el siguiente método especial con una implementación más eficiente, que tampoco requiere que el objeto sea iterable.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__contains__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__contains__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__contains__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Es llamado para implementar operadores de prueba de pertenencia. Deben retornar <em>true</em> si <em>item</em> se encuentra en <em>self</em>, de lo contrario <em>false</em>. Para objetos de mapeo, estos debe considerar las llaves del mapeo en lugar de los valores o los pares de llave-valor.</p>
<p class="translated">Para objetos que no definen <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>, la prueba de pertenencia primero intenta la iteración a través de <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>, y luego el antiguo protocolo de iteración de secuencia a través de <a class="reference internal" href="#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, ver <a class="reference internal" href="expressions.html#membership-test-details"><span class="std std-ref">esta sección en la referencia del lenguaje</span></a>.</p>
</dd></dl>

</section>
<section id="emulating-numeric-types">
<span id="numeric-types"></span><h3 class="translated"><span class="section-number">3.3.8. </span>Emulando tipos numéricos<a class="headerlink" href="#emulating-numeric-types" title="Link to this heading">¶</a></h3>
<p class="translated">Los siguientes métodos pueden ser definidos para emular objetos numéricos. Métodos que corresponden a operaciones que no son permitidas por el número particular implementado (por ejemplo, operaciones bit a bit para números no enteros) se deben dejar sin definir.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__add__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__add__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__sub__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__sub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__sub__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__mul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__mul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mul__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__matmul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__matmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__matmul__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__truediv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__truediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__truediv__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__floordiv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__floordiv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floordiv__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__mod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__mod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__mod__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__divmod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__divmod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__divmod__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__pow__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__pow__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__pow__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__lshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__lshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__lshift__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rshift__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__and__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__and__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__and__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__xor__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__xor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__xor__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__or__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__or__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__or__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated" id="index-106">These methods are called to implement the binary arithmetic operations
(<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>,
<a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>).  For instance, to
evaluate the expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>, where <em>x</em> is an instance of a class that
has an <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a> method, <code class="docutils literal notranslate"><span class="pre">type(x).__add__(x,</span> <span class="pre">y)</span></code> is called.  The
<a class="reference internal" href="#object.__divmod__" title="object.__divmod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__divmod__()</span></code></a> method should be the equivalent to using
<a class="reference internal" href="#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a> and <a class="reference internal" href="#object.__mod__" title="object.__mod__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__mod__()</span></code></a>; it should not be related to
<a class="reference internal" href="#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a>.  Note that <a class="reference internal" href="#object.__pow__" title="object.__pow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__pow__()</span></code></a> should be defined to accept
an optional third argument if the three-argument version of the built-in <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>
function is to be supported.</p>
<p class="untranslated">If one of those methods does not support the operation with the supplied
arguments, it should return <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__radd__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__radd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__radd__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rsub__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rsub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rsub__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rmul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmul__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rmatmul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rmatmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmatmul__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rtruediv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rtruediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rtruediv__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rfloordiv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rfloordiv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rfloordiv__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rmod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rmod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rmod__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rdivmod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rdivmod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rdivmod__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rpow__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rpow__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__rpow__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rlshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rlshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rlshift__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rrshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rrshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rrshift__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rand__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rand__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__rxor__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__rxor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__rxor__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ror__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ror__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ror__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated" id="index-107">These methods are called to implement the binary arithmetic operations
(<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <a class="reference internal" href="../library/functions.html#divmod" title="divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>,
<a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">**</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>) with reflected
(swapped) operands.  These functions are only called if the operands
are of different types, when the left operand does not support the corresponding
operation <a class="footnote-reference brackets" href="#id22" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>, or the right operand’s class is derived from the left operand’s
class. <a class="footnote-reference brackets" href="#id23" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a> For instance, to evaluate the expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">y</span></code>, where <em>y</em> is
an instance of a class that has an <a class="reference internal" href="#object.__rsub__" title="object.__rsub__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rsub__()</span></code></a> method, <code class="docutils literal notranslate"><span class="pre">type(y).__rsub__(y,</span> <span class="pre">x)</span></code>
is called if <code class="docutils literal notranslate"><span class="pre">type(x).__sub__(x,</span> <span class="pre">y)</span></code> returns <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> or <code class="docutils literal notranslate"><span class="pre">type(y)</span></code>
is a subclass of <code class="docutils literal notranslate"><span class="pre">type(x)</span></code>. <a class="footnote-reference brackets" href="#id24" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a></p>
<p class="untranslated">Note that <a class="reference internal" href="#object.__rpow__" title="object.__rpow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rpow__()</span></code></a> should be defined to accept an optional third
argument if the three-argument version of the built-in <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> function
is to be supported.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.14: </span>Three-argument <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> now try calling <a class="reference internal" href="#object.__rpow__" title="object.__rpow__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__rpow__()</span></code></a> if necessary.
Previously it was only called in two-argument <code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code> and the binary
power operator.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Si el tipo del operando de la derecha es una subclase del tipo del operando de la izquierda y esa subclase proporciona el método reflejado para la operación, este método será llamado antes del método no reflejado del operando izquierdo. Este comportamiento permite que las subclases anulen las operaciones de sus predecesores.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__iadd__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__iadd__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iadd__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__isub__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__isub__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__isub__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__imul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__imul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imul__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__imatmul__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__imatmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imatmul__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__itruediv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__itruediv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__itruediv__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ifloordiv__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ifloordiv__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ifloordiv__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__imod__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__imod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__imod__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ipow__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ipow__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__ipow__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ilshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ilshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ilshift__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__irshift__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__irshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__irshift__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__iand__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__iand__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__iand__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ixor__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ixor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ixor__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ior__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ior__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ior__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">These methods are called to implement the augmented arithmetic assignments
(<code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">//=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>, <code class="docutils literal notranslate"><span class="pre">**=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>,
<code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>).  These methods should attempt to do the
operation in-place (modifying <em>self</em>) and return the result (which could be,
but does not have to be, <em>self</em>).  If a specific method is not defined, or if
that method returns <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>, the
augmented assignment falls back to the normal methods.  For instance, if <em>x</em>
is an instance of a class with an <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a> method, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">y</span></code> is
equivalent to <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">x.__iadd__(y)</span></code> . If <a class="reference internal" href="#object.__iadd__" title="object.__iadd__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code></a> does not exist, or if <code class="docutils literal notranslate"><span class="pre">x.__iadd__(y)</span></code>
returns <code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code>, <code class="docutils literal notranslate"><span class="pre">x.__add__(y)</span></code> and
<code class="docutils literal notranslate"><span class="pre">y.__radd__(x)</span></code> are considered, as with the evaluation of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>. In
certain situations, augmented assignment can result in unexpected errors (see
<a class="reference internal" href="../faq/programming.html#faq-augmented-assignment-tuple-error"><span class="std std-ref">¿Por qué hacer lo siguiente, a_tuple[i] += ['item'], lanza una excepción cuando la suma funciona?</span></a>), but this behavior is in fact
part of the data model.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__neg__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__neg__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__neg__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__pos__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__pos__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__pos__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__abs__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__abs__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__abs__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__invert__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__invert__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__invert__" title="Link to this definition">¶</a></dt>
<dd><p class="translated" id="index-108">Es llamado para implementar las operaciones aritméticas unarias (<code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <a class="reference internal" href="../library/functions.html#abs" title="abs"><code class="xref py py-func docutils literal notranslate"><span class="pre">abs()</span></code></a> and <code class="docutils literal notranslate"><span class="pre">~</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__complex__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__complex__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__complex__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__int__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__int__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__int__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__float__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__float__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__float__" title="Link to this definition">¶</a></dt>
<dd><p class="translated" id="index-109">Es llamado para implementar las funciones incorporadas <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a>, <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> y <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a>. Debe retornar un valor del tipo apropiado.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__index__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__index__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__index__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Es llamado para implementar <a class="reference internal" href="../library/operator.html#operator.index" title="operator.index"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.index()</span></code></a>, y cuando sea que Python necesite convertir sin pérdidas el objeto numérico a un objeto entero (tal como en la segmentación o <em>slicing</em>, o las funciones incorporadas <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a>, <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-func docutils literal notranslate"><span class="pre">hex()</span></code></a> y <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a>). La presencia de este método indica que el objeto numérico es un tipo entero. Debe retornar un entero.</p>
<p class="translated">Si <a class="reference internal" href="#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a>, <a class="reference internal" href="#object.__float__" title="object.__float__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__float__()</span></code></a> y <a class="reference internal" href="#object.__complex__" title="object.__complex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code></a> no son definidos, entonces todas las funciones incorporadas correspondientes <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> y <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> vuelven a <a class="reference internal" href="#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__round__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__round__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">ndigits</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__round__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__trunc__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__trunc__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__trunc__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__floor__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__floor__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__floor__" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="object.__ceil__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__ceil__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__ceil__" title="Link to this definition">¶</a></dt>
<dd><p class="translated" id="index-110">Es llamado para implementar la función incorporada <a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> y las funciones <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> <a class="reference internal" href="../library/math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">trunc()</span></code></a>, <a class="reference internal" href="../library/math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a> y <a class="reference internal" href="../library/math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a>. A menos que <em>ndigits</em> sea pasado a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__round__()</span></code> todos estos métodos deben retornar el valor del objeto truncado a <a class="reference internal" href="../library/numbers.html#numbers.Integral" title="numbers.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a> (normalmente <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>).</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.14: </span><a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> no longer delegates to the <a class="reference internal" href="#object.__trunc__" title="object.__trunc__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__trunc__()</span></code></a> method.</p>
</div>
</dd></dl>

</section>
<section id="with-statement-context-managers">
<span id="context-managers"></span><h3 class="translated"><span class="section-number">3.3.9. </span>Gestores de Contexto en la Declaración <em>with</em><a class="headerlink" href="#with-statement-context-managers" title="Link to this heading">¶</a></h3>
<p class="translated">Un <em class="dfn">context manager</em> es un objeto que define el contexto en tiempo de ejecución a ser establecido cuando se ejecuta una declaración <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>. El gestor de contexto maneja la entrada y la salida del contexto en tiempo de ejecución deseado para la ejecución del bloque de código. Los gestores de contexto son normalmente invocados utilizando la declaración <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> (descritos en la sección <a class="reference internal" href="compound_stmts.html#with"><span class="std std-ref">La sentencia with</span></a>), pero también pueden ser utilizados al invocar directamente sus métodos.</p>
<p class="translated" id="index-111">Usos típicos de los gestores de contexto incluyen guardar y restablecer diversos tipos de declaraciones globales, bloquear y desbloquear recursos, cerrar archivos abiertos, etc.</p>
<p class="untranslated">For more information on context managers, see <a class="reference internal" href="../library/stdtypes.html#typecontextmanager"><span class="std std-ref">Tipos gestores de contexto</span></a>.
The <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> class itself does not provide the context manager methods.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__enter__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__enter__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__enter__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Ingresa al contexto en tiempo de ejecución relacionado con este objeto. La declaración <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> ligará el valor de retorno de este método al objetivo especificado en cláusula <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> de la declaración, en caso de existir.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__exit__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__exit__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__exit__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Sale del contexto en tiempo de ejecución relacionado a este objeto. Los parámetros describen la excepción que causa la salida del contexto. Si éste se termina sin excepción, los tres argumentos serán <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>.</p>
<p class="translated">Si se proporciona una excepción, y el método desea eliminarla (por ejemplo, prevenir que sea propagada), debe retornar un valor verdadero. De lo contrario, la excepción será procesada de forma normal al salir de este método.</p>
<p class="untranslated">Note that <a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> methods should not reraise the passed-in exception;
this is the caller’s responsibility.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-140"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a> - La declaración “with”</dt><dd><p class="translated">La especificación, el antecedente, y los ejemplos para la declaración de Python <a class="reference internal" href="compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>.</p>
</dd>
</dl>
</div>
</section>
<section id="customizing-positional-arguments-in-class-pattern-matching">
<span id="class-pattern-matching"></span><h3 class="translated"><span class="section-number">3.3.10. </span>Personalización de argumentos posicionales en la coincidencia de patrones de clase<a class="headerlink" href="#customizing-positional-arguments-in-class-pattern-matching" title="Link to this heading">¶</a></h3>
<p class="translated">Cuando se utiliza un nombre de clase en un patrón, los argumentos posicionales en el patrón no están permitidos de forma predeterminada, es decir, <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">MyClass(x,</span> <span class="pre">y)</span></code> normalmente no es válido sin un soporte especial en <code class="docutils literal notranslate"><span class="pre">MyClass</span></code>. Para poder utilizar ese tipo de patrón, la clase necesita definir un atributo <em>__match_args__</em>.</p>
<dl class="py data">
<dt class="sig sig-object py" id="object.__match_args__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__match_args__</span></span><a class="headerlink" href="#object.__match_args__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">A esta variable de clase se le puede asignar una tupla de cadenas. Cuando esta clase se utiliza en un patrón de clase con argumentos posicionales, cada argumento posicional se convertirá en un argumento de palabra clave, utilizando el valor correspondiente en <em>__match_args__</em> como palabra clave. La ausencia de este atributo es equivalente a establecerlo en <code class="docutils literal notranslate"><span class="pre">()</span></code>.</p>
</dd></dl>

<p class="translated">Por ejemplo, si <code class="docutils literal notranslate"><span class="pre">MyClass.__match_args__</span></code> es <code class="docutils literal notranslate"><span class="pre">(&quot;left&quot;,</span> <span class="pre">&quot;center&quot;,</span> <span class="pre">&quot;right&quot;)</span></code> eso significa que <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">MyClass(x,</span> <span class="pre">y)</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">MyClass(left=x,</span> <span class="pre">center=y)</span></code>. Ten en cuenta que el número de argumentos en el patrón debe ser menor o igual que el número de elementos en <em>__match_args__</em>; si es más grande, el intento de coincidencia de patrón producirá un <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.10.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-141"></span><a class="pep reference external" href="https://peps.python.org/pep-0634/"><strong>PEP 634</strong></a> - Coincidencia de patrones estructurales</dt><dd><p class="translated">La especificación para la declaración <code class="docutils literal notranslate"><span class="pre">match</span></code> de Python.</p>
</dd>
</dl>
</div>
</section>
<section id="emulating-buffer-types">
<span id="python-buffer-protocol"></span><h3 class="translated"><span class="section-number">3.3.11. </span>Emulando tipos de búfer<a class="headerlink" href="#emulating-buffer-types" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">buffer protocol</span></a> proporciona una forma para que los objetos Python expongan un acceso eficiente a una matriz de memoria de bajo nivel. Este protocolo se implementa mediante tipos integrados como <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> y <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>, y bibliotecas de terceros pueden definir tipos de búfer adicionales.</p>
<p class="translated">Si bien los tipos de búfer generalmente se implementan en C, también es posible implementar el protocolo en Python.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__buffer__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__buffer__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__buffer__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Se llama cuando se solicita un búfer desde <em>self</em> (por ejemplo, por el constructor <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>). El argumento <em>flags</em> es un número entero que representa el tipo de búfer solicitado y afecta, por ejemplo, si el búfer retornado es de solo lectura o de escritura. <a class="reference internal" href="../library/inspect.html#inspect.BufferFlags" title="inspect.BufferFlags"><code class="xref py py-class docutils literal notranslate"><span class="pre">inspect.BufferFlags</span></code></a> proporciona una manera conveniente de interpretar las banderas. El método debe retornar un objeto <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__release_buffer__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__release_buffer__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__release_buffer__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Se llama cuando ya no se necesita un búfer. El argumento <em>buffer</em> es un objeto <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> que <a class="reference internal" href="#object.__buffer__" title="object.__buffer__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__buffer__()</span></code></a> retornó anteriormente. El método debe liberar todos los recursos asociados con el búfer. Este método debería retornar <code class="docutils literal notranslate"><span class="pre">None</span></code>. Los objetos de búfer que no necesitan realizar ninguna limpieza no son necesarios para implementar este método.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-142"></span><a class="pep reference external" href="https://peps.python.org/pep-0688/"><strong>PEP 688</strong></a>: hacer accesible el protocolo de búfer en Python</dt><dd><p class="translated">Presenta los métodos Python <code class="docutils literal notranslate"><span class="pre">__buffer__</span></code> y <code class="docutils literal notranslate"><span class="pre">__release_buffer__</span></code>.</p>
</dd>
<dt class="translated"><a class="reference internal" href="../library/collections.abc.html#collections.abc.Buffer" title="collections.abc.Buffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Buffer</span></code></a></dt><dd><p class="translated">ABC para tipos de buffer.</p>
</dd>
</dl>
</div>
</section>
<section id="annotations">
<h3 class="untranslated"><span class="section-number">3.3.12. </span>Annotations<a class="headerlink" href="#annotations" title="Link to this heading">¶</a></h3>
<p class="untranslated">Functions, classes, and modules may contain <a class="reference internal" href="../glossary.html#term-annotation"><span class="xref std std-term">annotations</span></a>,
which are a way to associate information (usually <a class="reference internal" href="../glossary.html#term-type-hint"><span class="xref std std-term">type hints</span></a>)
with a symbol.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="object.__annotations__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__annotations__</span></span><a class="headerlink" href="#object.__annotations__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">This attribute contains the annotations for an object. It is
<a class="reference internal" href="executionmodel.html#lazy-evaluation"><span class="std std-ref">lazily evaluated</span></a>, so accessing the attribute may
execute arbitrary code and raise exceptions. If evaluation is successful, the
attribute is set to a dictionary mapping from variable names to annotations.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.14: </span>Annotations are now lazily evaluated.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__annotate__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__annotate__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__annotate__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">An <a class="reference internal" href="../glossary.html#term-annotate-function"><span class="xref std std-term">annotate function</span></a>.
Returns a new dictionary object mapping attribute/parameter names to their annotation values.</p>
<p class="untranslated">Takes a format parameter specifying the format in which annotations values should be provided.
It must be a member of the <a class="reference internal" href="../library/annotationlib.html#annotationlib.Format" title="annotationlib.Format"><code class="xref py py-class docutils literal notranslate"><span class="pre">annotationlib.Format</span></code></a> enum, or an integer with
a value corresponding to a member of the enum.</p>
<p class="untranslated">If an annotate function doesn’t support the requested format, it must raise
<a class="reference internal" href="../library/exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>. Annotate functions must always support
<a class="reference internal" href="../library/annotationlib.html#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE</span></code></a> format; they must not raise
<a class="reference internal" href="../library/exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError()</span></code></a> when called with this format.</p>
<p class="untranslated">When called with  <a class="reference internal" href="../library/annotationlib.html#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE</span></code></a> format, an annotate function may raise
<a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>; it must not raise <code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code> when called requesting any other format.</p>
<p class="untranslated">If an object does not have any annotations, <a class="reference internal" href="#object.__annotate__" title="object.__annotate__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotate__</span></code></a> should preferably be set
to <code class="docutils literal notranslate"><span class="pre">None</span></code> (it can’t be deleted), rather than set to a function that returns an empty dict.</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="untranslated"><span class="target" id="index-115"></span><a class="pep reference external" href="https://peps.python.org/pep-0649/"><strong>PEP 649</strong></a> — Deferred evaluation of annotation using descriptors</dt><dd><p class="untranslated">Introduces lazy evaluation of annotations and the <code class="docutils literal notranslate"><span class="pre">__annotate__</span></code> function.</p>
</dd>
</dl>
</div>
</section>
<section id="special-method-lookup">
<span id="special-lookup"></span><h3 class="translated"><span class="section-number">3.3.13. </span>Búsqueda de método especial<a class="headerlink" href="#special-method-lookup" title="Link to this heading">¶</a></h3>
<p class="translated">Para clases personalizadas, invocaciones implícitas de métodos especiales solo están garantizados para trabajar correctamente si son definidos en un tipo de objeto, no en el diccionario de instancia del objeto. Ese comportamiento es la razón por la que el siguiente código lanza una excepción:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">object of type &#39;C&#39; has no len()</span>
</pre></div>
</div>
<p class="translated">La razón detrás de este comportamiento radica en una serie de métodos especiales, como <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> y <a class="reference internal" href="#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a>, que implementan todos los objetos, incluidos los objetos de tipo. Si la búsqueda implícita de estos métodos utilizara el proceso de búsqueda convencional, fallarían cuando se invocaran en el objeto de tipo mismo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">descriptor &#39;__hash__&#39; of &#39;int&#39; object needs an argument</span>
</pre></div>
</div>
<p class="translated">Intentar invocar de manera incorrecta el método no ligado de una clase de esta forma a veces es denominado como ‘confusión de metaclase’, y se evita sobrepasando la instancia al buscar métodos especiales:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="translated">Además de omitir cualquier atributo de instancia en aras de la corrección, la búsqueda implícita de métodos especiales generalmente también omite el método <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> incluso de la metaclase del objeto:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Meta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Metaclass getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">Meta</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Class getattribute invoked&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>                 <span class="c1"># Explicit lookup via instance</span>
<span class="go">Class getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>          <span class="c1"># Explicit lookup via type</span>
<span class="go">Metaclass getattribute invoked</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>                      <span class="c1"># Implicit lookup</span>
<span class="go">10</span>
</pre></div>
</div>
<p class="translated">Omitir la maquinaria <a class="reference internal" href="#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> de esta manera proporciona un margen significativo para optimizar la velocidad dentro del intérprete, a costa de cierta flexibilidad en el manejo de métodos especiales (el método especial <em>must</em> debe configurarse en el propio objeto de clase para que el intérprete lo invoque consistentemente). ).</p>
</section>
</section>
<section id="coroutines">
<span id="index-116"></span><h2 class="translated"><span class="section-number">3.4. </span>Corrutinas<a class="headerlink" href="#coroutines" title="Link to this heading">¶</a></h2>
<section id="awaitable-objects">
<h3 class="translated"><span class="section-number">3.4.1. </span>Objetos esperables<a class="headerlink" href="#awaitable-objects" title="Link to this heading">¶</a></h3>
<p class="translated">Un objeto <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> generalmente implementa un método <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>. <a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutine objects</span></a> retornado por las funciones <a class="reference internal" href="compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> están a la espera.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Los objetos <a class="reference internal" href="../glossary.html#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a> retornados por generadores decorados con <a class="reference internal" href="../library/types.html#types.coroutine" title="types.coroutine"><code class="xref py py-func docutils literal notranslate"><span class="pre">types.coroutine()</span></code></a> también están a la espera, pero no implementan <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="object.__await__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__await__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__await__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Must return an <a class="reference internal" href="../glossary.html#term-iterator"><span class="xref std std-term">iterator</span></a>.  Should be used to implement
<a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a> objects.  For instance, <a class="reference internal" href="../library/asyncio-future.html#asyncio.Future" title="asyncio.Future"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Future</span></code></a> implements
this method to be compatible with the <a class="reference internal" href="expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> expression.
The <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> class itself is not awaitable and does not provide
this method.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">El lenguaje no impone ninguna restricción sobre el tipo o valor de los objetos generados por el iterador retornado por <code class="docutils literal notranslate"><span class="pre">__await__</span></code>, ya que esto es específico de la implementación del marco de ejecución asincrónica (por ejemplo, <a class="reference internal" href="../library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a>) que administrará el objeto <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a>.</p>
</div>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<p class="translated"><span class="target" id="index-143"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> para información adicional sobre objetos esperables.</p>
</div>
</section>
<section id="coroutine-objects">
<span id="id19"></span><h3 class="translated"><span class="section-number">3.4.2. </span>Objetos de corrutina<a class="headerlink" href="#coroutine-objects" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../glossary.html#term-coroutine"><span class="xref std std-term">Coroutine objects</span></a> son objetos <a class="reference internal" href="../glossary.html#term-awaitable"><span class="xref std std-term">awaitable</span></a>. La ejecución de una corrutina se puede controlar llamando a <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a> e iterando sobre el resultado. Cuando la rutina termina de ejecutarse y regresa, el iterador genera <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> y el atributo <a class="reference internal" href="../library/exceptions.html#StopIteration.value" title="StopIteration.value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code></a> de la excepción contiene el valor de retorno. Si la rutina genera una excepción, el iterador la propaga. Las corrutinas no deberían generar directamente excepciones <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> no controladas.</p>
<p class="translated">Las corrutinas también tienen los métodos mencionados a continuación, los cuales son análogos a los de los generadores. (ver <a class="reference internal" href="expressions.html#generator-methods"><span class="std std-ref">Métodos generador-iterador</span></a>). Sin embargo, a diferencia de los generadores, las corrutinas no soportan directamente iteración.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.5.2: </span>Es un error <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> esperar a una corrutina más de una vez.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="coroutine.send">
<span class="sig-prename descclassname"><span class="pre">coroutine.</span></span><span class="sig-name descname"><span class="pre">send</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.send" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Starts or resumes execution of the coroutine.  If <em>value</em> is <code class="docutils literal notranslate"><span class="pre">None</span></code>,
this is equivalent to advancing the iterator returned by
<a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>.  If <em>value</em> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, this method delegates
to the <a class="reference internal" href="expressions.html#generator.send" title="generator.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> method of the iterator that caused
the coroutine to suspend.  The result (return value,
<a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, or other exception) is the same as when
iterating over the <code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code> return value, described above.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coroutine.throw">
<span class="sig-prename descclassname"><span class="pre">coroutine.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.throw" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">coroutine.</span></span><span class="sig-name descname"><span class="pre">throw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p class="translated">Genera la excepción especificada en la corrutina. Este método delega al método <a class="reference internal" href="expressions.html#generator.throw" title="generator.throw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">throw()</span></code></a> del iterador que provocó la suspensión de la rutina, si tiene dicho método. En caso contrario, la excepción se plantea en el punto de suspensión. El resultado (valor de retorno, <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> u otra excepción) es el mismo que cuando se itera sobre el valor de retorno <a class="reference internal" href="#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>, descrito anteriormente. Si la excepción no queda atrapada en la rutina, se propaga de nuevo a la persona que llama.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.12: </span>La segunda firma (type[, value[, traceback]]) está obsoleta y puede eliminarse en una versión futura de Python.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="coroutine.close">
<span class="sig-prename descclassname"><span class="pre">coroutine.</span></span><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#coroutine.close" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Causa que la corrutina misma se borre a sí misma y termine su ejecución. Si la corrutina es suspendida, este método primero delega a <a class="reference internal" href="expressions.html#generator.close" title="generator.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>, si existe, del iterador que causó la suspensión de la corrutina. Luego lanza una excepción <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> en el punto de suspensión, causando que la corrutina se borre a sí misma. Finalmente, la corrutina es marcada como completada, aún si nunca inició.</p>
<p class="translated">Objetos de corrutina son cerrados automáticamente utilizando el proceso anterior cuando están a punto de ser destruidos.</p>
</dd></dl>

</section>
<section id="asynchronous-iterators">
<span id="async-iterators"></span><h3 class="translated"><span class="section-number">3.4.3. </span>Iteradores asíncronos<a class="headerlink" href="#asynchronous-iterators" title="Link to this heading">¶</a></h3>
<p class="translated">Un <em>iterador asíncrono</em> puede llamar código asíncrono en su método <code class="docutils literal notranslate"><span class="pre">__anext__</span></code>.</p>
<p class="translated">Iteradores asíncronos pueden ser utilizados en la declaración <a class="reference internal" href="compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>.</p>
<p class="untranslated">The <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> class itself does not provide these methods.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__aiter__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__aiter__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aiter__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Debe retornar un objeto de <em>iterador asíncrono</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__anext__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__anext__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__anext__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">Debe retornar un <em>esperable</em> (awaitable) resultante en el siguiente valor del iterador. Debe levantar una excepción <a class="reference internal" href="../library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a> cuando la iteración termina.</p>
</dd></dl>

<p class="translated">Un ejemplo de objeto iterable asíncrono:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Reader</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="fm">__anext__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopAsyncIteration</span>
        <span class="k">return</span> <span class="n">val</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Distinto en la versión 3.7: </span>Antes de Python 3.7, <a class="reference internal" href="#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> podía retornar un <em>awaitable</em> que se resolvería en un <a class="reference internal" href="../glossary.html#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a>.</p>
<p class="translated">A partir de Python 3.7, <a class="reference internal" href="#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> debe retornar un objeto iterador asincrónico. Retornar cualquier otra cosa resultará en un error <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p>
</div>
</section>
<section id="asynchronous-context-managers">
<span id="async-context-managers"></span><h3 class="translated"><span class="section-number">3.4.4. </span>Gestores de contexto asíncronos<a class="headerlink" href="#asynchronous-context-managers" title="Link to this heading">¶</a></h3>
<p class="translated">Un <em>gestor de contexto asíncrono</em> es un <em>gestor de contexto</em> que puede suspender la ejecución en sus métodos <code class="docutils literal notranslate"><span class="pre">__aenter__</span></code> y <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code>.</p>
<p class="translated">Los gestores de contexto asíncronos pueden ser utilizados en una declaración <a class="reference internal" href="compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>.</p>
<p class="untranslated">The <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> class itself does not provide these methods.</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__aenter__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__aenter__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aenter__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Semantically similar to <a class="reference internal" href="#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a>, the only
difference being that it must return an <em>awaitable</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__aexit__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__aexit__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exc_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traceback</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__aexit__" title="Link to this definition">¶</a></dt>
<dd><p class="untranslated">Semantically similar to <a class="reference internal" href="#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a>, the only
difference being that it must return an <em>awaitable</em>.</p>
</dd></dl>

<p class="translated">Un ejemplo de una clase de gestor de contexto asíncrono:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">AsyncContextManager</span><span class="p">:</span>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="fm">__aenter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;entering context&#39;</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="fm">__aexit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">log</span><span class="p">(</span><span class="s1">&#39;exiting context&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.5.</span></p>
</div>
<p class="translated rubric">Notas a pie de página</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id20" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p class="translated">Es posible cambiar en algunos casos un tipo de objeto bajo ciertas circunstancias controladas. Generalmente no es buena idea, ya que esto puede llevar a un comportamiento bastante extraño de no ser tratado correctamente.</p>
</aside>
<aside class="footnote brackets" id="id21" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">2</a><span class="fn-bracket">]</span></span>
<p class="untranslated">The <a class="reference internal" href="#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a>, <a class="reference internal" href="#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>,
<a class="reference internal" href="#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a>, <a class="reference internal" href="#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>,
<a class="reference internal" href="#object.__class_getitem__" title="object.__class_getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__class_getitem__()</span></code></a> and <a class="reference internal" href="../library/os.html#os.PathLike.__fspath__" title="os.PathLike.__fspath__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__fspath__()</span></code></a>
methods have special handling for this. Others
will still raise a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, but may do so by relying on
the behavior that <code class="docutils literal notranslate"><span class="pre">None</span></code> is not callable.</p>
</aside>
<aside class="footnote brackets" id="id22" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id16">3</a><span class="fn-bracket">]</span></span>
<p class="untranslated">«Does not support» here means that the class has no such method, or
the method returns <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>.  Do not set the method to
<code class="docutils literal notranslate"><span class="pre">None</span></code> if you want to force fallback to the right operand’s reflected
method—that will instead have the opposite effect of explicitly
<em>blocking</em> such fallback.</p>
</aside>
<aside class="footnote brackets" id="id23" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">4</a><span class="fn-bracket">]</span></span>
<p class="untranslated">For operands of the same type, it is assumed that if the non-reflected method
(such as <a class="reference internal" href="#object.__add__" title="object.__add__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__add__()</span></code></a>) fails then the operation is not supported, which is why the
reflected method is not called.</p>
</aside>
<aside class="footnote brackets" id="id24" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">5</a><span class="fn-bracket">]</span></span>
<p class="untranslated">If the right operand’s type is a subclass of the left operand’s type, the
reflected method having precedence allows subclasses to override their ancestors”
operations.</p>
</aside>
</aside>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">3. Modelo de datos</a><ul>
<li><a class="reference internal" href="#objects-values-and-types">3.1. Objetos, valores y tipos</a></li>
<li><a class="reference internal" href="#the-standard-type-hierarchy">3.2. Jerarquía de tipos estándar</a><ul>
<li><a class="reference internal" href="#none">3.2.1. None</a></li>
<li><a class="reference internal" href="#notimplemented">3.2.2. NotImplemented</a></li>
<li><a class="reference internal" href="#ellipsis">3.2.3. Elipsis</a></li>
<li><a class="reference internal" href="#numbers-number">3.2.4. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Number</span></code></a><ul>
<li><a class="reference internal" href="#numbers-integral">3.2.4.1. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Integral</span></code></a></li>
<li><a class="reference internal" href="#numbers-real-float">3.2.4.2. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Real</span></code> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>)</a></li>
<li><a class="reference internal" href="#numbers-complex-complex">3.2.4.3. <code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Complex</span></code> (<code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequences">3.2.5. Secuencias</a><ul>
<li><a class="reference internal" href="#immutable-sequences">3.2.5.1. Secuencias inmutables</a></li>
<li><a class="reference internal" href="#mutable-sequences">3.2.5.2. Secuencias mutables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#set-types">3.2.6. Tipos de conjuntos</a></li>
<li><a class="reference internal" href="#mappings">3.2.7. Mapeos</a><ul>
<li><a class="reference internal" href="#dictionaries">3.2.7.1. Diccionarios</a></li>
</ul>
</li>
<li><a class="reference internal" href="#callable-types">3.2.8. Tipos invocables</a><ul>
<li><a class="reference internal" href="#user-defined-functions">3.2.8.1. Funciones definidas por el usuario</a><ul>
<li><a class="reference internal" href="#special-read-only-attributes">3.2.8.1.1. Special read-only attributes</a></li>
<li><a class="reference internal" href="#special-writable-attributes">3.2.8.1.2. Special writable attributes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#instance-methods">3.2.8.2. Métodos de instancia</a></li>
<li><a class="reference internal" href="#generator-functions">3.2.8.3. Funciones generadoras</a></li>
<li><a class="reference internal" href="#coroutine-functions">3.2.8.4. Funciones de corrutina</a></li>
<li><a class="reference internal" href="#asynchronous-generator-functions">3.2.8.5. Funciones generadoras asincrónicas</a></li>
<li><a class="reference internal" href="#built-in-functions">3.2.8.6. Funciones incorporadas</a></li>
<li><a class="reference internal" href="#built-in-methods">3.2.8.7. Métodos incorporados</a></li>
<li><a class="reference internal" href="#classes">3.2.8.8. Clases</a></li>
<li><a class="reference internal" href="#class-instances">3.2.8.9. Instancias de clases</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modules">3.2.9. Módulos</a><ul>
<li><a class="reference internal" href="#import-related-attributes-on-module-objects">3.2.9.1. Import-related attributes on module objects</a></li>
<li><a class="reference internal" href="#other-writable-attributes-on-module-objects">3.2.9.2. Other writable attributes on module objects</a></li>
<li><a class="reference internal" href="#module-dictionaries">3.2.9.3. Module dictionaries</a></li>
</ul>
</li>
<li><a class="reference internal" href="#custom-classes">3.2.10. Clases personalizadas</a><ul>
<li><a class="reference internal" href="#special-attributes">3.2.10.1. Special attributes</a></li>
<li><a class="reference internal" href="#special-methods">3.2.10.2. Special methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">3.2.11. Instancias de clase</a><ul>
<li><a class="reference internal" href="#id5">3.2.11.1. Special attributes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#i-o-objects-also-known-as-file-objects">3.2.12. Objetos E/S (también conocidos como objetos de archivo)</a></li>
<li><a class="reference internal" href="#internal-types">3.2.13. Tipos internos</a><ul>
<li><a class="reference internal" href="#code-objects">3.2.13.1. Objetos de código</a><ul>
<li><a class="reference internal" href="#index-64">3.2.13.1.1. Special read-only attributes</a></li>
<li><a class="reference internal" href="#methods-on-code-objects">3.2.13.1.2. Methods on code objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#frame-objects">3.2.13.2. Objetos de marco</a><ul>
<li><a class="reference internal" href="#index-70">3.2.13.2.1. Special read-only attributes</a></li>
<li><a class="reference internal" href="#index-71">3.2.13.2.2. Special writable attributes</a></li>
<li><a class="reference internal" href="#frame-object-methods">3.2.13.2.3. Frame object methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#traceback-objects">3.2.13.3. Objetos de seguimiento de pila (traceback)</a></li>
<li><a class="reference internal" href="#slice-objects">3.2.13.4. Objetos de segmento (Slice objects)</a></li>
<li><a class="reference internal" href="#static-method-objects">3.2.13.5. Objetos de método estático</a></li>
<li><a class="reference internal" href="#class-method-objects">3.2.13.6. Objetos de método de clase</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#special-method-names">3.3. Nombres especiales de método</a><ul>
<li><a class="reference internal" href="#basic-customization">3.3.1. Personalización básica</a></li>
<li><a class="reference internal" href="#customizing-attribute-access">3.3.2. Personalizando acceso a atributos</a><ul>
<li><a class="reference internal" href="#customizing-module-attribute-access">3.3.2.1. Personalizando acceso a atributos de módulo</a></li>
<li><a class="reference internal" href="#implementing-descriptors">3.3.2.2. Implementando descriptores</a></li>
<li><a class="reference internal" href="#invoking-descriptors">3.3.2.3. Invocando descriptores</a></li>
<li><a class="reference internal" href="#slots">3.3.2.4. __slots__</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-class-creation">3.3.3. Personalización de creación de clases</a><ul>
<li><a class="reference internal" href="#metaclasses">3.3.3.1. Metaclases</a></li>
<li><a class="reference internal" href="#resolving-mro-entries">3.3.3.2. Resolviendo entradas de la Orden de Resolución de Métodos (MRU)</a></li>
<li><a class="reference internal" href="#determining-the-appropriate-metaclass">3.3.3.3. Determinando la metaclase adecuada</a></li>
<li><a class="reference internal" href="#preparing-the-class-namespace">3.3.3.4. Preparando el espacio de nombres de la clase</a></li>
<li><a class="reference internal" href="#executing-the-class-body">3.3.3.5. Ejecutando el cuerpo de la clase</a></li>
<li><a class="reference internal" href="#creating-the-class-object">3.3.3.6. Creando el objeto de clase</a></li>
<li><a class="reference internal" href="#uses-for-metaclasses">3.3.3.7. Usos para metaclases</a></li>
</ul>
</li>
<li><a class="reference internal" href="#customizing-instance-and-subclass-checks">3.3.4. Personalizando revisiones de instancia y subclase</a></li>
<li><a class="reference internal" href="#emulating-generic-types">3.3.5. Emulando tipos genéricos</a><ul>
<li><a class="reference internal" href="#the-purpose-of-class-getitem">3.3.5.1. El propósito de <em>__class_getitem__</em></a></li>
<li><a class="reference internal" href="#class-getitem-versus-getitem">3.3.5.2. <em>__class_getitem__</em> frente a <em>__getitem__</em></a></li>
</ul>
</li>
<li><a class="reference internal" href="#emulating-callable-objects">3.3.6. Emulando objetos que se pueden llamar</a></li>
<li><a class="reference internal" href="#emulating-container-types">3.3.7. Emulando tipos de contenedores</a></li>
<li><a class="reference internal" href="#emulating-numeric-types">3.3.8. Emulando tipos numéricos</a></li>
<li><a class="reference internal" href="#with-statement-context-managers">3.3.9. Gestores de Contexto en la Declaración <em>with</em></a></li>
<li><a class="reference internal" href="#customizing-positional-arguments-in-class-pattern-matching">3.3.10. Personalización de argumentos posicionales en la coincidencia de patrones de clase</a></li>
<li><a class="reference internal" href="#emulating-buffer-types">3.3.11. Emulando tipos de búfer</a></li>
<li><a class="reference internal" href="#annotations">3.3.12. Annotations</a></li>
<li><a class="reference internal" href="#special-method-lookup">3.3.13. Búsqueda de método especial</a></li>
</ul>
</li>
<li><a class="reference internal" href="#coroutines">3.4. Corrutinas</a><ul>
<li><a class="reference internal" href="#awaitable-objects">3.4.1. Objetos esperables</a></li>
<li><a class="reference internal" href="#coroutine-objects">3.4.2. Objetos de corrutina</a></li>
<li><a class="reference internal" href="#asynchronous-iterators">3.4.3. Iteradores asíncronos</a></li>
<li><a class="reference internal" href="#asynchronous-context-managers">3.4.4. Gestores de contexto asíncronos</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="lexical_analysis.html"
                          title="capítulo anterior"><span class="section-number">2. </span>Análisis léxico</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="executionmodel.html"
                          title="próximo capítulo"><span class="section-number">4. </span>Modelo de ejecución</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/reference/datamodel.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Contraer barra lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="executionmodel.html" title="4. Modelo de ejecución"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="lexical_analysis.html" title="2. Análisis léxico"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Referencia del Lenguaje Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3. </span>Modelo de datos</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Derechos de autor</a> 2001 Python Software Foundation.
    <br>
    Ésta página tiene la licencia Python Software Foundation Versión 2.
    <br>
    Ejemplos, guías, y otro código en la documentación están bajo la licencia adicional Zero Clause BSD.
    <br>
    
      Ver <a href="/license.html">Historia y Licencia</a> para más información.<br>
    
    
    <br>

    La Python Software Foundation es una corporación sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor dona.</a>
<br>
    <br>
      Última actualización en oct 06, 2025 (04:51 UTC).
    
      <a href="/bugs.html">Encontraste un bug</a>?
    
    <br>

    Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a>8.2.3.
    </div>

  </body>
</html>