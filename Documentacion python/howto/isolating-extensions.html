<!DOCTYPE html>

<html lang="es" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Aislamiento de módulos de extensión" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/howto/isolating-extensions.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Resumen: Tradicionalmente, el estado perteneciente a los módulos de extensión de Python se mantuvo en las variables C static, que tienen un alcance de todo el proceso. Este documento describe los p..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.15/es/_images/social_previews/summary_howto_isolating-extensions_82225126.png" />
<meta property="og:image:alt" content="Resumen: Tradicionalmente, el estado perteneciente a los módulos de extensión de Python se mantuvo en las variables C static, que tienen un alcance de todo el proceso. Este documento describe los p..." />
<meta name="description" content="Resumen: Tradicionalmente, el estado perteneciente a los módulos de extensión de Python se mantuvo en las variables C static, que tienen un alcance de todo el proceso. Este documento describe los p..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>Aislamiento de módulos de extensión &#8212; documentación de Python - 3.15.0a0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=bf1f176d"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f85f4cfb"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.15.0a0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Derechos de autor" href="../copyright.html" />
    <link rel="next" title="timer file descriptor HOWTO" href="timerfd.html" />
    <link rel="prev" title="Prácticas recomendadas para las anotaciones" href="annotations.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/howto/isolating-extensions.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menú">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Aislamiento de módulos de extensión</a><ul>
<li><a class="reference internal" href="#who-should-read-this">¿Quién debería leer esto?</a></li>
<li><a class="reference internal" href="#background">Trasfondo</a><ul>
<li><a class="reference internal" href="#enter-per-module-state">Ingrese al estado por módulo</a></li>
<li><a class="reference internal" href="#isolated-module-objects">Objetos módulos aislados</a></li>
<li><a class="reference internal" href="#surprising-edge-cases">Casos extremos sorprendentes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#making-modules-safe-with-multiple-interpreters">Cómo hacer que los módulos sean seguros con varios intérpretes</a><ul>
<li><a class="reference internal" href="#managing-global-state">Administrar el estado global</a></li>
<li><a class="reference internal" href="#managing-per-module-state">Administración del estado por módulo</a></li>
<li><a class="reference internal" href="#opt-out-limiting-to-one-module-object-per-process">Exclusión voluntaria: limitación a un objeto de módulo por proceso</a></li>
<li><a class="reference internal" href="#module-state-access-from-functions">Acceso al estado del módulo desde las funciones</a></li>
</ul>
</li>
<li><a class="reference internal" href="#heap-types">Tipos Heap</a><ul>
<li><a class="reference internal" href="#changing-static-types-to-heap-types">Cambio de tipos estáticos a tipos heap</a></li>
<li><a class="reference internal" href="#defining-heap-types">Definición de tipos heap</a></li>
<li><a class="reference internal" href="#garbage-collection-protocol">Protocolo de recolección de basura</a><ul>
<li><a class="reference internal" href="#tp-traverse-in-python-3-8-and-lower"><code class="docutils literal notranslate"><span class="pre">tp_traverse</span></code> in Python 3.8 and lower</a></li>
<li><a class="reference internal" href="#delegating-tp-traverse">Delegating <code class="docutils literal notranslate"><span class="pre">tp_traverse</span></code></a></li>
<li><a class="reference internal" href="#defining-tp-dealloc">Defining <code class="docutils literal notranslate"><span class="pre">tp_dealloc</span></code></a></li>
<li><a class="reference internal" href="#not-overriding-tp-free">Not overriding <code class="docutils literal notranslate"><span class="pre">tp_free</span></code></a></li>
<li><a class="reference internal" href="#avoiding-pyobject-new">Avoiding <code class="docutils literal notranslate"><span class="pre">PyObject_New</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-state-access-from-classes">Acceso al estado del módulo desde las clases</a></li>
<li><a class="reference internal" href="#module-state-access-from-regular-methods">Acceso al estado del módulo desde métodos regulares</a></li>
<li><a class="reference internal" href="#module-state-access-from-slot-methods-getters-and-setters">Acceso al estado del módulo desde métodos de Slot, Getters y Setters</a></li>
<li><a class="reference internal" href="#lifetime-of-the-module-state">Vida útil del estado del módulo</a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-issues">Problemas abiertos</a><ul>
<li><a class="reference internal" href="#per-class-scope">Alcance por clase</a></li>
<li><a class="reference internal" href="#lossless-conversion-to-heap-types">Conversión sin pérdidas a tipos heap</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="annotations.html"
                          title="capítulo anterior">Prácticas recomendadas para las anotaciones</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="timerfd.html"
                          title="próximo capítulo">timer file descriptor HOWTO</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/howto/isolating-extensions.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="timerfd.html" title="timer file descriptor HOWTO"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="annotations.html" title="Prácticas recomendadas para las anotaciones"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Comos (<em>HOWTOs</em>) de Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Aislamiento de módulos de extensión</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="isolating-extension-modules">
<span id="isolating-extensions-howto"></span><h1 class="translated">Aislamiento de módulos de extensión<a class="headerlink" href="#isolating-extension-modules" title="Link to this heading">¶</a></h1>
<aside class="topic">
<p class="translated topic-title">Resumen</p>
<p class="translated">Tradicionalmente, el estado perteneciente a los módulos de extensión de Python se mantuvo en las variables C <code class="docutils literal notranslate"><span class="pre">static</span></code>, que tienen un alcance de todo el proceso. Este documento describe los problemas de dicho estado por proceso y muestra una forma más segura: el estado por módulo.</p>
<p class="translated">El documento también describe cómo cambiar al estado por módulo cuando sea posible. Esta transición implica asignar espacio para ese estado, cambiar potencialmente de tipos estáticos a tipos de montón y, quizás lo más importante, acceder al estado por módulo desde el código.</p>
</aside>
<section id="who-should-read-this">
<h2 class="translated">¿Quién debería leer esto?<a class="headerlink" href="#who-should-read-this" title="Link to this heading">¶</a></h2>
<p class="translated">Esta guía está escrita para los mantenedores de extensiones <a class="reference internal" href="../c-api/index.html#c-api-index"><span class="std std-ref">C-API</span></a> que deseen hacer que esa extensión sea más segura para usar en aplicaciones donde Python se usa como biblioteca.</p>
</section>
<section id="background">
<h2 class="translated">Trasfondo<a class="headerlink" href="#background" title="Link to this heading">¶</a></h2>
<p class="translated">Un intérprete (<em>interpreter</em>) es el contexto en el que se ejecuta el código de Python. Contiene la configuración (p. ej., la ruta de importación) y el estado de tiempo de ejecución (p. ej., el conjunto de módulos importados).</p>
<p class="translated">Python admite la ejecución de varios intérpretes en un solo proceso. Hay dos casos en los que pensar, los usuarios pueden ejecutar intérpretes:</p>
<ul class="simple">
<li><p class="translated">en secuencia, con varios ciclos <a class="reference internal" href="../c-api/init.html#c.Py_InitializeEx" title="Py_InitializeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_InitializeEx()</span></code></a>/<a class="reference internal" href="../c-api/init.html#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a>, y</p></li>
<li><p class="translated">en paralelo, gestionando «subintérpretes» mediante <a class="reference internal" href="../c-api/init.html#c.Py_NewInterpreter" title="Py_NewInterpreter"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreter()</span></code></a>/<a class="reference internal" href="../c-api/init.html#c.Py_EndInterpreter" title="Py_EndInterpreter"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_EndInterpreter()</span></code></a>.</p></li>
</ul>
<p class="translated">Ambos casos (y combinaciones de ellos) serían más útiles al incorporar Python dentro de una biblioteca. Las bibliotecas generalmente no deben hacer suposiciones sobre la aplicación que las usa, lo que incluye asumir un «intérprete principal de Python» en todo el proceso.</p>
<p class="translated">Históricamente, los módulos de extensión de Python no manejan bien este caso de uso. Muchos módulos de extensión (e incluso algunos módulos stdlib) usan el estado global <em>por-proceso</em>, porque las variables C <code class="docutils literal notranslate"><span class="pre">static</span></code> son extremadamente fáciles de usar. Así, los datos que deberían ser específicos de un intérprete acaban siendo compartidos entre intérpretes. A menos que el desarrollador de la extensión tenga cuidado, es muy fácil introducir casos extremos que provocan bloqueos cuando un módulo se carga en más de un intérprete en el mismo proceso.</p>
<p class="translated">Desafortunadamente, el estado <em>por-intérprete</em> no es fácil de lograr. Los autores de extensiones tienden a no tener en cuenta múltiples intérpretes cuando desarrollan, y actualmente es engorroso probar el comportamiento.</p>
<section id="enter-per-module-state">
<h3 class="translated">Ingrese al estado por módulo<a class="headerlink" href="#enter-per-module-state" title="Link to this heading">¶</a></h3>
<p class="untranslated">Instead of focusing on per-interpreter state, Python’s C API is evolving
to better support the more granular <em>per-module</em> state.
This means that C-level data should be attached to a <em>module object</em>.
Each interpreter creates its own module object, keeping the data separate.
For testing the isolation, multiple module objects corresponding to a single
extension can even be loaded in a single interpreter.</p>
<p class="translated">El estado por módulo proporciona una manera fácil de pensar en la vida útil y la propiedad de los recursos: el módulo de extensión se inicializará cuando se cree un objeto de módulo y se limpiará cuando se libere. En este sentido, un módulo es como cualquier otro <span class="c-expr sig sig-inline c"><a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>; no hay ganchos de «apagado del intérprete» para pensar u olvidar.</p>
<p class="translated">Tenga en cuenta que hay casos de uso para diferentes tipos de «globales»: por proceso, por intérprete, por subproceso o por estado de tarea. Con el estado por módulo como predeterminado, estos aún son posibles, pero debe tratarlos como casos excepcionales: si los necesita, debe brindarles atención y pruebas adicionales. (Tenga en cuenta que esta guía no los cubre).</p>
</section>
<section id="isolated-module-objects">
<h3 class="translated">Objetos módulos aislados<a class="headerlink" href="#isolated-module-objects" title="Link to this heading">¶</a></h3>
<p class="translated">El punto clave a tener en cuenta al desarrollar un módulo de extensión es que se pueden crear varios objetos de módulo a partir de una única biblioteca compartida. Por ejemplo:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">binascii</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_binascii</span> <span class="o">=</span> <span class="n">binascii</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s1">&#39;binascii&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">binascii</span>  <span class="c1"># create a new module object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old_binascii</span> <span class="o">==</span> <span class="n">binascii</span>
<span class="go">False</span>
</pre></div>
</div>
<p class="translated">Como regla general, los dos módulos deben ser completamente independientes. Todos los objetos y el estado específico del módulo deben encapsularse dentro del objeto del módulo, no compartirse con otros objetos del módulo y limpiarse cuando se desasigna el objeto del módulo. Dado que esto es solo una regla general, las excepciones son posibles (consulte <a class="reference internal" href="#managing-global-state">Managing Global State</a>), pero necesitarán más reflexión y atención en los casos extremos.</p>
<p class="translated">Si bien algunos módulos podrían funcionar con restricciones menos estrictas, los módulos aislados facilitan el establecimiento de expectativas y pautas claras que funcionan en una variedad de casos de uso.</p>
</section>
<section id="surprising-edge-cases">
<h3 class="translated">Casos extremos sorprendentes<a class="headerlink" href="#surprising-edge-cases" title="Link to this heading">¶</a></h3>
<p class="translated">Tenga en cuenta que los módulos aislados crean algunos casos extremos sorprendentes. En particular, cada objeto de módulo normalmente no compartirá sus clases y excepciones con otros módulos similares. Continuando con <a class="reference internal" href="#isolated-module-objects">example above</a>, tenga en cuenta que <code class="docutils literal notranslate"><span class="pre">old_binascii.Error</span></code> y <code class="docutils literal notranslate"><span class="pre">binascii.Error</span></code> son objetos separados. En el código siguiente, se detecta la excepción <em>not</em>:</p>
<div class="untranslated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">old_binascii</span><span class="o">.</span><span class="n">Error</span> <span class="o">==</span> <span class="n">binascii</span><span class="o">.</span><span class="n">Error</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">old_binascii</span><span class="o">.</span><span class="n">unhexlify</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;qwertyuiop&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="n">binascii</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;boo&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">binascii.Error</span>: <span class="n">Non-hexadecimal digit found</span>
</pre></div>
</div>
<p class="translated">Esto se espera. Tenga en cuenta que los módulos de Python puro se comportan de la misma manera: es una parte de cómo funciona Python.</p>
<p class="translated">El objetivo es hacer que los módulos de extensión sean seguros en el nivel C, no hacer que los piratas informáticos se comporten de manera intuitiva. Mutar <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> «manualmente» cuenta como un hack.</p>
</section>
</section>
<section id="making-modules-safe-with-multiple-interpreters">
<h2 class="translated">Cómo hacer que los módulos sean seguros con varios intérpretes<a class="headerlink" href="#making-modules-safe-with-multiple-interpreters" title="Link to this heading">¶</a></h2>
<section id="managing-global-state">
<h3 class="translated">Administrar el estado global<a class="headerlink" href="#managing-global-state" title="Link to this heading">¶</a></h3>
<p class="translated">A veces, el estado asociado con un módulo de Python no es específico de ese módulo, sino de todo el proceso (o algo más «más global» que un módulo). Por ejemplo:</p>
<ul class="simple">
<li><p class="translated">El módulo <code class="docutils literal notranslate"><span class="pre">readline</span></code> gestiona <em>el</em> terminal.</p></li>
<li><p class="translated">Un módulo que se ejecuta en una placa de circuito quiere controlar <em>el</em> LED integrado.</p></li>
</ul>
<p class="translated">En estos casos, el módulo Python debería proporcionar <em>acceso</em> al estado global, en lugar de <em>poseerlo</em>. Si es posible, escriba el módulo para que varias copias del mismo puedan acceder al estado de forma independiente (junto con otras bibliotecas, ya sea para Python u otros lenguajes). Si eso no es posible, considere el bloqueo explícito.</p>
<p class="untranslated">If it is necessary to use process-global state, the simplest way to
avoid issues with multiple interpreters is to explicitly prevent a
module from being loaded more than once per process—see
<a class="reference internal" href="#isolating-extensions-optout"><span class="std std-ref">Exclusión voluntaria: limitación a un objeto de módulo por proceso</span></a>.</p>
</section>
<section id="managing-per-module-state">
<h3 class="translated">Administración del estado por módulo<a class="headerlink" href="#managing-per-module-state" title="Link to this heading">¶</a></h3>
<p class="translated">Para usar el estado por módulo, use <a class="reference internal" href="../c-api/extension-modules.html#multi-phase-initialization"><span class="std std-ref">multi-phase extension module initialization</span></a>. Esto indica que su módulo admite múltiples intérpretes correctamente.</p>
<p class="translated">Establezca <code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_size</span></code> en un número positivo para solicitar tantos bytes de almacenamiento local para el módulo. Por lo general, esto se establecerá en el tamaño de algún <code class="docutils literal notranslate"><span class="pre">struct</span></code> específico del módulo, que puede almacenar todo el estado de nivel C del módulo. En particular, es donde debe colocar los punteros a las clases (incluidas las excepciones, pero excluyendo los tipos estáticos) y configuraciones (por ejemplo, <a class="reference internal" href="../library/csv.html#csv.field_size_limit" title="csv.field_size_limit"><code class="xref py py-data docutils literal notranslate"><span class="pre">field_size_limit</span></code></a> de <code class="docutils literal notranslate"><span class="pre">csv</span></code>) que el código C necesita para funcionar.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Otra opción es almacenar el estado en el <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> del módulo, pero debe evitar fallas cuando los usuarios modifican <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> desde el código de Python. Esto generalmente significa verificación de errores y tipos en el nivel C, que es fácil equivocarse y difícil de probar lo suficiente.</p>
<p class="translated">Sin embargo, si el estado del módulo no es necesario en el código C, almacenarlo solo en <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> es una buena idea.</p>
</div>
<p class="translated">Si el estado del módulo incluye punteros <code class="docutils literal notranslate"><span class="pre">PyObject</span></code>, el objeto del módulo debe contener referencias a esos objetos e implementar los enlaces de nivel de módulo <code class="docutils literal notranslate"><span class="pre">m_traverse</span></code>, <code class="docutils literal notranslate"><span class="pre">m_clear</span></code> y <code class="docutils literal notranslate"><span class="pre">m_free</span></code>. Estos funcionan como <code class="docutils literal notranslate"><span class="pre">tp_traverse</span></code>, <code class="docutils literal notranslate"><span class="pre">tp_clear</span></code> y <code class="docutils literal notranslate"><span class="pre">tp_free</span></code> de una clase. Agregarlos requerirá algo de trabajo y hará que el código sea más largo; este es el precio de los módulos que se pueden descargar limpiamente.</p>
<p class="translated">Un ejemplo de un módulo con estado por módulo está actualmente disponible como <a class="reference external" href="https://github.com/python/cpython/blob/master/Modules/xxlimited.c">xxlimited</a>; ejemplo de inicialización del módulo que se muestra en la parte inferior del archivo.</p>
</section>
<section id="opt-out-limiting-to-one-module-object-per-process">
<span id="isolating-extensions-optout"></span><h3 class="translated">Exclusión voluntaria: limitación a un objeto de módulo por proceso<a class="headerlink" href="#opt-out-limiting-to-one-module-object-per-process" title="Link to this heading">¶</a></h3>
<p class="translated">Un <code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_size</span></code> no negativo indica que un módulo admite varios intérpretes correctamente. Si este aún no es el caso de su módulo, puede hacer que su módulo se pueda cargar explícitamente solo una vez por proceso. Por ejemplo:</p>
<div class="untranslated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// A process-wide flag</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">loaded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// Mutex to provide thread safety (only needed for free-threaded Python)</span>
<span class="k">static</span><span class="w"> </span><span class="n">PyMutex</span><span class="w"> </span><span class="n">modinit_mutex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">exec_module</span><span class="p">(</span><span class="n">PyObject</span><span class="o">*</span><span class="w"> </span><span class="n">module</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyMutex_Lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">modinit_mutex</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">loaded</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyMutex_Unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">modinit_mutex</span><span class="p">);</span>
<span class="w">        </span><span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_ImportError</span><span class="p">,</span>
<span class="w">                        </span><span class="s">&quot;cannot load module more than once per process&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">loaded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyMutex_Unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">modinit_mutex</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// ... rest of initialization</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="untranslated">If your module’s <a class="reference internal" href="../c-api/module.html#c.PyModuleDef.m_clear" title="PyModuleDef.m_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyModuleDef.m_clear</span></code></a> function is able to prepare
for future re-initialization, it should clear the <code class="docutils literal notranslate"><span class="pre">loaded</span></code> flag.
In this case, your module won’t support multiple instances existing
<em>concurrently</em>, but it will, for example, support being loaded after
Python runtime shutdown (<a class="reference internal" href="../c-api/init.html#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a>) and re-initialization
(<a class="reference internal" href="../c-api/init.html#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>).</p>
</section>
<section id="module-state-access-from-functions">
<h3 class="translated">Acceso al estado del módulo desde las funciones<a class="headerlink" href="#module-state-access-from-functions" title="Link to this heading">¶</a></h3>
<p class="translated">Acceder al estado desde funciones a nivel de módulo es sencillo. Las funciones obtienen el objeto del módulo como su primer argumento; para extraer el estado, puede usar <code class="docutils literal notranslate"><span class="pre">PyModule_GetState</span></code>:</p>
<div class="untranslated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">func</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">my_struct</span><span class="w"> </span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">my_struct</span><span class="o">*</span><span class="p">)</span><span class="n">PyModule_GetState</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// ... rest of logic</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">PyModule_GetState</span></code> puede retornar <code class="docutils literal notranslate"><span class="pre">NULL</span></code> sin establecer una excepción si no hay un estado de módulo, es decir, <code class="docutils literal notranslate"><span class="pre">PyModuleDef.m_size</span></code> era cero. En su propio módulo, tiene el control de <code class="docutils literal notranslate"><span class="pre">m_size</span></code>, por lo que es fácil de evitar.</p>
</div>
</section>
</section>
<section id="heap-types">
<h2 class="translated">Tipos Heap<a class="headerlink" href="#heap-types" title="Link to this heading">¶</a></h2>
<p class="translated">Tradicionalmente, los tipos definidos en código C son <em>estáticos</em>; es decir, estructuras <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">PyTypeObject</span></code> definidas directamente en el código e inicializadas mediante <code class="docutils literal notranslate"><span class="pre">PyType_Ready()</span></code>.</p>
<p class="translated">Tales tipos son necesariamente compartidos a lo largo del proceso. Compartirlos entre objetos de módulo requiere prestar atención a cualquier estado que posean o al que accedan. Para limitar los posibles problemas, los tipos estáticos son inmutables en el nivel de Python: por ejemplo, no puede configurar <code class="docutils literal notranslate"><span class="pre">str.myattribute</span> <span class="pre">=</span> <span class="pre">123</span></code>.</p>
<div class="impl-detail compound">
<p class="translated">Compartir objetos verdaderamente inmutables entre intérpretes está bien, siempre que no proporcionen acceso a objetos mutables. Sin embargo, en CPython, cada objeto de Python tiene un detalle de implementación mutable: el recuento de referencias. Los cambios en el refcount están protegidos por el GIL. Por lo tanto, el código que comparte cualquier objeto de Python entre intérpretes depende implícitamente del GIL actual de todo el proceso de CPython.</p>
</div>
<p class="translated">Debido a que son inmutables y globales de proceso, los tipos estáticos no pueden acceder a «su» estado de módulo. Si algún método de este tipo requiere acceso al estado del módulo, el tipo debe convertirse a <em>tipo almacenado en memoria dinámica (heap)</em> o <em>tipo heap</em> para abreviar. Estos se corresponden más estrechamente con las clases creadas por la instrucción <code class="docutils literal notranslate"><span class="pre">class</span></code> de Python.</p>
<p class="translated">Para los módulos nuevos, usar tipos heap de forma predeterminada es una buena regla general.</p>
<section id="changing-static-types-to-heap-types">
<h3 class="translated">Cambio de tipos estáticos a tipos heap<a class="headerlink" href="#changing-static-types-to-heap-types" title="Link to this heading">¶</a></h3>
<p class="translated">Los tipos estáticos se pueden convertir en tipos heap, pero tenga en cuenta que la API de tipo heap no se diseñó para la conversión «sin pérdidas» de tipos estáticos, es decir, para crear un tipo que funcione exactamente como un tipo estático determinado. Por lo tanto, al reescribir la definición de clase en una nueva API, es probable que cambie sin querer algunos detalles (por ejemplo, capacidad de selección o espacios heredados). Siempre pruebe los detalles que son importantes para usted.</p>
<p class="translated">Tenga cuidado con los siguientes dos puntos en particular (pero tenga en cuenta que esta no es una lista completa):</p>
<ul class="simple">
<li><p class="untranslated">Unlike static types, heap type objects are mutable by default.
Use the <a class="reference internal" href="../c-api/typeobj.html#c.Py_TPFLAGS_IMMUTABLETYPE" title="Py_TPFLAGS_IMMUTABLETYPE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_IMMUTABLETYPE</span></code></a> flag to prevent mutability.</p></li>
<li><p class="untranslated">Heap types inherit <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> by default,
so it may become possible to instantiate them from Python code.
You can prevent this with the <a class="reference internal" href="../c-api/typeobj.html#c.Py_TPFLAGS_DISALLOW_INSTANTIATION" title="Py_TPFLAGS_DISALLOW_INSTANTIATION"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_DISALLOW_INSTANTIATION</span></code></a> flag.</p></li>
</ul>
</section>
<section id="defining-heap-types">
<h3 class="translated">Definición de tipos heap<a class="headerlink" href="#defining-heap-types" title="Link to this heading">¶</a></h3>
<p class="translated">Los tipos heap se pueden crear completando una estructura <a class="reference internal" href="../c-api/type.html#c.PyType_Spec" title="PyType_Spec"><code class="xref c c-struct docutils literal notranslate"><span class="pre">PyType_Spec</span></code></a>, una descripción o «modelo» de una clase y llamando a <a class="reference internal" href="../c-api/type.html#c.PyType_FromModuleAndSpec" title="PyType_FromModuleAndSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromModuleAndSpec()</span></code></a> para construir un nuevo objeto de clase.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Otras funciones, como <a class="reference internal" href="../c-api/type.html#c.PyType_FromSpec" title="PyType_FromSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromSpec()</span></code></a>, también pueden crear tipos heap, pero <a class="reference internal" href="../c-api/type.html#c.PyType_FromModuleAndSpec" title="PyType_FromModuleAndSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromModuleAndSpec()</span></code></a> asocia el módulo con la clase, lo que permite el acceso al estado del módulo desde los métodos.</p>
</div>
<p class="translated">La clase generalmente debe almacenarse en <em>ambos</em>, el estado del módulo (para acceso seguro desde C) y el <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> del módulo (para acceso desde código Python).</p>
</section>
<section id="garbage-collection-protocol">
<h3 class="translated">Protocolo de recolección de basura<a class="headerlink" href="#garbage-collection-protocol" title="Link to this heading">¶</a></h3>
<p class="translated">Las instancias de tipos heap contienen una referencia a su tipo. Esto garantiza que el tipo no se destruya antes de que se destruyan todas sus instancias, pero puede generar ciclos de referencia que el recolector de elementos no utilizados debe interrumpir.</p>
<p class="translated">Para evitar pérdidas de memoria, las instancias de los tipos heap deben implementar el protocolo de recolección de elementos no utilizados. Es decir, los tipos heap deben:</p>
<ul class="simple">
<li><p class="untranslated">Have the <a class="reference internal" href="../c-api/typeobj.html#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> flag.</p></li>
<li><p class="untranslated">Define a traverse function using <code class="docutils literal notranslate"><span class="pre">Py_tp_traverse</span></code>, which
visits the type (e.g. using <code class="docutils literal notranslate"><span class="pre">Py_VISIT(Py_TYPE(self))</span></code>).</p></li>
</ul>
<p class="untranslated">Please refer to the documentation of
<a class="reference internal" href="../c-api/typeobj.html#c.Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> and <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a>
for additional considerations.</p>
<p class="untranslated">The API for defining heap types grew organically, leaving it
somewhat awkward to use in its current state.
The following sections will guide you through common issues.</p>
<section id="tp-traverse-in-python-3-8-and-lower">
<h4 class="untranslated"><code class="docutils literal notranslate"><span class="pre">tp_traverse</span></code> in Python 3.8 and lower<a class="headerlink" href="#tp-traverse-in-python-3-8-and-lower" title="Link to this heading">¶</a></h4>
<p class="untranslated">The requirement to visit the type from <code class="docutils literal notranslate"><span class="pre">tp_traverse</span></code> was added in Python 3.9.
If you support Python 3.8 and lower, the traverse function must <em>not</em>
visit the type, so it must be more complicated:</p>
<div class="untranslated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">my_traverse</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">visitproc</span><span class="w"> </span><span class="n">visit</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Py_Version</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mh">0x03090000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Py_VISIT</span><span class="p">(</span><span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="untranslated">Unfortunately, <a class="reference internal" href="../c-api/apiabiversion.html#c.Py_Version" title="Py_Version"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_Version</span></code></a> was only added in Python 3.11.
As a replacement, use:</p>
<ul class="simple">
<li><p class="untranslated"><a class="reference internal" href="../c-api/apiabiversion.html#c.PY_VERSION_HEX" title="PY_VERSION_HEX"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PY_VERSION_HEX</span></code></a>, if not using the stable ABI, or</p></li>
<li><p class="untranslated"><a class="reference internal" href="../library/sys.html#sys.version_info" title="sys.version_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.version_info</span></code></a> (via <a class="reference internal" href="../c-api/sys.html#c.PySys_GetObject" title="PySys_GetObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_GetObject()</span></code></a> and
<a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>).</p></li>
</ul>
</section>
<section id="delegating-tp-traverse">
<h4 class="untranslated">Delegating <code class="docutils literal notranslate"><span class="pre">tp_traverse</span></code><a class="headerlink" href="#delegating-tp-traverse" title="Link to this heading">¶</a></h4>
<p class="untranslated">If your traverse function delegates to the <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_traverse</span></code></a>
of its base class (or another type), ensure that <code class="docutils literal notranslate"><span class="pre">Py_TYPE(self)</span></code> is visited
only once.
Note that only heap type are expected to visit the type in <code class="docutils literal notranslate"><span class="pre">tp_traverse</span></code>.</p>
<p class="translated">Por ejemplo, si su función poligonal incluye:</p>
<div class="untranslated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tp_traverse</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">visit</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">…y <code class="docutils literal notranslate"><span class="pre">base</span></code> puede ser un tipo estático, entonces también debe incluir:</p>
<div class="untranslated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">tp_flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">Py_TPFLAGS_HEAPTYPE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// a heap type&#39;s tp_traverse already visited Py_TYPE(self)</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Py_Version</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mh">0x03090000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Py_VISIT</span><span class="p">(</span><span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="untranslated">It is not necessary to handle the type’s reference count in
<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> and <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_clear</span></code></a>.</p>
</section>
<section id="defining-tp-dealloc">
<h4 class="untranslated">Defining <code class="docutils literal notranslate"><span class="pre">tp_dealloc</span></code><a class="headerlink" href="#defining-tp-dealloc" title="Link to this heading">¶</a></h4>
<p class="untranslated">If your type has a custom <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_dealloc</span></code></a> function,
it needs to:</p>
<ul class="simple">
<li><p class="untranslated">call <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_UnTrack()</span></code></a> before any fields are invalidated, and</p></li>
<li><p class="untranslated">decrement the reference count of the type.</p></li>
</ul>
<p class="untranslated">To keep the type valid while <code class="docutils literal notranslate"><span class="pre">tp_free</span></code> is called, the type’s refcount needs
to be decremented <em>after</em> the instance is deallocated. For example:</p>
<div class="untranslated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_dealloc</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PyObject_GC_UnTrack</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">    </span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_free</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_DECREF</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="untranslated">The default <code class="docutils literal notranslate"><span class="pre">tp_dealloc</span></code> function does this, so
if your type does <em>not</em> override
<code class="docutils literal notranslate"><span class="pre">tp_dealloc</span></code> you don’t need to add it.</p>
</section>
<section id="not-overriding-tp-free">
<h4 class="untranslated">Not overriding <code class="docutils literal notranslate"><span class="pre">tp_free</span></code><a class="headerlink" href="#not-overriding-tp-free" title="Link to this heading">¶</a></h4>
<p class="untranslated">The <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_free" title="PyTypeObject.tp_free"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_free</span></code></a> slot of a heap type must be set to
<a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_Del" title="PyObject_GC_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Del()</span></code></a>.
This is the default; do not override it.</p>
</section>
<section id="avoiding-pyobject-new">
<h4 class="untranslated">Avoiding <code class="docutils literal notranslate"><span class="pre">PyObject_New</span></code><a class="headerlink" href="#avoiding-pyobject-new" title="Link to this heading">¶</a></h4>
<p class="untranslated">GC-tracked objects need to be allocated using GC-aware functions.</p>
<p class="untranslated">If you use <a class="reference internal" href="../c-api/allocation.html#c.PyObject_New" title="PyObject_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_New()</span></code></a> or <a class="reference internal" href="../c-api/allocation.html#c.PyObject_NewVar" title="PyObject_NewVar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_NewVar()</span></code></a>:</p>
<ul>
<li><p class="untranslated">Get and call type’s <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_alloc" title="PyTypeObject.tp_alloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_alloc</span></code></a> slot, if possible.
That is, replace <code class="docutils literal notranslate"><span class="pre">TYPE</span> <span class="pre">*o</span> <span class="pre">=</span> <span class="pre">PyObject_New(TYPE,</span> <span class="pre">typeobj)</span></code> with:</p>
<div class="untranslated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">TYPE</span><span class="w"> </span><span class="o">*</span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">typeobj</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">typeobj</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p class="untranslated">Replace <code class="docutils literal notranslate"><span class="pre">o</span> <span class="pre">=</span> <span class="pre">PyObject_NewVar(TYPE,</span> <span class="pre">typeobj,</span> <span class="pre">size)</span></code> with the same,
but use size instead of the 0.</p>
</li>
<li><p class="untranslated">If the above is not possible (e.g. inside a custom <code class="docutils literal notranslate"><span class="pre">tp_alloc</span></code>),
call <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_New()</span></code></a> or <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_NewVar()</span></code></a>:</p>
<div class="untranslated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">TYPE</span><span class="w"> </span><span class="o">*</span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyObject_GC_New</span><span class="p">(</span><span class="n">TYPE</span><span class="p">,</span><span class="w"> </span><span class="n">typeobj</span><span class="p">);</span>

<span class="n">TYPE</span><span class="w"> </span><span class="o">*</span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyObject_GC_NewVar</span><span class="p">(</span><span class="n">TYPE</span><span class="p">,</span><span class="w"> </span><span class="n">typeobj</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</section>
</section>
<section id="module-state-access-from-classes">
<h3 class="translated">Acceso al estado del módulo desde las clases<a class="headerlink" href="#module-state-access-from-classes" title="Link to this heading">¶</a></h3>
<p class="translated">Si tiene un objeto de tipo definido con <a class="reference internal" href="../c-api/type.html#c.PyType_FromModuleAndSpec" title="PyType_FromModuleAndSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromModuleAndSpec()</span></code></a>, puede llamar a <a class="reference internal" href="../c-api/type.html#c.PyType_GetModule" title="PyType_GetModule"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetModule()</span></code></a> para obtener el módulo asociado y luego a <a class="reference internal" href="../c-api/module.html#c.PyModule_GetState" title="PyModule_GetState"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_GetState()</span></code></a> para obtener el estado del módulo.</p>
<p class="translated">Para ahorrar un tedioso código repetitivo de manejo de errores, puede combinar estos dos pasos con <a class="reference internal" href="../c-api/type.html#c.PyType_GetModuleState" title="PyType_GetModuleState"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetModuleState()</span></code></a>, lo que da como resultado:</p>
<div class="untranslated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">my_struct</span><span class="w"> </span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">my_struct</span><span class="o">*</span><span class="p">)</span><span class="n">PyType_GetModuleState</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="module-state-access-from-regular-methods">
<h3 class="translated">Acceso al estado del módulo desde métodos regulares<a class="headerlink" href="#module-state-access-from-regular-methods" title="Link to this heading">¶</a></h3>
<p class="translated">Acceder al estado de nivel de módulo desde los métodos de una clase es algo más complicado, pero es posible gracias a la API introducida en Python 3.9. Para obtener el estado, primero debe obtener la <em>clase de definición</em> y luego obtener el estado del módulo.</p>
<p class="translated">El obstáculo más grande es obtener <em>la clase en la que se definió un método</em>, o la «clase de definición» de ese método para abreviar. La clase de definición puede tener una referencia al módulo del que forma parte.</p>
<p class="untranslated">Do not confuse the defining class with <code class="docutils literal notranslate"><span class="pre">Py_TYPE(self)</span></code>. If the method
is called on a <em>subclass</em> of your type, <code class="docutils literal notranslate"><span class="pre">Py_TYPE(self)</span></code> will refer to
that subclass, which may be defined in different module than yours.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">El siguiente código de Python puede ilustrar el concepto. <code class="docutils literal notranslate"><span class="pre">Base.get_defining_class</span></code> retorna <code class="docutils literal notranslate"><span class="pre">Base</span></code> incluso si <code class="docutils literal notranslate"><span class="pre">type(self)</span> <span class="pre">==</span> <span class="pre">Sub</span></code>:</p>
<div class="untranslated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_type_of_self</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_defining_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="vm">__class__</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Sub</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div>
<p class="untranslated">For a method to get its «defining class», it must use the
<a class="reference internal" href="../c-api/structures.html#meth-method-meth-fastcall-meth-keywords"><span class="std std-ref">METH_METHOD | METH_FASTCALL | METH_KEYWORDS</span></a>
<a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">calling</span> <span class="pre">convention</span></code></a>
and the corresponding <a class="reference internal" href="../c-api/structures.html#c.PyCMethod" title="PyCMethod"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCMethod</span></code></a> signature:</p>
<div class="untranslated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">PyCMethod</span><span class="p">(</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w">               </span><span class="c1">// object the method was called on</span>
<span class="w">    </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="o">*</span><span class="n">defining_class</span><span class="p">,</span><span class="w"> </span><span class="c1">// defining class</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w">        </span><span class="c1">// C array of arguments</span>
<span class="w">    </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">nargs</span><span class="p">,</span><span class="w">             </span><span class="c1">// length of &quot;args&quot;</span>
<span class="w">    </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">kwnames</span><span class="p">)</span><span class="w">            </span><span class="c1">// NULL, or dict of keyword arguments</span>
</pre></div>
</div>
<p class="translated">Una vez que tenga la clase de definición, llame a <a class="reference internal" href="../c-api/type.html#c.PyType_GetModuleState" title="PyType_GetModuleState"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetModuleState()</span></code></a> para obtener el estado de su módulo asociado.</p>
<p class="translated">Por ejemplo:</p>
<div class="untranslated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">example_method</span><span class="p">(</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">        </span><span class="n">PyTypeObject</span><span class="w"> </span><span class="o">*</span><span class="n">defining_class</span><span class="p">,</span>
<span class="w">        </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span>
<span class="w">        </span><span class="n">Py_ssize_t</span><span class="w"> </span><span class="n">nargs</span><span class="p">,</span>
<span class="w">        </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">kwnames</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">my_struct</span><span class="w"> </span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">my_struct</span><span class="o">*</span><span class="p">)</span><span class="n">PyType_GetModuleState</span><span class="p">(</span><span class="n">defining_class</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">...</span><span class="w"> </span><span class="c1">// rest of logic</span>
<span class="p">}</span>

<span class="n">PyDoc_STRVAR</span><span class="p">(</span><span class="n">example_method_doc</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;...&quot;</span><span class="p">);</span>

<span class="k">static</span><span class="w"> </span><span class="n">PyMethodDef</span><span class="w"> </span><span class="n">my_methods</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="s">&quot;example_method&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="p">(</span><span class="n">PyCFunction</span><span class="p">)(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="n">example_method</span><span class="p">,</span>
<span class="w">      </span><span class="n">METH_METHOD</span><span class="o">|</span><span class="n">METH_FASTCALL</span><span class="o">|</span><span class="n">METH_KEYWORDS</span><span class="p">,</span>
<span class="w">      </span><span class="n">example_method_doc</span><span class="p">}</span>
<span class="w">    </span><span class="p">{</span><span class="nb">NULL</span><span class="p">},</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="module-state-access-from-slot-methods-getters-and-setters">
<h3 class="translated">Acceso al estado del módulo desde métodos de Slot, Getters y Setters<a class="headerlink" href="#module-state-access-from-slot-methods-getters-and-setters" title="Link to this heading">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="translated">Esto es nuevo en Python 3.11.</p>
</div>
<p class="untranslated">Slot methods—the fast C equivalents for special methods, such as
<a class="reference internal" href="../c-api/typeobj.html#c.PyNumberMethods.nb_add" title="PyNumberMethods.nb_add"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_add</span></code></a> for <a class="reference internal" href="../reference/datamodel.html#object.__add__" title="object.__add__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__add__</span></code></a> or
<a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_new" title="PyTypeObject.tp_new"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_new</span></code></a> for initialization—have a very simple API that
doesn’t allow passing in the defining class, unlike with <a class="reference internal" href="../c-api/structures.html#c.PyCMethod" title="PyCMethod"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCMethod</span></code></a>.
The same goes for getters and setters defined with
<a class="reference internal" href="../c-api/structures.html#c.PyGetSetDef" title="PyGetSetDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyGetSetDef</span></code></a>.</p>
<p class="translated">Para acceder al estado del módulo en estos casos, utilice la función <a class="reference internal" href="../c-api/type.html#c.PyType_GetModuleByDef" title="PyType_GetModuleByDef"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetModuleByDef()</span></code></a> y pase la definición del módulo. Una vez que tenga el módulo, llame a <a class="reference internal" href="../c-api/module.html#c.PyModule_GetState" title="PyModule_GetState"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_GetState()</span></code></a> para obtener el estado:</p>
<div class="untranslated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyType_GetModuleByDef</span><span class="p">(</span><span class="n">Py_TYPE</span><span class="p">(</span><span class="n">self</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module_def</span><span class="p">);</span>
<span class="n">my_struct</span><span class="w"> </span><span class="o">*</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">my_struct</span><span class="o">*</span><span class="p">)</span><span class="n">PyModule_GetState</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="untranslated"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetModuleByDef()</span></code> works by searching the
<a class="reference internal" href="../glossary.html#term-method-resolution-order"><span class="xref std std-term">method resolution order</span></a> (i.e. all superclasses) for the first
superclass that has a corresponding module.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p class="untranslated">In very exotic cases (inheritance chains spanning multiple modules
created from the same definition), <code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetModuleByDef()</span></code> might not
return the module of the true defining class. However, it will always
return a module with the same definition, ensuring a compatible
C memory layout.</p>
</div>
</section>
<section id="lifetime-of-the-module-state">
<h3 class="translated">Vida útil del estado del módulo<a class="headerlink" href="#lifetime-of-the-module-state" title="Link to this heading">¶</a></h3>
<p class="translated">Cuando un objeto de módulo se recolecta como basura, se libera su estado de módulo. Para cada puntero a (una parte de) el estado del módulo, debe tener una referencia al objeto del módulo.</p>
<p class="translated">Por lo general, esto no es un problema, porque los tipos creados con <a class="reference internal" href="../c-api/type.html#c.PyType_FromModuleAndSpec" title="PyType_FromModuleAndSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_FromModuleAndSpec()</span></code></a> y sus instancias contienen una referencia al módulo. Sin embargo, debe tener cuidado en el recuento de referencias cuando hace referencia al estado del módulo desde otros lugares, como devoluciones de llamada para bibliotecas externas.</p>
</section>
</section>
<section id="open-issues">
<h2 class="translated">Problemas abiertos<a class="headerlink" href="#open-issues" title="Link to this heading">¶</a></h2>
<p class="translated">Varios problemas relacionados con el estado por módulo y los tipos heap todavía están abiertos.</p>
<p class="untranslated">Discussions about improving the situation are best held on the <a class="reference external" href="https://discuss.python.org/c/core-dev/c-api/30">discuss forum under c-api tag</a>.</p>
<section id="per-class-scope">
<h3 class="translated">Alcance por clase<a class="headerlink" href="#per-class-scope" title="Link to this heading">¶</a></h3>
<p class="translated">Actualmente (a partir de Python 3.11) no es posible adjuntar estado a <em>tipos</em> individuales sin depender de los detalles de implementación de CPython (que pueden cambiar en el futuro, tal vez, irónicamente, para permitir una solución adecuada para el alcance por clase).</p>
</section>
<section id="lossless-conversion-to-heap-types">
<h3 class="translated">Conversión sin pérdidas a tipos heap<a class="headerlink" href="#lossless-conversion-to-heap-types" title="Link to this heading">¶</a></h3>
<p class="translated">La API de tipo heap no se diseñó para la conversión «sin pérdidas» de tipos estáticos; es decir, crear un tipo que funcione exactamente como un tipo estático determinado.</p>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Aislamiento de módulos de extensión</a><ul>
<li><a class="reference internal" href="#who-should-read-this">¿Quién debería leer esto?</a></li>
<li><a class="reference internal" href="#background">Trasfondo</a><ul>
<li><a class="reference internal" href="#enter-per-module-state">Ingrese al estado por módulo</a></li>
<li><a class="reference internal" href="#isolated-module-objects">Objetos módulos aislados</a></li>
<li><a class="reference internal" href="#surprising-edge-cases">Casos extremos sorprendentes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#making-modules-safe-with-multiple-interpreters">Cómo hacer que los módulos sean seguros con varios intérpretes</a><ul>
<li><a class="reference internal" href="#managing-global-state">Administrar el estado global</a></li>
<li><a class="reference internal" href="#managing-per-module-state">Administración del estado por módulo</a></li>
<li><a class="reference internal" href="#opt-out-limiting-to-one-module-object-per-process">Exclusión voluntaria: limitación a un objeto de módulo por proceso</a></li>
<li><a class="reference internal" href="#module-state-access-from-functions">Acceso al estado del módulo desde las funciones</a></li>
</ul>
</li>
<li><a class="reference internal" href="#heap-types">Tipos Heap</a><ul>
<li><a class="reference internal" href="#changing-static-types-to-heap-types">Cambio de tipos estáticos a tipos heap</a></li>
<li><a class="reference internal" href="#defining-heap-types">Definición de tipos heap</a></li>
<li><a class="reference internal" href="#garbage-collection-protocol">Protocolo de recolección de basura</a><ul>
<li><a class="reference internal" href="#tp-traverse-in-python-3-8-and-lower"><code class="docutils literal notranslate"><span class="pre">tp_traverse</span></code> in Python 3.8 and lower</a></li>
<li><a class="reference internal" href="#delegating-tp-traverse">Delegating <code class="docutils literal notranslate"><span class="pre">tp_traverse</span></code></a></li>
<li><a class="reference internal" href="#defining-tp-dealloc">Defining <code class="docutils literal notranslate"><span class="pre">tp_dealloc</span></code></a></li>
<li><a class="reference internal" href="#not-overriding-tp-free">Not overriding <code class="docutils literal notranslate"><span class="pre">tp_free</span></code></a></li>
<li><a class="reference internal" href="#avoiding-pyobject-new">Avoiding <code class="docutils literal notranslate"><span class="pre">PyObject_New</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-state-access-from-classes">Acceso al estado del módulo desde las clases</a></li>
<li><a class="reference internal" href="#module-state-access-from-regular-methods">Acceso al estado del módulo desde métodos regulares</a></li>
<li><a class="reference internal" href="#module-state-access-from-slot-methods-getters-and-setters">Acceso al estado del módulo desde métodos de Slot, Getters y Setters</a></li>
<li><a class="reference internal" href="#lifetime-of-the-module-state">Vida útil del estado del módulo</a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-issues">Problemas abiertos</a><ul>
<li><a class="reference internal" href="#per-class-scope">Alcance por clase</a></li>
<li><a class="reference internal" href="#lossless-conversion-to-heap-types">Conversión sin pérdidas a tipos heap</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="annotations.html"
                          title="capítulo anterior">Prácticas recomendadas para las anotaciones</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="timerfd.html"
                          title="próximo capítulo">timer file descriptor HOWTO</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/howto/isolating-extensions.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Contraer barra lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="timerfd.html" title="timer file descriptor HOWTO"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="annotations.html" title="Prácticas recomendadas para las anotaciones"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Comos (<em>HOWTOs</em>) de Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Aislamiento de módulos de extensión</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Derechos de autor</a> 2001 Python Software Foundation.
    <br>
    Ésta página tiene la licencia Python Software Foundation Versión 2.
    <br>
    Ejemplos, guías, y otro código en la documentación están bajo la licencia adicional Zero Clause BSD.
    <br>
    
      Ver <a href="/license.html">Historia y Licencia</a> para más información.<br>
    
    
    <br>

    La Python Software Foundation es una corporación sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor dona.</a>
<br>
    <br>
      Última actualización en oct 06, 2025 (04:51 UTC).
    
      <a href="/bugs.html">Encontraste un bug</a>?
    
    <br>

    Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a>8.2.3.
    </div>

  </body>
</html>