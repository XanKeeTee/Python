<!DOCTYPE html>

<html lang="es" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Glosario" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/glossary.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="&gt;&gt;&gt;, The default Python prompt of the interactive shell. Often seen for code examples which can be executed interactively in the interpreter.,,..., Puede referirse a:- The default Python p..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.15/es/_images/social_previews/summary_glossary_2c51d601.png" />
<meta property="og:image:alt" content="&gt;&gt;&gt;, The default Python prompt of the interactive shell. Often seen for code examples which can be executed interactively in the interpreter.,,..., Puede referirse a:- The default Python p..." />
<meta name="description" content="&gt;&gt;&gt;, The default Python prompt of the interactive shell. Often seen for code examples which can be executed interactively in the interpreter.,,..., Puede referirse a:- The default Python p..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>Glosario &#8212; documentación de Python - 3.15.0a0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="_static/pygments_dark.css?v=5349f25f" />
    
    <script src="_static/documentation_options.js?v=bf1f176d"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=f85f4cfb"></script>
    
    <script src="_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.15.0a0"
          href="_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="about.html" />
    <link rel="index" title="Índice" href="genindex.html" />
    <link rel="search" title="Búsqueda" href="search.html" />
    <link rel="copyright" title="Derechos de autor" href="copyright.html" />
    <link rel="next" title="About this documentation" href="about.html" />
    <link rel="prev" title="Desusos" href="deprecations/index.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/glossary.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="_static/py.svg">
            <script type="text/javascript" src="_static/copybutton.js"></script>
            <script type="text/javascript" src="_static/menu.js"></script>
            <script type="text/javascript" src="_static/search-focus.js"></script>
            <script type="text/javascript" src="_static/themetoggle.js"></script> 
            <script type="text/javascript" src="_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menú">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="deprecations/index.html"
                          title="capítulo anterior">Desusos</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="about.html"
                          title="próximo capítulo">About this documentation</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/glossary.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="about.html" title="About this documentation"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="deprecations/index.html" title="Desusos"
             accesskey="P">anterior</a> |</li>

          <li><img src="_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.15.0a0 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">Glosario</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="glossary">
<span id="id1"></span><h1 class="translated">Glosario<a class="headerlink" href="#glossary" title="Link to this heading">¶</a></h1>
<dl class="glossary">
<dt class="translated" id="term-0"><code class="docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span></code><a class="headerlink" href="#term-0" title="Link to this term">¶</a></dt><dd><p class="untranslated">The default Python prompt of the <a class="reference internal" href="#term-interactive"><span class="xref std std-term">interactive</span></a> shell.  Often
seen for code examples which can be executed interactively in the
interpreter.</p>
</dd>
<dt class="translated" id="term-..."><code class="docutils literal notranslate"><span class="pre">...</span></code><a class="headerlink" href="#term-..." title="Link to this term">¶</a></dt><dd><p class="translated">Puede referirse a:</p>
<ul class="simple">
<li><p class="untranslated">The default Python prompt of the <a class="reference internal" href="#term-interactive"><span class="xref std std-term">interactive</span></a> shell when entering the
code for an indented code block, when within a pair of matching left and
right delimiters (parentheses, square brackets, curly braces or triple
quotes), or after specifying a decorator.</p></li>
</ul>
<ul class="simple" id="index-0">
<li><p class="untranslated">The three dots form of the <a class="reference internal" href="library/stdtypes.html#bltin-ellipsis-object"><span class="std std-ref">Ellipsis</span></a> object.</p></li>
</ul>
</dd>
<dt class="translated" id="term-abstract-base-class">clase base abstracta<a class="headerlink" href="#term-abstract-base-class" title="Link to this term">¶</a></dt><dd><p class="translated">Las clases base abstractas (ABC, por sus siglas en inglés <cite>Abstract Base Class</cite>) complementan al <a class="reference internal" href="#term-duck-typing"><span class="xref std std-term">duck-typing</span></a> brindando un forma de definir interfaces con técnicas como <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> que serían confusas o sutilmente erróneas (por ejemplo con <a class="reference internal" href="reference/datamodel.html#special-lookup"><span class="std std-ref">magic methods</span></a>). Las ABC introduce subclases virtuales, las cuales son clases que no heredan desde una clase pero aún así son reconocidas por <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> y <a class="reference internal" href="library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>; vea la documentación del módulo <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>. Python viene con muchas ABC incorporadas para las estructuras de datos( en el módulo <a class="reference internal" href="library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a>), números (en el módulo <a class="reference internal" href="library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">numbers</span></code></a> ) , flujos de datos (en el módulo <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> ) , buscadores y cargadores de importaciones (en el módulo <a class="reference internal" href="library/importlib.html#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> ) . Puede crear sus propios ABCs con el módulo <a class="reference internal" href="library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a>.</p>
</dd>
<dt class="untranslated" id="term-annotate-function">annotate function<a class="headerlink" href="#term-annotate-function" title="Link to this term">¶</a></dt><dd><p class="untranslated">A function that can be called to retrieve the <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotations</span></a>
of an object. This function is accessible as the <a class="reference internal" href="reference/datamodel.html#object.__annotate__" title="object.__annotate__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotate__</span></code></a>
attribute of functions, classes, and modules. Annotate functions are a
subset of <a class="reference internal" href="#term-evaluate-function"><span class="xref std std-term">evaluate functions</span></a>.</p>
</dd>
<dt class="translated" id="term-annotation">anotación<a class="headerlink" href="#term-annotation" title="Link to this term">¶</a></dt><dd><p class="translated">Una etiqueta asociada a una variable, atributo de clase, parámetro de función o valor de retorno, usado por convención como un <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">type hint</span></a>.</p>
<p class="untranslated">Annotations of local variables cannot be accessed at runtime, but
annotations of global variables, class attributes, and functions
can be retrieved by calling <a class="reference internal" href="library/annotationlib.html#annotationlib.get_annotations" title="annotationlib.get_annotations"><code class="xref py py-func docutils literal notranslate"><span class="pre">annotationlib.get_annotations()</span></code></a>
on modules, classes, and functions, respectively.</p>
<p class="untranslated">See <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">variable annotation</span></a>, <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">function annotation</span></a>, <span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>,
<span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>, and <span class="target" id="index-3"></span><a class="pep reference external" href="https://peps.python.org/pep-0649/"><strong>PEP 649</strong></a>, which describe this functionality.
Also see <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Prácticas recomendadas para las anotaciones</span></a>
for best practices on working with annotations.</p>
</dd>
<dt class="translated" id="term-argument">argumento<a class="headerlink" href="#term-argument" title="Link to this term">¶</a></dt><dd><p class="translated">Un valor pasado a una <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> (o <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a>) cuando se llama a la función. Hay dos clases de argumentos:</p>
<ul>
<li><p class="translated"><em class="dfn">argumento nombrado</em>: es un argumento precedido por un identificador (por ejemplo, <code class="docutils literal notranslate"><span class="pre">nombre=</span></code>) en una llamada a una función o pasado como valor en un diccionario precedido por <code class="docutils literal notranslate"><span class="pre">**</span></code>. Por ejemplo <code class="docutils literal notranslate"><span class="pre">3</span></code> y <code class="docutils literal notranslate"><span class="pre">5</span></code> son argumentos nombrados en las llamadas a <a class="reference internal" href="library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="n">real</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">imag</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s1">&#39;real&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;imag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
</li>
<li><p class="translated"><em class="dfn">argumento posicional</em> son aquellos que no son nombrados. Los argumentos posicionales deben aparecer al principio de una lista de argumentos o ser pasados como elementos de un <a class="reference internal" href="#term-iterable"><span class="xref std std-term">iterable</span></a> precedido por <code class="docutils literal notranslate"><span class="pre">*</span></code>. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">3</span></code> y <code class="docutils literal notranslate"><span class="pre">5</span></code> son argumentos posicionales en las siguientes llamadas:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">complex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">complex</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
<p class="translated">Los argumentos son asignados a las variables locales en el cuerpo de la función. Vea en la sección <a class="reference internal" href="reference/expressions.html#calls"><span class="std std-ref">Invocaciones</span></a> las reglas que rigen estas asignaciones. Sintácticamente, cualquier expresión puede ser usada para representar un argumento; el valor evaluado es asignado a la variable local.</p>
<p class="translated">Vea también el <a class="reference internal" href="#term-parameter"><span class="xref std std-term">parameter</span></a> en el glosario, la pregunta frecuente <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">la diferencia entre argumentos y parámetros</span></a>, y <span class="target" id="index-70"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a>.</p>
</dd>
<dt class="translated" id="term-asynchronous-context-manager">administrador asincrónico de contexto<a class="headerlink" href="#term-asynchronous-context-manager" title="Link to this term">¶</a></dt><dd><p class="translated">Un objeto que controla el entorno visible en un sentencia <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a> al definir los métodos <a class="reference internal" href="reference/datamodel.html#object.__aenter__" title="object.__aenter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aenter__()</span></code></a> y <a class="reference internal" href="reference/datamodel.html#object.__aexit__" title="object.__aexit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aexit__()</span></code></a>.  Introducido por <span class="target" id="index-71"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt class="translated" id="term-asynchronous-generator">generador asincrónico<a class="headerlink" href="#term-asynchronous-generator" title="Link to this term">¶</a></dt><dd><p class="translated">Una función que retorna un <a class="reference internal" href="#term-asynchronous-generator-iterator"><span class="xref std std-term">asynchronous generator iterator</span></a>. Es similar a una función corrutina definida con <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a> excepto que contiene expresiones <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> para producir series de variables usadas en un ciclo <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>.</p>
<p class="translated">Usualmente se refiere a una función generadora asincrónica, pero puede referirse a un <em>iterador generador asincrónico</em> en ciertos contextos. En aquellos casos en los que el significado no está claro, usar los términos completos evita la ambigüedad.</p>
<p class="translated">Una función generadora asincrónica puede contener expresiones <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a> así como sentencias <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>, y <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>.</p>
</dd>
<dt class="translated" id="term-asynchronous-generator-iterator">iterador generador asincrónico<a class="headerlink" href="#term-asynchronous-generator-iterator" title="Link to this term">¶</a></dt><dd><p class="untranslated">An object created by an <a class="reference internal" href="#term-asynchronous-generator"><span class="xref std std-term">asynchronous generator</span></a> function.</p>
<p class="translated">Este es un <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> el cual cuando es llamado usa el método <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> retornando un objeto a la espera (<em>awaitable</em>) el cual ejecutará el cuerpo de la función generadora asincrónica hasta la siguiente expresión <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>.</p>
<p class="untranslated">Each <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> temporarily suspends processing, remembering the
execution state (including local variables and pending
try-statements).  When the <em>asynchronous generator iterator</em> effectively
resumes with another awaitable returned by <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>, it
picks up where it left off.  See <span class="target" id="index-6"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a> and <span class="target" id="index-7"></span><a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a>.</p>
</dd>
<dt class="translated" id="term-asynchronous-iterable">iterable asincrónico<a class="headerlink" href="#term-asynchronous-iterable" title="Link to this term">¶</a></dt><dd><p class="translated">Un objeto, que puede ser usado en una sentencia <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>. Debe retornar un <a class="reference internal" href="#term-asynchronous-iterator"><span class="xref std std-term">asynchronous iterator</span></a> de su método <a class="reference internal" href="reference/datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a>. Introducido por <span class="target" id="index-72"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt class="translated" id="term-asynchronous-iterator">iterador asincrónico<a class="headerlink" href="#term-asynchronous-iterator" title="Link to this term">¶</a></dt><dd><p class="translated">Un objeto que implementa los métodos <a class="reference internal" href="reference/datamodel.html#object.__aiter__" title="object.__aiter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__aiter__()</span></code></a> y <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a>. <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> debe retornar un objeto <a class="reference internal" href="#term-awaitable"><span class="xref std std-term">awaitable</span></a>. <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a> resuelve los esperables retornados por un método de iterador asincrónico <a class="reference internal" href="reference/datamodel.html#object.__anext__" title="object.__anext__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__anext__()</span></code></a> hasta que lanza una excepción <a class="reference internal" href="library/exceptions.html#StopAsyncIteration" title="StopAsyncIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopAsyncIteration</span></code></a>. Introducido por <span class="target" id="index-73"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt class="untranslated" id="term-attached-thread-state">attached thread state<a class="headerlink" href="#term-attached-thread-state" title="Link to this term">¶</a></dt><dd><p class="untranslated">A <a class="reference internal" href="#term-thread-state"><span class="xref std std-term">thread state</span></a> that is active for the current OS thread.</p>
<p class="untranslated">When a <a class="reference internal" href="#term-thread-state"><span class="xref std std-term">thread state</span></a> is attached, the OS thread has
access to the full Python C API and can safely invoke the
bytecode interpreter.</p>
<p class="untranslated">Unless a function explicitly notes otherwise, attempting to call
the C API without an attached thread state will result in a fatal
error or undefined behavior.  A thread state can be attached and detached
explicitly by the user through the C API, or implicitly by the runtime,
including during blocking C calls and by the bytecode interpreter in between
calls.</p>
<p class="untranslated">On most builds of Python, having an attached thread state implies that the
caller holds the <a class="reference internal" href="#term-GIL"><span class="xref std std-term">GIL</span></a> for the current interpreter, so only
one OS thread can have an attached thread state at a given moment. In
<a class="reference internal" href="#term-free-threading"><span class="xref std std-term">free-threaded</span></a> builds of Python, threads can concurrently
hold an attached thread state, allowing for true parallelism of the bytecode
interpreter.</p>
</dd>
<dt class="translated" id="term-attribute">atributo<a class="headerlink" href="#term-attribute" title="Link to this term">¶</a></dt><dd><p class="translated">Un valor asociado a un objeto al que se suele hacer referencia por su nombre utilizando expresiones punteadas. Por ejemplo, si un objeto <em>o</em> tiene un atributo <em>a</em> se referenciaría como <em>o.a</em>.</p>
<p class="translated">Es posible dar a un objeto un atributo cuyo nombre no sea un identificador definido por <a class="reference internal" href="reference/lexical_analysis.html#identifiers"><span class="std std-ref">Names (identifiers and keywords)</span></a>, por ejemplo usando <a class="reference internal" href="library/functions.html#setattr" title="setattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">setattr()</span></code></a>, si el objeto lo permite. Dicho atributo no será accesible utilizando una expresión con puntos, y en su lugar deberá ser recuperado con <a class="reference internal" href="library/functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a>.</p>
</dd>
<dt class="translated" id="term-awaitable">a la espera<a class="headerlink" href="#term-awaitable" title="Link to this term">¶</a></dt><dd><p class="translated">Un objeto que puede utilizarse en una expresión <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>.  Puede ser una <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">corutina</span></a> o un objeto con un método <a class="reference internal" href="reference/datamodel.html#object.__await__" title="object.__await__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__await__()</span></code></a>. Véase también <span class="target" id="index-74"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt class="translated" id="term-BDFL">BDFL<a class="headerlink" href="#term-BDFL" title="Link to this term">¶</a></dt><dd><p class="translated">Sigla de <em>Benevolent Dictator For Life</em>, benevolente dictador vitalicio, es decir <a class="reference external" href="https://gvanrossum.github.io/">Guido van Rossum</a>, el creador de Python.</p>
</dd>
<dt class="translated" id="term-binary-file">archivo binario<a class="headerlink" href="#term-binary-file" title="Link to this term">¶</a></dt><dd><p class="untranslated">A <a class="reference internal" href="#term-file-object"><span class="xref std std-term">file object</span></a> able to read and write
<a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">bytes-like objects</span></a>.
Examples of binary files are files opened in binary mode (<code class="docutils literal notranslate"><span class="pre">'rb'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'wb'</span></code> or <code class="docutils literal notranslate"><span class="pre">'rb+'</span></code>), <a class="reference internal" href="library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin.buffer</span></code></a>,
<a class="reference internal" href="library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout.buffer</span></code></a>, and instances of
<a class="reference internal" href="library/io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> and <a class="reference internal" href="library/gzip.html#gzip.GzipFile" title="gzip.GzipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">gzip.GzipFile</span></code></a>.</p>
<p class="translated">Vea también <a class="reference internal" href="#term-text-file"><span class="xref std std-term">text file</span></a> para un objeto archivo capaz de leer y escribir objetos <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>.</p>
</dd>
<dt class="translated" id="term-borrowed-reference">referencia prestada<a class="headerlink" href="#term-borrowed-reference" title="Link to this term">¶</a></dt><dd><p class="translated">En la API C de Python, una referencia prestada es una referencia a un objeto, donde el código usando el objeto no posee la referencia. Se convierte en un puntero colgante si se destruye el objeto. Por ejemplo, una recolección de basura puede eliminar el último <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">strong reference</span></a> del objeto y así destruirlo.</p>
<p class="translated">Se recomienda llamar a <a class="reference internal" href="c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_INCREF()</span></code></a> en la <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">referencia prestada</span></a> para convertirla en una <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">referencia fuerte</span></a> in situ, excepto cuando el objeto no se puede destruir antes del último uso de la referencia prestada. La función <a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a> se puede utilizar para crear una nueva <a class="reference internal" href="#term-strong-reference"><span class="xref std std-term">referencia fuerte</span></a>.</p>
</dd>
<dt class="translated" id="term-bytes-like-object">objetos tipo binarios<a class="headerlink" href="#term-bytes-like-object" title="Link to this term">¶</a></dt><dd><p class="translated">Un objeto que soporta <a class="reference internal" href="c-api/buffer.html#bufferobjects"><span class="std std-ref">Protocolo búfer</span></a>  y puede exportar un búfer C-<a class="reference internal" href="#term-contiguous"><span class="xref std std-term">contiguous</span></a>. Esto incluye todas los objetos <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>, <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>, y <a class="reference internal" href="library/array.html#array.array" title="array.array"><code class="xref py py-class docutils literal notranslate"><span class="pre">array.array</span></code></a>, así como muchos objetos comunes <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>. Los objetos tipo binarios pueden ser usados para varias operaciones que usan datos binarios; éstas incluyen compresión, salvar a archivos binarios, y enviarlos a través de un socket.</p>
<p class="translated">Algunas operaciones necesitan que los datos binarios sean mutables. La documentación frecuentemente se refiere a éstos como «objetos tipo binario de lectura y escritura». Ejemplos de objetos de búfer mutables incluyen a <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> y <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> de la <a class="reference internal" href="library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>. Otras operaciones que requieren datos binarios almacenados en objetos inmutables («objetos tipo binario de sólo lectura»); ejemplos de éstos incluyen <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> y <a class="reference internal" href="library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> del objeto <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.</p>
</dd>
<dt class="translated" id="term-bytecode">bytecode<a class="headerlink" href="#term-bytecode" title="Link to this term">¶</a></dt><dd><p class="translated">El código fuente Python es compilado en <em>bytecode</em>, la representación interna de un programa python en el intérprete CPython. El <em>bytecode</em> también es guardado en caché en los archivos <cite>.pyc</cite> de tal forma que ejecutar el mismo archivo es más fácil la segunda vez (la recompilación desde el código fuente a <em>bytecode</em> puede ser evitada). Este «lenguaje intermedio» deberá corren en una <a class="reference internal" href="#term-virtual-machine"><span class="xref std std-term">virtual machine</span></a> que ejecute el código de máquina correspondiente a cada <em>bytecode</em>. Note que los <em>bytecodes</em> no tienen como requisito trabajar en las diversas máquina virtuales de Python, ni de ser estable entre versiones Python.</p>
<p class="translated">Una lista de las instrucciones en <em>bytecode</em> está disponible en la documentación de <a class="reference internal" href="library/dis.html#bytecodes"><span class="std std-ref">el módulo dis</span></a>.</p>
</dd>
<dt class="translated" id="term-callable">callable<a class="headerlink" href="#term-callable" title="Link to this term">¶</a></dt><dd><p class="translated">Un callable es un objeto que puede ser llamado, posiblemente con un conjunto de argumentos (véase <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>), con la siguiente sintaxis:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">callable</span><span class="p">(</span><span class="n">argument1</span><span class="p">,</span> <span class="n">argument2</span><span class="p">,</span> <span class="n">argumentN</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Una <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a>, y por extensión un <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a>, es un callable. Una instancia de una clase que implementa el método <a class="reference internal" href="reference/datamodel.html#object.__call__" title="object.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__call__()</span></code></a> también es un callable.</p>
</dd>
<dt class="translated" id="term-callback">retrollamada<a class="headerlink" href="#term-callback" title="Link to this term">¶</a></dt><dd><p class="translated">Una función de subrutina que se pasa como un argumento para ejecutarse en algún momento en el futuro.</p>
</dd>
<dt class="translated" id="term-class">clase<a class="headerlink" href="#term-class" title="Link to this term">¶</a></dt><dd><p class="translated">Una plantilla para crear objetos definidos por el usuario. Las definiciones de clase normalmente contienen definiciones de métodos que operan una instancia de la clase.</p>
</dd>
<dt class="translated" id="term-class-variable">variable de clase<a class="headerlink" href="#term-class-variable" title="Link to this term">¶</a></dt><dd><p class="translated">Una variable definida en una clase y prevista para ser modificada sólo a nivel de clase (es decir, no en una instancia de la clase).</p>
</dd>
<dt class="untranslated" id="term-closure-variable">closure variable<a class="headerlink" href="#term-closure-variable" title="Link to this term">¶</a></dt><dd><p class="untranslated">A <a class="reference internal" href="#term-free-variable"><span class="xref std std-term">free variable</span></a> referenced from a <a class="reference internal" href="#term-nested-scope"><span class="xref std std-term">nested scope</span></a> that is defined in an outer
scope rather than being resolved at runtime from the globals or builtin namespaces.
May be explicitly defined with the <a class="reference internal" href="reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> keyword to allow write access,
or implicitly defined if the variable is only being read.</p>
<p class="untranslated">For example, in the <code class="docutils literal notranslate"><span class="pre">inner</span></code> function in the following code, both <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">print</span></code> are
<a class="reference internal" href="#term-free-variable"><span class="xref std std-term">free variables</span></a>, but only <code class="docutils literal notranslate"><span class="pre">x</span></code> is a <em>closure variable</em>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">outer</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inner</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">x</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>
</pre></div>
</div>
<p class="untranslated">Due to the <a class="reference internal" href="reference/datamodel.html#codeobject.co_freevars" title="codeobject.co_freevars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">codeobject.co_freevars</span></code></a> attribute (which, despite its name, only
includes the names of closure variables rather than listing all referenced free
variables), the more general <a class="reference internal" href="#term-free-variable"><span class="xref std std-term">free variable</span></a> term is sometimes used even
when the intended meaning is to refer specifically to closure variables.</p>
</dd>
<dt class="translated" id="term-complex-number">número complejo<a class="headerlink" href="#term-complex-number" title="Link to this term">¶</a></dt><dd><p class="translated">Una extensión del sistema familiar de número reales en el cual los números son expresados como la suma de una parte real y una parte imaginaria.  Los números imaginarios son múltiplos de la unidad imaginaria (la raíz cuadrada de <code class="docutils literal notranslate"><span class="pre">-1</span></code>), usualmente escrita como <code class="docutils literal notranslate"><span class="pre">i</span></code> en matemáticas o <code class="docutils literal notranslate"><span class="pre">j</span></code> en ingeniería.  Python tiene soporte incorporado para números complejos, los cuales son escritos con la notación mencionada al final.; la parte imaginaria es escrita con un sufijo <code class="docutils literal notranslate"><span class="pre">j</span></code>, por ejemplo, <code class="docutils literal notranslate"><span class="pre">3+1j</span></code>.  Para tener acceso a los equivalentes complejos del módulo <a class="reference internal" href="library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> module, use <a class="reference internal" href="library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a>.  El uso de números complejos es matemática bastante avanzada.  Si no le parecen necesarios, puede ignorarlos sin inconvenientes.</p>
</dd>
<dt class="untranslated" id="term-context">context<a class="headerlink" href="#term-context" title="Link to this term">¶</a></dt><dd><p class="untranslated">This term has different meanings depending on where and how it is used.
Some common meanings:</p>
<ul class="simple">
<li><p class="untranslated">The temporary state or environment established by a <a class="reference internal" href="#term-context-manager"><span class="xref std std-term">context
manager</span></a> via a <a class="reference internal" href="reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> statement.</p></li>
<li><p class="untranslated">The collection of key­value bindings associated with a particular
<a class="reference internal" href="library/contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> object and accessed via
<a class="reference internal" href="library/contextvars.html#contextvars.ContextVar" title="contextvars.ContextVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">ContextVar</span></code></a> objects.  Also see <a class="reference internal" href="#term-context-variable"><span class="xref std std-term">context
variable</span></a>.</p></li>
<li><p class="untranslated">A <a class="reference internal" href="library/contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> object.  Also see <a class="reference internal" href="#term-current-context"><span class="xref std std-term">current
context</span></a>.</p></li>
</ul>
</dd>
<dt class="untranslated" id="term-context-management-protocol">context management protocol<a class="headerlink" href="#term-context-management-protocol" title="Link to this term">¶</a></dt><dd><p class="untranslated">The <a class="reference internal" href="reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> and <a class="reference internal" href="reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> methods called
by the <a class="reference internal" href="reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> statement.  See <span class="target" id="index-11"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a>.</p>
</dd>
<dt class="translated" id="term-context-manager">administrador de contextos<a class="headerlink" href="#term-context-manager" title="Link to this term">¶</a></dt><dd><p class="untranslated">An object which implements the <a class="reference internal" href="#term-context-management-protocol"><span class="xref std std-term">context management protocol</span></a> and
controls the environment seen in a <a class="reference internal" href="reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> statement.  See
<span class="target" id="index-12"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a>.</p>
</dd>
<dt class="translated" id="term-context-variable">variable de contexto<a class="headerlink" href="#term-context-variable" title="Link to this term">¶</a></dt><dd><p class="untranslated">A variable whose value depends on which context is the <a class="reference internal" href="#term-current-context"><span class="xref std std-term">current
context</span></a>.  Values are accessed via <a class="reference internal" href="library/contextvars.html#contextvars.ContextVar" title="contextvars.ContextVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.ContextVar</span></code></a>
objects.  Context variables are primarily used to isolate state between
concurrent asynchronous tasks.</p>
</dd>
<dt class="translated" id="term-contiguous">contiguo<a class="headerlink" href="#term-contiguous" title="Link to this term">¶</a></dt><dd><p class="translated" id="index-13">Un búfer es considerado contiguo con precisión si es <em>C-contiguo</em> o <em>Fortran contiguo</em>. Los búferes cero dimensionales con C y Fortran contiguos. En los arreglos unidimensionales, los ítems deben ser dispuestos en memoria uno siguiente al otro, ordenados por índices que comienzan en cero. En arreglos unidimensionales C-contiguos, el último índice varía más velozmente en el orden de las direcciones de memoria. Sin embargo, en arreglos Fortran contiguos, el primer índice vería más rápidamente.</p>
</dd>
<dt class="translated" id="term-coroutine">corrutina<a class="headerlink" href="#term-coroutine" title="Link to this term">¶</a></dt><dd><p class="translated">Las corrutinas son una forma más generalizadas de las subrutinas. A las subrutinas se ingresa por un punto y se sale por otro punto. Las corrutinas pueden se iniciadas, finalizadas y reanudadas en muchos puntos diferentes. Pueden ser implementadas con la sentencia <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>. Vea además <span class="target" id="index-75"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt class="translated" id="term-coroutine-function">función corrutina<a class="headerlink" href="#term-coroutine-function" title="Link to this term">¶</a></dt><dd><p class="translated">Un función que retorna un objeto  <a class="reference internal" href="#term-coroutine"><span class="xref std std-term">coroutine</span></a> . Una función corrutina puede ser definida con la sentencia <a class="reference internal" href="reference/compound_stmts.html#async-def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code></a>, y puede contener las palabras claves <a class="reference internal" href="reference/expressions.html#await"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">await</span></code></a>, <a class="reference internal" href="reference/compound_stmts.html#async-for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code></a>, y <a class="reference internal" href="reference/compound_stmts.html#async-with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code></a>. Las mismas son introducidas en <span class="target" id="index-76"></span><a class="pep reference external" href="https://peps.python.org/pep-0492/"><strong>PEP 492</strong></a>.</p>
</dd>
<dt class="translated" id="term-CPython">CPython<a class="headerlink" href="#term-CPython" title="Link to this term">¶</a></dt><dd><p class="translated">La implementación canónica del lenguaje de programación Python, como se distribuye en <a class="reference external" href="https://www.python.org">python.org</a>. El término «CPython» es usado cuando es necesario distinguir esta implementación de otras como <em>Jython</em> o <em>IronPython</em>.</p>
</dd>
<dt class="untranslated" id="term-current-context">current context<a class="headerlink" href="#term-current-context" title="Link to this term">¶</a></dt><dd><p class="untranslated">The <a class="reference internal" href="#term-context"><span class="xref std std-term">context</span></a> (<a class="reference internal" href="library/contextvars.html#contextvars.Context" title="contextvars.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> object) that is
currently used by <a class="reference internal" href="library/contextvars.html#contextvars.ContextVar" title="contextvars.ContextVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">ContextVar</span></code></a> objects to access (get
or set) the values of <a class="reference internal" href="#term-context-variable"><span class="xref std std-term">context variables</span></a>.  Each
thread has its own current context.  Frameworks for executing asynchronous
tasks (see <a class="reference internal" href="library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a>) associate each task with a context which
becomes the current context whenever the task starts or resumes execution.</p>
</dd>
<dt class="untranslated" id="term-cyclic-isolate">cyclic isolate<a class="headerlink" href="#term-cyclic-isolate" title="Link to this term">¶</a></dt><dd><p class="untranslated">A subgroup of one or more objects that reference each other in a reference
cycle, but are not referenced by objects outside the group.  The goal of
the <a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">cyclic garbage collector</span></a> is to identify these groups and break the reference
cycles so that the memory can be reclaimed.</p>
</dd>
<dt class="translated" id="term-decorator">decorador<a class="headerlink" href="#term-decorator" title="Link to this term">¶</a></dt><dd><p class="translated">Una función que retorna otra función, usualmente aplicada como una función de transformación empleando la sintaxis <code class="docutils literal notranslate"><span class="pre">&#64;envoltorio</span></code>. Ejemplos comunes de decoradores son  <a class="reference internal" href="library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> y <a class="reference internal" href="library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a>.</p>
<p class="translated">La sintaxis del decorador es meramente azúcar sintáctico, las definiciones de las siguientes dos funciones son semánticamente equivalentes:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">El mismo concepto existe para clases, pero son menos usadas. Vea la documentación de <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">function definitions</span></a> y <a class="reference internal" href="reference/compound_stmts.html#class"><span class="std std-ref">class definitions</span></a> para mayor detalle sobre decoradores.</p>
</dd>
<dt class="translated" id="term-descriptor">descriptor<a class="headerlink" href="#term-descriptor" title="Link to this term">¶</a></dt><dd><p class="untranslated">Any object which defines the methods <a class="reference internal" href="reference/datamodel.html#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__get__()</span></code></a>,
<a class="reference internal" href="reference/datamodel.html#object.__set__" title="object.__set__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__set__()</span></code></a>, or <a class="reference internal" href="reference/datamodel.html#object.__delete__" title="object.__delete__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delete__()</span></code></a>.
When a class attribute is a descriptor, its special
binding behavior is triggered upon attribute lookup.  Normally, using
<em>a.b</em> to get, set or delete an attribute looks up the object named <em>b</em> in
the class dictionary for <em>a</em>, but if <em>b</em> is a descriptor, the respective
descriptor method gets called.  Understanding descriptors is a key to a
deep understanding of Python because they are the basis for many features
including functions, methods, properties, class methods, static methods,
and reference to super classes.</p>
<p class="translated">Para obtener más información sobre los métodos de los descriptores, consulte <a class="reference internal" href="reference/datamodel.html#descriptors"><span class="std std-ref">Implementando descriptores</span></a> o <a class="reference internal" href="howto/descriptor.html#descriptorhowto"><span class="std std-ref">Guía práctica de uso de los descriptores</span></a>.</p>
</dd>
<dt class="translated" id="term-dictionary">diccionario<a class="headerlink" href="#term-dictionary" title="Link to this term">¶</a></dt><dd><p class="untranslated">An associative array, where arbitrary keys are mapped to values.  The
keys can be any object with <a class="reference internal" href="reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> and
<a class="reference internal" href="reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> methods.
Called a hash in Perl.</p>
</dd>
<dt class="translated" id="term-dictionary-comprehension">comprensión de diccionarios<a class="headerlink" href="#term-dictionary-comprehension" title="Link to this term">¶</a></dt><dd><p class="translated">Una forma compacta de procesar todos o parte de los elementos en un iterable y retornar un diccionario con los resultados. <code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{n:</span> <span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span> <span class="pre">for</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">range(10)}</span></code> genera un diccionario que contiene la clave <code class="docutils literal notranslate"><span class="pre">n</span></code> asignada al valor <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">**</span> <span class="pre">2</span></code>. Ver <a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">Despliegues para listas, conjuntos y diccionarios</span></a>.</p>
</dd>
<dt class="translated" id="term-dictionary-view">vista de diccionario<a class="headerlink" href="#term-dictionary-view" title="Link to this term">¶</a></dt><dd><p class="translated">Los objetos retornados por los métodos  <a class="reference internal" href="library/stdtypes.html#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.keys()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.values()</span></code></a>, y <a class="reference internal" href="library/stdtypes.html#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.items()</span></code></a> son llamados vistas de diccionarios. Proveen una vista dinámica de las entradas de un diccionario, lo que significa que cuando el diccionario cambia, la vista refleja éstos cambios. Para forzar a la vista de diccionario a convertirse en una lista completa, use <code class="docutils literal notranslate"><span class="pre">list(dictview)</span></code>.  Vea <a class="reference internal" href="library/stdtypes.html#dict-views"><span class="std std-ref">Objetos tipos vista de diccionario</span></a>.</p>
</dd>
<dt class="translated" id="term-docstring">docstring<a class="headerlink" href="#term-docstring" title="Link to this term">¶</a></dt><dd><p class="untranslated">A string literal which appears as the first expression in a class,
function or module.  While ignored when the suite is executed, it is
recognized by the compiler and put into the <a class="reference internal" href="library/stdtypes.html#definition.__doc__" title="definition.__doc__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></a> attribute
of the enclosing class, function or module.  Since it is available via
introspection, it is the canonical place for documentation of the
object.</p>
</dd>
<dt class="translated" id="term-duck-typing">tipado de pato<a class="headerlink" href="#term-duck-typing" title="Link to this term">¶</a></dt><dd><p class="translated">Un estilo de programación que no revisa el tipo del objeto para determinar si tiene la interfaz correcta; en vez de ello, el método o atributo es simplemente llamado o usado («Si se ve como un pato y grazna como un pato, debe ser un pato»).  Enfatizando las interfaces en vez de hacerlo con los tipos específicos, un código bien diseñado pues tener mayor flexibilidad permitiendo la sustitución polimórfica.  El tipado de pato <em>duck-typing</em> evita usar pruebas llamando a <a class="reference internal" href="library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a> o <a class="reference internal" href="library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a>.  (Nota: si embargo, el tipado de pato puede ser complementado con <a class="reference internal" href="#term-abstract-base-class"><span class="xref std std-term">abstract base classes</span></a>. En su lugar, generalmente pregunta con <a class="reference internal" href="library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> o <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a>.</p>
</dd>
<dt class="untranslated" id="term-dunder">dunder<a class="headerlink" href="#term-dunder" title="Link to this term">¶</a></dt><dd><p class="untranslated">An informal short-hand for «double underscore», used when talking about a
<a class="reference internal" href="#term-special-method"><span class="xref std std-term">special method</span></a>. For example, <code class="docutils literal notranslate"><span class="pre">__init__</span></code> is often pronounced
«dunder init».</p>
</dd>
<dt class="translated" id="term-EAFP">EAFP<a class="headerlink" href="#term-EAFP" title="Link to this term">¶</a></dt><dd><p class="translated">Del inglés <em>Easier to ask for forgiveness than permission</em>, es más fácil pedir perdón que pedir permiso.  Este estilo de codificación común en Python asume la existencia de claves o atributos válidos y atrapa las excepciones si esta suposición resulta falsa.  Este estilo rápido y limpio está caracterizado por muchas sentencias <a class="reference internal" href="reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> y <a class="reference internal" href="reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a>.  Esta técnica contrasta con estilo <a class="reference internal" href="#term-LBYL"><span class="xref std std-term">LBYL</span></a> usual en otros lenguajes como C.</p>
</dd>
<dt class="untranslated" id="term-evaluate-function">evaluate function<a class="headerlink" href="#term-evaluate-function" title="Link to this term">¶</a></dt><dd><p class="untranslated">A function that can be called to evaluate a lazily evaluated attribute
of an object, such as the value of type aliases created with the <a class="reference internal" href="reference/simple_stmts.html#type"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">type</span></code></a>
statement.</p>
</dd>
<dt class="translated" id="term-expression">expresión<a class="headerlink" href="#term-expression" title="Link to this term">¶</a></dt><dd><p class="translated">Una construcción sintáctica que puede ser evaluada, hasta dar un valor.  En otras palabras, una expresión es una acumulación de elementos de expresión tales como literales, nombres, accesos a atributos, operadores o llamadas a funciones, todos ellos retornando valor.  A diferencia de otros lenguajes, no toda la sintaxis del lenguaje son expresiones. También hay <a class="reference internal" href="#term-statement"><span class="xref std std-term">statement</span></a>s que no pueden ser usadas como expresiones, como la <a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a>.  Las asignaciones también son sentencias, no expresiones.</p>
</dd>
<dt class="translated" id="term-extension-module">módulo de extensión<a class="headerlink" href="#term-extension-module" title="Link to this term">¶</a></dt><dd><p class="translated">Un módulo escrito en C o C++, usando la API para C de Python para interactuar con el núcleo y el código del usuario.</p>
</dd>
<dt class="translated" id="term-f-string">f-string<a class="headerlink" href="#term-f-string" title="Link to this term">¶</a></dt><dt class="untranslated" id="term-f-strings">f-strings<a class="headerlink" href="#term-f-strings" title="Link to this term">¶</a></dt><dd><p class="untranslated">String literals prefixed with <code class="docutils literal notranslate"><span class="pre">f</span></code> or <code class="docutils literal notranslate"><span class="pre">F</span></code> are commonly called
«f-strings» which is short for
<a class="reference internal" href="reference/lexical_analysis.html#f-strings"><span class="std std-ref">formatted string literals</span></a>.  See also <span class="target" id="index-16"></span><a class="pep reference external" href="https://peps.python.org/pep-0498/"><strong>PEP 498</strong></a>.</p>
</dd>
<dt class="translated" id="term-file-object">objeto archivo<a class="headerlink" href="#term-file-object" title="Link to this term">¶</a></dt><dd><p class="untranslated">An object exposing a file-oriented API (with methods such as
<code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code>) to an underlying resource.  Depending
on the way it was created, a file object can mediate access to a real
on-disk file or to another type of storage or communication device
(for example standard input/output, in-memory buffers, sockets, pipes,
etc.).  File objects are also called <em class="dfn">file-like objects</em> or
<em class="dfn">streams</em>.</p>
<p class="translated">Existen tres categorías de objetos archivo: crudos <em>raw</em> <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">archivos binarios</span></a>, con búfer <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">archivos binarios</span></a> y <a class="reference internal" href="#term-text-file"><span class="xref std std-term">archivos de texto</span></a>.  Sus interfaces son definidas en el módulo <a class="reference internal" href="library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a>.  La forma canónica de crear objetos archivo es usando la función <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.</p>
</dd>
<dt class="translated" id="term-file-like-object">objetos tipo archivo<a class="headerlink" href="#term-file-like-object" title="Link to this term">¶</a></dt><dd><p class="translated">Un sinónimo de <a class="reference internal" href="#term-file-object"><span class="xref std std-term">file object</span></a>.</p>
</dd>
<dt class="translated" id="term-filesystem-encoding-and-error-handler">codificación del sistema de archivos y manejador de errores<a class="headerlink" href="#term-filesystem-encoding-and-error-handler" title="Link to this term">¶</a></dt><dd><p class="translated">Controlador de errores y codificación utilizado por Python para decodificar bytes del sistema operativo y codificar Unicode en el sistema operativo.</p>
<p class="translated">La codificación del sistema de archivos debe garantizar la decodificación exitosa de todos los bytes por debajo de 128. Si la codificación del sistema de archivos no proporciona esta garantía, las funciones de API pueden lanzar <a class="reference internal" href="library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>.</p>
<p class="translated">Las funciones <a class="reference internal" href="library/sys.html#sys.getfilesystemencoding" title="sys.getfilesystemencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencoding()</span></code></a> y <a class="reference internal" href="library/sys.html#sys.getfilesystemencodeerrors" title="sys.getfilesystemencodeerrors"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getfilesystemencodeerrors()</span></code></a> se pueden utilizar para obtener la codificación del sistema de archivos y el controlador de errores.</p>
<p class="translated">La <a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">codificación del sistema de archivos y el manejador de errores</span></a> se configuran al inicio de Python mediante la función <a class="reference internal" href="c-api/init_config.html#c.PyConfig_Read" title="PyConfig_Read"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Read()</span></code></a>: consulte los miembros <a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_encoding" title="PyConfig.filesystem_encoding"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_encoding</span></code></a> y <a class="reference internal" href="c-api/init_config.html#c.PyConfig.filesystem_errors" title="PyConfig.filesystem_errors"><code class="xref c c-member docutils literal notranslate"><span class="pre">filesystem_errors</span></code></a> de <a class="reference internal" href="c-api/init_config.html#c.PyConfig" title="PyConfig"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyConfig</span></code></a>.</p>
<p class="translated">Vea también <a class="reference internal" href="#term-locale-encoding"><span class="xref std std-term">locale encoding</span></a>.</p>
</dd>
<dt class="translated" id="term-finder">buscador<a class="headerlink" href="#term-finder" title="Link to this term">¶</a></dt><dd><p class="translated">Un objeto que trata de encontrar el <a class="reference internal" href="#term-loader"><span class="xref std std-term">loader</span></a> para el módulo que está siendo importado.</p>
<p class="untranslated">There are two types of finder: <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">meta path finders</span></a> for use with <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>, and <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">path
entry finders</span></a> for use with <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a>.</p>
<p class="untranslated">See <a class="reference internal" href="reference/import.html#finders-and-loaders"><span class="std std-ref">Buscadores y cargadores</span></a> and <a class="reference internal" href="library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> for much more detail.</p>
</dd>
<dt class="translated" id="term-floor-division">división entera a la baja<a class="headerlink" href="#term-floor-division" title="Link to this term">¶</a></dt><dd><p class="translated">Una división matemática que se redondea hacia el entero menor más cercano.  El operador de la división entera a la baja es <code class="docutils literal notranslate"><span class="pre">//</span></code>.  Por ejemplo, la expresión <code class="docutils literal notranslate"><span class="pre">11</span> <span class="pre">//</span> <span class="pre">4</span></code> evalúa <code class="docutils literal notranslate"><span class="pre">2</span></code> a diferencia del <code class="docutils literal notranslate"><span class="pre">2.75</span></code> retornado por la verdadera división de números flotantes.  Note que <code class="docutils literal notranslate"><span class="pre">(-11)</span> <span class="pre">//</span> <span class="pre">4</span></code> es <code class="docutils literal notranslate"><span class="pre">-3</span></code> porque es <code class="docutils literal notranslate"><span class="pre">-2.75</span></code> redondeado <em>para abajo</em>. Ver <span class="target" id="index-77"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a>.</p>
</dd>
<dt class="untranslated" id="term-free-threading">free threading<a class="headerlink" href="#term-free-threading" title="Link to this term">¶</a></dt><dd><p class="untranslated">A threading model where multiple threads can run Python bytecode
simultaneously within the same interpreter.  This is in contrast to
the <a class="reference internal" href="#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a> which allows only one thread to
execute Python bytecode at a time.  See <span class="target" id="index-18"></span><a class="pep reference external" href="https://peps.python.org/pep-0703/"><strong>PEP 703</strong></a>.</p>
</dd>
<dt class="untranslated" id="term-free-variable">free variable<a class="headerlink" href="#term-free-variable" title="Link to this term">¶</a></dt><dd><p class="untranslated">Formally, as defined in the <a class="reference internal" href="reference/executionmodel.html#bind-names"><span class="std std-ref">language execution model</span></a>, a free
variable is any variable used in a namespace which is not a local variable in that
namespace. See <a class="reference internal" href="#term-closure-variable"><span class="xref std std-term">closure variable</span></a> for an example.
Pragmatically, due to the name of the <a class="reference internal" href="reference/datamodel.html#codeobject.co_freevars" title="codeobject.co_freevars"><code class="xref py py-attr docutils literal notranslate"><span class="pre">codeobject.co_freevars</span></code></a> attribute,
the term is also sometimes used as a synonym for <a class="reference internal" href="#term-closure-variable"><span class="xref std std-term">closure variable</span></a>.</p>
</dd>
<dt class="translated" id="term-function">función<a class="headerlink" href="#term-function" title="Link to this term">¶</a></dt><dd><p class="translated">Una serie de sentencias que retornan un valor al que las llama.  También se le puede pasar cero o más <a class="reference internal" href="#term-argument"><span class="xref std std-term">argumentos</span></a> los cuales pueden ser usados en la ejecución de la misma. Vea también <a class="reference internal" href="#term-parameter"><span class="xref std std-term">parameter</span></a>, <a class="reference internal" href="#term-method"><span class="xref std std-term">method</span></a>, y la sección <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Definiciones de funciones</span></a>.</p>
</dd>
<dt class="translated" id="term-function-annotation">anotación de función<a class="headerlink" href="#term-function-annotation" title="Link to this term">¶</a></dt><dd><p class="translated">Una <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> del parámetro de una función o un valor de retorno.</p>
<p class="translated">Las anotaciones de funciones son usadas frecuentemente para <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">indicadores de tipo</span></a>, por ejemplo, se espera que una función tome dos argumentos de clase <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>  y también se espera que retorne dos valores <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">sum_two_numbers</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
   <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p class="translated">La sintaxis de las anotaciones de funciones son explicadas en la sección <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Definiciones de funciones</span></a>.</p>
<p class="translated">Consulte <a class="reference internal" href="#term-variable-annotation"><span class="xref std std-term">variable annotation</span></a> y <span class="target" id="index-78"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, que describen esta funcionalidad. Consulte también <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Prácticas recomendadas para las anotaciones</span></a> para conocer las mejores prácticas sobre cómo trabajar con anotaciones.</p>
</dd>
<dt class="translated" id="term-__future__">__future__<a class="headerlink" href="#term-__future__" title="Link to this term">¶</a></dt><dd><p class="translated">Un <a class="reference internal" href="reference/simple_stmts.html#future"><span class="std std-ref">future statement</span></a>, <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">&lt;feature&gt;</span></code>, indica al compilador que compile el módulo actual utilizando una sintaxis o semántica que se convertirá en estándar en una versión futura de Python. El módulo <a class="reference internal" href="library/__future__.html#module-__future__" title="__future__: Future statement definitions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">__future__</span></code></a> documenta los posibles valores de <em>feature</em>. Al importar este módulo y evaluar sus variables, puede ver cuándo se agregó por primera vez una nueva característica al lenguaje y cuándo se convertirá (o se convirtió) en la predeterminada:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">__future__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">__future__</span><span class="o">.</span><span class="n">division</span>
<span class="go">_Feature((2, 2, 0, &#39;alpha&#39;, 2), (3, 0, 0, &#39;alpha&#39;, 0), 8192)</span>
</pre></div>
</div>
</dd>
<dt class="translated" id="term-garbage-collection">recolección de basura<a class="headerlink" href="#term-garbage-collection" title="Link to this term">¶</a></dt><dd><p class="translated">El proceso de liberar la memoria de lo que ya no está en uso.  Python realiza recolección de basura (<em>garbage collection</em>) llevando la cuenta de las referencias, y el recogedor de basura cíclico es capaz de detectar y romper las referencias cíclicas.  El recogedor de basura puede ser controlado mediante el módulo <a class="reference internal" href="library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> .</p>
</dd>
<dt class="translated" id="term-generator">generador<a class="headerlink" href="#term-generator" title="Link to this term">¶</a></dt><dd><p class="translated">Una función que retorna un <a class="reference internal" href="#term-generator-iterator"><span class="xref std std-term">generator iterator</span></a>.  Luce como una función normal excepto que contiene la expresión <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> para producir series de valores utilizables en un bucle <em>for</em> o que pueden ser obtenidas una por una con la función <a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>.</p>
<p class="translated">Usualmente se refiere a una función generadora, pero puede referirse a un <em>iterador generador</em> en ciertos contextos.  En aquellos casos en los que el significado no está claro, usar los términos completos  evita la ambigüedad.</p>
</dd>
<dt class="translated" id="term-generator-iterator">iterador generador<a class="headerlink" href="#term-generator-iterator" title="Link to this term">¶</a></dt><dd><p class="translated">Un objeto creado por una función <a class="reference internal" href="#term-generator"><span class="xref std std-term">generator</span></a>.</p>
<p class="untranslated">Each <a class="reference internal" href="reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> temporarily suspends processing, remembering the
execution state (including local variables and pending
try-statements).  When the <em>generator iterator</em> resumes, it picks up where
it left off (in contrast to functions which start fresh on every
invocation).</p>
</dd>
<dt class="translated" id="term-generator-expression">expresión generadora<a class="headerlink" href="#term-generator-expression" title="Link to this term">¶</a></dt><dd><p class="untranslated">An <a class="reference internal" href="#term-expression"><span class="xref std std-term">expression</span></a> that returns an <a class="reference internal" href="#term-iterator"><span class="xref std std-term">iterator</span></a>.  It looks like a normal expression
followed by a <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code> clause defining a loop variable, range,
and an optional <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> clause.  The combined expression
generates values for an enclosing function:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>         <span class="c1"># sum of squares 0, 1, 4, ... 81</span>
<span class="go">285</span>
</pre></div>
</div>
</dd>
<dt class="translated" id="term-generic-function">función genérica<a class="headerlink" href="#term-generic-function" title="Link to this term">¶</a></dt><dd><p class="translated">Una función compuesta de muchas funciones que implementan la misma operación para diferentes tipos. Qué implementación deberá ser usada durante la llamada a la misma es determinado por el algoritmo de despacho.</p>
<p class="translated">Vea también la entrada de glosario <a class="reference internal" href="#term-single-dispatch"><span class="xref std std-term">single dispatch</span></a>, el decorador <a class="reference internal" href="library/functools.html#functools.singledispatch" title="functools.singledispatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.singledispatch()</span></code></a>, y <span class="target" id="index-79"></span><a class="pep reference external" href="https://peps.python.org/pep-0443/"><strong>PEP 443</strong></a>.</p>
</dd>
<dt class="translated" id="term-generic-type">tipos genéricos<a class="headerlink" href="#term-generic-type" title="Link to this term">¶</a></dt><dd><p class="translated">Un <a class="reference internal" href="#term-type"><span class="xref std std-term">type</span></a> que se puede parametrizar; normalmente un <a class="reference internal" href="reference/datamodel.html#sequence-types"><span class="std std-ref">container class</span></a> como <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> o <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>. Usado para <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">type hints</span></a> y <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotations</span></a>.</p>
<p class="translated">Para más detalles, véase <a class="reference internal" href="library/stdtypes.html#types-genericalias"><span class="std std-ref">generic alias types</span></a>, <span class="target" id="index-80"></span><a class="pep reference external" href="https://peps.python.org/pep-0483/"><strong>PEP 483</strong></a>, <span class="target" id="index-81"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, <span class="target" id="index-82"></span><a class="pep reference external" href="https://peps.python.org/pep-0585/"><strong>PEP 585</strong></a>, y el módulo <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a>.</p>
</dd>
<dt class="translated" id="term-GIL">GIL<a class="headerlink" href="#term-GIL" title="Link to this term">¶</a></dt><dd><p class="translated">Vea <a class="reference internal" href="#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a>.</p>
</dd>
<dt class="translated" id="term-global-interpreter-lock">bloqueo global del intérprete<a class="headerlink" href="#term-global-interpreter-lock" title="Link to this term">¶</a></dt><dd><p class="translated">Mecanismo empleado por el intérprete <a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> para asegurar que sólo un hilo ejecute el  <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">bytecode</span></a> Python por vez. Esto simplifica la implementación de CPython haciendo que el modelo de objetos (incluyendo algunos críticos como <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>) están implícitamente a salvo de acceso concurrente.  Bloqueando el intérprete completo se simplifica hacerlo multi-hilos, a costa de mucho del paralelismo ofrecido por las máquinas con múltiples procesadores.</p>
<p class="translated">Sin embargo, algunos módulos de extensión, tanto estándar como de terceros, están diseñados para liberar el GIL cuando se realizan tareas computacionalmente intensivas como la compresión o el <em>hashing</em>.  Además, el GIL siempre es liberado cuando se hace entrada/salida.</p>
<p class="untranslated">As of Python 3.13, the GIL can be disabled using the <a class="reference internal" href="using/configure.html#cmdoption-disable-gil"><code class="xref std std-option docutils literal notranslate"><span class="pre">--disable-gil</span></code></a>
build configuration. After building Python with this option, code must be
run with <a class="reference internal" href="using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span> <span class="pre">gil=0</span></code></a> or after setting the <span class="target" id="index-26"></span><a class="reference internal" href="using/cmdline.html#envvar-PYTHON_GIL"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHON_GIL=0</span></code></a>
environment variable. This feature enables improved performance for
multi-threaded applications and makes it easier to use multi-core CPUs
efficiently. For more details, see <span class="target" id="index-27"></span><a class="pep reference external" href="https://peps.python.org/pep-0703/"><strong>PEP 703</strong></a>.</p>
<p class="untranslated">In prior versions of Python’s C API, a function might declare that it
requires the GIL to be held in order to use it. This refers to having an
<a class="reference internal" href="#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>.</p>
</dd>
<dt class="translated" id="term-hash-based-pyc">hash-based pyc<a class="headerlink" href="#term-hash-based-pyc" title="Link to this term">¶</a></dt><dd><p class="translated">Un archivo cache de <em>bytecode</em> que usa el <em>hash</em> en vez de usar el tiempo de la última modificación del archivo fuente correspondiente para determinar su validez. Vea <a class="reference internal" href="reference/import.html#pyc-invalidation"><span class="std std-ref">Invalidación del código de bytes en caché</span></a>.</p>
</dd>
<dt class="translated" id="term-hashable">hashable<a class="headerlink" href="#term-hashable" title="Link to this term">¶</a></dt><dd><p class="untranslated">An object is <em>hashable</em> if it has a hash value which never changes during
its lifetime (it needs a <a class="reference internal" href="reference/datamodel.html#object.__hash__" title="object.__hash__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code></a> method), and can be
compared to other objects (it needs an <a class="reference internal" href="reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> method).
Hashable objects which
compare equal must have the same hash value.</p>
<p class="translated">Ser <em>hashable</em> hace a un objeto utilizable como clave de un diccionario y miembro de un set, porque éstas estructuras de datos usan los valores de hash internamente.</p>
<p class="translated">La mayoría de los objetos inmutables incorporados en Python son <em>hashables</em>; los contenedores mutables (como las listas o los diccionarios) no lo son; los contenedores inmutables (como tuplas y conjuntos <em>frozensets</em>) son <em>hashables</em> si sus elementos son <em>hashables</em> .  Los objetos que son instancias de clases definidas por el usuario son <em>hashables</em> por defecto.  Todos se comparan como desiguales (excepto consigo mismos), y su valor de hash está derivado de su función <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a>.</p>
</dd>
<dt class="translated" id="term-IDLE">IDLE<a class="headerlink" href="#term-IDLE" title="Link to this term">¶</a></dt><dd><p class="translated">Un Entorno Integrado de Desarrollo y Aprendizaje para Python. <a class="reference internal" href="library/idle.html#idle"><span class="std std-ref">IDLE — Python editor and shell</span></a> es un editor básico y un entorno de intérprete que se incluye con la distribución estándar de Python.</p>
</dd>
<dt class="untranslated" id="term-immortal">immortal<a class="headerlink" href="#term-immortal" title="Link to this term">¶</a></dt><dd><p class="untranslated"><em>Immortal objects</em> are a CPython implementation detail introduced
in <span class="target" id="index-28"></span><a class="pep reference external" href="https://peps.python.org/pep-0683/"><strong>PEP 683</strong></a>.</p>
<p class="untranslated">If an object is immortal, its <a class="reference internal" href="#term-reference-count"><span class="xref std std-term">reference count</span></a> is never modified,
and therefore it is never deallocated while the interpreter is running.
For example, <a class="reference internal" href="library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> and <a class="reference internal" href="library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> are immortal in CPython.</p>
<p class="untranslated">Immortal objects can be identified via <a class="reference internal" href="library/sys.html#sys._is_immortal" title="sys._is_immortal"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys._is_immortal()</span></code></a>, or
via <a class="reference internal" href="c-api/object.html#c.PyUnstable_IsImmortal" title="PyUnstable_IsImmortal"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnstable_IsImmortal()</span></code></a> in the C API.</p>
</dd>
<dt class="translated" id="term-immutable">inmutable<a class="headerlink" href="#term-immutable" title="Link to this term">¶</a></dt><dd><p class="translated">Un objeto con un valor fijo.  Los objetos inmutables son números, cadenas y tuplas.  Éstos objetos no pueden ser alterados.  Un nuevo objeto debe ser creado si un valor diferente ha de ser guardado.  Juegan un rol importante en lugares donde es necesario un valor de hash constante, por ejemplo como claves de un diccionario.</p>
</dd>
<dt class="translated" id="term-import-path">ruta de importación<a class="headerlink" href="#term-import-path" title="Link to this term">¶</a></dt><dd><p class="translated">Una lista de las ubicaciones (o <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">entradas de ruta</span></a>) que son revisadas por <a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">path based finder</span></a> al importar módulos. Durante la importación, ésta lista de localizaciones usualmente viene de <a class="reference internal" href="library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>, pero para los subpaquetes también puede incluir al atributo <code class="docutils literal notranslate"><span class="pre">__path__</span></code> del paquete padre.</p>
</dd>
<dt class="translated" id="term-importing">importar<a class="headerlink" href="#term-importing" title="Link to this term">¶</a></dt><dd><p class="translated">El proceso mediante el cual el código Python dentro de un módulo se hace alcanzable desde otro código Python en otro módulo.</p>
</dd>
<dt class="translated" id="term-importer">importador<a class="headerlink" href="#term-importer" title="Link to this term">¶</a></dt><dd><p class="translated">Un objeto que buscan y lee un módulo; un objeto que es tanto <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a> como <a class="reference internal" href="#term-loader"><span class="xref std std-term">loader</span></a>.</p>
</dd>
<dt class="translated" id="term-interactive">interactivo<a class="headerlink" href="#term-interactive" title="Link to this term">¶</a></dt><dd><p class="untranslated">Python has an interactive interpreter which means you can enter
statements and expressions at the interpreter prompt, immediately
execute them and see their results.  Just launch <code class="docutils literal notranslate"><span class="pre">python</span></code> with no
arguments (possibly by selecting it from your computer’s main
menu). It is a very powerful way to test out new ideas or inspect
modules and packages (remember <code class="docutils literal notranslate"><span class="pre">help(x)</span></code>). For more on interactive
mode, see <a class="reference internal" href="tutorial/appendix.html#tut-interac"><span class="std std-ref">Modo interactivo</span></a>.</p>
</dd>
<dt class="translated" id="term-interpreted">interpretado<a class="headerlink" href="#term-interpreted" title="Link to this term">¶</a></dt><dd><p class="translated">Python es un lenguaje interpretado, a diferencia de uno compilado, a pesar de que la distinción puede ser difusa debido al compilador a <em>bytecode</em>.  Esto significa que los archivos fuente pueden ser corridos directamente, sin crear explícitamente un ejecutable que es corrido luego. Los lenguajes interpretados típicamente tienen ciclos de desarrollo y depuración más cortos que los compilados, sin embargo sus programas suelen correr más lentamente.  Vea también  <a class="reference internal" href="#term-interactive"><span class="xref std std-term">interactive</span></a>.</p>
</dd>
<dt class="translated" id="term-interpreter-shutdown">apagado del intérprete<a class="headerlink" href="#term-interpreter-shutdown" title="Link to this term">¶</a></dt><dd><p class="translated">Cuando se le solicita apagarse, el intérprete Python ingresa a un fase especial en la cual gradualmente libera todos los recursos reservados, como módulos y varias estructuras internas críticas.  También hace varias llamadas al <a class="reference internal" href="#term-garbage-collection"><span class="xref std std-term">recolector de basura</span></a>.  Esto puede disparar la ejecución de código de destructores definidos por el usuario o <em>weakref callbacks</em>. El código ejecutado durante la fase de apagado puede encontrar varias excepciones debido a que los recursos que necesita pueden no funcionar más (ejemplos comunes son los módulos de bibliotecas o los artefactos de advertencias <em>warnings machinery</em>)</p>
<p class="translated">La principal razón para el apagado del intérpreter es que el módulo <code class="docutils literal notranslate"><span class="pre">__main__</span></code> o el script que estaba corriendo termine su ejecución.</p>
</dd>
<dt class="translated" id="term-iterable">iterable<a class="headerlink" href="#term-iterable" title="Link to this term">¶</a></dt><dd><p class="untranslated">An object capable of returning its members one at a time. Examples of
iterables include all sequence types (such as <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>,
and <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>) and some non-sequence types like <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>,
<a class="reference internal" href="#term-file-object"><span class="xref std std-term">file objects</span></a>, and objects of any classes you define
with an <a class="reference internal" href="reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method or with a
<a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> method
that implements <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a> semantics.</p>
<p class="untranslated">Iterables can be
used in a <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> loop and in many other places where a sequence is
needed (<a class="reference internal" href="library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a>, <a class="reference internal" href="library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a>, …).  When an iterable object is passed
as an argument to the built-in function <a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a>, it returns an
iterator for the object.  This iterator is good for one pass over the set
of values.  When using iterables, it is usually not necessary to call
<a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> or deal with iterator objects yourself.  The <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>
statement does that automatically for you, creating a temporary unnamed
variable to hold the iterator for the duration of the loop.  See also
<a class="reference internal" href="#term-iterator"><span class="xref std std-term">iterator</span></a>, <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>, and <a class="reference internal" href="#term-generator"><span class="xref std std-term">generator</span></a>.</p>
</dd>
<dt class="translated" id="term-iterator">iterador<a class="headerlink" href="#term-iterator" title="Link to this term">¶</a></dt><dd><p class="untranslated">An object representing a stream of data.  Repeated calls to the iterator’s
<a class="reference internal" href="library/stdtypes.html#iterator.__next__" title="iterator.__next__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code></a> method (or passing it to the built-in function
<a class="reference internal" href="library/functions.html#next" title="next"><code class="xref py py-func docutils literal notranslate"><span class="pre">next()</span></code></a>) return successive items in the stream.  When no more data
are available a <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> exception is raised instead.  At this
point, the iterator object is exhausted and any further calls to its
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__next__()</span></code> method just raise <a class="reference internal" href="library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> again.  Iterators
are required to have an <a class="reference internal" href="library/stdtypes.html#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a> method that returns the iterator
object itself so every iterator is also iterable and may be used in most
places where other iterables are accepted.  One notable exception is code
which attempts multiple iteration passes.  A container object (such as a
<a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>) produces a fresh new iterator each time you pass it to the
<a class="reference internal" href="library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> function or use it in a <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> loop.  Attempting this
with an iterator will just return the same exhausted iterator object used
in the previous iteration pass, making it appear like an empty container.</p>
<p class="translated">Puede encontrar más información en <a class="reference internal" href="library/stdtypes.html#typeiter"><span class="std std-ref">Tipos de iteradores</span></a>.</p>
<div class="impl-detail compound">
<p class="untranslated"><strong>Detalles de implementación de CPython:</strong> CPython does not consistently apply the requirement that an iterator
define <a class="reference internal" href="library/stdtypes.html#iterator.__iter__" title="iterator.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>.
And also please note that the free-threading CPython does not guarantee
the thread-safety of iterator operations.</p>
</div>
</dd>
<dt class="translated" id="term-key-function">función clave<a class="headerlink" href="#term-key-function" title="Link to this term">¶</a></dt><dd><p class="translated">Una función clave o una función de colación es un invocable que retorna un valor usado para el ordenamiento o clasificación.  Por ejemplo, <a class="reference internal" href="library/locale.html#locale.strxfrm" title="locale.strxfrm"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.strxfrm()</span></code></a> es usada para producir claves de ordenamiento que se adaptan a las convenciones específicas de ordenamiento de un <em>locale</em>.</p>
<p class="translated">Cierta cantidad de herramientas de Python aceptan funciones clave para controlar como los elementos son ordenados o agrupados. Incluyendo a  <a class="reference internal" href="library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>, <a class="reference internal" href="library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a>, <a class="reference internal" href="library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.merge" title="heapq.merge"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.merge()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nsmallest" title="heapq.nsmallest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nsmallest()</span></code></a>, <a class="reference internal" href="library/heapq.html#heapq.nlargest" title="heapq.nlargest"><code class="xref py py-func docutils literal notranslate"><span class="pre">heapq.nlargest()</span></code></a>, y <a class="reference internal" href="library/itertools.html#itertools.groupby" title="itertools.groupby"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.groupby()</span></code></a>.</p>
<p class="translated">Hay varias formas de crear una función clave.  Por ejemplo, el método <a class="reference internal" href="library/stdtypes.html#str.lower" title="str.lower"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.lower()</span></code></a> puede servir como función clave para ordenamientos que no distingan mayúsculas de minúsculas.  Como alternativa, una función clave puede ser realizada con una expresión <a class="reference internal" href="reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> como <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">r:</span> <span class="pre">(r[0],</span> <span class="pre">r[2])</span></code>.  Además, <a class="reference internal" href="library/operator.html#operator.attrgetter" title="operator.attrgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.attrgetter()</span></code></a>, <a class="reference internal" href="library/operator.html#operator.itemgetter" title="operator.itemgetter"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.itemgetter()</span></code></a> y <a class="reference internal" href="library/operator.html#operator.methodcaller" title="operator.methodcaller"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.methodcaller()</span></code></a> son tres constructores de funciones clave.  Consulte <a class="reference internal" href="howto/sorting.html#sortinghowto"><span class="std std-ref">Sorting HOW TO</span></a> para ver ejemplos de cómo crear y utilizar funciones clave.</p>
</dd>
<dt class="translated" id="term-keyword-argument">argumento nombrado<a class="headerlink" href="#term-keyword-argument" title="Link to this term">¶</a></dt><dd><p class="translated">Vea <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>.</p>
</dd>
<dt class="translated" id="term-lambda">lambda<a class="headerlink" href="#term-lambda" title="Link to this term">¶</a></dt><dd><p class="translated">Una función anónima de una línea consistente en un sola <a class="reference internal" href="#term-expression"><span class="xref std std-term">expression</span></a> que es evaluada cuando la función es llamada.  La sintaxis para crear una función lambda es <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">[parameters]:</span> <span class="pre">expression</span></code></p>
</dd>
<dt class="translated" id="term-LBYL">LBYL<a class="headerlink" href="#term-LBYL" title="Link to this term">¶</a></dt><dd><p class="translated">Del inglés <em>Look before you leap</em>, «mira antes de saltar».  Es un estilo de codificación que prueba explícitamente las condiciones previas antes de hacer llamadas o búsquedas.  Este estilo contrasta con la manera <a class="reference internal" href="#term-EAFP"><span class="xref std std-term">EAFP</span></a> y está caracterizado por la presencia de muchas sentencias <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>.</p>
<p class="translated">En entornos multi-hilos, el método LBYL tiene el riesgo de introducir condiciones de carrera entre los hilos que están «mirando» y los que están «saltando».  Por ejemplo, el código, <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">key</span> <span class="pre">in</span> <span class="pre">mapping:</span> <span class="pre">return</span> <span class="pre">mapping[key]</span></code>  puede fallar si otro hilo remueve <em>key</em> de <em>mapping</em> después del test, pero antes de retornar el valor.  Este problema puede ser resuelto usando bloqueos o empleando el método EAFP.</p>
</dd>
<dt class="untranslated" id="term-lexical-analyzer">lexical analyzer<a class="headerlink" href="#term-lexical-analyzer" title="Link to this term">¶</a></dt><dd><p class="untranslated">Formal name for the <em>tokenizer</em>; see <a class="reference internal" href="#term-token"><span class="xref std std-term">token</span></a>.</p>
</dd>
<dt class="translated" id="term-list">lista<a class="headerlink" href="#term-list" title="Link to this term">¶</a></dt><dd><p class="untranslated">A built-in Python <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>.  Despite its name it is more akin
to an array in other languages than to a linked list since access to
elements is <em>O</em>(1).</p>
</dd>
<dt class="translated" id="term-list-comprehension">comprensión de listas<a class="headerlink" href="#term-list-comprehension" title="Link to this term">¶</a></dt><dd><p class="translated">Una forma compacta de procesar todos o parte de los elementos en una secuencia y retornar una lista como resultado.  <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">['{:#04x}'.format(x)</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">range(256)</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0]</span></code> genera una lista de cadenas conteniendo números hexadecimales (0x..) entre 0 y 255. La cláusula <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> es opcional.  Si es omitida, todos los elementos en <code class="docutils literal notranslate"><span class="pre">range(256)</span></code> son procesados.</p>
</dd>
<dt class="translated" id="term-loader">cargador<a class="headerlink" href="#term-loader" title="Link to this term">¶</a></dt><dd><p class="untranslated">An object that loads a module.
It must define the <code class="xref py py-meth docutils literal notranslate"><span class="pre">exec_module()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">create_module()</span></code> methods
to implement the <a class="reference internal" href="library/importlib.html#importlib.abc.Loader" title="importlib.abc.Loader"><code class="xref py py-class docutils literal notranslate"><span class="pre">Loader</span></code></a> interface.
A loader is typically returned by a <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a>.
See also:</p>
<ul class="simple">
<li><p class="untranslated"><a class="reference internal" href="reference/import.html#finders-and-loaders"><span class="std std-ref">Buscadores y cargadores</span></a></p></li>
<li><p class="untranslated"><a class="reference internal" href="library/importlib.html#importlib.abc.Loader" title="importlib.abc.Loader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.Loader</span></code></a></p></li>
<li><p class="untranslated"><span class="target" id="index-29"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a></p></li>
</ul>
</dd>
<dt class="translated" id="term-locale-encoding">codificación de la configuración regional<a class="headerlink" href="#term-locale-encoding" title="Link to this term">¶</a></dt><dd><p class="translated">En Unix, es la codificación de la configuración regional LC_CTYPE. Se puede configurar con <a class="reference internal" href="library/locale.html#locale.setlocale" title="locale.setlocale"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.setlocale(locale.LC_CTYPE,</span> <span class="pre">new_locale)</span></code></a>.</p>
<p class="translated">En Windows, es la página de códigos ANSI (por ejemplo, <code class="docutils literal notranslate"><span class="pre">&quot;cp1252&quot;</span></code>).</p>
<p class="translated">En Android y VxWorks, Python utiliza <code class="docutils literal notranslate"><span class="pre">&quot;utf-8&quot;</span></code> como codificación regional.</p>
<p class="untranslated"><a class="reference internal" href="library/locale.html#locale.getencoding" title="locale.getencoding"><code class="xref py py-func docutils literal notranslate"><span class="pre">locale.getencoding()</span></code></a> can be used to get the locale encoding.</p>
<p class="translated">Vea también <a class="reference internal" href="#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a>.</p>
</dd>
<dt class="translated" id="term-magic-method">método mágico<a class="headerlink" href="#term-magic-method" title="Link to this term">¶</a></dt><dd><p class="translated" id="index-30">Una manera informal de llamar a un <a class="reference internal" href="#term-special-method"><span class="xref std std-term">special method</span></a>.</p>
</dd>
<dt class="translated" id="term-mapping">mapeado<a class="headerlink" href="#term-mapping" title="Link to this term">¶</a></dt><dd><p class="translated">Un objeto contenedor que permite recupero de claves arbitrarias y que implementa los métodos especificados en la <a class="reference internal" href="library/collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Mapping</span></code></a> o <a class="reference internal" href="library/collections.abc.html#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.MutableMapping</span></code></a> <a class="reference internal" href="library/collections.abc.html#collections-abstract-base-classes"><span class="std std-ref">abstract base classes</span></a>.  Por ejemplo, <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.defaultdict" title="collections.defaultdict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.defaultdict</span></code></a>, <a class="reference internal" href="library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> y <a class="reference internal" href="library/collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.Counter</span></code></a>.</p>
</dd>
<dt class="translated" id="term-meta-path-finder">meta buscadores de ruta<a class="headerlink" href="#term-meta-path-finder" title="Link to this term">¶</a></dt><dd><p class="translated">Un <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a> retornado por una búsqueda de <a class="reference internal" href="library/sys.html#sys.meta_path" title="sys.meta_path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.meta_path</span></code></a>.  Los meta buscadores de ruta están relacionados a <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">buscadores de entradas de rutas</span></a>, pero son algo diferente.</p>
<p class="translated">Vea en <a class="reference internal" href="library/importlib.html#importlib.abc.MetaPathFinder" title="importlib.abc.MetaPathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder</span></code></a> los métodos que los meta buscadores de ruta implementan.</p>
</dd>
<dt class="translated" id="term-metaclass">metaclase<a class="headerlink" href="#term-metaclass" title="Link to this term">¶</a></dt><dd><p class="translated">La clase de una clase.  Las definiciones de clases crean nombres de clase, un diccionario de clase, y una lista de clases base.  Las metaclases son responsables de tomar estos tres argumentos y crear la clase.  La mayoría de los objetos de un lenguaje de programación orientado a objetos provienen de una implementación por defecto.  Lo que hace a Python especial que es posible crear metaclases a medida.  La mayoría de los usuario nunca necesitarán esta herramienta, pero cuando la necesidad surge, las metaclases pueden brindar soluciones poderosas y elegantes.  Han sido usadas para <em>loggear</em> acceso de atributos, agregar seguridad a hilos, rastrear la creación de objetos, implementar <em>singletons</em>, y muchas otras tareas.</p>
<p class="translated">Más información hallará en <a class="reference internal" href="reference/datamodel.html#metaclasses"><span class="std std-ref">Metaclases</span></a>.</p>
</dd>
<dt class="translated" id="term-method">método<a class="headerlink" href="#term-method" title="Link to this term">¶</a></dt><dd><p class="translated">Una función que es definida dentro del cuerpo de una clase.  Si es llamada como un atributo de una instancia de otra clase, el método tomará el objeto instanciado como su primer <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a> (el cual es usualmente denominado <cite>self</cite>). Vea <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> y <a class="reference internal" href="#term-nested-scope"><span class="xref std std-term">nested scope</span></a>.</p>
</dd>
<dt class="translated" id="term-method-resolution-order">orden de resolución de métodos<a class="headerlink" href="#term-method-resolution-order" title="Link to this term">¶</a></dt><dd><p class="untranslated">Method Resolution Order is the order in which base classes are searched
for a member during lookup. See <a class="reference internal" href="howto/mro.html#python-2-3-mro"><span class="std std-ref">The Python 2.3 Method Resolution Order</span></a> for details of the
algorithm used by the Python interpreter since the 2.3 release.</p>
</dd>
<dt class="translated" id="term-module">módulo<a class="headerlink" href="#term-module" title="Link to this term">¶</a></dt><dd><p class="translated">Un objeto que sirve como unidad de organización del código Python.  Los módulos tienen espacios de nombres conteniendo objetos Python arbitrarios.  Los módulos son cargados en Python por el proceso de <a class="reference internal" href="#term-importing"><span class="xref std std-term">importing</span></a>.</p>
<p class="translated">Vea también <a class="reference internal" href="#term-package"><span class="xref std std-term">package</span></a>.</p>
</dd>
<dt class="translated" id="term-module-spec">especificador de módulo<a class="headerlink" href="#term-module-spec" title="Link to this term">¶</a></dt><dd><p class="translated">Un espacio de nombres que contiene la información relacionada a la importación usada al leer un módulo.  Una instancia de  <a class="reference internal" href="library/importlib.html#importlib.machinery.ModuleSpec" title="importlib.machinery.ModuleSpec"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ModuleSpec</span></code></a>.</p>
<p class="untranslated">See also <a class="reference internal" href="reference/import.html#module-specs"><span class="std std-ref">Module specs</span></a>.</p>
</dd>
<dt class="translated" id="term-MRO">MRO<a class="headerlink" href="#term-MRO" title="Link to this term">¶</a></dt><dd><p class="translated">Vea <a class="reference internal" href="#term-method-resolution-order"><span class="xref std std-term">method resolution order</span></a>.</p>
</dd>
<dt class="translated" id="term-mutable">mutable<a class="headerlink" href="#term-mutable" title="Link to this term">¶</a></dt><dd><p class="translated">Los objetos mutables pueden cambiar su valor pero mantener su <a class="reference internal" href="library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a>.  Vea también <a class="reference internal" href="#term-immutable"><span class="xref std std-term">immutable</span></a>.</p>
</dd>
<dt class="translated" id="term-named-tuple">tupla nombrada<a class="headerlink" href="#term-named-tuple" title="Link to this term">¶</a></dt><dd><p class="translated">La denominación «tupla nombrada» se aplica a cualquier tipo o clase que hereda de una tupla y cuyos elementos indexables son también accesibles usando atributos nombrados. Este tipo o clase puede tener además otras capacidades.</p>
<p class="translated">Varios tipos incorporados son tuplas nombradas, incluyendo los valores retornados por <a class="reference internal" href="library/time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.localtime()</span></code></a> y <a class="reference internal" href="library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a>.  Otro ejemplo es <a class="reference internal" href="library/sys.html#sys.float_info" title="sys.float_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.float_info</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>                   <span class="c1"># indexed access</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max_exp</span>              <span class="c1"># named field access</span>
<span class="go">1024</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>   <span class="c1"># kind of tuple</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="untranslated">Some named tuples are built-in types (such as the above examples).
Alternatively, a named tuple can be created from a regular class
definition that inherits from <a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> and that defines named
fields.  Such a class can be written by hand, or it can be created by
inheriting <a class="reference internal" href="library/typing.html#typing.NamedTuple" title="typing.NamedTuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.NamedTuple</span></code></a>, or with the factory function
<a class="reference internal" href="library/collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a>.  The latter techniques also add some
extra methods that may not be found in hand-written or built-in named
tuples.</p>
</dd>
<dt class="translated" id="term-namespace">espacio de nombres<a class="headerlink" href="#term-namespace" title="Link to this term">¶</a></dt><dd><p class="translated">El lugar donde la variable es almacenada.  Los espacios de nombres son implementados como diccionarios.  Hay espacio de nombre local, global, e incorporado así como espacios de nombres anidados en objetos (en métodos).  Los espacios de nombres soportan modularidad previniendo conflictos de nombramiento.  Por ejemplo, las funciones <a class="reference internal" href="library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">builtins.open</span></code></a> y <a class="reference internal" href="library/os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> se distinguen por su espacio de nombres.  Los espacios de nombres también ayuda a la legibilidad y mantenibilidad dejando claro qué módulo implementa una función.  Por ejemplo, escribiendo <a class="reference internal" href="library/random.html#random.seed" title="random.seed"><code class="xref py py-func docutils literal notranslate"><span class="pre">random.seed()</span></code></a> o <a class="reference internal" href="library/itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.islice()</span></code></a> queda claro que éstas funciones están implementadas en los módulos <a class="reference internal" href="library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> y <a class="reference internal" href="library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a>, respectivamente.</p>
</dd>
<dt class="translated" id="term-namespace-package">paquete de espacios de nombres<a class="headerlink" href="#term-namespace-package" title="Link to this term">¶</a></dt><dd><p class="untranslated">A <a class="reference internal" href="#term-package"><span class="xref std std-term">package</span></a> which serves only as a container for subpackages.
Namespace packages may have no physical representation,
and specifically are not like a <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">regular package</span></a> because they
have no <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file.</p>
<p class="untranslated">Namespace packages allow several individually installable packages to have a common parent package.
Otherwise, it is recommended to use a <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">regular package</span></a>.</p>
<p class="untranslated">For more information, see <span class="target" id="index-31"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a> and <a class="reference internal" href="reference/import.html#reference-namespace-package"><span class="std std-ref">Paquetes de espacio de nombres</span></a>.</p>
<p class="translated">Vea también <a class="reference internal" href="#term-module"><span class="xref std std-term">module</span></a>.</p>
</dd>
<dt class="translated" id="term-nested-scope">alcances anidados<a class="headerlink" href="#term-nested-scope" title="Link to this term">¶</a></dt><dd><p class="translated">La habilidad de referirse a una variable dentro de una definición encerrada.  Por ejemplo, una función definida dentro de otra función puede referir a variables en la función externa.  Note que los alcances anidados por defecto sólo funcionan para referencia y no para asignación.  Las variables locales leen y escriben sólo en el alcance más interno.  De manera semejante, las variables globales pueden leer y escribir en el espacio de nombres global.  Con <a class="reference internal" href="reference/simple_stmts.html#nonlocal"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">nonlocal</span></code></a> se puede escribir en alcances exteriores.</p>
</dd>
<dt class="translated" id="term-new-style-class">clase de nuevo estilo<a class="headerlink" href="#term-new-style-class" title="Link to this term">¶</a></dt><dd><p class="untranslated">Old name for the flavor of classes now used for all class objects.  In
earlier Python versions, only new-style classes could use Python’s newer,
versatile features like <a class="reference internal" href="reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>, descriptors,
properties, <a class="reference internal" href="reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a>, class methods, and static
methods.</p>
</dd>
<dt class="translated" id="term-object">objeto<a class="headerlink" href="#term-object" title="Link to this term">¶</a></dt><dd><p class="translated">Cualquier dato con estado (atributo o valor) y comportamiento definido (métodos).  También es la más básica clase base para cualquier <a class="reference internal" href="#term-new-style-class"><span class="xref std std-term">new-style class</span></a>.</p>
</dd>
<dt class="untranslated" id="term-optimized-scope">optimized scope<a class="headerlink" href="#term-optimized-scope" title="Link to this term">¶</a></dt><dd><p class="untranslated">A scope where target local variable names are reliably known to the
compiler when the code is compiled, allowing optimization of read and
write access to these names. The local namespaces for functions,
generators, coroutines, comprehensions, and generator expressions are
optimized in this fashion. Note: most interpreter optimizations are
applied to all scopes, only those relying on a known set of local
and nonlocal variable names are restricted to optimized scopes.</p>
</dd>
<dt class="translated" id="term-package">paquete<a class="headerlink" href="#term-package" title="Link to this term">¶</a></dt><dd><p class="translated">Un <a class="reference internal" href="#term-module"><span class="xref std std-term">module</span></a> Python que puede contener submódulos o recursivamente, subpaquetes.  Técnicamente, un paquete es un módulo Python con un atributo <code class="docutils literal notranslate"><span class="pre">__path__</span></code>.</p>
<p class="translated">Vea también <a class="reference internal" href="#term-regular-package"><span class="xref std std-term">regular package</span></a> y <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">namespace package</span></a>.</p>
</dd>
<dt class="translated" id="term-parameter">parámetro<a class="headerlink" href="#term-parameter" title="Link to this term">¶</a></dt><dd><p class="translated">Una entidad nombrada en una definición de una <a class="reference internal" href="#term-function"><span class="xref std std-term">function</span></a> (o método) que especifica un <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a> (o en algunos casos, varios argumentos) que la función puede aceptar.  Existen cinco tipos de argumentos:</p>
<ul>
<li><p class="translated"><em class="dfn">posicional o nombrado</em>: especifica un argumento que puede ser pasado tanto como <a class="reference internal" href="#term-argument"><span class="xref std std-term">posicional</span></a> o como <a class="reference internal" href="#term-argument"><span class="xref std std-term">nombrado</span></a>.  Este es el tipo por defecto de parámetro, como <em>foo</em> y <em>bar</em> en el siguiente ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="positional-only-parameter">
<li><p class="translated"><em class="dfn">sólo posicional</em>: especifica un argumento que puede ser pasado sólo por posición.  Los parámetros sólo posicionales pueden ser definidos incluyendo un carácter <code class="docutils literal notranslate"><span class="pre">/</span></code> en la lista de parámetros de la función después de ellos, como <em>posonly1</em> y <em>posonly2</em> en el ejemplo que sigue:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">posonly1</span><span class="p">,</span> <span class="n">posonly2</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">positional_or_keyword</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<ul id="keyword-only-parameter">
<li><p class="translated"><em class="dfn">sólo nombrado</em>: especifica un argumento que sólo puede ser pasado por nombre.  Los parámetros sólo por nombre pueden ser definidos incluyendo un parámetro posicional de una sola variable o un simple <code class="docutils literal notranslate"><span class="pre">*`</span></code> antes de ellos en la lista de parámetros en la definición de la función, como <em>kw_only1</em> y <em>kw_only2</em> en el ejemplo siguiente:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kw_only1</span><span class="p">,</span> <span class="n">kw_only2</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p class="translated"><em class="dfn">variable posicional</em>: especifica una secuencia arbitraria de argumentos posicionales que pueden ser brindados (además de cualquier argumento posicional aceptado por otros parámetros).  Este parámetro puede ser definido anteponiendo al nombre del parámetro <code class="docutils literal notranslate"><span class="pre">*</span></code>, como a <em>args</em> en el siguiente ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</li>
<li><p class="translated"><em class="dfn">variable nombrado</em>: especifica que arbitrariamente muchos argumentos nombrados pueden ser brindados (además de cualquier argumento nombrado ya aceptado por cualquier otro parámetro).  Este parámetro puede ser definido anteponiendo al nombre del parámetro con <code class="docutils literal notranslate"><span class="pre">**</span></code>, como <em>kwargs</em> en el ejemplo precedente.</p></li>
</ul>
<p class="translated">Los parámetros puede especificar tanto argumentos opcionales como requeridos, así como valores por defecto para algunos argumentos opcionales.</p>
<p class="translated">Vea también el glosario de <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>, la pregunta respondida en <a class="reference internal" href="faq/programming.html#faq-argument-vs-parameter"><span class="std std-ref">la diferencia entre argumentos y parámetros</span></a>, la clase <a class="reference internal" href="library/inspect.html#inspect.Parameter" title="inspect.Parameter"><code class="xref py py-class docutils literal notranslate"><span class="pre">inspect.Parameter</span></code></a>, la sección <a class="reference internal" href="reference/compound_stmts.html#function"><span class="std std-ref">Definiciones de funciones</span></a> , y <span class="target" id="index-83"></span><a class="pep reference external" href="https://peps.python.org/pep-0362/"><strong>PEP 362</strong></a>.</p>
</dd>
<dt class="translated" id="term-path-entry">entrada de ruta<a class="headerlink" href="#term-path-entry" title="Link to this term">¶</a></dt><dd><p class="translated">Una ubicación única en el <a class="reference internal" href="#term-import-path"><span class="xref std std-term">import path</span></a> que el <a class="reference internal" href="#term-path-based-finder"><span class="xref std std-term">path based finder</span></a> consulta para encontrar los módulos a importar.</p>
</dd>
<dt class="translated" id="term-path-entry-finder">buscador de entradas de ruta<a class="headerlink" href="#term-path-entry-finder" title="Link to this term">¶</a></dt><dd><p class="translated">Un <a class="reference internal" href="#term-finder"><span class="xref std std-term">finder</span></a> retornado por un invocable en <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> (esto es, un <a class="reference internal" href="#term-path-entry-hook"><span class="xref std std-term">path entry hook</span></a>) que sabe cómo localizar módulos dada una <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">path entry</span></a>.</p>
<p class="translated">Vea en <a class="reference internal" href="library/importlib.html#importlib.abc.PathEntryFinder" title="importlib.abc.PathEntryFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder</span></code></a> los métodos que los buscadores de entradas de ruta implementan.</p>
</dd>
<dt class="translated" id="term-path-entry-hook">gancho a entrada de ruta<a class="headerlink" href="#term-path-entry-hook" title="Link to this term">¶</a></dt><dd><p class="untranslated">A callable on the <a class="reference internal" href="library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> list which returns a <a class="reference internal" href="#term-path-entry-finder"><span class="xref std std-term">path
entry finder</span></a> if it knows how to find modules on a specific <a class="reference internal" href="#term-path-entry"><span class="xref std std-term">path
entry</span></a>.</p>
</dd>
<dt class="translated" id="term-path-based-finder">buscador basado en ruta<a class="headerlink" href="#term-path-based-finder" title="Link to this term">¶</a></dt><dd><p class="translated">Uno de los <a class="reference internal" href="#term-meta-path-finder"><span class="xref std std-term">meta buscadores de ruta</span></a> por defecto que busca un <a class="reference internal" href="#term-import-path"><span class="xref std std-term">import path</span></a> para los módulos.</p>
</dd>
<dt class="translated" id="term-path-like-object">objeto tipo ruta<a class="headerlink" href="#term-path-like-object" title="Link to this term">¶</a></dt><dd><p class="translated">Un objeto que representa una ruta del sistema de archivos. Un objeto tipo ruta puede ser tanto una <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> como un <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> representando una ruta, o un objeto que implementa el protocolo <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a>. Un objeto que soporta el protocolo  <a class="reference internal" href="library/os.html#os.PathLike" title="os.PathLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">os.PathLike</span></code></a> puede ser convertido a ruta del sistema de archivo de clase <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> o <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> usando la función <a class="reference internal" href="library/os.html#os.fspath" title="os.fspath"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fspath()</span></code></a>; <a class="reference internal" href="library/os.html#os.fsdecode" title="os.fsdecode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsdecode()</span></code></a> <a class="reference internal" href="library/os.html#os.fsencode" title="os.fsencode"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fsencode()</span></code></a> pueden emplearse para garantizar que retorne respectivamente <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> o <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Introducido por <span class="target" id="index-84"></span><a class="pep reference external" href="https://peps.python.org/pep-0519/"><strong>PEP 519</strong></a>.</p>
</dd>
<dt class="translated" id="term-PEP">PEP<a class="headerlink" href="#term-PEP" title="Link to this term">¶</a></dt><dd><p class="translated">Propuesta de mejora de Python, del inglés <em>Python Enhancement Proposal</em>. Un PEP es un documento de diseño que brinda información a la comunidad Python, o describe una nueva capacidad para Python, sus procesos o entorno. Los PEPs deberían dar una especificación técnica concisa y una fundamentación para las capacidades propuestas.</p>
<p class="translated">Los PEPs tienen como propósito ser los mecanismos primarios para proponer nuevas y mayores capacidad, para recoger la opinión de la comunidad sobre un tema, y para documentar las decisiones de diseño que se han hecho en Python. El autor del PEP es el responsable de lograr consenso con la comunidad y documentar las opiniones disidentes.</p>
<p class="translated">Vea <span class="target" id="index-85"></span><a class="pep reference external" href="https://peps.python.org/pep-0001/"><strong>PEP 1</strong></a>.</p>
</dd>
<dt class="translated" id="term-portion">porción<a class="headerlink" href="#term-portion" title="Link to this term">¶</a></dt><dd><p class="translated">Un conjunto de archivos en un único directorio (posiblemente guardo en un archivo comprimido <em>zip</em>) que contribuye a un espacio de nombres de paquete, como está definido en <span class="target" id="index-86"></span><a class="pep reference external" href="https://peps.python.org/pep-0420/"><strong>PEP 420</strong></a>.</p>
</dd>
<dt class="translated" id="term-positional-argument">argumento posicional<a class="headerlink" href="#term-positional-argument" title="Link to this term">¶</a></dt><dd><p class="translated">Vea <a class="reference internal" href="#term-argument"><span class="xref std std-term">argument</span></a>.</p>
</dd>
<dt class="translated" id="term-provisional-API">API provisional<a class="headerlink" href="#term-provisional-API" title="Link to this term">¶</a></dt><dd><p class="translated">Una API provisoria es aquella que deliberadamente fue excluida de las garantías de compatibilidad hacia atrás de la biblioteca estándar.  Aunque no se esperan cambios fundamentales en dichas interfaces, como están marcadas como provisionales, los cambios incompatibles hacia atrás (incluso remover la misma interfaz) podrían ocurrir si los desarrolladores principales lo estiman.  Estos cambios no se hacen gratuitamente – solo ocurrirán si fallas fundamentales y serias son descubiertas que no fueron vistas antes de la inclusión de la API.</p>
<p class="translated">Incluso para APIs provisorias, los cambios incompatibles hacia atrás son vistos como una «solución de último recurso» - se intentará todo para encontrar una solución compatible hacia atrás para los problemas identificados.</p>
<p class="translated">Este proceso permite que la biblioteca estándar continúe evolucionando con el tiempo, sin bloquearse por errores de diseño problemáticos por períodos extensos de tiempo. Vea <span class="target" id="index-87"></span><a class="pep reference external" href="https://peps.python.org/pep-0411/"><strong>PEP 411</strong></a> para más detalles.</p>
</dd>
<dt class="translated" id="term-provisional-package">paquete provisorio<a class="headerlink" href="#term-provisional-package" title="Link to this term">¶</a></dt><dd><p class="translated">Vea <a class="reference internal" href="#term-provisional-API"><span class="xref std std-term">provisional API</span></a>.</p>
</dd>
<dt class="translated" id="term-Python-3000">Python 3000<a class="headerlink" href="#term-Python-3000" title="Link to this term">¶</a></dt><dd><p class="translated">Apodo para la fecha de lanzamiento de Python 3.x (acuñada en un tiempo cuando llegar a la versión 3 era algo distante en el futuro.)  También se lo abrevió como <em>Py3k</em>.</p>
</dd>
<dt class="translated" id="term-Pythonic">Pythónico<a class="headerlink" href="#term-Pythonic" title="Link to this term">¶</a></dt><dd><p class="translated">Una idea o pieza de código que sigue ajustadamente la convenciones idiomáticas comunes del lenguaje Python, en vez de implementar código usando conceptos comunes a otros lenguajes.  Por ejemplo, una convención común en Python es hacer bucles sobre todos los elementos de un iterable con la sentencia <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>.  Muchos otros lenguajes no tienen este tipo de construcción, así que los que no están familiarizados con Python podrían usar contadores numéricos:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">food</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">food</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p class="translated">En contraste, un método Pythónico más limpio:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">piece</span> <span class="ow">in</span> <span class="n">food</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt class="translated" id="term-qualified-name">nombre calificado<a class="headerlink" href="#term-qualified-name" title="Link to this term">¶</a></dt><dd><p class="translated">Un nombre con puntos mostrando la ruta desde el alcance global del módulo a la clase, función o método definido en dicho módulo, como se define en <span class="target" id="index-88"></span><a class="pep reference external" href="https://peps.python.org/pep-3155/"><strong>PEP 3155</strong></a>.  Para las funciones o clases de más alto nivel, el nombre calificado es el igual al nombre del objeto:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">class</span><span class="w"> </span><span class="nc">D</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">def</span><span class="w"> </span><span class="nf">meth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>            <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">meth</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;C.D.meth&#39;</span>
</pre></div>
</div>
<p class="translated">Cuando es usado para referirse a los módulos, <em>nombre completamente calificado</em> significa la ruta con puntos completo al módulo, incluyendo cualquier paquete padre, por ejemplo, <code class="docutils literal notranslate"><span class="pre">email.mime.text</span></code>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">email.mime.text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">email</span><span class="o">.</span><span class="n">mime</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;email.mime.text&#39;</span>
</pre></div>
</div>
</dd>
<dt class="translated" id="term-reference-count">contador de referencias<a class="headerlink" href="#term-reference-count" title="Link to this term">¶</a></dt><dd><p class="untranslated">The number of references to an object.  When the reference count of an
object drops to zero, it is deallocated.  Some objects are
<a class="reference internal" href="#term-immortal"><span class="xref std std-term">immortal</span></a> and have reference counts that are never modified, and
therefore the objects are never deallocated.  Reference counting is
generally not visible to Python code, but it is a key element of the
<a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> implementation.  Programmers can call the
<a class="reference internal" href="library/sys.html#sys.getrefcount" title="sys.getrefcount"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getrefcount()</span></code></a> function to return the
reference count for a particular object.</p>
<p class="untranslated">In <a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a>, reference counts are not considered to be stable
or well-defined values; the number of references to an object, and how
that number is affected by Python code, may be different between
versions.</p>
</dd>
<dt class="translated" id="term-regular-package">paquete regular<a class="headerlink" href="#term-regular-package" title="Link to this term">¶</a></dt><dd><p class="translated">Un  <a class="reference internal" href="#term-package"><span class="xref std std-term">package</span></a> tradicional, como aquellos con un directorio conteniendo el archivo <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code>.</p>
<p class="translated">Vea también <a class="reference internal" href="#term-namespace-package"><span class="xref std std-term">namespace package</span></a>.</p>
</dd>
<dt class="untranslated" id="term-REPL">REPL<a class="headerlink" href="#term-REPL" title="Link to this term">¶</a></dt><dd><p class="untranslated">An acronym for the «read–eval–print loop», another name for the
<a class="reference internal" href="#term-interactive"><span class="xref std std-term">interactive</span></a> interpreter shell.</p>
</dd>
<dt class="translated" id="term-__slots__">__slots__<a class="headerlink" href="#term-__slots__" title="Link to this term">¶</a></dt><dd><p class="translated">Es una declaración dentro de una clase que ahorra memoria predeclarando espacio para las atributos de la instancia y eliminando diccionarios de la instancia.  Aunque es popular, esta técnica es algo dificultosa de lograr correctamente y es mejor reservarla para los casos raros en los que existen grandes cantidades de instancias en aplicaciones con uso crítico de memoria.</p>
</dd>
<dt class="translated" id="term-sequence">secuencia<a class="headerlink" href="#term-sequence" title="Link to this term">¶</a></dt><dd><p class="untranslated">An <a class="reference internal" href="#term-iterable"><span class="xref std std-term">iterable</span></a> which supports efficient element access using integer
indices via the <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> special method and defines a
<a class="reference internal" href="reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a> method that returns the length of the sequence.
Some built-in sequence types are <a class="reference internal" href="library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a>, <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>,
<a class="reference internal" href="library/stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a>, and <a class="reference internal" href="library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>. Note that <a class="reference internal" href="library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> also
supports <a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code>, but is considered a
mapping rather than a sequence because the lookups use arbitrary
<a class="reference internal" href="#term-hashable"><span class="xref std std-term">hashable</span></a> keys rather than integers.</p>
<p class="untranslated">The <a class="reference internal" href="library/collections.abc.html#collections.abc.Sequence" title="collections.abc.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.abc.Sequence</span></code></a> abstract base class
defines a much richer interface that goes beyond just
<a class="reference internal" href="reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> and <a class="reference internal" href="reference/datamodel.html#object.__len__" title="object.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code></a>, adding
<a class="reference internal" href="library/stdtypes.html#sequence.count" title="sequence.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code></a>, <a class="reference internal" href="library/stdtypes.html#sequence.index" title="sequence.index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code></a>,
<a class="reference internal" href="reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a>, and <a class="reference internal" href="reference/datamodel.html#object.__reversed__" title="object.__reversed__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reversed__()</span></code></a>.
Types that implement this expanded
interface can be registered explicitly using
<a class="reference internal" href="library/abc.html#abc.ABCMeta.register" title="abc.ABCMeta.register"><code class="xref py py-func docutils literal notranslate"><span class="pre">register()</span></code></a>. For more documentation on sequence
methods generally, see
<a class="reference internal" href="library/stdtypes.html#typesseq-common"><span class="std std-ref">Common Sequence Operations</span></a>.</p>
</dd>
<dt class="translated" id="term-set-comprehension">comprensión de conjuntos<a class="headerlink" href="#term-set-comprehension" title="Link to this term">¶</a></dt><dd><p class="translated">Una forma compacta de procesar todos o parte de los elementos en un iterable y retornar un conjunto con los resultados. <code class="docutils literal notranslate"><span class="pre">results</span> <span class="pre">=</span> <span class="pre">{c</span> <span class="pre">for</span> <span class="pre">c</span> <span class="pre">in</span> <span class="pre">'abracadabra'</span> <span class="pre">if</span> <span class="pre">c</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">'abc'}</span></code> genera el conjunto de cadenas <code class="docutils literal notranslate"><span class="pre">{'r',</span> <span class="pre">'d'}</span></code>. Ver <a class="reference internal" href="reference/expressions.html#comprehensions"><span class="std std-ref">Despliegues para listas, conjuntos y diccionarios</span></a>.</p>
</dd>
<dt class="translated" id="term-single-dispatch">despacho único<a class="headerlink" href="#term-single-dispatch" title="Link to this term">¶</a></dt><dd><p class="translated">Una forma de despacho de una <a class="reference internal" href="#term-generic-function"><span class="xref std std-term">generic function</span></a> donde la implementación es elegida a partir del tipo de un sólo argumento.</p>
</dd>
<dt class="translated" id="term-slice">rebanada<a class="headerlink" href="#term-slice" title="Link to this term">¶</a></dt><dd><p class="translated">Un objeto que contiene una porción de una <a class="reference internal" href="#term-sequence"><span class="xref std std-term">sequence</span></a>.  Una rebanada es creada usando la notación de suscripto, <code class="docutils literal notranslate"><span class="pre">[]</span></code> con dos puntos entre los números cuando se ponen varios, como en <code class="docutils literal notranslate"><span class="pre">nombre_variable[1:3:5]</span></code>.  La notación con corchete (suscrito) usa internamente objetos <a class="reference internal" href="library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a>.</p>
</dd>
<dt class="untranslated" id="term-soft-deprecated">soft deprecated<a class="headerlink" href="#term-soft-deprecated" title="Link to this term">¶</a></dt><dd><p class="untranslated">A soft deprecated API should not be used in new code,
but it is safe for already existing code to use it.
The API remains documented and tested, but will not be enhanced further.</p>
<p class="untranslated">Soft deprecation, unlike normal deprecation, does not plan on removing the API
and will not emit warnings.</p>
<p class="untranslated">See <a class="reference external" href="https://peps.python.org/pep-0387/#soft-deprecation">PEP 387: Soft Deprecation</a>.</p>
</dd>
<dt class="translated" id="term-special-method">método especial<a class="headerlink" href="#term-special-method" title="Link to this term">¶</a></dt><dd><p class="translated" id="index-38">Un método que es llamado implícitamente por Python cuando ejecuta ciertas operaciones en un tipo, como la adición.  Estos métodos tienen nombres que comienzan y terminan con doble barra baja.  Los métodos especiales están documentados en <a class="reference internal" href="reference/datamodel.html#specialnames"><span class="std std-ref">Nombres especiales de método</span></a>.</p>
</dd>
<dt class="untranslated" id="term-standard-library">standard library<a class="headerlink" href="#term-standard-library" title="Link to this term">¶</a></dt><dd><p class="untranslated">The collection of <a class="reference internal" href="#term-package"><span class="xref std std-term">packages</span></a>, <a class="reference internal" href="#term-module"><span class="xref std std-term">modules</span></a>
and <a class="reference internal" href="#term-extension-module"><span class="xref std std-term">extension modules</span></a> distributed as a part
of the official Python interpreter package.  The exact membership of the
collection may vary based on platform, available system libraries, or
other criteria.  Documentation can be found at <a class="reference internal" href="library/index.html#library-index"><span class="std std-ref">La biblioteca estándar de Python</span></a>.</p>
<p class="untranslated">See also <a class="reference internal" href="library/sys.html#sys.stdlib_module_names" title="sys.stdlib_module_names"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdlib_module_names</span></code></a> for a list of all possible
standard library module names.</p>
</dd>
<dt class="translated" id="term-statement">sentencia<a class="headerlink" href="#term-statement" title="Link to this term">¶</a></dt><dd><p class="translated">Una sentencia es parte de un conjunto (un «bloque» de código).  Una sentencia tanto es una <a class="reference internal" href="#term-expression"><span class="xref std std-term">expression</span></a>  como alguna de las varias sintaxis usando una palabra clave, como <a class="reference internal" href="reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>, <a class="reference internal" href="reference/compound_stmts.html#while"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> o <a class="reference internal" href="reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>.</p>
</dd>
<dt class="untranslated" id="term-static-type-checker">static type checker<a class="headerlink" href="#term-static-type-checker" title="Link to this term">¶</a></dt><dd><p class="untranslated">An external tool that reads Python code and analyzes it, looking for
issues such as incorrect types. See also <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">type hints</span></a>
and the <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> module.</p>
</dd>
<dt class="untranslated" id="term-stdlib">stdlib<a class="headerlink" href="#term-stdlib" title="Link to this term">¶</a></dt><dd><p class="untranslated">An abbreviation of <a class="reference internal" href="#term-standard-library"><span class="xref std std-term">standard library</span></a>.</p>
</dd>
<dt class="translated" id="term-strong-reference">referencia fuerte<a class="headerlink" href="#term-strong-reference" title="Link to this term">¶</a></dt><dd><p class="translated">En la API de C de Python, una referencia fuerte es una referencia a un objeto que es propiedad del código que mantiene la referencia.  La referencia fuerte se toma llamando a <a class="reference internal" href="c-api/refcounting.html#c.Py_INCREF" title="Py_INCREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_INCREF()</span></code></a> cuando se crea la referencia y se libera con <a class="reference internal" href="c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a> cuando se elimina la referencia.</p>
<p class="translated">La función <a class="reference internal" href="c-api/refcounting.html#c.Py_NewRef" title="Py_NewRef"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewRef()</span></code></a> se puede utilizar para crear una referencia fuerte a un objeto. Por lo general, se debe llamar a la función <a class="reference internal" href="c-api/refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DECREF()</span></code></a> en la referencia fuerte antes de salir del alcance de la referencia fuerte, para evitar filtrar una referencia.</p>
<p class="translated">Consulte también <a class="reference internal" href="#term-borrowed-reference"><span class="xref std std-term">borrowed reference</span></a>.</p>
</dd>
<dt class="untranslated" id="term-t-string">t-string<a class="headerlink" href="#term-t-string" title="Link to this term">¶</a></dt><dt class="untranslated" id="term-t-strings">t-strings<a class="headerlink" href="#term-t-strings" title="Link to this term">¶</a></dt><dd><p class="untranslated">String literals prefixed with <code class="docutils literal notranslate"><span class="pre">t</span></code> or <code class="docutils literal notranslate"><span class="pre">T</span></code> are commonly called
«t-strings» which is short for
<a class="reference internal" href="reference/lexical_analysis.html#t-strings"><span class="std std-ref">template string literals</span></a>.</p>
</dd>
<dt class="translated" id="term-text-encoding">codificación de texto<a class="headerlink" href="#term-text-encoding" title="Link to this term">¶</a></dt><dd><p class="translated">Una cadena de caracteres en Python es una secuencia de puntos de código Unicode (en el rango <code class="docutils literal notranslate"><span class="pre">U+0000</span></code>–<code class="docutils literal notranslate"><span class="pre">U+10FFFF</span></code>). Para almacenar o transferir una cadena de caracteres, es necesario serializarla como una secuencia de bytes.</p>
<p class="translated">La serialización de una cadena de caracteres en una secuencia de bytes se conoce como «codificación», y la recreación de la cadena de caracteres a partir de la secuencia de bytes se conoce como «decodificación».</p>
<p class="translated">Existe una gran variedad de serializaciones de texto <a class="reference internal" href="library/codecs.html#standard-encodings"><span class="std std-ref">codecs</span></a>, que se denominan colectivamente «codificaciones de texto».</p>
</dd>
<dt class="translated" id="term-text-file">archivo de texto<a class="headerlink" href="#term-text-file" title="Link to this term">¶</a></dt><dd><p class="translated">Un <a class="reference internal" href="#term-file-object"><span class="xref std std-term">file object</span></a> capaz de leer y escribir objetos <a class="reference internal" href="library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>. Frecuentemente, un archivo de texto también accede a un flujo de datos binario y maneja automáticamente el <a class="reference internal" href="#term-text-encoding"><span class="xref std std-term">text encoding</span></a>. Ejemplos de archivos de texto que son abiertos en modo texto (<code class="docutils literal notranslate"><span class="pre">'r'</span></code> o <code class="docutils literal notranslate"><span class="pre">'w'</span></code>), <a class="reference internal" href="library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a>, <a class="reference internal" href="library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>, y las instancias de <a class="reference internal" href="library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a>.</p>
<p class="translated">Vea también <a class="reference internal" href="#term-binary-file"><span class="xref std std-term">binary file</span></a> por objeto de archivos capaces de leer y escribir <a class="reference internal" href="#term-bytes-like-object"><span class="xref std std-term">objeto tipo binario</span></a>.</p>
</dd>
<dt class="untranslated" id="term-thread-state">thread state<a class="headerlink" href="#term-thread-state" title="Link to this term">¶</a></dt><dd><p class="untranslated">The information used by the <a class="reference internal" href="#term-CPython"><span class="xref std std-term">CPython</span></a> runtime to run in an OS thread.
For example, this includes the current exception, if any, and the
state of the bytecode interpreter.</p>
<p class="untranslated">Each thread state is bound to a single OS thread, but threads may have
many thread states available.  At most, one of them may be
<a class="reference internal" href="#term-attached-thread-state"><span class="xref std std-term">attached</span></a> at once.</p>
<p class="untranslated">An <a class="reference internal" href="#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> is required to call most
of Python’s C API, unless a function explicitly documents otherwise.
The bytecode interpreter only runs under an attached thread state.</p>
<p class="untranslated">Each thread state belongs to a single interpreter, but each interpreter
may have many thread states, including multiple for the same OS thread.
Thread states from multiple interpreters may be bound to the same
thread, but only one can be <a class="reference internal" href="#term-attached-thread-state"><span class="xref std std-term">attached</span></a> in
that thread at any given moment.</p>
<p class="untranslated">See <a class="reference internal" href="c-api/init.html#threads"><span class="std std-ref">Thread State and the Global Interpreter Lock</span></a> for more
information.</p>
</dd>
<dt class="untranslated" id="term-token">token<a class="headerlink" href="#term-token" title="Link to this term">¶</a></dt><dd><p class="untranslated">A small unit of source code, generated by the
<a class="reference internal" href="reference/lexical_analysis.html#lexical"><span class="std std-ref">lexical analyzer</span></a> (also called the <em>tokenizer</em>).
Names, numbers, strings, operators,
newlines and similar are represented by tokens.</p>
<p class="untranslated">The <a class="reference internal" href="library/tokenize.html#module-tokenize" title="tokenize: Lexical scanner for Python source code."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tokenize</span></code></a> module exposes Python’s lexical analyzer.
The <a class="reference internal" href="library/token.html#module-token" title="token: Constants representing terminal nodes of the parse tree."><code class="xref py py-mod docutils literal notranslate"><span class="pre">token</span></code></a> module contains information on the various types
of tokens.</p>
</dd>
<dt class="translated" id="term-triple-quoted-string">cadena con triple comilla<a class="headerlink" href="#term-triple-quoted-string" title="Link to this term">¶</a></dt><dd><p class="translated">Una cadena que está enmarcada por tres instancias de comillas (») o apostrofes (“).  Aunque no brindan ninguna funcionalidad que no está disponible usando cadenas con comillas simple, son útiles por varias razones.  Permiten incluir comillas simples o dobles sin escapar dentro de las cadenas y pueden abarcar múltiples líneas sin el uso de caracteres de continuación, haciéndolas particularmente útiles para escribir docstrings.</p>
</dd>
<dt class="translated" id="term-type">tipo<a class="headerlink" href="#term-type" title="Link to this term">¶</a></dt><dd><p class="untranslated">The type of a Python object determines what kind of object it is; every
object has a type.  An object’s type is accessible as its
<a class="reference internal" href="reference/datamodel.html#object.__class__" title="object.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> attribute or can be retrieved with
<code class="docutils literal notranslate"><span class="pre">type(obj)</span></code>.</p>
</dd>
<dt class="translated" id="term-type-alias">alias de tipos<a class="headerlink" href="#term-type-alias" title="Link to this term">¶</a></dt><dd><p class="translated">Un sinónimo para un tipo, creado al asignar un tipo a un identificador.</p>
<p class="translated">Los alias de tipos son útiles para simplificar los <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">indicadores de tipo</span></a>. Por ejemplo:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">remove_gray_shades</span><span class="p">(</span>
        <span class="n">colors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p class="translated">podría ser más legible así:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Color</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">remove_gray_shades</span><span class="p">(</span><span class="n">colors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Color</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Color</span><span class="p">]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p class="translated">Vea <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> y <span class="target" id="index-89"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, que describen esta funcionalidad.</p>
</dd>
<dt class="translated" id="term-type-hint">indicador de tipo<a class="headerlink" href="#term-type-hint" title="Link to this term">¶</a></dt><dd><p class="translated">Una  <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> que especifica el tipo esperado para una variable, un atributo de clase, un parámetro para una función o un valor de retorno.</p>
<p class="untranslated">Type hints are optional and are not enforced by Python but
they are useful to <a class="reference internal" href="#term-static-type-checker"><span class="xref std std-term">static type checkers</span></a>.
They can also aid IDEs with code completion and refactoring.</p>
<p class="translated">Los indicadores de tipo de las variables globales, atributos de clase, y funciones, no de variables locales, pueden ser accedidos usando <a class="reference internal" href="library/typing.html#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_type_hints()</span></code></a>.</p>
<p class="translated">Vea <a class="reference internal" href="library/typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> y <span class="target" id="index-90"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a>, que describen esta funcionalidad.</p>
</dd>
<dt class="translated" id="term-universal-newlines">saltos de líneas universales<a class="headerlink" href="#term-universal-newlines" title="Link to this term">¶</a></dt><dd><p class="translated">Una manera de interpretar flujos de texto en la cual son reconocidos como finales de línea todas siguientes formas: la convención de Unix para fin de línea <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>, la convención de Windows <code class="docutils literal notranslate"><span class="pre">'\r\n'</span></code>, y la vieja convención de Macintosh <code class="docutils literal notranslate"><span class="pre">'\r'</span></code>.  Vea <span class="target" id="index-91"></span><a class="pep reference external" href="https://peps.python.org/pep-0278/"><strong>PEP 278</strong></a> y <span class="target" id="index-92"></span><a class="pep reference external" href="https://peps.python.org/pep-3116/"><strong>PEP 3116</strong></a>, además de <a class="reference internal" href="library/stdtypes.html#bytes.splitlines" title="bytes.splitlines"><code class="xref py py-func docutils literal notranslate"><span class="pre">bytes.splitlines()</span></code></a> para usos adicionales.</p>
</dd>
<dt class="translated" id="term-variable-annotation">anotación de variable<a class="headerlink" href="#term-variable-annotation" title="Link to this term">¶</a></dt><dd><p class="translated">Una <a class="reference internal" href="#term-annotation"><span class="xref std std-term">annotation</span></a> de una variable o un atributo de clase.</p>
<p class="translated">Cuando se anota una variable o un atributo de clase, la asignación es opcional:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>
    <span class="n">field</span><span class="p">:</span> <span class="s1">&#39;annotation&#39;</span>
</pre></div>
</div>
<p class="translated">Las anotaciones de variables son frecuentemente usadas para <a class="reference internal" href="#term-type-hint"><span class="xref std std-term">type hints</span></a>: por ejemplo, se espera que esta variable tenga valores de clase <a class="reference internal" href="library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p class="translated">La sintaxis de la anotación de variables está explicada en la sección <a class="reference internal" href="reference/simple_stmts.html#annassign"><span class="std std-ref">Declaraciones de asignación anotadas</span></a>.</p>
<p class="translated">Consulte <a class="reference internal" href="#term-function-annotation"><span class="xref std std-term">function annotation</span></a>, <span class="target" id="index-93"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> y <span class="target" id="index-94"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>, que describen esta funcionalidad. Consulte también <a class="reference internal" href="howto/annotations.html#annotations-howto"><span class="std std-ref">Prácticas recomendadas para las anotaciones</span></a> para conocer las mejores prácticas sobre cómo trabajar con anotaciones.</p>
</dd>
<dt class="translated" id="term-virtual-environment">entorno virtual<a class="headerlink" href="#term-virtual-environment" title="Link to this term">¶</a></dt><dd><p class="translated">Un entorno cooperativamente aislado de ejecución que permite a los usuarios de Python y a las aplicaciones instalar y actualizar paquetes de distribución de Python sin interferir con el comportamiento de otras aplicaciones de Python en el mismo sistema.</p>
<p class="translated">Vea también <a class="reference internal" href="library/venv.html#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a>.</p>
</dd>
<dt class="translated" id="term-virtual-machine">máquina virtual<a class="headerlink" href="#term-virtual-machine" title="Link to this term">¶</a></dt><dd><p class="translated">Una computadora definida enteramente por software.  La máquina virtual de Python ejecuta el <a class="reference internal" href="#term-bytecode"><span class="xref std std-term">bytecode</span></a> generado por el compilador de <em>bytecode</em>.</p>
</dd>
<dt class="untranslated" id="term-walrus-operator">walrus operator<a class="headerlink" href="#term-walrus-operator" title="Link to this term">¶</a></dt><dd><p class="untranslated">A light-hearted way to refer to the <a class="reference internal" href="reference/expressions.html#assignment-expressions"><span class="std std-ref">assignment expression</span></a> operator <code class="docutils literal notranslate"><span class="pre">:=</span></code> because it looks a bit like a
walrus if you turn your head.</p>
</dd>
<dt class="translated" id="term-Zen-of-Python">Zen de Python<a class="headerlink" href="#term-Zen-of-Python" title="Link to this term">¶</a></dt><dd><p class="translated">Un listado de los principios de diseño y la filosofía de Python que son útiles para entender y usar el lenguaje.  El listado puede encontrarse ingresando  «<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">this</span></code>» en la consola interactiva.</p>
</dd>
</dl>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="deprecations/index.html"
                          title="capítulo anterior">Desusos</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="about.html"
                          title="próximo capítulo">About this documentation</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/glossary.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Contraer barra lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="about.html" title="About this documentation"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="deprecations/index.html" title="Desusos"
             >anterior</a> |</li>

          <li><img src="_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="index.html">3.15.0a0 Documentation</a> &#187;
    </li>

        <li class="nav-item nav-item-this"><a href="">Glosario</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="copyright.html">Derechos de autor</a> 2001 Python Software Foundation.
    <br>
    Ésta página tiene la licencia Python Software Foundation Versión 2.
    <br>
    Ejemplos, guías, y otro código en la documentación están bajo la licencia adicional Zero Clause BSD.
    <br>
    
      Ver <a href="/license.html">Historia y Licencia</a> para más información.<br>
    
    
    <br>

    La Python Software Foundation es una corporación sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor dona.</a>
<br>
    <br>
      Última actualización en oct 06, 2025 (04:51 UTC).
    
      <a href="/bugs.html">Encontraste un bug</a>?
    
    <br>

    Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a>8.2.3.
    </div>

  </body>
</html>