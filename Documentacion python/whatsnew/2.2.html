<!DOCTYPE html>

<html lang="es" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Qué hay de nuevo en Python 2.2" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/2.2.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Autor, A.M. Kuchling,. Introducción: Este artículo explica las nuevas características en Python 2.2.2, publicado el 14 de octubre de 2002. Python 2.2.2 es una versión de corrección de errores de Py..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.15/es/_images/social_previews/summary_whatsnew_2.2_a058e740.png" />
<meta property="og:image:alt" content="Autor, A.M. Kuchling,. Introducción: Este artículo explica las nuevas características en Python 2.2.2, publicado el 14 de octubre de 2002. Python 2.2.2 es una versión de corrección de errores de Py..." />
<meta name="description" content="Autor, A.M. Kuchling,. Introducción: Este artículo explica las nuevas características en Python 2.2.2, publicado el 14 de octubre de 2002. Python 2.2.2 es una versión de corrección de errores de Py..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>Qué hay de nuevo en Python 2.2 &#8212; documentación de Python - 3.15.0a0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=bf1f176d"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f85f4cfb"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.15.0a0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Derechos de autor" href="../copyright.html" />
    <link rel="next" title="Qué hay de nuevo en Python 2.1" href="2.1.html" />
    <link rel="prev" title="Qué hay de nuevo en Python 2.3" href="2.3.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.2.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menú">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Qué hay de nuevo en Python 2.2</a><ul>
<li><a class="reference internal" href="#introduction">Introducción</a></li>
<li><a class="reference internal" href="#peps-252-and-253-type-and-class-changes">PEPs 252 y 253: Cambios de tipo y clase</a><ul>
<li><a class="reference internal" href="#old-and-new-classes">Clases antiguas y nuevas</a></li>
<li><a class="reference internal" href="#descriptors">Descriptores</a></li>
<li><a class="reference internal" href="#multiple-inheritance-the-diamond-rule">Herencia múltiple: la regla del diamante</a></li>
<li><a class="reference internal" href="#attribute-access">Acceso a atributos</a></li>
<li><a class="reference internal" href="#related-links">Enlaces relacionados</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-234-iterators">PEP 234: Iteradores</a></li>
<li><a class="reference internal" href="#pep-255-simple-generators">PEP 255: Generadores simples</a></li>
<li><a class="reference internal" href="#pep-237-unifying-long-integers-and-integers">PEP 237: Unificación de enteros largos y enteros</a></li>
<li><a class="reference internal" href="#pep-238-changing-the-division-operator">PEP 238: Cambio del operador de división</a></li>
<li><a class="reference internal" href="#unicode-changes">Cambios en Unicode</a></li>
<li><a class="reference internal" href="#pep-227-nested-scopes">PEP 227: Ámbitos anidados</a></li>
<li><a class="reference internal" href="#new-and-improved-modules">Módulos nuevos y mejorados</a></li>
<li><a class="reference internal" href="#interpreter-changes-and-fixes">Cambios y correcciones en el intérprete</a></li>
<li><a class="reference internal" href="#other-changes-and-fixes">Otros cambios y correcciones</a></li>
<li><a class="reference internal" href="#acknowledgements">Agradecimientos</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="2.3.html"
                          title="capítulo anterior">Qué hay de nuevo en Python 2.3</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="2.1.html"
                          title="próximo capítulo">Qué hay de nuevo en Python 2.1</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.2.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="2.1.html" title="Qué hay de nuevo en Python 2.1"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="2.3.html" title="Qué hay de nuevo en Python 2.3"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Qué hay de nuevo en Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Qué hay de nuevo en Python 2.2</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-2">
<h1 class="translated">Qué hay de nuevo en Python 2.2<a class="headerlink" href="#what-s-new-in-python-2-2" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd translated">Autor<span class="colon">:</span></dt>
<dd class="field-odd translated"><p class="translated">A.M. Kuchling</p>
</dd>
</dl>
<section id="introduction">
<h2 class="translated">Introducción<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p class="translated">Este artículo explica las nuevas características en Python 2.2.2, publicado el 14 de octubre de 2002. Python 2.2.2 es una versión de corrección de errores de Python 2.2, lanzada originalmente el 21 de diciembre de 2001.</p>
<p class="translated">Python 2.2 se puede considerar como la «versión de limpieza». Hay algunas características como los generadores e iteradores que son completamente nuevas, pero la mayoría de los cambios, aunque sean significativos y de gran alcance, tienen como objetivo limpiar las irregularidades y los rincones oscuros del diseño del lenguaje.</p>
<p class="translated">Este artículo no procura proporcionar una especificación completa de las nuevas características, pero en su lugar proporciona una descripción general conveniente. Para más detalles, deberías consultar la documentación de Python 2.2, como <a class="reference external" href="https://docs.python.org/2.2/lib/lib.html">Python Library Reference</a> y <a class="reference external" href="https://docs.python.org/2.2/ref/ref.html">Python Reference Manual</a>. Si quieres comprender la justificación completa de la implementación y el diseño de un cambio, consultar la PEP para conocer una característica nueva en particular.</p>
</section>
<section id="peps-252-and-253-type-and-class-changes">
<h2 class="translated">PEPs 252 y 253: Cambios de tipo y clase<a class="headerlink" href="#peps-252-and-253-type-and-class-changes" title="Link to this heading">¶</a></h2>
<p class="translated">Los cambios más grandes y de mayor alcance en Python 2.2 son el modelo de objetos y clases de Python. Los cambios deben ser compatibles con versiones anteriores, por lo que es probable que tu código continuará ejecutándose sin cambios, pero los cambios proporcionan algunas capacidades nuevas increíbles. Antes de comenzar esta, la sección más larga y complicada de este artículo, brindaré una descripción general de los cambios y ofreceré algunos comentarios.</p>
<p class="translated">Hace mucho tiempo escribí una página web en la que enumeraba los defectos de diseño de Python. Uno de los defectos más importantes era que resulta imposible crear subclases de los tipos de Python implementados en C. En particular, no es posible crear subclases de los tipos integrados, por lo que no se pueden crear subclases de, por ejemplo, listas para añadirles un único método útil. El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">UserList</span></code> proporciona una clase que admite todos los métodos de las listas y que se puede subclasificar aún más, pero hay mucho código C que espera una lista de Python normal y no acepta una instancia de <a class="reference internal" href="../library/collections.html#collections.UserList" title="collections.UserList"><code class="xref py py-class docutils literal notranslate"><span class="pre">UserList</span></code></a>.</p>
<p class="translated">Python 2.2 corrige esto y, en el proceso, agrega algunas capacidades nuevas interesantes. Un breve resumen:</p>
<ul class="simple">
<li><p class="translated">Puedes subclasificar tipos incorporados como listas e incluso enteros, y tus subclases deberían funcionar en todos los lugares que requieran el tipo original.</p></li>
<li><p class="translated">Ahora es posible definir métodos estáticos y de clase, además de los métodos de instancia disponibles en versiones anteriores de Python.</p></li>
<li><p class="translated">También es posible llamar automáticamente a métodos al acceder o configurar un atributo de instancia mediante un nuevo mecanismo llamado <em class="dfn">properties</em>. Muchos usos de <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> se pueden reescribir para utilizar propiedades en su lugar, lo que hace que el código resultante sea más simple y rápido. Como pequeño beneficio adicional, los atributos ahora también pueden tener cadenas de documentación.</p></li>
<li><p class="translated">La lista de atributos legales para una instancia se puede limitar a un conjunto particular usando <em class="dfn">slots</em>, lo que hace posible protegerse contra errores tipográficos y quizás hacer posibles más optimizaciones en versiones futuras de Python.</p></li>
</ul>
<p class="translated">Algunos usuarios han expresado preocupación por todos estos cambios. Claro, dicen, las nuevas características son ordenadas y se prestan a todo tipo de trucos que no eran posibles en versiones anteriores de Python, pero también hacen que el lenguaje sea más complicado. Algunas personas han dicho que siempre han recomendado Python por su simplicidad, y sienten que su simplicidad se está perdiendo.</p>
<p class="translated">Personalmente. pienso que no hay que preocuparse. Muchas de las nuevas características son bastante esotéricas, y puedes escribir mucho código de Python sin tener que estar al tanto de ellas. Escribir una clase simple no es más difícil de lo que nunca fue, así que no necesitas molestarte en aprender o enseñarlos a menos que realmente sean necesarios. Algunas tareas muy complicadas que antes solo eran posibles desde C ahora serán posibles en Python puro, y en mi opinión, esto es todo para mejor.</p>
<p class="translated">No voy a intentar cubrir todas los casos de las esquinas y los pequeños cambios que fueron necesarios para hacer que las nuevas características funcionen. En su lugar, esta sección pintará solo a grandes rasgos. Consultar la sección <a class="reference internal" href="#sect-rellinks"><span class="std std-ref">Enlaces relacionados</span></a>, «Enlaces relacionados», para más fuentes de información sobre el nuevo modelo de objetos de Python 2.2.</p>
<section id="old-and-new-classes">
<h3 class="translated">Clases antiguas y nuevas<a class="headerlink" href="#old-and-new-classes" title="Link to this heading">¶</a></h3>
<p class="translated">Primero, debes saber que realmente Python 2.2 tiene dos tipos de clases: clases clásicas o de estilo antiguo y clases de estilo nuevo. El modelo de clase de estilo antiguo exactamente es el mismo que el modelo de clase en versiones anteriores de Python. Todas las nuevas características descritas en esta sección se aplican solo a las clases de estilo nuevo. Esta divergencia no está destinada a durar para siempre; eventualmente las clases de estilo antiguo se eliminarán, posiblemente en Python 3.0.</p>
<p class="translated">Entonces, ¿cómo defines una clase de estilo nuevo? Lo haces subclasificando una clases de estilo nuevo existente. La mayoría de los tipos integrados de Python, como enteros, listas, diccionarios e incluso archivos, ahora son clases de estilo nuevo. También se agregó una clase de estilo nuevo llamada <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>, la clase base para todos los tipos integrados, por lo que si ningún tipo integrado es apropiado, puedes solo subclasificar <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">clase</span> <span class="n">C</span><span class="p">(</span><span class="n">objeto</span><span class="p">):</span>
<span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="o">...</span>
<span class="o">...</span>
</pre></div>
</div>
<p class="translated">Esto significa que las instrucciones <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> que no tienen ninguna clase base siempre son clases clásicas en Python 2.2. (En realidad, también puede cambiar esto configurando una variable a nivel de módulo llamada <code class="xref py py-attr docutils literal notranslate"><span class="pre">__metaclass__</span></code> — consulte <span class="target" id="index-46"></span><a class="pep reference external" href="https://peps.python.org/pep-0253/"><strong>PEP 253</strong></a> para obtener más detalles — pero es más fácil simplemente subclasificar <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>).</p>
<p class="translated">Los objetos de tipo para los tipos integrados están disponibles como incorporados, nombrados mediante un truco inteligente. Python siempre ha tenido funciones incorporadas llamadas <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>, <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> y <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>. En la versión 2.2, ya no son funciones, sino objetos de tipo que se comportan como fábricas cuando se les llaman.</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span>
<span class="go">&lt;tipo &#39;int&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">)</span>
<span class="go">123</span>
</pre></div>
</div>
<p class="translated">Para completar el conjunto de tipos, se han añadido nuevos objetos de tipo, como <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">dict()</span></code></a> y <code class="xref py py-func docutils literal notranslate"><span class="pre">file()</span></code>. A continuación, se muestra un ejemplo más interesante, en el que se añade un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">lock()</span></code> a los objetos de archivo:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">clase</span> <span class="n">LockableFile</span><span class="p">(</span><span class="n">archivo</span><span class="p">):</span>
<span class="k">def</span><span class="w"> </span><span class="nf">lock</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operación</span><span class="p">,</span> <span class="n">longitud</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inicio</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">origen</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">fcntl</span>
<span class="k">return</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">lockf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">operación</span><span class="p">,</span>
<span class="n">longitud</span><span class="p">,</span> <span class="n">inicio</span><span class="p">,</span> <span class="n">origen</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">posixfile</span></code>, ahora obsoleto, contenía una clase que emulaba todos los métodos de un objeto de archivo y también agregaba un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">lock()</span></code>, pero esta clase no podía pasarse a funciones internas que esperaban un archivo integrado, algo que es posible con nuestro nuevo <code class="xref py py-class docutils literal notranslate"><span class="pre">LockableFile</span></code>.</p>
</section>
<section id="descriptors">
<h3 class="translated">Descriptores<a class="headerlink" href="#descriptors" title="Link to this heading">¶</a></h3>
<p class="translated">En versiones anteriores de Python, no había una forma consistente de descubrir qué atributos y métodos eran compatibles con un objeto. Existían algunas convenciones informales, como definir los atributos <code class="xref py py-attr docutils literal notranslate"><span class="pre">__members__</span></code> y <code class="xref py py-attr docutils literal notranslate"><span class="pre">__methods__</span></code> que eran listas de nombres, pero a menudo el autor de un tipo de extensión o una clase no se molestaba en definirlos. Se podía recurrir a inspeccionar el <a class="reference internal" href="../reference/datamodel.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> de un objeto, pero cuando se utilizaba la herencia de clase o un gancho <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code> arbitrario, esto podía seguir siendo inexacto.</p>
<p class="translated">La única gran idea que subyace al nuevo modelo de clases es que se ha formalizado una API para describir los atributos de un objeto usando <em class="dfn">descriptors</em>. Los descriptores especifican el valor de un atributo, indicando si es un método o un campo. Con la API de un descriptor, los métodos estáticos y de clase se vuelven posibles, así como constructos más exóticos.</p>
<p class="translated">Los descriptores de atributos son objetos que viven dentro de los objetos de clase y tienen algunos atributos propios:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="../library/stdtypes.html#definition.__name__" title="definition.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> es el nombre del atributo.</p></li>
<li><p class="translated"><a class="reference internal" href="../library/stdtypes.html#definition.__doc__" title="definition.__doc__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__doc__</span></code></a> es el docstring del atributo.</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">__get__(object)</span></code> es un método que recupera el valor del atributo de <em>object</em>.</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">__set__(object,</span> <span class="pre">value)</span></code> establece el atributo de <em>object</em> en <em>value</em>.</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">__delete__(object,</span> <span class="pre">value)</span></code> elimina el atributo <em>value</em> de <em>object</em>.</p></li>
</ul>
<p class="translated">Por ejemplo, cuando escribes <code class="docutils literal notranslate"><span class="pre">obj.x</span></code>, los pasos que realmente Python realiza son:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">x</span>
<span class="n">descriptor</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Para los métodos, <a class="reference internal" href="../reference/datamodel.html#object.__get__" title="object.__get__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">descriptor.__get__</span></code></a> devuelve un objeto temporal que se puede llamar y envuelve la instancia y el método que se llamará en él. Esta es también la razón por la que ahora son posibles los métodos estáticos y los métodos de clase; tienen descriptores que envuelven solo el método, o el método y la clase. Como breve explicación de estos nuevos tipos de métodos, los métodos estáticos no se pasan a la instancia y, por lo tanto, se parecen a las funciones normales. A los métodos de clase se les pasa la clase del objeto, pero no el objeto en sí. Los métodos estáticos y de clase se definen de la siguiente manera:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">clase</span> <span class="n">C</span><span class="p">(</span><span class="n">objeto</span><span class="p">):</span>
<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
<span class="o">...</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">método</span> <span class="n">estático</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
<span class="o">...</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">método</span> <span class="n">de</span> <span class="n">clase</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">La función <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> toma la función <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code> y la devuelve envuelta en un descriptor para que pueda almacenarse en el objeto de clase. Se podría esperar que existiera una sintaxis especial para crear dichos métodos (<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">static</span> <span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">defstatic</span> <span class="pre">f()</span></code> o algo similar), pero aún no se ha definido dicha sintaxis; eso se ha dejado para futuras versiones de Python.</p>
<p class="translated">También se implementan más características nuevas, como ranuras y propiedades, como nuevos tipos de descriptores, y no es difícil escribir una clase de descriptor que haga algo nuevo. Por ejemplo, sería posible escribir una clase de descriptor que hiciera posible escribir condiciones previas al estilo Eiffel y posteriores para un método. Una clase que usó esta característica podría definirse así:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">eiffel</span><span class="w"> </span><span class="kn">import</span> <span class="n">eiffelmethod</span>

<span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
<span class="c1"># La función actual</span>
<span class="o">...</span>
<span class="k">def</span><span class="w"> </span><span class="nf">pre_f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="c1"># Verificar condiciones previas</span>
<span class="o">...</span>
<span class="k">def</span><span class="w"> </span><span class="nf">post_f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="c1"># Verificar condiciones posteriores</span>
<span class="o">...</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">eiffelmethod</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">pre_f</span><span class="p">,</span> <span class="n">post_f</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Tenga en cuenta que una persona que utilice el nuevo <code class="xref py py-func docutils literal notranslate"><span class="pre">eiffelmethod()</span></code> no tiene por qué entender nada sobre descriptores. Por eso creo que las nuevas características no aumentan la complejidad básica del lenguaje. Habrá algunos expertos que necesitarán saber sobre él para escribir <code class="xref py py-func docutils literal notranslate"><span class="pre">eiffelmethod()</span></code> o ZODB o lo que sea, pero la mayoría de los usuarios simplemente escribirán código sobre las bibliotecas resultantes e ignorarán los detalles de implementación.</p>
</section>
<section id="multiple-inheritance-the-diamond-rule">
<h3 class="translated">Herencia múltiple: la regla del diamante<a class="headerlink" href="#multiple-inheritance-the-diamond-rule" title="Link to this heading">¶</a></h3>
<p class="translated">La herencia múltiple también se ha hecho más útil al cambiar las reglas bajo las cuales se resuelven los nombres. Considera este conjunto de clases (diagrama tomado de <span class="target" id="index-47"></span><a class="pep reference external" href="https://peps.python.org/pep-0253/"><strong>PEP 253</strong></a> de Guido van Rossum):</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">clase</span> <span class="n">A</span><span class="p">:</span>
<span class="o">^</span> <span class="o">^</span> <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>
<span class="o">/</span> \
<span class="o">/</span> \
<span class="o">/</span> \
<span class="o">/</span> \
<span class="n">clase</span> <span class="n">B</span> <span class="n">clase</span> <span class="n">C</span><span class="p">:</span>
<span class="o">^</span> <span class="o">^</span> <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="o">...</span>
\ <span class="o">/</span>
\ <span class="o">/</span>
\ <span class="o">/</span>
\ <span class="o">/</span>
<span class="n">clase</span> <span class="n">D</span>
</pre></div>
</div>
<p class="translated">La regla de búsqueda para las clases clásicas es simple pero no muy inteligente; las clases base se buscan primero en profundidad, de izquierda a derecha. Una referencia a <code class="xref py py-meth docutils literal notranslate"><span class="pre">D.save()</span></code> buscará las clases <code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">B</span></code> y luego <code class="xref py py-class docutils literal notranslate"><span class="pre">A</span></code>, donde se encontraría y devolvería <code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code>. <code class="xref py py-meth docutils literal notranslate"><span class="pre">C.save()</span></code> nunca se encontraría. Esto es malo, porque si el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code> de <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code> está guardando algún estado interno específico de <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, no llamarlo hará que ese estado nunca se guarde.</p>
<p class="translated">Las clases de estilo nuevo siguen un algoritmo diferente que es más complicado de explicar, pero hace lo correcto en esta situación. (Toma en cuenta que Python 2.3 cambia este algoritmo a uno que produce los mismos resultados en la mayoría de los casos, pero produce resultados más útiles para gráficos de herencia realmente complicados.)</p>
<ol class="arabic simple">
<li><p class="translated">Enumere todas las clases base siguiendo la regla de búsqueda clásica e incluya una clase varias veces si se la visita repetidamente. En el ejemplo anterior, la lista de clases visitadas es [<code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">B</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">A</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">A</span></code>].</p></li>
<li><p class="translated">Examine la lista en busca de clases duplicadas. Si encuentra alguna, elimine todas las instancias excepto una y deje la <em>last</em> en la lista. En el ejemplo anterior, la lista se convierte en [<code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">B</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">C</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">A</span></code>] después de eliminar los duplicados.</p></li>
</ol>
<p class="translated">Siguiendo esta regla, al hacer referencia a <code class="xref py py-meth docutils literal notranslate"><span class="pre">D.save()</span></code> se devolverá <code class="xref py py-meth docutils literal notranslate"><span class="pre">C.save()</span></code>, que es el comportamiento que buscamos. Esta regla de búsqueda es la misma que sigue Common Lisp. Una nueva función incorporada, <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>, proporciona una forma de acceder a las superclases de una clase sin tener que volver a implementar el algoritmo de Python. La forma más utilizada será <code class="docutils literal notranslate"><span class="pre">super(class,</span> <span class="pre">obj)</span></code>, que devuelve un objeto de superclase enlazado (no el objeto de clase real). Esta forma se utilizará en métodos para llamar a un método en la superclase; por ejemplo, el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code> de <code class="xref py py-class docutils literal notranslate"><span class="pre">D</span></code> se vería así:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">clase</span> <span class="n">D</span> <span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">):</span>
<span class="k">def</span><span class="w"> </span><span class="nf">save</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="c1"># Llamar a la superclase .save()</span>
<span class="nb">super</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="c1"># Guardar la información privada de D aquí</span>
<span class="o">...</span>
</pre></div>
</div>
<p class="translated">También <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> puede retornar objetos de superclase no vinculados cuando se llama como <code class="docutils literal notranslate"><span class="pre">super(class)</span></code> o <code class="docutils literal notranslate"><span class="pre">super(class1,</span> <span class="pre">class2)</span></code>, pero probablemente esto no sea útil a menudo.</p>
</section>
<section id="attribute-access">
<h3 class="translated">Acceso a atributos<a class="headerlink" href="#attribute-access" title="Link to this heading">¶</a></h3>
<p class="translated">Una buena cantidad de clases sofisticadas de Python definen ganchos para el acceso a atributos mediante <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>; lo más común es que esto se haga por conveniencia, para que el código sea más legible al asignar automáticamente un acceso a atributos como <code class="docutils literal notranslate"><span class="pre">obj.parent</span></code> a una llamada de método como <code class="docutils literal notranslate"><span class="pre">obj.get_parent</span></code>. Python 2.2 agrega algunas formas nuevas de controlar el acceso a atributos.</p>
<p class="translated">Primero, <code class="docutils literal notranslate"><span class="pre">__getattr__(attr_name)</span></code> aún es compatible con las clases de nuevo estilo, y nada al respecto ha cambiado. Como antes, se llamará cuando se intente acceder a <code class="docutils literal notranslate"><span class="pre">obj.foo</span></code> y no se encuentre ningún atributo llamado <code class="docutils literal notranslate"><span class="pre">foo</span></code> en el diccionario de la instancia.</p>
<p class="translated">Las clases de nuevo estilo también admiten un nuevo método, <code class="docutils literal notranslate"><span class="pre">__getattribute__(attr_name)</span></code>. La diferencia entre los dos métodos es que <a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> se llama <em>always</em> siempre que se accede a un atributo, mientras que el antiguo <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> solo se llama si <code class="docutils literal notranslate"><span class="pre">foo</span></code> no se encuentra en el diccionario de la instancia.</p>
<p class="translated">Sin embargo, el soporte de Python 2.2 para <em class="dfn">properties</em> será a menudo una forma más sencilla de atrapar referencias de atributos. Escribir un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code> es complicado porque para evitar la recursión no se pueden utilizar accesos a atributos regulares dentro de ellos, y en su lugar hay que jugar con el contenido de <a class="reference internal" href="../reference/datamodel.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a>. Los métodos <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a> también terminan siendo llamados por Python cuando comprueba otros métodos como <a class="reference internal" href="../reference/datamodel.html#object.__repr__" title="object.__repr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__repr__()</span></code></a> o <code class="xref py py-meth docutils literal notranslate"><span class="pre">__coerce__()</span></code>, y por lo tanto tienen que ser escritos con esto en mente. Finalmente, llamar a una función en cada acceso a un atributo da como resultado una pérdida de rendimiento considerable.</p>
<p class="translated"><a class="reference internal" href="../library/functions.html#property" title="property"><code class="xref py py-class docutils literal notranslate"><span class="pre">property</span></code></a> es un nuevo tipo integrado que incluye tres funciones que obtienen, establecen o eliminan un atributo y una cadena de documentación. Por ejemplo, si desea definir un atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code> que se calcule, pero que también se pueda configurar, puede escribir:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">clase</span> <span class="n">C</span><span class="p">(</span><span class="n">objeto</span><span class="p">):</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_size</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="n">result</span> <span class="o">=</span> <span class="o">...</span> <span class="n">computation</span> <span class="o">...</span>
<span class="k">return</span> <span class="n">result</span>
<span class="k">def</span><span class="w"> </span><span class="nf">set_size</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="o">...</span> <span class="n">calcula</span> <span class="n">algo</span> <span class="n">en</span> <span class="n">función</span> <span class="k">del</span> <span class="n">tamaño</span>
<span class="n">y</span> <span class="n">establece</span> <span class="n">el</span> <span class="n">estado</span> <span class="n">interno</span> <span class="n">de</span> <span class="n">forma</span> <span class="n">adecuada</span> <span class="o">...</span>

<span class="c1"># Define una propiedad. El método &#39;eliminar este atributo&#39;</span>
<span class="c1"># se define como None, por lo que el atributo</span>
<span class="c1"># no se puede eliminar.</span>
<span class="n">size</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">get_size</span><span class="p">,</span> <span class="n">set_size</span><span class="p">,</span>
<span class="kc">None</span><span class="p">,</span>
<span class="s2">&quot;Tamaño de almacenamiento de esta instancia&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Sin duda, esto es más claro y más fácil de escribir que un par de métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code>/<code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code> que comprueban el atributo <code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code> y lo gestionan de forma especial mientras recuperan todos los demás atributos del <a class="reference internal" href="../reference/datamodel.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> de la instancia. Los accesos a <code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code> también son los únicos que tienen que realizar el trabajo de llamar a una función, por lo que las referencias a otros atributos se ejecutan a su velocidad habitual.</p>
<p class="translated">Finalmente, es posible restringir la lista de atributos que se pueden referenciar en un objeto usando el nuevo atributo de clase <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>. Los objetos de Python por lo general son muy dinámicos; en cualquier momento es posible definir un nuevo atributo en una instancia haciendo simplemente <code class="docutils literal notranslate"><span class="pre">obj.new_attr=1</span></code>. Una clase de estilo nuevo puede definir un atributo de clase llamado <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> para limitar los atributos legales a un conjunto particular de nombres. Un ejemplo hará esto claro:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span><span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;template&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">obj</span><span class="o">.</span><span class="n">template</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">template</span> <span class="o">=</span> <span class="s1">&#39;Test&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">obj</span><span class="o">.</span><span class="n">template</span>
<span class="go">Test</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">newattr</span> <span class="o">=</span> <span class="kc">None</span>
<span class="go">Traceback (última llamada más reciente):</span>
<span class="go">Archivo &quot;&lt;stdin&gt;&quot;, línea 1, en ?</span>
<span class="go">AttributeError: el objeto &#39;C&#39; no tiene el atributo &#39;newattr&#39;</span>
</pre></div>
</div>
<p class="translated">Toma en cuenta cómo obtienes un <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> en el intento de asignar a un atributo que no aparece en <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a>.</p>
</section>
<section id="related-links">
<span id="sect-rellinks"></span><h3 class="translated">Enlaces relacionados<a class="headerlink" href="#related-links" title="Link to this heading">¶</a></h3>
<p class="translated">Esta sección solo ha sido una descripción rápida de las nuevas características, brindando una explicación suficiente para comenzar a programar, pero muchos detalles se han simplificado o ignorado. ¿Dónde deberías ir para obtener una imagen más completa?</p>
<p class="translated"><a class="reference internal" href="../howto/descriptor.html#descriptorhowto"><span class="std std-ref">Descriptor Guide</span></a> es una introducción extensa y tutorial a las características del descriptor, escrita por Guido van Rossum. Si mi descripción le ha abierto el apetito, lea este tutorial a continuación, porque brinda mucho más detalle sobre las nuevas características y sigue siendo bastante fácil de leer.</p>
<p class="translated">A continuación, hay dos PEPs relevantes, <span class="target" id="index-48"></span><a class="pep reference external" href="https://peps.python.org/pep-0252/"><strong>PEP 252</strong></a> y <span class="target" id="index-49"></span><a class="pep reference external" href="https://peps.python.org/pep-0253/"><strong>PEP 253</strong></a>. <span class="target" id="index-50"></span><a class="pep reference external" href="https://peps.python.org/pep-0252/"><strong>PEP 252</strong></a> se titula «Hacer que los tipos se parezcan más a las clases», y cubre la API del descriptor. <span class="target" id="index-51"></span><a class="pep reference external" href="https://peps.python.org/pep-0253/"><strong>PEP 253</strong></a> se titula «Subtipado de tipos incorporados», y describe los cambios de los objetos de tipo que hacen posible el subtipo de objetos incorporados. <span class="target" id="index-52"></span><a class="pep reference external" href="https://peps.python.org/pep-0253/"><strong>PEP 253</strong></a> es la PEP más complicada de las dos, y en algunos puntos las explicaciones necesarias de tipos y meta-tipos pueden causar que tu cabeza explote. Ambas PEPs se escribieron e implementaron por Guido van Rossum con la asistencia sustancial del resto del equipo de Zope Corp.</p>
<p class="translated">Finalmente, está la máxima autoridad: el código fuente. La mayoría de la maquinaria para el manejo de tipos está en <code class="file docutils literal notranslate"><span class="pre">Objects/typeobject.c</span></code>, pero solo debes recurrir a él después de que se hayan agotado todas las demás vías, incluida la publicación de una pregunta en python-list o python-dev.</p>
</section>
</section>
<section id="pep-234-iterators">
<h2 class="translated">PEP 234: Iteradores<a class="headerlink" href="#pep-234-iterators" title="Link to this heading">¶</a></h2>
<p class="translated">Otra adición significativa a la versión 2.2 es una interfaz de iteración tanto a nivel de C como de Python.  Los objetos pueden definir cómo pueden ser iterados por quienes los llaman.</p>
<p class="translated">En las versiones de Python hasta la 2.1, la forma habitual de hacer que funcione <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">item</span> <span class="pre">in</span> <span class="pre">obj</span></code> es definir un método <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> que se parezca a esto:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="k">return</span> <span class="o">&lt;</span><span class="n">siguiente</span> <span class="n">elemento</span><span class="o">&gt;</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> se utiliza de forma más adecuada para definir una operación de indexación en un objeto, de modo que pueda escribir <code class="docutils literal notranslate"><span class="pre">obj[5]</span></code> para recuperar el sexto elemento. Es un poco engañoso cuando se utiliza esto solo para admitir bucles <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a>. Considere un objeto similar a un archivo que desea ser recorrido en bucle; el parámetro <em>index</em> esencialmente no tiene sentido, ya que la clase probablemente asume que se realizará una serie de llamadas <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> con <em>index</em> incrementándose en uno cada vez. En otras palabras, la presencia del método <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> no significa que el uso de <code class="docutils literal notranslate"><span class="pre">file[5]</span></code> para acceder aleatoriamente al sexto elemento funcionará, aunque realmente debería funcionar.</p>
<p class="translated">En Python 2.2, la iteración se puede implementar por separado y los métodos <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> se pueden limitar a las clases que realmente admiten el acceso aleatorio. La idea básica de los iteradores es simple. Se utiliza una nueva función incorporada, <code class="docutils literal notranslate"><span class="pre">iter(obj)</span></code> o <code class="docutils literal notranslate"><span class="pre">iter(C,</span> <span class="pre">sentinel)</span></code>, para obtener un iterador. <code class="docutils literal notranslate"><span class="pre">iter(obj)</span></code> devuelve un iterador para el objeto <em>obj</em>, mientras que <code class="docutils literal notranslate"><span class="pre">iter(C,</span> <span class="pre">sentinel)</span></code> devuelve un iterador que invocará el objeto invocable <em>C</em> hasta que devuelva <em>sentinel</em> para indicar que el iterador ha finalizado.</p>
<p class="translated">Las clases de Python pueden definir un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code>, que debe crear y devolver un nuevo iterador para el objeto; si el objeto es su propio iterador, este método puede devolver simplemente <code class="docutils literal notranslate"><span class="pre">self</span></code>. En particular, los iteradores normalmente serán sus propios iteradores. Los tipos de extensión implementados en C pueden implementar una función <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a> para devolver un iterador, y los tipos de extensión que quieran comportarse como iteradores pueden definir una función <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iternext" title="PyTypeObject.tp_iternext"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iternext</span></code></a>.</p>
<p class="translated">Entonces, después de todo esto, ¿qué hacen realmente los iteradores?  Tienen un método obligatorio, <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a>, que no toma argumentos y retorna el siguiente valor.  Cuando no hay más valores que retornar, la llamada a <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> debería lanzar la excepción <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>.</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">i</span>
<span class="go">&lt;iterator object at 0x8116870&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">Traceback (última llamada más reciente):</span>
<span class="go">Archivo &quot;&lt;stdin&gt;&quot;, línea 1, en ?</span>
<span class="go">StopIteration</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">En la versión 2.2, la declaración <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> de Python ya no espera una secuencia, sino algo para lo que <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> devolverá un iterador. Para mayor comodidad y compatibilidad con versiones anteriores, se construye automáticamente un iterador para las secuencias que no implementan <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code> o una ranura <a class="reference internal" href="../c-api/typeobj.html#c.PyTypeObject.tp_iter" title="PyTypeObject.tp_iter"><code class="xref c c-member docutils literal notranslate"><span class="pre">tp_iter</span></code></a>, por lo que <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">[1,2,3]</span></code> seguirá funcionando. Siempre que el intérprete de Python recorra una secuencia, se ha modificado para utilizar el protocolo de iterador. Esto significa que puede hacer cosas como esta:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span>
<span class="go">(1, 2, 3)</span>
</pre></div>
</div>
<p class="translated">Se ha añadido soporte de iteradores a algunos de los tipos básicos de Python.   Llamar a <a class="reference internal" href="../library/functions.html#iter" title="iter"><code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code></a> sobre un diccionario retornará un iterador que hace un bucle sobre sus claves:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Jan&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Feb&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;Mar&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;Apr&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;May&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;Jun&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
<span class="gp">... </span>     <span class="s1">&#39;Jul&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;Aug&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;Sep&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;Oct&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;Nov&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s1">&#39;Dec&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span> <span class="nb">print</span> <span class="n">key</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">Mar 3</span>
<span class="go">Feb 2</span>
<span class="go">Aug 8</span>
<span class="go">Sep 9</span>
<span class="go">May 5</span>
<span class="go">Jun 6</span>
<span class="go">Jul 7</span>
<span class="go">Jan 1</span>
<span class="go">Apr 4</span>
<span class="go">Nov 11</span>
<span class="go">Dec 12</span>
<span class="go">Oct 10</span>
</pre></div>
</div>
<p class="translated">Ese es simplemente el comportamiento predeterminado. Si desea iterar sobre claves, valores o pares clave/valor, puede llamar explícitamente a los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">iterkeys()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">itervalues()</span></code> o <code class="xref py py-meth docutils literal notranslate"><span class="pre">iteritems()</span></code> para obtener un iterador adecuado. En un cambio menor relacionado, el operador <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> ahora funciona en diccionarios, por lo que <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">in</span> <span class="pre">dict</span></code> ahora es equivalente a <code class="docutils literal notranslate"><span class="pre">dict.has_key(key)</span></code>.</p>
<p class="translated">Los archivos también proporcionan un iterador, que llama al método <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> hasta que no hay más líneas en el archivo.  Esto significa que ahora puede leer cada línea de un archivo utilizando un código como este:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
    <span class="c1"># do something for each line</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Tenga en cuenta que sólo puede avanzar en un iterador; no hay forma de obtener el elemento anterior, reiniciar el iterador o hacer una copia del mismo. Un objeto iterador podría proporcionar estas capacidades adicionales, pero el protocolo iterador sólo requiere un método <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-53"></span><a class="pep reference external" href="https://peps.python.org/pep-0234/"><strong>PEP 234</strong></a> - Iteradores</dt><dd><p class="translated">Escrito por Ka-Ping Yee y GvR; implementado por el equipo de Python Labs, principalmente por GvR y Tim Peters.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-255-simple-generators">
<h2 class="translated">PEP 255: Generadores simples<a class="headerlink" href="#pep-255-simple-generators" title="Link to this heading">¶</a></h2>
<p class="translated">Los generadores son otra novedad que interactúa con la introducción de los iteradores.</p>
<p class="translated">Sin duda estás familiarizado con cómo funcionan las llamadas a funciones en Python o C. Cuando llamas a una función, ésta obtiene un espacio de nombres privado donde se crean sus variables locales.  Cuando la función llega a una declaración <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>, las variables locales se destruyen y el valor resultante se retorna a quien la llamó.  Una llamada posterior a la misma función obtendrá un nuevo conjunto de variables locales. Pero, ¿qué pasaría si las variables locales no se tiraran al salir de una función? ¿Qué pasaría si pudieras reanudar la función donde la dejaste?  Esto es lo que proporcionan los generadores; se puede pensar en ellos como funciones reanudables.</p>
<p class="translated">Este es el ejemplo más sencillo de una función generadora:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">generate_ints</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">i</span>
</pre></div>
</div>
<p class="translated">Se ha introducido una nueva palabra clave, <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>, para los generadores.  Cualquier función que contenga una declaración <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> es una función generadora; esto es detectado por el compilador de código de bits de Python que compila la función especialmente como resultado.  Debido a la introducción de una nueva palabra clave, los generadores deben ser explícitamente habilitados en un módulo incluyendo una declaración <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">generators</span></code> cerca de la parte superior del código fuente del módulo.  En Python 2.3 esta declaración será innecesaria.</p>
<p class="translated">Cuando se llama a una función generadora, ésta no retorna un único valor, sino que retorna un objeto generador que soporta el protocolo de los iteradores.  Al ejecutar la sentencia <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>, el generador retorna el valor de <code class="docutils literal notranslate"><span class="pre">i</span></code>, de forma similar a una sentencia <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a>.  La gran diferencia entre <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> y una sentencia <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> es que al llegar a una sentencia <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> se suspende el estado de ejecución del generador y se conservan las variables locales.  En la siguiente llamada al método <code class="docutils literal notranslate"><span class="pre">next()</span></code> del generador, la función se reanudará la ejecución inmediatamente después de la sentencia <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code>.  (Por razones complicadas, la sentencia <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> no está permitida dentro del bloque <code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code> de una sentencia <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>…`<a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a>; lea <span class="target" id="index-54"></span><a class="pep reference external" href="https://peps.python.org/pep-0255/"><strong>PEP 255</strong></a> para una explicación completa de la interacción entre <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> y las excepciones)</p>
<p class="translated">Este es un ejemplo de uso del generador <code class="xref py py-func docutils literal notranslate"><span class="pre">generate_ints()</span></code>:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="n">generate_ints</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span>
<span class="go">&lt;objeto generador en 0x8117f90&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">Traceback (última llamada más reciente):</span>
<span class="go">Archivo &quot;&lt;stdin&gt;&quot;, línea 1, en ?</span>
<span class="go">Archivo &quot;&lt;stdin&gt;&quot;, línea 2, en generate_ints</span>
<span class="go">StopIteration</span>
</pre></div>
</div>
<p class="translated">También podrías escribir <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">generate_ints(5)</span></code>, o <code class="docutils literal notranslate"><span class="pre">a,b,c</span> <span class="pre">=</span> <span class="pre">generate_ints(3)</span></code>.</p>
<p class="translated">Dentro de una función generadora, la sentencia <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> sólo puede usarse sin un valor, y señala el final de la procesión de valores; después el generador no puede retornar más valores. <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> con un valor, como <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">5</span></code>, es un error de sintaxis dentro de una función generadora.  El final de los resultados del generador también puede indicarse levantando manualmente <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>, o simplemente dejando que el flujo de ejecución caiga en el fondo de la función.</p>
<p class="translated">Puedes conseguir el efecto de los generadores manualmente escribiendo tu propia clase y almacenando todas las variables locales del generador como variables de instancia.  Por ejemplo, la lución de una lista de enteros podría hacerse estableciendo <code class="docutils literal notranslate"><span class="pre">self.count</span></code> a 0, y haciendo que el método <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> incremente <code class="docutils literal notranslate"><span class="pre">self.count</span></code> y lo retorne. Sin embargo, para un generador medianamente complicado, escribir la clase correspondiente sería mucho más complicado. <code class="file docutils literal notranslate"><span class="pre">Lib/test/test_generators.py</span></code> contiene varios ejemplos más interesantes.  El más sencillo implementa un recorrido en orden de un árbol utilizando generadores de forma recursiva</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Un generador recursivo que genera hojas de árboles en orden.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">inorder</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="k">if</span> <span class="n">t</span><span class="p">:</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inorder</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">left</span><span class="p">):</span>
<span class="k">yield</span> <span class="n">x</span>
<span class="k">yield</span> <span class="n">t</span><span class="o">.</span><span class="n">label</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inorder</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
<span class="k">yield</span> <span class="n">x</span>
</pre></div>
</div>
<p class="translated">Otros dos ejemplos en <code class="file docutils literal notranslate"><span class="pre">Lib/test/test_generators.py</span></code> producen soluciones para el problema de las N reinas (colocar $N$ reinas en un tablero de ajedrez $NxN$ de forma que ninguna reina amenace a otra) y el recorrido del caballero (una ruta que lleva a un caballo a cada casilla de un tablero de ajedrez $NxN$ sin visitar ninguna casilla dos veces).</p>
<p class="translated">La idea de los generadores proviene de otros lenguajes de programación, especialmente Icon (<a class="reference external" href="https://www2.cs.arizona.edu/icon/">https://www2.cs.arizona.edu/icon/</a>), donde la idea de los generadores es central. En Icon, cada expresión y llamada a función se comporta como un generador. Un ejemplo de «An Overview of the Icon Programming Language» en <a class="reference external" href="https://www2.cs.arizona.edu/icon/docs/ipd266.htm">https://www2.cs.arizona.edu/icon/docs/ipd266.htm</a> da una idea de cómo se ve esto:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sentence</span> <span class="o">:=</span> <span class="s2">&quot;Store it in the neighboring harbor&quot;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">:=</span> <span class="n">find</span><span class="p">(</span><span class="s2">&quot;or&quot;</span><span class="p">,</span> <span class="n">sentence</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="n">then</span> <span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">En Icon, la función <code class="xref py py-func docutils literal notranslate"><span class="pre">find()</span></code> devuelve los índices en los que se encuentra la subcadena «o»: 3, 23, 33. En la declaración <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a>, a <code class="docutils literal notranslate"><span class="pre">i</span></code> primero se le asigna un valor de 3, pero 3 es menor que 5, por lo que la comparación falla y Icon la vuelve a intentar con el segundo valor de 23. 23 es mayor que 5, por lo que la comparación ahora tiene éxito y el código imprime el valor 23 en la pantalla.</p>
<p class="translated">Python no va tan lejos como Icon en la adopción de generadores como concepto central.  Los generadores se consideran una nueva parte del núcleo del lenguaje Python, pero aprenderlos o utilizarlos no es obligatorio; si no resuelven ningún problema que tengas, siéntete libre de ignorarlos. Una característica novedosa de la interfaz de Python en comparación con la de Icon es que el estado de un generador se representa como un objeto concreto (el iterador) que puede pasarse a otras funciones o almacenarse en una estructura de datos.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-55"></span><a class="pep reference external" href="https://peps.python.org/pep-0255/"><strong>PEP 255</strong></a> - Generadores simples</dt><dd><p class="translated">Escrito por Neil Schemenauer, Tim Peters, Magnus Lie Hetland.  Implementado principalmente por Neil Schemenauer y Tim Peters, con otras correcciones del equipo de Python Labs.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-237-unifying-long-integers-and-integers">
<h2 class="translated">PEP 237: Unificación de enteros largos y enteros<a class="headerlink" href="#pep-237-unifying-long-integers-and-integers" title="Link to this heading">¶</a></h2>
<p class="translated">En versiones recientes, la distinción entre números enteros regulares, que son valores de 32 bits en la mayoría de las máquinas, y números enteros largos, que pueden ser de tamaño arbitrario, se estaba volviendo una molestia. Por ejemplo, en plataformas que admiten archivos de más de bytes que <code class="docutils literal notranslate"><span class="pre">2**32</span></code>, el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">tell()</span></code> de objetos de archivo tiene que devolver un número entero largo. Sin embargo, había varias partes de Python que esperaban números enteros simples y generarían un error si se proporcionaba un número entero largo en su lugar. Por ejemplo, en Python 1.5, solo se podían usar números enteros regulares como índice de segmento, y <code class="docutils literal notranslate"><span class="pre">'abc'[1L:]</span></code> generaría una excepción <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> con el mensaje “el índice de segmento debe ser int”.</p>
<p class="translated">Python 2.2 cambiará los valores de enteros cortos a enteros largos según sea necesario. El sufijo “L” ya no es necesario para indicar un literal entero largo, ya que ahora el compilador elegirá el tipo apropiado.  (El uso del sufijo “L” se desaconsejará en futuras versiones 2.x de Python, provocando una advertencia en Python 2.4, y probablemente se eliminará en Python 3.0)  Muchas operaciones que solían lanzar un <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a> ahora retornarán un entero largo como resultado.  Por ejemplo:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1234567890123</span>
<span class="go">1234567890123L</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span> <span class="o">**</span> <span class="mi">64</span>
<span class="go">18446744073709551616L</span>
</pre></div>
</div>
<p class="translated">En la mayoría de los casos, los enteros y los enteros largos se tratarán ahora de forma idéntica.  Todavía se pueden distinguir con la función incorporada <a class="reference internal" href="../library/functions.html#type" title="type"><code class="xref py py-func docutils literal notranslate"><span class="pre">type()</span></code></a>, pero rara vez se necesita.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-56"></span><a class="pep reference external" href="https://peps.python.org/pep-0237/"><strong>PEP 237</strong></a> - Unificación de enteros largos y enteros</dt><dd><p class="translated">Escrito por Moshe Zadka y Guido van Rossum.  Implementado principalmente por Guido van Rossum.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-238-changing-the-division-operator">
<h2 class="translated">PEP 238: Cambio del operador de división<a class="headerlink" href="#pep-238-changing-the-division-operator" title="Link to this heading">¶</a></h2>
<p class="translated">El cambio más controvertido de Python 2.2 anuncia el inicio de un esfuerzo por arreglar un viejo defecto de diseño que ha estado en Python desde el principio. Actualmente, el operador de división de Python, <code class="docutils literal notranslate"><span class="pre">/</span></code>, se comporta como el operador de división de C cuando se le presentan dos argumentos enteros: retorna un resultado entero que se trunca cuando hay una parte fraccionaria.  Por ejemplo, <code class="docutils literal notranslate"><span class="pre">3/2</span></code> es 1, no 1,5, y <code class="docutils literal notranslate"><span class="pre">(-1)/2</span></code> es -1, no -0,5.  Esto significa que los resultados de la división pueden variar inesperadamente dependiendo del tipo de los dos operandos y, como Python está tipado dinámicamente, puede ser difícil determinar los posibles tipos de los operandos.</p>
<p class="translated">(La controversia se centra en si esto es <em>realmente</em> un defecto de diseño, y si vale la pena romper el código existente para arreglarlo.  Ha provocado interminables discusiones en python-dev, y en julio de 2001 estalló una tormenta de publicaciones ácidamente sarcásticas en <em class="newsgroup">comp.lang.python</em>. No argumentaré aquí a favor de ninguno de los dos bandos y me limitaré a describir lo que se ha implementado en la 2.2.  Lea <span class="target" id="index-57"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a> para un resumen de los argumentos y contra-argumentos)</p>
<p class="translated">Debido a que este cambio podría romper el código, se está introduciendo de forma muy gradual. Python 2.2 comienza la transición, pero el cambio no será completo hasta Python 3.0.</p>
<p class="translated">En primer lugar, tomaré prestada alguna terminología de <span class="target" id="index-58"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a>. La «división verdadera» es la división con la que la mayoría de los no programadores están familiarizados: 3/2 es 1,5, 1/4 es 0,25, y así sucesivamente. La «división entera a la baja» es lo que hace actualmente el operador <code class="docutils literal notranslate"><span class="pre">/</span></code> de Python cuando se le dan operandos enteros; el resultado es el redondeo a la baja (<em>floor</em>) del valor retornado por la división verdadera. La «división clásica» es el comportamiento mixto actual de <code class="docutils literal notranslate"><span class="pre">/</span></code>; retorna el resultado de la división entera a la baja cuando los operandos son enteros, y retorna el resultado de la división verdadera cuando uno de los operandos es un número de punto flotante.</p>
<p class="translated">Estos son los cambios que introduce la versión 2.2:</p>
<ul>
<li><p class="translated">Un nuevo operador, <code class="docutils literal notranslate"><span class="pre">//</span></code>, es el operador de división entera a la baja. (Sí, ya sabemos que se parece al símbolo de comentario de C++.) <code class="docutils literal notranslate"><span class="pre">//</span></code> <em>siempre</em> realiza la división entera a la baja sin importar los tipos de sus operandos, así que <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">//</span> <span class="pre">2</span></code> es 0 y <code class="docutils literal notranslate"><span class="pre">1.0</span> <span class="pre">//</span> <span class="pre">2.0</span></code> también es 0.0.</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">//</span></code> está siempre disponible en Python 2.2; no es necesario habilitarlo mediante una sentencia <code class="docutils literal notranslate"><span class="pre">__future__</span></code>.</p>
</li>
<li><p class="translated">Al incluir una declaración <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code> en un módulo, el operador <code class="docutils literal notranslate"><span class="pre">/</span></code> se cambiará para retornar el resultado de la división verdadera, por lo que <code class="docutils literal notranslate"><span class="pre">1/2</span></code> es 0,5.  Sin la declaración <code class="docutils literal notranslate"><span class="pre">__future__</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code> sigue significando la división clásica. El significado por defecto de <code class="docutils literal notranslate"><span class="pre">/</span></code> no cambiará hasta Python 3.0.</p></li>
<li><p class="translated">Las clases pueden definir métodos denominados <a class="reference internal" href="../reference/datamodel.html#object.__truediv__" title="object.__truediv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__truediv__()</span></code></a> y <a class="reference internal" href="../reference/datamodel.html#object.__floordiv__" title="object.__floordiv__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__floordiv__()</span></code></a> para sobrecargar los dos operadores de división. En el nivel C, también hay espacios en la estructura <a class="reference internal" href="../c-api/typeobj.html#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyNumberMethods</span></code></a> para que los tipos de extensión puedan definir los dos operadores.</p></li>
<li><p class="translated">Python 2.2 admite algunos argumentos de línea de comandos para comprobar si el código funcionará con la semántica de división modificada.  Ejecutar python con <code class="xref std std-option docutils literal notranslate"><span class="pre">-Q</span> <span class="pre">warn</span></code> hará que se emita una advertencia cada vez que se aplique la división a dos enteros.  Puedes usar esto para encontrar el código que está afectado por el cambio y arreglarlo.  Por defecto, Python 2.2 simplemente realizará la división clásica sin una advertencia; la advertencia se activará por defecto en Python 2.3.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-59"></span><a class="pep reference external" href="https://peps.python.org/pep-0238/"><strong>PEP 238</strong></a> - Cambio del operador de división</dt><dd><p class="translated">Escrito por Moshe Zadka y Guido van Rossum.  Implementado por Guido van Rossum..</p>
</dd>
</dl>
</div>
</section>
<section id="unicode-changes">
<h2 class="translated">Cambios en Unicode<a class="headerlink" href="#unicode-changes" title="Link to this heading">¶</a></h2>
<p class="translated">El soporte de Unicode de Python se ha mejorado un poco en la versión 2.2.  Las cadenas Unicode se almacenan normalmente como UCS-2, como enteros sin signo de 16 bits. Python 2.2 también puede ser compilado para usar UCS-4, enteros sin signo de 32 bits, como su codificación interna suministrando <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-unicode=ucs4</span></code> al script de configuración.   (También es posible especificar <code class="xref std std-option docutils literal notranslate"><span class="pre">--disable-unicode</span></code> para desactivar completamente el soporte de Unicode)</p>
<p class="translated">Cuando se crea para utilizar UCS-4 (un «Python ancho»), el intérprete puede manejar de forma nativa caracteres Unicode desde U+000000 hasta U+110000, por lo que el rango de valores legales para la función <code class="xref py py-func docutils literal notranslate"><span class="pre">unichr()</span></code> se amplía en consecuencia. Si se utiliza un intérprete compilado para utilizar UCS-2 (un «Python estrecho»), los valores mayores que 65535 seguirán haciendo que <code class="xref py py-func docutils literal notranslate"><span class="pre">unichr()</span></code> genere una excepción <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>. Todo esto se describe en <span class="target" id="index-60"></span><a class="pep reference external" href="https://peps.python.org/pep-0261/"><strong>PEP 261</strong></a>, «Compatibilidad con caracteres Unicode “anchos”»; consúltelo para obtener más detalles.</p>
<p class="translated">Otro cambio es más sencillo de explicar. Desde su introducción, las cadenas Unicode admiten un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> para convertir la cadena a una codificación seleccionada, como UTF-8 o Latin-1. En la versión 2.2 se ha añadido un método <code class="docutils literal notranslate"><span class="pre">decode([*encoding*])</span></code> simétrico a las cadenas de 8 bits (aunque no a las cadenas Unicode). <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> supone que la cadena está en la codificación especificada y la decodifica, devolviendo lo que devuelva el códec.</p>
<p class="translated">Gracias a esta nueva función, se han añadido códecs para tareas no relacionadas directamente con Unicode.  Por ejemplo, se han añadido códecs para la codificación uu, la codificación base64 de MIME y la compresión con el módulo <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a>:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Aquí hay un largo fragmento de texto redundante, excesivamente verboso,</span>
<span class="gp">... </span><span class="s2">y repetitivo.</span>
<span class="gp">... </span><span class="s2">&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;zlib&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">&#39;x\x9c\r\xc9\xc1\r\x80 \x10\x04\xc0?Ul...&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;zlib&#39;</span><span class="p">)</span>
<span class="go">&#39;Aquí hay un largo fragmento de texto redundante, excesivamente verboso,\ny repetitivo.\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">s</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;uu&#39;</span><span class="p">)</span>
<span class="go">begin 666 &lt;datos&gt;</span>
<span class="go">M2&amp;5R92!I&lt;R!A(&amp;QE;F=T:&#39;D@&lt;&amp;EE8V4@;V8@&lt;F5D=6YD86YT+&quot;!O=F5R;&#39;D@</span>
<span class="go">&gt;=F5R8F]S92P*86YD(&#39;)E&lt;&amp;5T:71I=F4@=&amp;5X=&quot;X*</span>

<span class="go">fin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;caramba&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;rot-13&#39;</span><span class="p">)</span>
<span class="go">&#39;furrfu&#39;</span>
</pre></div>
</div>
<p class="translated">Para convertir una instancia de clase a Unicode, se puede definir un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__unicode__()</span></code> mediante una clase, análogo a <code class="xref py py-meth docutils literal notranslate"><span class="pre">__str__()</span></code>.</p>
<p class="translated">Marc-André Lemburg implementó <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">__unicode__()</span></code>. Fredrik Lundh y Martin von Löwis implementaron los cambios para admitir el uso interno de UCS-4.</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-61"></span><a class="pep reference external" href="https://peps.python.org/pep-0261/"><strong>PEP 261</strong></a> - Soporte para caracteres Unicode “anchos”</dt><dd><p class="translated">Escrito por Paul Prescod.</p>
</dd>
</dl>
</div>
</section>
<section id="pep-227-nested-scopes">
<h2 class="translated">PEP 227: Ámbitos anidados<a class="headerlink" href="#pep-227-nested-scopes" title="Link to this heading">¶</a></h2>
<p class="translated">En Python 2.1, los ámbitos anidados estáticamente se añadieron como una característica opcional, que se activaba mediante una directiva <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">nested_scopes</span></code>.  En 2.2 los ámbitos anidados ya no necesitan ser habilitados especialmente, y ahora están siempre presentes.  El resto de esta sección es una copia de la descripción de los ámbitos anidados de mi documento «What’s New in Python 2.1»; si lo leíste cuando salió la 2.1, puedes saltarte el resto de esta sección.</p>
<p class="translated">El mayor cambio introducido en Python 2.1, y completado en 2.2, es el de las reglas de alcance de Python.  En Python 2.0, en cualquier momento hay como máximo tres espacios de nombres utilizados para buscar nombres de variables: local, a nivel de módulo y el espacio de nombres incorporado.  Esto a menudo sorprendía a la gente porque no coincidía con sus expectativas intuitivas.  Por ejemplo, una definición de función recursiva anidada no funciona:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">():</span>
<span class="o">...</span>
<span class="k">def</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="n">valor</span><span class="p">):</span>
<span class="o">...</span>
<span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">valor</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">...</span>
</pre></div>
</div>
<p class="translated">La función <code class="xref py py-func docutils literal notranslate"><span class="pre">g()</span></code> siempre generará una excepción <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>, porque la vinculación del nombre <code class="docutils literal notranslate"><span class="pre">g</span></code> no está en su espacio de nombres local ni en el espacio de nombres a nivel de módulo. Esto no es un gran problema en la práctica (¿con qué frecuencia se definen recursivamente funciones internas como esta?), pero esto también hizo que el uso de la expresión <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> fuera más complicado, y esto fue un problema en la práctica. En el código que usa <code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code>, a menudo se pueden encontrar variables locales que se copian al pasarlas como valores predeterminados de los argumentos.</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="s2">&quot;Devuelve una lista de todas las entradas iguales a &#39;name&#39;&quot;</span>
<span class="n">L</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">name</span><span class="p">,</span>
<span class="bp">self</span><span class="o">.</span><span class="n">list_attribute</span><span class="p">)</span>
<span class="k">return</span> <span class="n">L</span>
</pre></div>
</div>
<p class="translated">La legibilidad del código Python escrito en un estilo fuertemente funcional sufre mucho como resultado.</p>
<p class="translated">El cambio más significativo de Python 2.2 es que se ha añadido al lenguaje el ámbito estático para solucionar este problema.  Como primer efecto, el argumento por defecto <code class="docutils literal notranslate"><span class="pre">name=name</span></code> es ahora innecesario en el ejemplo anterior.  En pocas palabras, cuando a un nombre de variable dado no se le asigna un valor dentro de una función (mediante una asignación, o las sentencias <a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a>, <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a>, o <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a>), las referencias a la variable se buscarán en el espacio de nombres local del ámbito que la rodea.  Puede encontrar una explicación más detallada de las reglas y una disección de la implementación en el PEP.</p>
<p class="translated">Este cambio puede causar algunos problemas de compatibilidad para el código en el que el mismo nombre de variable se utiliza tanto a nivel de módulo como de variable local dentro de una función que contiene otras definiciones de función. Sin embargo, esto parece bastante improbable, ya que dicho código habría sido bastante confuso de leer en primer lugar.</p>
<p class="translated">Un efecto secundario del cambio es que las sentencias <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> y <code class="docutils literal notranslate"><span class="pre">exec</span></code> se han hecho ilegales dentro del ámbito de una función bajo ciertas condiciones.  El manual de referencia de Python ha dicho todo el tiempo que <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> sólo es legal en el nivel superior de un módulo, pero el intérprete de CPython nunca ha aplicado esto antes.  Como parte de la implementación de los ámbitos anidados, el compilador que convierte el código fuente de Python en bytecodes tiene que generar un código diferente para acceder a las variables de un ámbito contenedor.  Los códigos <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> y <code class="docutils literal notranslate"><span class="pre">exec</span></code> hacen que el compilador no pueda averiguar esto, porque añaden nombres al espacio de nombres local que son desconocidos en tiempo de compilación. Por lo tanto, si una función contiene definiciones de funciones o expresiones <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> con variables libres, el compilador lo señalará lanzando una excepción <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>.</p>
<p class="translated">Para que la explicación anterior quede un poco más clara, he aquí un ejemplo:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">():</span>
<span class="c1"># La siguiente línea es un error de sintaxis</span>
<span class="n">exec</span> <span class="s1">&#39;x=2&#39;</span>
<span class="k">def</span><span class="w"> </span><span class="nf">g</span><span class="p">():</span>
<span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p class="translated">La línea 4 que contiene la declaración <code class="docutils literal notranslate"><span class="pre">exec</span></code> es un error de sintaxis, ya que <code class="docutils literal notranslate"><span class="pre">exec</span></code> definiría una nueva variable local denominada <code class="docutils literal notranslate"><span class="pre">x</span></code> a cuyo valor debería acceder <code class="xref py py-func docutils literal notranslate"><span class="pre">g()</span></code>.</p>
<p class="translated">Esto no debería ser una gran limitación, ya que <code class="docutils literal notranslate"><span class="pre">exec</span></code> rara vez se utiliza en la mayoría del código de Python (y cuando se utiliza, a menudo es un signo de un mal diseño de todos modos).</p>
<div class="admonition seealso">
<p class="admonition-title">Ver también</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-62"></span><a class="pep reference external" href="https://peps.python.org/pep-0227/"><strong>PEP 227</strong></a> - Ámbitos anidados estáticamente</dt><dd><p class="translated">Escrito e implementado por Jeremy Hylton.</p>
</dd>
</dl>
</div>
</section>
<section id="new-and-improved-modules">
<h2 class="translated">Módulos nuevos y mejorados<a class="headerlink" href="#new-and-improved-modules" title="Link to this heading">¶</a></h2>
<ul>
<li><p class="translated">El módulo <a class="reference internal" href="../library/xmlrpc.client.html#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code></a> fue aportado a la biblioteca estándar por Fredrik Lundh, que proporciona soporte para escribir clientes XML-RPC. XML-RPC es un protocolo simple de llamada a procedimiento remoto creado sobre HTTP y XML. Por ejemplo, el siguiente fragmento recupera una lista de canales RSS de la red O’Reilly y, a continuación, enumera los titulares recientes de un canal:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">xmlrpclib</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">xmlrpclib</span><span class="o">.</span><span class="n">Server</span><span class="p">(</span>
<span class="s1">&#39;http://www.oreillynet.com/meerkat/xml-rpc/server.php&#39;</span><span class="p">)</span>
<span class="n">channels</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">meerkat</span><span class="o">.</span><span class="n">getChannels</span><span class="p">()</span>
<span class="c1"># channels es una lista de diccionarios, como esta:</span>
<span class="c1"># [{&#39;id&#39;: 4, &#39;title&#39;: &#39;Freshmeat Daily News&#39;}</span>
<span class="c1"># {&#39;id&#39;: 190, &#39;title&#39;: &#39;32Bits Online&#39;},</span>
<span class="c1"># {&#39;id&#39;: 4549, &#39;title&#39;: &#39;3DGamers&#39;}, ... ]</span>

<span class="c1"># Obtener los elementos de un canal</span>
<span class="n">items</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">meerkat</span><span class="o">.</span><span class="n">getItems</span><span class="p">(</span> <span class="p">{</span><span class="s1">&#39;channel&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span> <span class="p">)</span>

<span class="c1"># &#39;items&#39; es otra lista de diccionarios, como esta:</span>
<span class="c1"># [{&#39;link&#39;: &#39;http://freshmeat.net/releases/52719/&#39;,</span>
<span class="c1"># &#39;description&#39;: &#39;Una utilidad que convierte HTML a XSL FO.&#39;,</span>
<span class="c1"># &#39;title&#39;: &#39;html2fo 0.3 (Predeterminado)&#39;}, ... ]</span>
</pre></div>
</div>
<p class="translated">El módulo <a class="reference internal" href="../library/xmlrpc.server.html#module-xmlrpc.server" title="xmlrpc.server: Basic XML-RPC server implementations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">SimpleXMLRPCServer</span></code></a> facilita la creación de servidores XML-RPC sencillos. Consulte <a class="reference external" href="http://xmlrpc.scripting.com/">http://xmlrpc.scripting.com/</a> para obtener más información sobre XML-RPC.</p>
</li>
<li><p class="translated">El nuevo módulo <a class="reference internal" href="../library/hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a> implementa el algoritmo HMAC descrito por <span class="target" id="index-63"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2104.html"><strong>RFC 2104</strong></a>. (Contribución de Gerhard Häring)</p></li>
<li><p class="translated">Varias funciones que originalmente devolvían tuplas extensas ahora devuelven pseudosecuencias que aún se comportan como tuplas pero que también tienen atributos mnemotécnicos como <code class="xref py py-attr docutils literal notranslate"><span class="pre">memberst_mtime</span></code> o <a class="reference internal" href="../library/time.html#time.struct_time.tm_year" title="time.struct_time.tm_year"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tm_year</span></code></a>. Las funciones mejoradas incluyen <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">stat()</span></code></a>, <a class="reference internal" href="../library/os.html#os.fstat" title="os.fstat"><code class="xref py py-func docutils literal notranslate"><span class="pre">fstat()</span></code></a>, <a class="reference internal" href="../library/os.html#os.statvfs" title="os.statvfs"><code class="xref py py-func docutils literal notranslate"><span class="pre">statvfs()</span></code></a> y <a class="reference internal" href="../library/os.html#os.fstatvfs" title="os.fstatvfs"><code class="xref py py-func docutils literal notranslate"><span class="pre">fstatvfs()</span></code></a> en el módulo <a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a>, y <a class="reference internal" href="../library/time.html#time.localtime" title="time.localtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">localtime()</span></code></a>, <a class="reference internal" href="../library/time.html#time.gmtime" title="time.gmtime"><code class="xref py py-func docutils literal notranslate"><span class="pre">gmtime()</span></code></a> y <a class="reference internal" href="../library/time.html#time.strptime" title="time.strptime"><code class="xref py py-func docutils literal notranslate"><span class="pre">strptime()</span></code></a> en el módulo <a class="reference internal" href="../library/time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">time</span></code></a>.</p>
<p class="translated">Por ejemplo, para obtener el tamaño de un archivo utilizando las antiguas tuplas, se terminaba escribiendo algo como <code class="docutils literal notranslate"><span class="pre">tamaño_de_archivo</span> <span class="pre">=</span> <span class="pre">os.stat(nombre_de_archivo)[stat.ST_SIZE]</span></code>, pero ahora se puede escribir más claramente como <code class="docutils literal notranslate"><span class="pre">tamaño_de_archivo</span> <span class="pre">=</span> <span class="pre">os.stat(nombre_de_archivo).st_size</span></code>.</p>
<p class="translated">El parche original para esta función fue aportado por Nick Mathewson.</p>
</li>
<li><p class="translated">El perfilador de Python ha sido ampliamente revisado y se han corregido varios errores en su salida.  (Contribución de Fred L. Drake, Jr. y Tim Peters)</p></li>
<li><p class="translated">El módulo <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> puede ser compilado para soportar IPv6; especifica la opción <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-ipv6</span></code> al script configure de Python.  (Contribución de Jun-ichiro «itojun» Hagino)</p></li>
<li><p class="translated">Se agregaron dos nuevos caracteres de formato al módulo <a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> para enteros de 64 bits en plataformas que admiten el tipo C <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span>. <code class="docutils literal notranslate"><span class="pre">q</span></code> es para un entero de 64 bits con signo y <code class="docutils literal notranslate"><span class="pre">Q</span></code> es para uno sin firmar. El valor se retorna en el tipo de entero largo de Python. (Aportado por Tim Peters.)</p></li>
<li><p class="translated">En el modo interactivo del intérprete, hay una nueva función incorporada <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a> que utiliza el módulo <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> introducido en Python 2.1 para proporcionar ayuda interactiva. <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a> sin ningún argumento te sitúa en una utilidad de ayuda online, donde puedes introducir los nombres de las funciones, clases o módulos para leer su texto de ayuda. (Contribuido por Guido van Rossum, usando el módulo <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> de Ka-Ping Yee)</p></li>
<li><p class="translated">Se han realizado varias correcciones de errores y mejoras de rendimiento en el motor SRE subyacente al módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a>. Por ejemplo, las funciones <a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.sub()</span></code></a> y <a class="reference internal" href="../library/re.html#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.split()</span></code></a> se han reescrito en C. Otro parche aportado acelera ciertos rangos de caracteres Unicode por un factor de dos, y un nuevo método <a class="reference internal" href="../library/re.html#re.finditer" title="re.finditer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">finditer()</span></code></a> que devuelve un iterador sobre todas las coincidencias no superpuestas en una cadena dada. (SRE es mantenido por Fredrik Lundh. El parche BIGCHARSET fue aportado por Martin von Löwis).</p></li>
<li><p class="translated">El módulo <a class="reference internal" href="../library/smtplib.html#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> soporta ahora <span class="target" id="index-64"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2487.html"><strong>RFC 2487</strong></a>, «Secure SMTP over TLS», por lo que ahora es posible cifrar el tráfico SMTP entre un programa Python y el agente de transporte de correo que recibe un mensaje. <a class="reference internal" href="../library/smtplib.html#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> también soporta la autenticación SMTP.  (Contribución de Gerhard Häring)</p></li>
<li><p class="translated">El módulo <a class="reference internal" href="../library/imaplib.html#module-imaplib" title="imaplib: IMAP4 protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">imaplib</span></code></a>, mantenido por Piers Lauder, tiene soporte para varias extensiones nuevas: la extensión NAMESPACE definida en <span class="target" id="index-65"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2342.html"><strong>RFC 2342</strong></a>, SORT, GETACL y SETACL.  (Contribución de Anthony Baxter y Michel Pelletier)</p></li>
<li><p class="translated">El análisis de direcciones de correo electrónico del módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">rfc822</span></code> ahora es compatible con <span class="target" id="index-66"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2822.html"><strong>RFC 2822</strong></a>, una actualización de <span class="target" id="index-67"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc822.html"><strong>RFC 822</strong></a>. (El nombre del módulo, <em>not</em>, se cambiará a <code class="docutils literal notranslate"><span class="pre">rfc2822</span></code>). También se ha añadido un nuevo paquete, <a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a>, para analizar y generar mensajes de correo electrónico. (Contribuido por Barry Warsaw y derivado de su trabajo en Mailman).</p></li>
<li><p class="translated">El módulo <a class="reference internal" href="../library/difflib.html#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code></a> ahora contiene una nueva clase <code class="xref py py-class docutils literal notranslate"><span class="pre">Differ</span></code> para producir listas legibles por humanos de cambios (un «delta») entre dos secuencias de líneas de texto. También hay dos funciones generadoras, <code class="xref py py-func docutils literal notranslate"><span class="pre">ndiff()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">restore()</span></code>, que devuelven respectivamente un delta de dos secuencias, o una de las secuencias originales de un delta. (Trabajo básico aportado por David Goodger, a partir del código ndiff.py de Tim Peters, quien luego realizó la generación).</p></li>
<li><p class="translated">Se agregaron las nuevas constantes <code class="xref py py-const docutils literal notranslate"><span class="pre">ascii_letters</span></code>, <code class="xref py py-const docutils literal notranslate"><span class="pre">ascii_lowercase</span></code> y <code class="xref py py-const docutils literal notranslate"><span class="pre">ascii_uppercase</span></code> al módulo <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a>. Había varios módulos en la biblioteca estándar que usaban <code class="xref py py-const docutils literal notranslate"><span class="pre">string.letters</span></code> para referirse a los rangos A-Za-z, pero esa suposición es incorrecta cuando se usan las configuraciones regionales, porque <code class="xref py py-const docutils literal notranslate"><span class="pre">string.letters</span></code> varía según el conjunto de caracteres legales definidos por la configuración regional actual. Todos los módulos con errores se han corregido para que usen <code class="xref py py-const docutils literal notranslate"><span class="pre">ascii_letters</span></code> en su lugar. (Informado por una persona desconocida; corregido por Fred L. Drake, Jr.)</p></li>
<li><p class="translated">El módulo <a class="reference internal" href="../library/mimetypes.html#module-mimetypes" title="mimetypes: Mapping of filename extensions to MIME types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">mimetypes</span></code></a> ahora facilita el uso de bases de datos de tipo MIME alternativas mediante la incorporación de una clase <a class="reference internal" href="../library/mimetypes.html#mimetypes.MimeTypes" title="mimetypes.MimeTypes"><code class="xref py py-class docutils literal notranslate"><span class="pre">MimeTypes</span></code></a>, que toma una lista de nombres de archivos para analizar. (Contribuido por Fred L. Drake, Jr.)</p></li>
<li><p class="translated">Se agregó una clase <a class="reference internal" href="../library/threading.html#threading.Timer" title="threading.Timer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timer</span></code></a> al módulo <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> que permite programar una actividad para que se realice en un momento futuro. (Contribución de Itamar Shtull-Trauring).</p></li>
</ul>
</section>
<section id="interpreter-changes-and-fixes">
<h2 class="translated">Cambios y correcciones en el intérprete<a class="headerlink" href="#interpreter-changes-and-fixes" title="Link to this heading">¶</a></h2>
<p class="translated">Algunos de los cambios sólo afectan a la gente que trata con el intérprete de Python a nivel de C porque están escribiendo módulos de extensión de Python, incrustando el intérprete, o simplemente hackeando el propio intérprete. Si sólo escribes código Python, ninguno de los cambios descritos aquí te afectará mucho.</p>
<ul>
<li><p class="translated">Las funciones de perfilado y rastreo pueden implementarse ahora en C, que puede operar a velocidades mucho mayores que las funciones basadas en Python y debería reducir la sobrecarga de perfilado y rastreo.  Esto será de interés para los autores de entornos de desarrollo para Python.  Se han añadido dos nuevas funciones en C a la API de Python, <a class="reference internal" href="../c-api/init.html#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a> y <a class="reference internal" href="../c-api/init.html#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a>. Las funciones <a class="reference internal" href="../library/sys.html#sys.setprofile" title="sys.setprofile"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setprofile()</span></code></a> y <a class="reference internal" href="../library/sys.html#sys.settrace" title="sys.settrace"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.settrace()</span></code></a> existentes siguen existiendo, y simplemente se han cambiado para utilizar la nueva interfaz de nivel C.  (Contribución de Fred L. Drake, Jr.)</p></li>
<li><p class="translated">Se agregó otra API de bajo nivel, principalmente de interés para los implementadores de depuradores y herramientas de desarrollo de Python. <a class="reference internal" href="../c-api/init.html#c.PyInterpreterState_Head" title="PyInterpreterState_Head"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Head()</span></code></a> y <a class="reference internal" href="../c-api/init.html#c.PyInterpreterState_Next" title="PyInterpreterState_Next"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Next()</span></code></a> permiten que un llamador recorra todos los objetos de intérprete existentes; <a class="reference internal" href="../c-api/init.html#c.PyInterpreterState_ThreadHead" title="PyInterpreterState_ThreadHead"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_ThreadHead()</span></code></a> y <a class="reference internal" href="../c-api/init.html#c.PyThreadState_Next" title="PyThreadState_Next"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Next()</span></code></a> permiten recorrer todos los estados de subprocesos para un intérprete determinado. (Contribución de David Beazley).</p></li>
<li><p class="translated">La interfaz a nivel de C para el recolector de basura ha sido cambiada para facilitar la escritura de tipos de extensión que soporten la recolección de basura y para depurar los malos usos de las funciones. Varias funciones tienen una semántica ligeramente diferente, por lo que hubo que cambiar el nombre de un montón de funciones.  Las extensiones que utilizan la antigua API seguirán compilando pero <em>no</em> participarán en la recolección de basura, por lo que actualizarlas para la 2.2 debería considerarse de alta prioridad.</p>
<p class="translated">Para actualizar un módulo de extensión a la nueva API, realice los siguientes pasos:</p>
</li>
<li><p class="translated">Cambia el nombre de <code class="xref c c-func docutils literal notranslate"><span class="pre">Py_TPFLAGS_GC()</span></code> a <code class="xref c c-func docutils literal notranslate"><span class="pre">PyTPFLAGS_HAVE_GC()</span></code>.</p></li>
<li><dl class="simple">
<dt class="translated">Utilice <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_New()</span></code></a> o <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_NewVar()</span></code></a> para asignar</dt><dd><p class="translated">objetos, y <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_Del" title="PyObject_GC_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Del()</span></code></a> para desocuparlos.</p>
</dd>
</dl>
</li>
<li><p class="translated">Cambie el nombre de <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Init()</span></code> a <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_Track" title="PyObject_GC_Track"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Track()</span></code></a> y de <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_Fini()</span></code> a <a class="reference internal" href="../c-api/gcsupport.html#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GC_UnTrack()</span></code></a>.</p></li>
<li><p class="translated">Eliminar <code class="xref c c-macro docutils literal notranslate"><span class="pre">PyGC_HEAD_SIZE</span></code> de los cálculos de tamaño de objeto.</p></li>
<li><p class="translated">Eliminar llamadas a <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_AS_GC()</span></code> y <code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_FROM_GC()</span></code>.</p></li>
<li><p class="translated">Se ha añadido una nueva secuencia de formato <code class="docutils literal notranslate"><span class="pre">et</span></code> a <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>; <code class="docutils literal notranslate"><span class="pre">et</span></code> toma tanto un parámetro como un nombre de codificación, y convierte el parámetro a la codificación dada si el parámetro resulta ser una cadena Unicode, o lo deja solo si es una cadena de 8 bits, asumiendo que ya está en la codificación deseada.  Esto difiere del carácter de formato <code class="docutils literal notranslate"><span class="pre">es</span></code>, que asume que las cadenas de 8 bits están en la codificación ASCII por defecto de Python y las convierte a la nueva codificación especificada. (Contribuido por M.-A. Lemburg, y utilizado para el soporte de MBCS en Windows descrito en la siguiente sección)</p></li>
<li><p class="translated">Se ha agregado una función de análisis de argumentos diferente, <a class="reference internal" href="../c-api/arg.html#c.PyArg_UnpackTuple" title="PyArg_UnpackTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_UnpackTuple()</span></code></a>, que es más simple y presumiblemente más rápida. En lugar de especificar una cadena de formato, la persona que llama simplemente proporciona el número mínimo y máximo de argumentos esperados y un conjunto de punteros a las variables <span class="c-expr sig sig-inline c"><a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> que se completarán con los valores de los argumentos.</p></li>
<li><p class="translated">Hay dos nuevos indicadores <a class="reference internal" href="../c-api/structures.html#c.METH_NOARGS" title="METH_NOARGS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_NOARGS</span></code></a> y <a class="reference internal" href="../c-api/structures.html#c.METH_O" title="METH_O"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_O</span></code></a> disponibles en las tablas de definición de métodos para simplificar la implementación de métodos sin argumentos o con un único argumento sin tipo. Llamar a estos métodos es más eficiente que llamar a un método correspondiente que utilice <a class="reference internal" href="../c-api/structures.html#c.METH_VARARGS" title="METH_VARARGS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_VARARGS</span></code></a>. Además, el antiguo estilo <code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_OLDARGS</span></code> de escribir métodos en C ahora está oficialmente obsoleto.</p></li>
<li><p class="translated">Se agregaron dos nuevas funciones de contenedor, <a class="reference internal" href="../c-api/conversion.html#c.PyOS_snprintf" title="PyOS_snprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_snprintf()</span></code></a> y <a class="reference internal" href="../c-api/conversion.html#c.PyOS_vsnprintf" title="PyOS_vsnprintf"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_vsnprintf()</span></code></a>, para proporcionar implementaciones multiplataforma para las relativamente nuevas API de bibliotecas C <code class="xref c c-func docutils literal notranslate"><span class="pre">snprintf()</span></code> y <code class="xref c c-func docutils literal notranslate"><span class="pre">vsnprintf()</span></code>. A diferencia de las funciones estándar <code class="xref c c-func docutils literal notranslate"><span class="pre">sprintf()</span></code> y <code class="xref c c-func docutils literal notranslate"><span class="pre">vsprintf()</span></code>, las versiones de Python verifican los límites del búfer utilizado para protegerse contra desbordamientos del búfer. (Contribuido por M.-A. Lemburg).</p></li>
<li><p class="translated">La función <a class="reference internal" href="../c-api/tuple.html#c._PyTuple_Resize" title="_PyTuple_Resize"><code class="xref c c-func docutils literal notranslate"><span class="pre">_PyTuple_Resize()</span></code></a> ha perdido un parámetro que no se utilizaba, por lo que ahora toma 2 parámetros en lugar de 3. El tercer argumento nunca se utilizaba, y puede descartarse simplemente al portar el código de versiones anteriores a Python 2.2.</p></li>
</ul>
</section>
<section id="other-changes-and-fixes">
<h2 class="translated">Otros cambios y correcciones<a class="headerlink" href="#other-changes-and-fixes" title="Link to this heading">¶</a></h2>
<p class="translated">Como es habitual, hubo un montón de otras mejoras y correcciones de errores repartidas por todo el árbol de fuentes.  Una búsqueda en los registros de cambios de CVS revela que se aplicaron 527 parches y se corrigieron 683 errores entre Python 2.1 y 2.2; en 2.2.1 se aplicaron 139 parches y se corrigieron 143 errores; en 2.2.2 se aplicaron 106 parches y se corrigieron 82 errores.  Es probable que estas cifras estén subestimadas.</p>
<p class="translated">Algunos de los cambios más notables son:</p>
<ul>
<li><p class="translated">El código del puerto MacOS para Python, mantenido por Jack Jansen, se mantiene ahora en el árbol CVS principal de Python, y se han realizado muchos cambios para soportar MacOS X.</p>
<p class="translated">El cambio más significativo es la capacidad de construir Python como un marco de trabajo, que se activa proporcionando la opción <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-framework</span></code> al script de configuración cuando se compila Python.  Según Jack Jansen, «Esto instala una instalación autónoma de Python más el «pegamento» del framework de OS X en <code class="file docutils literal notranslate"><span class="pre">/Library/Frameworks/Python.framework</span></code> (o en otra ubicación de su elección). Por ahora hay poco beneficio inmediato añadido a esto (en realidad, existe la desventaja de que tienes que cambiar tu PATH para poder encontrar Python), pero es la base para crear una aplicación Python completa, portar el IDE de MacPython, posiblemente usar Python como un lenguaje de scripting estándar de OSA y mucho más.»</p>
<p class="translated">La mayoría de los módulos de la caja de herramientas de MacPython, que interactúan con las APIs de MacOS como ventanas, QuickTime, scripts, etc. han sido portados a OS X, pero se han dejado comentados en <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code>.  Las personas que quieran experimentar con estos módulos pueden descomentarlos manualmente.</p>
</li>
<li><p class="translated">Los argumentos de palabras clave pasados a funciones incorporadas que no los aceptan ahora provocan una excepción <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>, con el mensaje «<em>function</em> no acepta argumentos de palabras clave».</p></li>
<li><p class="translated">Las referencias débiles, añadidas en Python 2.1 como un módulo de extensión, son ahora parte del núcleo porque se utilizan en la implementación de clases de nuevo estilo.  Por lo tanto, la excepción <a class="reference internal" href="../library/exceptions.html#ReferenceError" title="ReferenceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ReferenceError</span></code></a> se ha movido del módulo <a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> para convertirse en una excepción incorporada.</p></li>
<li><p class="translated">Un nuevo script, <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/cleanfuture.py</span></code> de Tim Peters, elimina automáticamente las sentencias <code class="docutils literal notranslate"><span class="pre">__future__</span></code> obsoletas del código fuente de Python.</p></li>
<li><p class="translated">Se ha añadido un argumento adicional <em>flags</em> a la función incorporada <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a>, por lo que el comportamiento de las sentencias <code class="docutils literal notranslate"><span class="pre">__future__</span></code> puede ahora observarse correctamente en shells simulados, como los presentados por IDLE y otros entornos de desarrollo.  Esto se describe en <span class="target" id="index-68"></span><a class="pep reference external" href="https://peps.python.org/pep-0264/"><strong>PEP 264</strong></a>. (Contribución de Michael Hudson)</p></li>
<li><p class="translated">La nueva licencia introducida con Python 1.6 no era compatible con la GPL.  Esto se ha solucionado con algunos cambios textuales menores en la licencia 2.2, de modo que ahora es legal volver a incrustar Python dentro de un programa con licencia GPL.  Tenga en cuenta que Python en sí mismo no es GPL, sino que está bajo una licencia que es esencialmente equivalente a la licencia BSD, igual que siempre.  Los cambios en la licencia también se aplicaron a las versiones 2.0.1 y 2.1.1 de Python.</p></li>
<li><p class="translated">Cuando se presenta un nombre de archivo Unicode en Windows, Python ahora lo convertirá en una cadena codificada en MBCS, como la que utilizan las APIs de archivos de Microsoft.  Como las APIs de archivos utilizan explícitamente MBCS, la elección de Python de ASCII como codificación por defecto resulta ser una molestia.  En Unix, se utiliza el juego de caracteres de la localización si <code class="docutils literal notranslate"><span class="pre">locale.nl_langinfo(CODESET)</span></code> está disponible.  (El soporte de Windows fue contribuido por Mark Hammond con la ayuda de Marc-André Lemburg. El soporte para Unix fue añadido por Martin von Löwis)</p></li>
<li><p class="translated">La compatibilidad con archivos de gran tamaño ya está activada en Windows.  (Contribución de Tim Peters.)</p></li>
<li><p class="translated">El script <code class="file docutils literal notranslate"><span class="pre">Tools/scripts/ftpmirror.py</span></code> ahora analiza un archivo <code class="file docutils literal notranslate"><span class="pre">.netrc</span></code>, si tiene uno. (Contribución de Mike Romberg)</p></li>
<li><p class="translated">Algunas características del objeto devuelto por la función <code class="xref py py-func docutils literal notranslate"><span class="pre">xrange()</span></code> ahora están obsoletas y activan advertencias cuando se accede a ellas; desaparecerán en Python 2.3. Los objetos <code class="xref py py-class docutils literal notranslate"><span class="pre">xrange</span></code> intentaron simular que eran tipos de secuencia completa al admitir la segmentación, la multiplicación de secuencias y el operador <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a>, pero estas características se usaban rara vez y, por lo tanto, presentaban errores. El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">tolist()</span></code> y los atributos <code class="xref py py-attr docutils literal notranslate"><span class="pre">start</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">stop</span></code> y <code class="xref py py-attr docutils literal notranslate"><span class="pre">step</span></code> también están en desuso. En el nivel C, el cuarto argumento de la función <code class="xref c c-func docutils literal notranslate"><span class="pre">PyRange_New()</span></code>, <code class="docutils literal notranslate"><span class="pre">repeat</span></code>, también ha quedado en desuso.</p></li>
<li><p class="translated">Hubo un montón de parches para la implementación del diccionario, sobre todo para arreglar posibles vertidos del núcleo si un diccionario contiene objetos que cambian furtivamente su valor hash, o mutan el diccionario que contienen. Durante un tiempo python-dev cayó en un suave ritmo de Michael Hudson encontrando un caso que volcaba el núcleo, Tim Peters corrigiendo el error, Michael encontrando otro caso, y así sucesivamente.</p></li>
<li><p class="translated">En Windows, Python puede ahora compilarse con Borland C gracias a una serie de parches aportados por Stephen Hansen, aunque el resultado aún no es totalmente funcional.  (Pero esto <em>es</em> un progreso…)</p></li>
<li><p class="translated">Otra mejora de Windows: Wise Solutions ofreció generosamente a PythonLabs el uso de su sistema InstallerMaster 8.1.  Los anteriores instaladores de PythonLabs para Windows utilizaban Wise 5.0a, que estaba empezando a mostrar su edad.  (Empaquetado por Tim Peters)</p></li>
<li><p class="translated">Los archivos que terminan en <code class="docutils literal notranslate"><span class="pre">.pyw</span></code> pueden importarse ahora en Windows. <code class="docutils literal notranslate"><span class="pre">.pyw</span></code> es algo exclusivo de Windows, que se utiliza para indicar que un script debe ejecutarse utilizando PYTHONW.EXE en lugar de PYTHON.EXE para evitar que aparezca una consola DOS para mostrar la salida.  Este parche hace posible la importación de tales scripts, en caso de que también se puedan utilizar como módulos.  (Implementado por David Bolen)</p></li>
<li><p class="translated">En las plataformas en las que Python utiliza la función C <code class="xref c c-func docutils literal notranslate"><span class="pre">dlopen()</span></code> para cargar módulos de extensión, ahora es posible establecer las banderas utilizadas por <code class="xref c c-func docutils literal notranslate"><span class="pre">dlopen()</span></code> utilizando las funciones <a class="reference internal" href="../library/sys.html#sys.getdlopenflags" title="sys.getdlopenflags"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getdlopenflags()</span></code></a> y <a class="reference internal" href="../library/sys.html#sys.setdlopenflags" title="sys.setdlopenflags"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setdlopenflags()</span></code></a>. (Contribución de Bram Stolk.)</p></li>
<li><p class="translated">La función incorporada <a class="reference internal" href="../library/functions.html#pow" title="pow"><code class="xref py py-func docutils literal notranslate"><span class="pre">pow()</span></code></a> ya no admite 3 argumentos cuando se suministran números de punto flotante. <code class="docutils literal notranslate"><span class="pre">pow(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> devuelve <code class="docutils literal notranslate"><span class="pre">(x**y)</span> <span class="pre">%</span> <span class="pre">z</span></code>, pero esto nunca es útil para números de punto flotante y el resultado final varía de manera impredecible según la plataforma. Una llamada como <code class="docutils literal notranslate"><span class="pre">pow(2.0,</span> <span class="pre">8.0,</span> <span class="pre">7.0)</span></code> ahora generará una excepción <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>.</p></li>
</ul>
</section>
<section id="acknowledgements">
<h2 class="translated">Agradecimientos<a class="headerlink" href="#acknowledgements" title="Link to this heading">¶</a></h2>
<p class="translated">El autor desea agradecer a las siguientes personas sus sugerencias, correcciones y ayuda en varios borradores de este artículo: Fred Bremmer, Keith Briggs, Andrew Dalke, Fred L. Drake, Jr, Carel Fellinger, David Goodger, Mark Hammond, Stephen Hansen, Michael Hudson, Jack Jansen, Marc-André Lemburg, Martin von Löwis, Fredrik Lundh, Michael McLay, Nick Mathewson, Paul Moore, Gustavo Niemeyer, Don O’Donnell, Joonas Paalasma, Tim Peters, Jens Quade, Tom Reinhardt, Neil Schemenauer, Guido van Rossum, Greg Ward, Edward Welbourne.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Qué hay de nuevo en Python 2.2</a><ul>
<li><a class="reference internal" href="#introduction">Introducción</a></li>
<li><a class="reference internal" href="#peps-252-and-253-type-and-class-changes">PEPs 252 y 253: Cambios de tipo y clase</a><ul>
<li><a class="reference internal" href="#old-and-new-classes">Clases antiguas y nuevas</a></li>
<li><a class="reference internal" href="#descriptors">Descriptores</a></li>
<li><a class="reference internal" href="#multiple-inheritance-the-diamond-rule">Herencia múltiple: la regla del diamante</a></li>
<li><a class="reference internal" href="#attribute-access">Acceso a atributos</a></li>
<li><a class="reference internal" href="#related-links">Enlaces relacionados</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-234-iterators">PEP 234: Iteradores</a></li>
<li><a class="reference internal" href="#pep-255-simple-generators">PEP 255: Generadores simples</a></li>
<li><a class="reference internal" href="#pep-237-unifying-long-integers-and-integers">PEP 237: Unificación de enteros largos y enteros</a></li>
<li><a class="reference internal" href="#pep-238-changing-the-division-operator">PEP 238: Cambio del operador de división</a></li>
<li><a class="reference internal" href="#unicode-changes">Cambios en Unicode</a></li>
<li><a class="reference internal" href="#pep-227-nested-scopes">PEP 227: Ámbitos anidados</a></li>
<li><a class="reference internal" href="#new-and-improved-modules">Módulos nuevos y mejorados</a></li>
<li><a class="reference internal" href="#interpreter-changes-and-fixes">Cambios y correcciones en el intérprete</a></li>
<li><a class="reference internal" href="#other-changes-and-fixes">Otros cambios y correcciones</a></li>
<li><a class="reference internal" href="#acknowledgements">Agradecimientos</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="2.3.html"
                          title="capítulo anterior">Qué hay de nuevo en Python 2.3</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="2.1.html"
                          title="próximo capítulo">Qué hay de nuevo en Python 2.1</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.2.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Contraer barra lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="2.1.html" title="Qué hay de nuevo en Python 2.1"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="2.3.html" title="Qué hay de nuevo en Python 2.3"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Qué hay de nuevo en Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Qué hay de nuevo en Python 2.2</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Derechos de autor</a> 2001 Python Software Foundation.
    <br>
    Ésta página tiene la licencia Python Software Foundation Versión 2.
    <br>
    Ejemplos, guías, y otro código en la documentación están bajo la licencia adicional Zero Clause BSD.
    <br>
    
      Ver <a href="/license.html">Historia y Licencia</a> para más información.<br>
    
    
    <br>

    La Python Software Foundation es una corporación sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor dona.</a>
<br>
    <br>
      Última actualización en oct 06, 2025 (04:51 UTC).
    
      <a href="/bugs.html">Encontraste un bug</a>?
    
    <br>

    Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a>8.2.3.
    </div>

  </body>
</html>