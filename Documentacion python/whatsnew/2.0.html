<!DOCTYPE html>

<html lang="es" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Qué hay de nuevo en Python 2.0" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/2.0.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="Autor, A.M. Kuchling y Moshe Zadka,. Introducción: El 16 de octubre de 2000 se publicó una nueva versión de Python, la 2.0. Este artículo cubre las emocionantes nuevas características de la 2.0, de..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.15/es/_images/social_previews/summary_whatsnew_2.0_92575c63.png" />
<meta property="og:image:alt" content="Autor, A.M. Kuchling y Moshe Zadka,. Introducción: El 16 de octubre de 2000 se publicó una nueva versión de Python, la 2.0. Este artículo cubre las emocionantes nuevas características de la 2.0, de..." />
<meta name="description" content="Autor, A.M. Kuchling y Moshe Zadka,. Introducción: El 16 de octubre de 2000 se publicó una nueva versión de Python, la 2.0. Este artículo cubre las emocionantes nuevas características de la 2.0, de..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>Qué hay de nuevo en Python 2.0 &#8212; documentación de Python - 3.15.0a0</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=bf1f176d"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=f85f4cfb"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Buscar en documentación de Python - 3.15.0a0"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="Sobre este documento" href="../about.html" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="copyright" title="Derechos de autor" href="../copyright.html" />
    <link rel="next" title="Registro de cambios" href="changelog.html" />
    <link rel="prev" title="Qué hay de nuevo en Python 2.1" href="2.1.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.0.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menú">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q">
                <input type="submit" value="Ir">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Qué hay de nuevo en Python 2.0</a><ul>
<li><a class="reference internal" href="#introduction">Introducción</a></li>
<li><a class="reference internal" href="#what-about-python-1-6">¿Qué pasa con Python 1.6?</a></li>
<li><a class="reference internal" href="#new-development-process">Nuevo proceso de desarrollo</a></li>
<li><a class="reference internal" href="#unicode">Unicode</a></li>
<li><a class="reference internal" href="#list-comprehensions">Comprensión de listas</a></li>
<li><a class="reference internal" href="#augmented-assignment">Asignación aumentada</a></li>
<li><a class="reference internal" href="#string-methods">Métodos de cadena de caracteres</a></li>
<li><a class="reference internal" href="#garbage-collection-of-cycles">Recogida de basura de los ciclos</a></li>
<li><a class="reference internal" href="#other-core-changes">Otros cambios en el núcleo</a><ul>
<li><a class="reference internal" href="#minor-language-changes">Cambios menores del lenguaje</a></li>
<li><a class="reference internal" href="#changes-to-built-in-functions">Cambios en las funciones incorporadas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-2-0">Adaptación a la versión 2.0</a></li>
<li><a class="reference internal" href="#extending-embedding-changes">Extensión/Incorporación de cambios</a></li>
<li><a class="reference internal" href="#distutils-making-modules-easy-to-install">Distutils: Facilitando la instalación de módulos</a></li>
<li><a class="reference internal" href="#xml-modules">Módulos XML</a><ul>
<li><a class="reference internal" href="#sax2-support">Soporte de SAX2</a></li>
<li><a class="reference internal" href="#dom-support">Soporte DOM</a></li>
<li><a class="reference internal" href="#relationship-to-pyxml">Relación con PyXML</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-changes">Cambios en los módulos</a></li>
<li><a class="reference internal" href="#new-modules">Nuevos módulos</a></li>
<li><a class="reference internal" href="#idle-improvements">Mejoras en IDLE</a></li>
<li><a class="reference internal" href="#deleted-and-deprecated-modules">Módulos eliminados y obsoletos</a></li>
<li><a class="reference internal" href="#acknowledgements">Agradecimientos</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="2.1.html"
                          title="capítulo anterior">Qué hay de nuevo en Python 2.1</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="changelog.html"
                          title="próximo capítulo">Registro de cambios</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.0.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="changelog.html" title="Registro de cambios"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="2.1.html" title="Qué hay de nuevo en Python 2.1"
             accesskey="P">anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Qué hay de nuevo en Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Qué hay de nuevo en Python 2.0</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-0">
<h1 class="translated">Qué hay de nuevo en Python 2.0<a class="headerlink" href="#what-s-new-in-python-2-0" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd translated">Autor<span class="colon">:</span></dt>
<dd class="field-odd translated"><p class="translated">A.M. Kuchling y Moshe Zadka</p>
</dd>
</dl>
<section id="introduction">
<h2 class="translated">Introducción<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p class="translated">El 16 de octubre de 2000 se publicó una nueva versión de Python, la 2.0. Este artículo cubre las emocionantes nuevas características de la 2.0, destaca algunos otros cambios útiles y señala algunos cambios incompatibles que pueden requerir reescribir el código.</p>
<p class="translated">El desarrollo de Python nunca se detiene por completo entre versiones, y siempre se envía un flujo constante de correcciones de errores y mejoras. Una gran cantidad de correcciones menores, algunas optimizaciones, cadenas de documentación adicionales y mejores mensajes de error entraron en 2.0; enumerarlos a todos sería imposible, pero ciertamente son significativos. Consulte los registros de CVS disponibles públicamente si desea ver la lista completa. Este progreso se debe a que a los cinco desarrolladores que trabajan para PythonLabs ahora se les paga por dedicar sus días a corregir errores, y también a la mejora de la comunicación resultante de la migración a SourceForge.</p>
</section>
<section id="what-about-python-1-6">
<h2 class="translated">¿Qué pasa con Python 1.6?<a class="headerlink" href="#what-about-python-1-6" title="Link to this heading">¶</a></h2>
<p class="translated">Python 1.6 puede considerarse como la versión de Python de las Obligaciones Contractuales. Después de que el equipo principal de desarrollo dejara el CNRI en mayo de 2000, el CNRI pidió que se creara una versión 1.6 que contuviera todo el trabajo sobre Python que se había realizado en el CNRI. Por lo tanto, Python 1.6 representa el estado del árbol CVS en mayo de 2000, siendo la novedad más importante el soporte de Unicode. El desarrollo continuó después de mayo, por supuesto, así que el árbol 1.6 recibió algunas correcciones para asegurar que es compatible con Python 2.0. 1.Por lo tanto, la 6 es parte de la evolución de Python, y no una rama lateral.</p>
<p class="translated">Entonces, ¿deberías interesarte mucho por Python 1.6?  Probablemente no. Las versiones 1.6final y 2.0beta1 se publicaron el mismo día (5 de septiembre de 2000), y el plan es finalizar Python 2.0 en un mes más o menos. Si tienes aplicaciones que mantener, no parece que tenga mucho sentido romper cosas al pasar a la 1.6, arreglarlas, y luego tener otra ronda de roturas dentro de un mes al pasar a la 2.0; es mejor pasar directamente a la 2.0. La mayoría de las características realmente interesantes descritas en este documento sólo están en la 2.0, porque se hizo mucho trabajo entre mayo y septiembre.</p>
</section>
<section id="new-development-process">
<h2 class="translated">Nuevo proceso de desarrollo<a class="headerlink" href="#new-development-process" title="Link to this heading">¶</a></h2>
<p class="translated">El cambio más importante en Python 2.0 puede que no sea en el código en absoluto, sino en la forma de desarrollar Python: en mayo de 2000 los desarrolladores de Python comenzaron a utilizar las herramientas puestas a disposición por SourceForge para almacenar el código fuente, rastrear los informes de errores y gestionar la cola de envíos de parches. Para informar de errores o enviar parches para Python 2.0, utilice las herramientas de seguimiento de errores y gestión de parches disponibles en la página del proyecto Python, situada en <a class="reference external" href="https://sourceforge.net/projects/python/">https://sourceforge.net/projects/python/</a>.</p>
<p class="translated">El más importante de los servicios alojados ahora en SourceForge es el árbol CVS de Python, el repositorio de versiones controladas que contiene el código fuente de Python. Anteriormente, había unas 7 personas que tenían acceso de escritura al árbol CVS, y todos los parches tenían que ser inspeccionados y comprobados por una de las personas de esta corta lista. Obviamente, esto no era muy escalable. Al trasladar el árbol CVS a SourceForge, fue posible conceder acceso de escritura a más personas; en septiembre de 2000 había 27 personas que podían revisar los cambios, un aumento de cuatro veces. Esto hace posible cambios a gran escala que no se intentarían si tuvieran que pasar por el pequeño grupo de desarrolladores del núcleo. Por ejemplo, un día a Peter Schneider-Kamp se le ocurrió dejar de lado la compatibilidad con K&amp;R C y convertir el código fuente de Python a ANSI C. Después de obtener la aprobación en la lista de correo de python-dev, se lanzó a una ráfaga de revisiones que duró aproximadamente una semana, otros desarrolladores se unieron para ayudar, y el trabajo estaba hecho. Si sólo hubiera habido 5 personas con acceso de escritura, probablemente esa tarea habría sido considerada como «agradable, pero no vale la pena el tiempo y el esfuerzo necesarios» y nunca se habría realizado.</p>
<p class="translated">El cambio al uso de los servicios de SourceForge ha dado lugar a un notable aumento de la velocidad de desarrollo. Ahora los parches se envían, se comentan, son revisados por otras personas además del remitente original, y van de un lado a otro hasta que se considera que el parche merece ser revisado. Los errores se rastrean en una ubicación central y se pueden asignar a una persona específica para que los corrija, y podemos contar el número de errores abiertos para medir el progreso. Esto no ha tenido un coste: los desarrolladores tienen ahora más correo electrónico con el que lidiar, más listas de correo que seguir, y se han tenido que escribir herramientas especiales para el nuevo entorno. Por ejemplo, SourceForge envía por defecto mensajes de correo electrónico de notificación de parches y errores que son completamente inútiles, por lo que Ka-Ping Yee escribió un raspador de pantalla HTML que envía mensajes más útiles.</p>
<p class="translated">La facilidad para añadir código provocó algunos problemas iniciales de crecimiento, como el hecho de que el código se registrara antes de estar listo o sin obtener un acuerdo claro del grupo de desarrolladores. El proceso de aprobación que ha surgido es algo similar al utilizado por el grupo Apache. Los desarrolladores pueden votar +1, +0, -0 o -1 sobre un parche; +1 y -1 denotan aceptación o rechazo, mientras que +0 y -0 significan que el desarrollador es mayormente indiferente al cambio, aunque con un ligero sesgo positivo o negativo. El cambio más significativo con respecto al modelo de Apache es que la votación es esencialmente consultiva, lo que permite a Guido van Rossum, que tiene el estatus de Dictador Benevolente Vitalicio, saber cuál es la opinión general. Puede seguir ignorando el resultado de una votación y aprobar o rechazar un cambio aunque la comunidad no esté de acuerdo con él.</p>
<p class="translated">Producir un parche real es el último paso en la adición de una nueva característica, y suele ser fácil en comparación con la tarea anterior de llegar a un buen diseño. Las discusiones sobre nuevas funcionalidades a menudo pueden explotar en largos hilos de la lista de correo, haciendo que la discusión sea difícil de seguir, y nadie puede leer todos los mensajes en python-dev. Por lo tanto, se ha establecido un proceso relativamente formal para escribir Propuestas de Mejora de Python (PEPs), siguiendo el modelo del proceso RFC de Internet. Las PEP son borradores de documentos que describen una nueva característica propuesta, y se revisan continuamente hasta que la comunidad llega a un consenso, aceptando o rechazando la propuesta. Cita de la introducción de <span class="target" id="index-8"></span><a class="pep reference external" href="https://peps.python.org/pep-0001/"><strong>PEP 1</strong></a>, «PEP Purpose and Guidelines»:</p>
<blockquote class="epigraph">
<div><p class="translated">PEP son las siglas de Python Enhancement Proposal. Un PEP es un documento de diseño que proporciona información a la comunidad de Python, o que describe una nueva característica para Python. El PEP debe proporcionar una especificación técnica concisa de la característica y una justificación de la misma.</p>
<p class="translated">Pretendemos que los PEPs sean los mecanismos principales para proponer nuevas características, para recoger las opiniones de la comunidad sobre un tema y para documentar las decisiones de diseño que se han tomado en Python. El autor del PEP es responsable de crear consenso dentro de la comunidad y de documentar las opiniones discrepantes.</p>
</div></blockquote>
<p class="translated">Lea el resto de <span class="target" id="index-9"></span><a class="pep reference external" href="https://peps.python.org/pep-0001/"><strong>PEP 1</strong></a> para conocer los detalles del proceso editorial, el estilo y el formato de PEP. Los PEP se guardan en el árbol CVS de Python en SourceForge, aunque no son parte de la distribución de Python 2.0, y también están disponibles en formato HTML en <a class="reference external" href="https://peps.python.org/">https://peps.python.org/</a>. A partir de septiembre de 2000, existen 25 PEP, que van desde <span class="target" id="index-10"></span><a class="pep reference external" href="https://peps.python.org/pep-0201/"><strong>PEP 201</strong></a>, «Iteración en sincronía», hasta PEP 225, «Operadores por elementos y por objetos».</p>
</section>
<section id="unicode">
<h2 class="translated">Unicode<a class="headerlink" href="#unicode" title="Link to this heading">¶</a></h2>
<p class="translated">La mayor novedad de Python 2.0 es un nuevo tipo de datos fundamental: Las cadenas Unicode. Unicode utiliza números de 16 bits para representar los caracteres en lugar de los 8 bits utilizados por ASCII, lo que significa que se pueden admitir 65.536 caracteres distintos.</p>
<p class="translated">La interfaz final para el soporte de Unicode se alcanzó a través de innumerables discusiones, a menudo tormentosas, en la lista de correo de python-dev, y fue implementada en su mayor parte por Marc-André Lemburg, basándose en una implementación del tipo de cadena Unicode de Fredrik Lundh. Una explicación detallada de la interfaz fue escrita como <span class="target" id="index-11"></span><a class="pep reference external" href="https://peps.python.org/pep-0100/"><strong>PEP 100</strong></a>, «Python Unicode Integration». Este artículo se limitará a cubrir los puntos más significativos de las interfaces Unicode.</p>
<p class="translated">En el código fuente de Python, las cadenas Unicode se escriben como <code class="docutils literal notranslate"><span class="pre">u&quot;string&quot;</span></code>. Se pueden escribir caracteres Unicode arbitrarios utilizando una nueva secuencia de escape, <code class="samp docutils literal notranslate"><span class="pre">\u</span><em><span class="pre">HHHH</span></em></code>, donde <em>HHHH</em> es un número hexadecimal de 4 dígitos de 0000 a FFFF. También se puede utilizar la secuencia de escape existente <code class="samp docutils literal notranslate"><span class="pre">\x</span><em><span class="pre">HH</span></em></code>, y se pueden utilizar escapes octales para caracteres hasta U+01FF, que se representa mediante <code class="docutils literal notranslate"><span class="pre">\777</span></code>.</p>
<p class="translated">Las cadenas Unicode, al igual que las cadenas normales, son un tipo de secuencia inmutable. Pueden ser indexadas y cortadas, pero no modificadas en su lugar. Las cadenas Unicode tienen un método <code class="docutils literal notranslate"><span class="pre">encode(</span> <span class="pre">[encoding]</span> <span class="pre">)</span></code> que retorna una cadena de 8 bits en la codificación deseada. Las codificaciones son nombradas por cadenas, como <code class="docutils literal notranslate"><span class="pre">'ascii'</span></code>, <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>, <code class="docutils literal notranslate"><span class="pre">'iso-8859-1'</span></code>, o lo que sea. Se define una API de códecs para implementar y registrar nuevas codificaciones que luego están disponibles en todo el programa Python. Si no se especifica una codificación, la codificación por defecto suele ser ASCII de 7 bits, aunque puede cambiarse para tu instalación de Python llamando a la función <code class="docutils literal notranslate"><span class="pre">sys.setdefaultencoding(encoding)</span></code> en una versión personalizada de <code class="file docutils literal notranslate"><span class="pre">site.py</span></code>.</p>
<p class="translated">La combinación de cadenas de 8 bits y Unicode siempre fuerza conversión a Unicode, utilizando la codificación ASCII por defecto; el resultado de <code class="docutils literal notranslate"><span class="pre">'a'</span> <span class="pre">+</span> <span class="pre">u'bc'</span></code> es <code class="docutils literal notranslate"><span class="pre">u'abc'</span></code>.</p>
<p class="translated">Se han añadido nuevas funciones incorporadas y se han modificado las existentes para que sean compatibles con Unicode:</p>
<ul class="simple">
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">unichr(ch)</span></code> retorna una cadena Unicode de 1 carácter, que contiene el carácter <em>ch</em>.</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">ord(u)</span></code>, donde <em>u</em> es una cadena regular o Unicode de 1 carácter, retorna el número del carácter como un entero.</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">unicode(string</span> <span class="pre">[,</span> <span class="pre">encoding]</span> <span class="pre">[,</span> <span class="pre">errors]</span> <span class="pre">)</span></code> crea una cadena Unicode a partir de una cadena de 8 bits. <code class="docutils literal notranslate"><span class="pre">encoding</span></code> es una cadena que nombra la codificación a utilizar. El parámetro <code class="docutils literal notranslate"><span class="pre">errors</span></code> especifica el tratamiento de los caracteres que no son válidos para la codificación actual; pasar <code class="docutils literal notranslate"><span class="pre">'strict</span></code> como valor hace que se lance una excepción en cualquier error de codificación, mientras que <code class="docutils literal notranslate"><span class="pre">'ignore</span></code> hace que los errores se ignoren silenciosamente y <code class="docutils literal notranslate"><span class="pre">'replace</span></code> utiliza U+FFFD, el carácter oficial de reemplazo, en caso de cualquier problema.</p></li>
<li><p class="translated">La sentencia <code class="docutils literal notranslate"><span class="pre">exec</span></code>, y varias funciones integradas como <code class="docutils literal notranslate"><span class="pre">eval()</span></code>, <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>, y <code class="docutils literal notranslate"><span class="pre">setattr()</span></code> también aceptarán cadenas Unicode así como cadenas regulares. (Es posible que en el proceso de corrección de esto se hayan pasado por alto algunas funciones incorporadas; si encuentra una función incorporada que acepte cadenas pero que no acepte cadenas Unicode en absoluto, por favor, infórmelo como un error)</p></li>
</ul>
<p class="translated">Un nuevo módulo, <a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a>, proporciona una interfaz para las propiedades de los caracteres Unicode. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">unicodedata.category(u'A')</span></code> retorna la cadena de 2 caracteres “Lu”, la “L” denota que es una letra, y la “u” significa que es mayúscula. <code class="docutils literal notranslate"><span class="pre">unicodedata.bidirectional(u'\u0660')</span></code> retorna “AN”, lo que significa que U+0660 es un número árabe.</p>
<p class="translated">El módulo <a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> contiene funciones para buscar codificaciones existentes y registrar otras nuevas. A menos que quiera implementar una nueva codificación, lo más habitual es que utilice la función <code class="docutils literal notranslate"><span class="pre">codecs.lookup(encoding)</span></code>, que retorna una tupla de 4 elementos: <code class="docutils literal notranslate"><span class="pre">(encode_func,</span> <span class="pre">decode_func,</span> <span class="pre">stream_reader,</span> <span class="pre">stream_writer)</span></code>.</p>
<ul class="simple">
<li><p class="translated"><em>encode_func</em> es una función que toma una cadena Unicode, y retorna una 2-tupla <code class="docutils literal notranslate"><span class="pre">(string,</span> <span class="pre">length)</span></code>. <em>string</em> es una cadena de 8 bits que contiene una porción (tal vez toda) de la cadena Unicode convertida a la codificación dada, y <em>longitud</em> indica la cantidad de cadena Unicode convertida.</p></li>
<li><p class="translated"><em>decode_func</em> es lo opuesto a <em>encode_func</em>, tomando una cadena de 8 bits y retornando una 2-tupla <code class="docutils literal notranslate"><span class="pre">(ustring,</span> <span class="pre">length)</span></code>, que consiste en la cadena Unicode resultante <em>ustring</em> y el entero <em>length</em> que dice cuánto de la cadena de 8 bits se consumió.</p></li>
<li><p class="translated"><em>stream_reader</em> es una clase que admite la decodificación de la entrada de un flujo. <em>stream_reader(file_obj)</em> devuelve un objeto que admite los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">readlines()</span></code>. Todos estos métodos traducirán a partir de la codificación dada y devolverán cadenas Unicode.</p></li>
<li><p class="translated">De manera similar, <em>stream_writer</em> es una clase que admite la codificación de la salida en una secuencia. <em>stream_writer(file_obj)</em> devuelve un objeto que admite los métodos <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">writelines()</span></code>. Estos métodos esperan cadenas Unicode y las traducen a la codificación dada en la salida.</p></li>
</ul>
<p class="translated">Por ejemplo, el siguiente código escribe una cadena Unicode en un archivo, codificándola como UTF-8:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">codecs</span>

<span class="n">unistr</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u0660\u2000</span><span class="s1">ab ...&#39;</span>

<span class="p">(</span><span class="n">UTF8_encode</span><span class="p">,</span> <span class="n">UTF8_decode</span><span class="p">,</span>
 <span class="n">UTF8_streamreader</span><span class="p">,</span> <span class="n">UTF8_streamwriter</span><span class="p">)</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">)</span>

<span class="n">output</span> <span class="o">=</span> <span class="n">UTF8_streamwriter</span><span class="p">(</span> <span class="nb">open</span><span class="p">(</span> <span class="s1">&#39;/tmp/output&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="p">)</span>
<span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span> <span class="n">unistr</span> <span class="p">)</span>
<span class="n">output</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p class="translated">El siguiente código leería la entrada UTF-8 del archivo:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">input</span> <span class="o">=</span> <span class="n">UTF8_streamreader</span><span class="p">(</span> <span class="nb">open</span><span class="p">(</span> <span class="s1">&#39;/tmp/output&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="p">)</span>
<span class="nb">print</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
<span class="nb">input</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p class="translated">Las expresiones regulares compatibles con Unicode están disponibles a través del módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a>, que tiene una nueva implementación subyacente llamada SRE escrita por Fredrik Lundh de Secret Labs AB.</p>
<p class="translated">Se ha añadido una opción de línea de comandos <code class="docutils literal notranslate"><span class="pre">-U</span></code> que hace que el compilador de Python interprete todos los literales de cadena como literales de cadena Unicode. Esta opción está pensada para ser utilizada en las pruebas y para asegurar el futuro de su código Python, ya que alguna versión futura de Python puede dejar de soportar cadenas de 8 bits y proporcionar sólo cadenas Unicode.</p>
</section>
<section id="list-comprehensions">
<h2 class="translated">Comprensión de listas<a class="headerlink" href="#list-comprehensions" title="Link to this heading">¶</a></h2>
<p class="translated">Las listas son un tipo de datos muy útil en Python, y muchos programas manipulan una lista en algún momento. Dos operaciones comunes en las listas son hacer un bucle sobre ellas, y escoger los elementos que cumplen un cierto criterio, o aplicar alguna función a cada elemento. Por ejemplo, dada una lista de cadenas, podrías querer sacar todas las cadenas que contengan una determinada subcadena, o quitar los espacios en blanco de cada línea.</p>
<p class="translated">Las funciones <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> y <a class="reference internal" href="../library/functions.html#filter" title="filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a> existentes pueden usarse para este propósito, pero requieren una función como uno de sus argumentos. Esto está bien si hay una función incorporada que se puede pasar directamente, pero si no la hay, hay que crear una pequeña función para hacer el trabajo requerido, y las reglas de ámbito de Python hacen que el resultado sea feo si la pequeña función necesita información adicional. Tomemos el primer ejemplo del párrafo anterior, encontrar todas las cadenas de la lista que contienen una subcadena dada. Podrías escribir lo siguiente para hacerlo:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Given the list L, make a list of all strings</span>
<span class="c1"># containing the substring S.</span>
<span class="n">sublist</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">substring</span><span class="o">=</span><span class="n">S</span><span class="p">:</span>
                     <span class="n">string</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">substring</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Debido a las reglas de ámbito de Python, se utiliza un argumento por defecto para que la función anónima creada por la expresión <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> sepa qué subcadena se está buscando. Las comprensiones de lista hacen esto más limpio:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sublista</span> <span class="o">=</span> <span class="p">[</span> <span class="n">s</span> <span class="n">para</span> <span class="n">s</span> <span class="n">en</span> <span class="n">L</span> <span class="n">si</span> <span class="n">cadena</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">]</span>
</pre></div>
</div>
<p class="translated">Las comprensiones de listas tienen la forma:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="n">expression</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">sequence1</span>
             <span class="k">for</span> <span class="n">expr2</span> <span class="ow">in</span> <span class="n">sequence2</span> <span class="o">...</span>
             <span class="k">for</span> <span class="n">exprN</span> <span class="ow">in</span> <span class="n">sequenceN</span>
             <span class="k">if</span> <span class="n">condition</span> <span class="p">]</span>
</pre></div>
</div>
<p class="translated">Las cláusulas <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code>…<code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> contienen las secuencias a iterar. Las secuencias no tienen por qué tener la misma longitud, ya que no se itera sobre ellas en paralelo, sino de izquierda a derecha; esto se explica más claramente en los párrafos siguientes. Los elementos de la lista generada serán los valores sucesivos de la <em>expresión</em>. La cláusula final <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> es opcional; si está presente, la <em>expresión</em> sólo se evalúa y se añade al resultado si la <em>condición</em> es verdadera.</p>
<p class="translated">Para dejar muy clara la semántica, una comprensión de lista equivale al siguiente código de Python:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">expr1</span> <span class="ow">in</span> <span class="n">sequence1</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">expr2</span> <span class="ow">in</span> <span class="n">sequence2</span><span class="p">:</span>
    <span class="o">...</span>
        <span class="k">for</span> <span class="n">exprN</span> <span class="ow">in</span> <span class="n">sequenceN</span><span class="p">:</span>
             <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">):</span>
                  <span class="c1"># Append the value of</span>
                  <span class="c1"># the expression to the</span>
                  <span class="c1"># resulting list.</span>
</pre></div>
</div>
<p class="translated">Esto significa que cuando hay múltiples cláusulas <code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code>…<code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code>, la lista resultante será igual al producto de las longitudes de todas las secuencias. Si tiene dos listas de longitud 3, la lista de salida tendrá 9 elementos:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">seq1</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span>
<span class="n">seq2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>
<span class="p">[(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
</pre></div>
</div>
<p class="translated">Para evitar introducir una ambigüedad en la gramática de Python, si <em>expresión</em> está creando una tupla, debe estar rodeada de paréntesis. La primera comprensión de la lista a continuación es un error de sintaxis, mientras que la segunda es correcta:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Syntax error</span>
<span class="p">[</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>
<span class="c1"># Correct</span>
<span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">seq2</span><span class="p">]</span>
</pre></div>
</div>
<p class="translated">La idea de las comprensiones de listas procede originalmente del lenguaje de programación funcional Haskell (<a class="reference external" href="https://www.haskell.org">https://www.haskell.org</a>). Greg Ewing fue el que más abogó por añadirlas a Python y escribió el parche inicial de comprensión de listas, que luego se discutió durante un tiempo aparentemente interminable en la lista de correo de python-dev y se mantuvo actualizada por Skip Montanaro.</p>
</section>
<section id="augmented-assignment">
<h2 class="translated">Asignación aumentada<a class="headerlink" href="#augmented-assignment" title="Link to this heading">¶</a></h2>
<p class="translated">Los operadores de asignación aumentados, otra característica largamente solicitada, han sido añadidos a Python 2.0. Los operadores de asignación aumentados incluyen <code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, etc. Por ejemplo, la sentencia <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">2</span></code> incrementa el valor de la variable <code class="docutils literal notranslate"><span class="pre">a</span></code> en 2, lo que equivale a la sentencia algo más larga <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">2</span></code>.</p>
<p class="translated">La lista completa de operadores de asignación admitidos es <code class="docutils literal notranslate"><span class="pre">+=</span></code>, <code class="docutils literal notranslate"><span class="pre">-=</span></code>, <code class="docutils literal notranslate"><span class="pre">*=</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">%=</span></code>, <code class="docutils literal notranslate"><span class="pre">**=</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>, <code class="docutils literal notranslate"><span class="pre">|=</span></code>, <code class="docutils literal notranslate"><span class="pre">^=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> y <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code>. Las clases de Python pueden anular los operadores de asignación aumentados definiendo métodos denominados <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">__isub__()</span></code>, etc. Por ejemplo, la siguiente clase <code class="xref py py-class docutils literal notranslate"><span class="pre">Number</span></code> almacena un número y admite el uso de += para crear una nueva instancia con un valor incrementado.</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Number</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">increment</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Number</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">increment</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="n">Number</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">n</span> <span class="o">+=</span> <span class="mi">3</span>
<span class="nb">print</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span>
</pre></div>
</div>
<p class="translated">El método especial <code class="xref py py-meth docutils literal notranslate"><span class="pre">__iadd__()</span></code> se llama con el valor del incremento y debe devolver una nueva instancia con un valor modificado apropiadamente; este valor de retorno está vinculado como el nuevo valor de la variable en el lado izquierdo.</p>
<p class="translated">Los operadores de asignación aumentada se introdujeron por primera vez en el lenguaje de programación C, y la mayoría de los lenguajes derivados de C, como <strong class="program">awk</strong>, C++, Java, Perl y PHP también los soportan. El parche de asignación aumentada fue implementado por Thomas Wouters.</p>
</section>
<section id="string-methods">
<h2 class="translated">Métodos de cadena de caracteres<a class="headerlink" href="#string-methods" title="Link to this heading">¶</a></h2>
<p class="translated">Hasta ahora, la funcionalidad de manipulación de cadenas estaba en el módulo <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a>, que normalmente era una interfaz para el módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">strop</span></code> escrito en C. La incorporación de Unicode planteó una dificultad para el módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">strop</span></code>, porque todas las funciones debían reescribirse para aceptar cadenas de 8 bits o Unicode. Para funciones como <code class="xref py py-func docutils literal notranslate"><span class="pre">string.replace()</span></code>, que acepta 3 cadenas como argumentos, eso significa ocho permutaciones posibles y, en consecuencia, un código complicado.</p>
<p class="translated">En cambio, Python 2.0 traslada el problema al tipo de cadena de caracteres, haciendo que la funcionalidad de manipulación de cadenas esté disponible a través de métodos tanto en cadenas de 8 bits como en cadenas Unicode.</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;andrew&#39;</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
<span class="go">&#39;Andrew&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;hostname&#39;</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;os&#39;</span><span class="p">,</span> <span class="s1">&#39;linux&#39;</span><span class="p">)</span>
<span class="go">&#39;hlinuxtname&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;moshe&#39;</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;sh&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p class="translated">Una cosa que no ha cambiado, a pesar de una notable broma de April Fools, es que las cadenas de Python son inmutables. Así, los métodos de cadenas retornan cadenas nuevas, y no modifican la cadena sobre la que operan.</p>
<p class="translated">El antiguo módulo <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> sigue existiendo por compatibilidad con el pasado, pero actúa principalmente como un front-end para los nuevos métodos de cadena de caracteres.</p>
<p class="translated">Dos métodos que no tienen paralelo en versiones anteriores a la 2.0, aunque existieron en JPython durante bastante tiempo, son <code class="xref py py-meth docutils literal notranslate"><span class="pre">startswith()</span></code> y <code class="xref py py-meth docutils literal notranslate"><span class="pre">endswith()</span></code>. <code class="docutils literal notranslate"><span class="pre">s.startswith(t)</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">s[:len(t)]</span> <span class="pre">==</span> <span class="pre">t</span></code>, mientras que <code class="docutils literal notranslate"><span class="pre">s.endswith(t)</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">s[-len(t):]</span> <span class="pre">==</span> <span class="pre">t</span></code>.</p>
<p class="translated">Otro método que merece una mención especial es el <code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code>. El método <code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code> de una cadena recibe un parámetro, una secuencia de cadenas, y es equivalente a la función <code class="xref py py-func docutils literal notranslate"><span class="pre">string.join()</span></code> del antiguo módulo <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a>, con los argumentos invertidos. En otras palabras, el <code class="docutils literal notranslate"><span class="pre">s.join(seq)</span></code> es equivalente al antiguo <code class="docutils literal notranslate"><span class="pre">string.join(seq,</span> <span class="pre">s)</span></code>.</p>
</section>
<section id="garbage-collection-of-cycles">
<h2 class="translated">Recogida de basura de los ciclos<a class="headerlink" href="#garbage-collection-of-cycles" title="Link to this heading">¶</a></h2>
<p class="translated">La implementación en C de Python utiliza el conteo de referencias para implementar la recolección de basura. Cada objeto de Python mantiene un recuento del número de referencias que apuntan a sí mismo, y ajusta el recuento a medida que se crean o destruyen referencias. Una vez que el recuento de referencias llega a cero, el objeto deja de ser accesible, ya que es necesario tener una referencia a un objeto para acceder a él, y si el recuento es cero, ya no existen referencias.</p>
<p class="translated">El conteo de referencias tiene algunas propiedades agradables: es fácil de entender e implementar, y la implementación resultante es portable, bastante rápida, y reacciona bien con otras bibliotecas que implementan sus propios esquemas de manejo de memoria. El mayor problema del conteo de referencias es que a veces no se da cuenta de que los objetos ya no son accesibles, lo que provoca una fuga de memoria. Esto ocurre cuando hay ciclos de referencias.</p>
<p class="translated">Consideremos el ciclo más simple posible, una instancia de clase que tiene una referencia a sí misma:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">instancia</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="p">()</span>
<span class="n">instancia</span><span class="o">.</span><span class="n">myself</span> <span class="o">=</span> <span class="n">instancia</span>
</pre></div>
</div>
<p class="translated">Después de ejecutar las dos líneas de código anteriores, la cuenta de referencias de <code class="docutils literal notranslate"><span class="pre">instance</span></code> es 2; una referencia es de la variable llamada <code class="docutils literal notranslate"><span class="pre">'instance</span></code>, y la otra es del atributo <code class="docutils literal notranslate"><span class="pre">myself</span></code> de la instancia.</p>
<p class="translated">Si la siguiente línea de código es <code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">instance</span></code>, ¿qué ocurre?  La cuenta de referencias de <code class="docutils literal notranslate"><span class="pre">instance</span></code> se reduce en 1, por lo que tiene una cuenta de referencias de 1; la referencia en el atributo <code class="docutils literal notranslate"><span class="pre">myself</span></code> sigue existiendo. Sin embargo, la instancia ya no es accesible a través del código de Python, y podría ser eliminada. Varios objetos pueden participar en un ciclo si tienen referencias entre sí, haciendo que todos los objetos se filtren.</p>
<p class="translated">Python 2.0 soluciona este problema ejecutando periódicamente un algoritmo de detección de ciclos que busca los ciclos inaccesibles y borra los objetos implicados. Un nuevo módulo <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> proporciona funciones para realizar una recolección de basura, obtener estadísticas de depuración y afinar los parámetros del recolector.</p>
<p class="translated">Ejecutar el algoritmo de detección de ciclos lleva algo de tiempo, y por lo tanto resultará en una sobrecarga adicional. Se espera que después de que hayamos adquirido experiencia con la recogida de ciclos al utilizar la versión 2.0, Python 2.1 sea capaz de minimizar la sobrecarga con un cuidadoso ajuste. Todavía no es obvio cuánto rendimiento se pierde, porque la evaluación comparativa de esto es difícil y depende crucialmente de la frecuencia con la que el programa crea y destruye objetos. La detección de ciclos puede ser desactivada cuando Python es compilado, si no puede permitirse ni siquiera una pequeña penalización de velocidad o sospecha que la recolección de ciclos es un error, especificando la opción <code class="xref std std-option docutils literal notranslate"><span class="pre">--without-cycle-gc</span></code> cuando se ejecuta el script <strong class="program">configure</strong>.</p>
<p class="translated">Varias personas abordaron este problema y contribuyeron a una solución. Una primera implementación del enfoque de detección de ciclos fue escrita por Toby Kelsey. El algoritmo actual fue sugerido por Eric Tiedemann durante una visita al CNRI, y Guido van Rossum y Neil Schemenauer escribieron dos implementaciones diferentes, que posteriormente fueron integradas por Neil. Muchas otras personas ofrecieron sugerencias a lo largo del camino; los archivos de marzo de 2000 de la lista de correo python-dev contienen la mayor parte de la discusión relevante, especialmente en los hilos titulados «Colección de ciclos de referencia para Python» y «Finalización de nuevo».</p>
</section>
<section id="other-core-changes">
<h2 class="translated">Otros cambios en el núcleo<a class="headerlink" href="#other-core-changes" title="Link to this heading">¶</a></h2>
<p class="translated">Se han realizado varios cambios menores en la sintaxis y las funciones incorporadas de Python. Ninguno de los cambios es de gran alcance, pero son conveniencias prácticas.</p>
<section id="minor-language-changes">
<h3 class="translated">Cambios menores del lenguaje<a class="headerlink" href="#minor-language-changes" title="Link to this heading">¶</a></h3>
<p class="translated">Una nueva sintaxis hace que sea más conveniente llamar a una función dada con una tupla de argumentos y/o un diccionario de argumentos de palabras clave. En Python 1.5 y anteriores, se usaba la función incorporada <code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code>: <code class="docutils literal notranslate"><span class="pre">apply(f,</span> <span class="pre">args,</span> <span class="pre">kw)</span></code> llama a la función <code class="xref py py-func docutils literal notranslate"><span class="pre">f()</span></code> con la tupla de argumentos <em>args</em> y los argumentos de palabras clave en el diccionario <em>kw</em>. <code class="xref py py-func docutils literal notranslate"><span class="pre">apply()</span></code> es lo mismo en 2.0, pero gracias a un parche de Greg Ewing, <code class="docutils literal notranslate"><span class="pre">f(*args,</span> <span class="pre">**kw)</span></code> es una forma más corta y clara de lograr el mismo efecto. Esta sintaxis es simétrica con la sintaxis para definir funciones:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="c1"># args is a tuple of positional args,</span>
    <span class="c1"># kw is a dictionary of keyword args</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Ahora, la salida de la sentencia <code class="docutils literal notranslate"><span class="pre">print</span></code> puede dirigirse a un objeto similar a un archivo si se sigue <code class="docutils literal notranslate"><span class="pre">print</span></code> con <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span> <span class="pre">file</span></code>, de forma similar al operador de redirección de los shells de Unix. Antes, se tenía que utilizar el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> del objeto similar a un archivo, que carece de la comodidad y la simplicidad de <code class="docutils literal notranslate"><span class="pre">print</span></code>, o se podía asignar un nuevo valor a <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> y luego restaurar el valor anterior. Para enviar la salida al error estándar, es mucho más fácil escribir esto:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="o">&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;Warning: action field not supplied&quot;</span>
</pre></div>
</div>
<p class="translated">Ahora se puede cambiar el nombre de los módulos al importarlos, utilizando la sintaxis <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">module</span> <span class="pre">as</span> <span class="pre">name</span></code> o <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">name</span> <span class="pre">as</span> <span class="pre">othername</span></code>. El parche fue enviado por Thomas Wouters.</p>
<p class="translated">Un nuevo estilo de formato está disponible cuando se utiliza el operador <code class="docutils literal notranslate"><span class="pre">%</span></code>; “%r” insertará el <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> de su argumento. Esto también se añadió por consideraciones de simetría, esta vez por simetría con el estilo de formato existente “%s”, que inserta el <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> de su argumento. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">'%r</span> <span class="pre">%s'</span> <span class="pre">%</span> <span class="pre">('abc',</span> <span class="pre">'abc')</span></code> retorna una cadena que contiene <code class="docutils literal notranslate"><span class="pre">'abc'</span> <span class="pre">abc</span></code>.</p>
<p class="translated">Anteriormente no había forma de implementar una clase que anulara el operador <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> incorporado de Python e implementara una versión personalizada. <code class="docutils literal notranslate"><span class="pre">obj</span> <span class="pre">in</span> <span class="pre">seq</span></code> devuelve verdadero si <em>obj</em> está presente en la secuencia <em>seq</em>; Python calcula esto simplemente probando cada índice de la secuencia hasta que se encuentre <em>obj</em> o <a class="reference internal" href="../library/exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>. Moshe Zadka contribuyó con un parche que agrega un método mágico <code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code> para proporcionar una implementación personalizada para <code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code>. Además, los nuevos objetos incorporados escritos en C pueden definir lo que <code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code> significa para ellos a través de una nueva ranura en el protocolo de secuencia.</p>
<p class="translated">Las versiones anteriores de Python utilizaban un algoritmo recursivo para borrar objetos. Las estructuras de datos muy anidadas podían hacer que el intérprete llenara la pila de C y se bloqueara; Christian Tismer reescribió la lógica de borrado para solucionar este problema. En una nota relacionada, la comparación de objetos recursivos se repite infinitamente y se bloquea; Jeremy Hylton reescribió el código para que no se bloquee, produciendo un resultado útil. Por ejemplo, después de este código:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">La comparación <code class="docutils literal notranslate"><span class="pre">a==b</span></code> devuelve verdadero, porque las dos estructuras de datos recursivas son isomorfas. Consulte el hilo «trashcan y PR#7» en los archivos de abril de 2000 de la lista de correo python-dev para ver la discusión que condujo a esta implementación y algunos enlaces relevantes útiles. Tenga en cuenta que las comparaciones ahora también pueden generar excepciones. En versiones anteriores de Python, una operación de comparación como <code class="docutils literal notranslate"><span class="pre">cmp(a,b)</span></code> siempre produciría una respuesta, incluso si un método <code class="xref py py-meth docutils literal notranslate"><span class="pre">__cmp__()</span></code> definido por el usuario encontrara un error, ya que la excepción resultante simplemente se tragaría silenciosamente.</p>
<p class="translated">Se ha trabajado en la migración de Python a Windows de 64 bits en el procesador Itanium, principalmente por Trent Mick de ActiveState. (Confusamente, <code class="docutils literal notranslate"><span class="pre">sys.platform</span></code> sigue siendo <code class="docutils literal notranslate"><span class="pre">'win32'</span></code> en Win64 porque parece que, para facilitar la migración, MS Visual C++ trata el código como de 32 bits en Itanium). PythonWin también es compatible con Windows CE; consulte la página de Python CE en <a class="reference external" href="https://pythonce.sourceforge.net/">https://pythonce.sourceforge.net/</a> para obtener más información.</p>
<p class="translated">Otra plataforma nueva es Darwin/MacOS X; el soporte inicial para ella está en Python 2.0. La carga dinámica funciona, si se especifica «configure –with-dyld –with-suffix=.x». Consulte el README de la distribución de fuentes de Python para obtener más instrucciones.</p>
<p class="translated">Se ha intentado aliviar uno de los defectos de Python, la a menudo confusa excepción <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> cuando el código hace referencia a una variable local antes de que se le haya asignado un valor. Por ejemplo, el siguiente código lanza una excepción en la sentencia <code class="docutils literal notranslate"><span class="pre">print</span></code> tanto en 1.5.2 como en 2.0; en 1.5.2 se lanza una excepción <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>, mientras que en 2.0 se lanza una nueva excepción <a class="reference internal" href="../library/exceptions.html#UnboundLocalError" title="UnboundLocalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnboundLocalError</span></code></a>. <a class="reference internal" href="../library/exceptions.html#UnboundLocalError" title="UnboundLocalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnboundLocalError</span></code></a> es una subclase de <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>, así que cualquier código existente que espere que se lance <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> debería seguir funcionando.</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">():</span>
    <span class="nb">print</span> <span class="s2">&quot;i=&quot;</span><span class="p">,</span><span class="n">i</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p class="translated">Se han introducido dos nuevas excepciones, <a class="reference internal" href="../library/exceptions.html#TabError" title="TabError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TabError</span></code></a> y <a class="reference internal" href="../library/exceptions.html#IndentationError" title="IndentationError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndentationError</span></code></a>. Ambas son subclases de <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>, y se lanzan cuando el código Python se encuentra con una sangría incorrecta.</p>
</section>
<section id="changes-to-built-in-functions">
<h3 class="translated">Cambios en las funciones incorporadas<a class="headerlink" href="#changes-to-built-in-functions" title="Link to this heading">¶</a></h3>
<p class="translated">Se ha añadido un nuevo built-in, <code class="docutils literal notranslate"><span class="pre">zip(seq1,</span> <span class="pre">seq2,</span> <span class="pre">...)</span></code>. <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> retorna una lista de tuplas donde cada tupla contiene el i-ésimo elemento de cada una de las secuencias del argumento. La diferencia entre <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> y <code class="docutils literal notranslate"><span class="pre">map(None,</span> <span class="pre">seq1,</span> <span class="pre">seq2)</span></code> es que <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> rellena las secuencias con <code class="docutils literal notranslate"><span class="pre">None</span></code> si las secuencias no tienen la misma longitud, mientras que <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> trunca la lista retornada a la longitud de la secuencia argumental más corta.</p>
<p class="translated">Las funciones <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> y <code class="xref py py-func docutils literal notranslate"><span class="pre">long()</span></code> ahora aceptan un parámetro «base» opcional cuando el primer argumento es una cadena. <code class="docutils literal notranslate"><span class="pre">int('123',</span> <span class="pre">10)</span></code> devuelve 123, mientras que <code class="docutils literal notranslate"><span class="pre">int('123',</span> <span class="pre">16)</span></code> devuelve 291. <code class="docutils literal notranslate"><span class="pre">int(123,</span> <span class="pre">16)</span></code> genera una excepción <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> con el mensaje «no se puede convertir una cadena con una base explícita».</p>
<p class="translated">Se ha añadido al módulo <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> una nueva variable que contiene información más detallada sobre la versión. <code class="docutils literal notranslate"><span class="pre">sys.version_info</span></code> es una tupla <code class="docutils literal notranslate"><span class="pre">(major,</span> <span class="pre">minor,</span> <span class="pre">micro,</span> <span class="pre">level,</span> <span class="pre">serial)</span></code> Por ejemplo, en una hipotética 2.0.1beta1, <code class="docutils literal notranslate"><span class="pre">sys.version_info</span></code> sería <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">'beta',</span> <span class="pre">1)</span></code>. <em>level</em> es una cadena como <code class="docutils literal notranslate"><span class="pre">&quot;alpha&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;beta&quot;</span></code>, o <code class="docutils literal notranslate"><span class="pre">&quot;final&quot;</span></code> para una versión final.</p>
<p class="translated">Los diccionarios tienen un nuevo método extraño, <code class="docutils literal notranslate"><span class="pre">setdefault(key,</span> <span class="pre">default)</span></code>, que se comporta de manera similar al método <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code> existente. Sin embargo, si falta la clave, <code class="xref py py-meth docutils literal notranslate"><span class="pre">setdefault()</span></code> devuelve el valor de <em>default</em> como lo haría <code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code> y también lo inserta en el diccionario como el valor de <em>key</em>. Por lo tanto, las siguientes líneas de código:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nb">dict</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span> <span class="n">key</span> <span class="p">):</span> <span class="k">return</span> <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</pre></div>
</div>
<p class="translated">puede reducirse a una única sentencia <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">dict.setdefault(key,</span> <span class="pre">[])</span></code>.</p>
<p class="translated">El intérprete establece una profundidad de recursión máxima para atrapar la recursión desbocada antes de llenar la pila de C y causar un volcado del núcleo o GPF. Anteriormente este límite se fijaba cuando se compilaba Python, pero en la versión 2.0 la profundidad máxima de recursión puede leerse y modificarse usando <a class="reference internal" href="../library/sys.html#sys.getrecursionlimit" title="sys.getrecursionlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getrecursionlimit()</span></code></a> y <a class="reference internal" href="../library/sys.html#sys.setrecursionlimit" title="sys.setrecursionlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setrecursionlimit()</span></code></a>. El valor por defecto es 1000, y se puede encontrar un valor máximo aproximado para una plataforma determinada ejecutando un nuevo script, <code class="file docutils literal notranslate"><span class="pre">Misc/find_recursionlimit.py</span></code>.</p>
</section>
</section>
<section id="porting-to-2-0">
<h2 class="translated">Adaptación a la versión 2.0<a class="headerlink" href="#porting-to-2-0" title="Link to this heading">¶</a></h2>
<p class="translated">Las nuevas versiones de Python se esfuerzan por ser compatibles con las anteriores, y el historial ha sido bastante bueno. Sin embargo, algunos cambios se consideran lo suficientemente útiles, normalmente porque corrigen decisiones de diseño iniciales que resultaron ser activamente erróneas, que no siempre se puede evitar romper la compatibilidad hacia atrás. Esta sección enumera los cambios en Python 2.0 que pueden hacer que el código Python antiguo se rompa.</p>
<p class="untranslated">The change which will probably break the most code is tightening up the
arguments accepted by some methods.  Some methods would take multiple arguments
and treat them as a tuple, particularly various list methods such as
<a class="reference internal" href="../library/stdtypes.html#list.append" title="list.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code></a> and <a class="reference internal" href="../library/stdtypes.html#list.insert" title="list.insert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">insert()</span></code></a>.
In earlier versions of Python, if <code class="docutils literal notranslate"><span class="pre">L</span></code> is
a list, <code class="docutils literal notranslate"><span class="pre">L.append(</span> <span class="pre">1,2</span> <span class="pre">)</span></code> appends the tuple <code class="docutils literal notranslate"><span class="pre">(1,2)</span></code> to the list.  In Python
2.0 this causes a <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> exception to be raised, with the message:
“append requires exactly 1 argument; 2 given”.  The fix is to simply add an
extra set of parentheses to pass both values as a tuple:  <code class="docutils literal notranslate"><span class="pre">L.append(</span> <span class="pre">(1,2)</span> <span class="pre">)</span></code>.</p>
<p class="translated">Las versiones anteriores de estos métodos eran más indulgentes porque utilizaban una función antigua en la interfaz C de Python para analizar sus argumentos; la versión 2.0 los moderniza para utilizar <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a>, la función de análisis de argumentos actual, que proporciona mensajes de error más útiles y trata las llamadas de múltiples argumentos como errores. Si es absolutamente necesario utilizar la versión 2.0 pero no puede corregir su código, puede editar <code class="file docutils literal notranslate"><span class="pre">Objects/listobject.c</span></code> y definir el símbolo de preprocesador <code class="docutils literal notranslate"><span class="pre">NO_STRICT_LIST_APPEND</span></code> para preservar el comportamiento anterior; esto no se recomienda.</p>
<p class="translated">Algunas de las funciones del módulo <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> siguen siendo indulgentes en este sentido. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">socket.connect(</span> <span class="pre">('hostname',</span> <span class="pre">25)</span> <span class="pre">)</span></code> es la forma correcta, ya que pasa una tupla que representa una dirección IP, pero <code class="docutils literal notranslate"><span class="pre">socket.connect('hostname',</span> <span class="pre">25)</span></code> también funciona. <a class="reference internal" href="../library/socket.html#socket.socket.connect_ex" title="socket.socket.connect_ex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect_ex</span></code></a> y <a class="reference internal" href="../library/socket.html#socket.socket.bind" title="socket.socket.bind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.bind</span></code></a> son igualmente fáciles de usar. 2.0alpha1 restringió estas funciones, pero debido a que la documentación en realidad usaba la forma de argumentos múltiples errónea, muchas personas escribieron código que rompería con la verificación más estricta. GvR retiró los cambios ante la reacción del público, por lo que para el módulo <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a>, la documentación se corrigió y la forma de argumentos múltiples simplemente se marcó como obsoleta; <em>will</em> se ajustará nuevamente en una futura versión de Python.</p>
<p class="translated">El escape <code class="docutils literal notranslate"><span class="pre">\x</span></code> en los literales de cadena ahora toma exactamente 2 dígitos hexadecimales. Antes consumía todos los dígitos hexadecimales que seguían a la “x” y tomaba los 8 bits más bajos del resultado, por lo que <code class="docutils literal notranslate"><span class="pre">\x123456</span></code> era equivalente a <code class="docutils literal notranslate"><span class="pre">\x56</span></code>.</p>
<p class="translated">Las excepciones <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> y <a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> tienen un mensaje de error más amigable, cuyo texto será algo así como <code class="docutils literal notranslate"><span class="pre">'Spam'</span> <span class="pre">instance</span> <span class="pre">has</span> <span class="pre">no</span> <span class="pre">attribute</span> <span class="pre">'eggs'</span></code> o <code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">'eggs'</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">defined</span></code>. Anteriormente, el mensaje de error era simplemente la falta del nombre del atributo <code class="docutils literal notranslate"><span class="pre">eggs</span></code>, y el código escrito para aprovechar este hecho se romperá en la versión 2.0.</p>
<p class="translated">Se ha trabajado un poco para que los números enteros y los números enteros largos sean un poco más intercambiables. En 1.5.2, se agregó soporte para archivos grandes para Solaris, para permitir la lectura de archivos mayores a 2 GiB; esto hizo que el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">tell()</span></code> de objetos de archivo devolviera un número entero largo en lugar de un número entero regular. Algunos códigos restaban dos desplazamientos de archivo e intentaban usar el resultado para multiplicar una secuencia o cortar una cadena, pero esto generaba un <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. En 2.0, los números enteros largos se pueden usar para multiplicar o cortar una secuencia, y se comportará como esperaría intuitivamente; <code class="docutils literal notranslate"><span class="pre">3L</span> <span class="pre">*</span> <span class="pre">'abc'</span></code> produce “abcabcabc” y <code class="docutils literal notranslate"><span class="pre">(0,1,2,3)[2L:4L]</span></code> produce (2,3). Los números enteros largos también se pueden usar en varios contextos donde anteriormente solo se aceptaban números enteros, como en el método <code class="xref py py-meth docutils literal notranslate"><span class="pre">seek()</span></code> de objetos de archivo y en los formatos admitidos por el operador <code class="docutils literal notranslate"><span class="pre">%</span></code> (<code class="docutils literal notranslate"><span class="pre">%d</span></code>, <code class="docutils literal notranslate"><span class="pre">%i</span></code>, <code class="docutils literal notranslate"><span class="pre">%x</span></code>, etc.). Por ejemplo, <code class="docutils literal notranslate"><span class="pre">&quot;%d&quot;</span> <span class="pre">%</span> <span class="pre">2L**64</span></code> producirá la cadena <code class="docutils literal notranslate"><span class="pre">18446744073709551616</span></code>.</p>
<p class="translated">El cambio más sutil de los enteros largos es que el <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> de un entero largo ya no tiene un carácter “L” al final, aunque <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> todavía lo incluye. La “L” molestaba a muchas personas que querían imprimir enteros largos con el mismo aspecto que los enteros normales, ya que tenían que esforzarse por cortar el carácter. Esto ya no es un problema en 2.0, pero el código que hace <code class="docutils literal notranslate"><span class="pre">str(longval)[:-1]</span></code> y asume que la “L” está ahí, ahora perderá el dígito final.</p>
<p class="translated">Ahora, al tomar el <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> de un float, se utiliza una precisión de formato diferente a la de <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>. <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> utiliza la cadena de formato <code class="docutils literal notranslate"><span class="pre">%.17g</span></code> para <code class="xref py py-func docutils literal notranslate"><span class="pre">sprintf()</span></code> de C, mientras que <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> utiliza <code class="docutils literal notranslate"><span class="pre">%.12g</span></code> como antes. El efecto es que <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> puede mostrar ocasionalmente más decimales que <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> para ciertos números. Por ejemplo, el número 8.1 no se puede representar exactamente en binario, por lo que <code class="docutils literal notranslate"><span class="pre">repr(8.1)</span></code> es <code class="docutils literal notranslate"><span class="pre">'8.0999999999999996'</span></code>, mientras que str(8.1) es <code class="docutils literal notranslate"><span class="pre">'8.1'</span></code>.</p>
<p class="translated">Se ha eliminado la opción de línea de comandos <code class="docutils literal notranslate"><span class="pre">-X</span></code>, que convertía todas las excepciones estándar en cadenas en lugar de clases; ahora las excepciones estándar siempre serán clases. El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">exceptions</span></code> que contiene las excepciones estándar se tradujo de Python a un módulo C integrado, escrito por Barry Warsaw y Fredrik Lundh.</p>
</section>
<section id="extending-embedding-changes">
<h2 class="translated">Extensión/Incorporación de cambios<a class="headerlink" href="#extending-embedding-changes" title="Link to this heading">¶</a></h2>
<p class="translated">Algunos de los cambios están bajo la cubierta, y sólo serán evidentes para la gente que escribe módulos de extensión de C o que incrusta un intérprete de Python en una aplicación más grande. Si no estás tratando con la API de C de Python, puedes saltarte esta sección.</p>
<p class="translated">El número de versión de la API C de Python se incrementó, por lo que las extensiones C compiladas para 1.5.2 deben ser recompiladas para que funcionen con 2.0. En Windows, no es posible que Python 2.0 importe una extensión de terceros construida para Python 1.5.x debido a cómo funcionan las DLL de Windows, por lo que Python lanzará una excepción y la importación fallará.</p>
<p class="translated">Los usuarios del módulo ExtensionClass de Jim Fulton estarán encantados de saber que se han añadido ganchos para que las ExtensionClasses sean ahora compatibles con <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> y <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a>. Esto significa que ya no tiene que recordar escribir código como <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">type(obj)</span> <span class="pre">==</span> <span class="pre">myExtensionClass</span></code>, sino que puede utilizar el más natural <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">isinstance(obj,</span> <span class="pre">myExtensionClass)</span></code>.</p>
<p class="translated">El archivo <code class="file docutils literal notranslate"><span class="pre">Python/importdl.c</span></code>, que era una masa de #ifdefs para soportar la carga dinámica en muchas plataformas diferentes, fue limpiado y reorganizado por Greg Stein. <code class="file docutils literal notranslate"><span class="pre">importdl.c</span></code> es ahora bastante pequeño, y el código específico de la plataforma se ha movido a un montón de archivos <code class="file docutils literal notranslate"><span class="pre">Python/dynload_*.c</span></code>. Otra limpieza: también había una serie de archivos <code class="file docutils literal notranslate"><span class="pre">my*.h</span></code> en el directorio Include/ que contenían varios hacks de portabilidad; se han fusionado en un único archivo, <code class="file docutils literal notranslate"><span class="pre">Include/pyport.h</span></code>.</p>
<p class="translated">La esperada reestructuración de malloc de Vladimir Marangozov se completó para facilitar que el intérprete de Python use un asignador personalizado en lugar del <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> estándar de C. Para consultar la documentación, lea los comentarios en <code class="file docutils literal notranslate"><span class="pre">Include/pymem.h</span></code> y <code class="file docutils literal notranslate"><span class="pre">Include/objimpl.h</span></code>. Para consultar las extensas discusiones durante las cuales se elaboró ​​la interfaz, consulte los archivos web de las listas “patches” y “python-dev” en python.org.</p>
<p class="translated">Las versiones recientes del entorno de desarrollo GUSI para MacOS soportan hilos POSIX. Por lo tanto, el soporte de hilos POSIX de Python ahora funciona en Macintosh. También se ha contribuido al soporte de hilos utilizando la biblioteca GNU <code class="docutils literal notranslate"><span class="pre">pth</span></code> del espacio de usuario.</p>
<p class="translated">También se ha mejorado el soporte de hilos en Windows. Windows soporta bloqueos de hilos que utilizan objetos del núcleo sólo en caso de contención; en el caso común cuando no hay contención, utilizan funciones más simples que son un orden de magnitud más rápido. Una versión con hilos de Python 1.5.2 en NT es dos veces más lenta que una versión sin hilos; con los cambios de la 2.0, la diferencia es sólo del 10%. Estas mejoras fueron aportadas por Yakov Markovitch.</p>
<p class="translated">El código fuente de Python 2.0 ahora sólo utiliza prototipos ANSI C, por lo que la compilación de Python ahora requiere un compilador ANSI C, y ya no puede hacerse utilizando un compilador que sólo soporte K&amp;R C.</p>
<p class="translated">Anteriormente, la máquina virtual de Python utilizaba números de 16 bits en su bytecode, lo que limitaba el tamaño de los archivos fuente. En particular, esto afectaba al tamaño máximo de las listas literales y los diccionarios en el código fuente de Python; ocasionalmente, las personas que generan código Python se encontraban con este límite. Un parche de Charles G. Waldman eleva el límite de <code class="docutils literal notranslate"><span class="pre">2^16</span></code> a <code class="docutils literal notranslate"><span class="pre">2^{32}</span></code>.</p>
<p class="translated">Se agregaron tres nuevas funciones de conveniencia destinadas a agregar constantes al diccionario de un módulo en el momento de inicialización del módulo: <a class="reference internal" href="../c-api/module.html#c.PyModule_AddObject" title="PyModule_AddObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_AddObject()</span></code></a>, <a class="reference internal" href="../c-api/module.html#c.PyModule_AddIntConstant" title="PyModule_AddIntConstant"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_AddIntConstant()</span></code></a> y <a class="reference internal" href="../c-api/module.html#c.PyModule_AddStringConstant" title="PyModule_AddStringConstant"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_AddStringConstant()</span></code></a>. Cada una de estas funciones toma un objeto de módulo, una cadena C terminada en cero que contiene el nombre que se agregará y un tercer argumento para el valor que se asignará al nombre. Este tercer argumento es, respectivamente, un objeto Python, un long C o una cadena C.</p>
<p class="translated">Se agregó una API contenedora para los controladores de señales de estilo Unix. <a class="reference internal" href="../c-api/sys.html#c.PyOS_getsig" title="PyOS_getsig"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_getsig()</span></code></a> obtiene un controlador de señales y <a class="reference internal" href="../c-api/sys.html#c.PyOS_setsig" title="PyOS_setsig"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_setsig()</span></code></a> establecerá un nuevo controlador.</p>
</section>
<section id="distutils-making-modules-easy-to-install">
<h2 class="translated">Distutils: Facilitando la instalación de módulos<a class="headerlink" href="#distutils-making-modules-easy-to-install" title="Link to this heading">¶</a></h2>
<p class="translated">Antes de Python 2.0, la instalación de módulos era un asunto tedioso – no había forma de averiguar automáticamente dónde se instalaba Python, o qué opciones del compilador se debían usar para los módulos de extensión. Los autores de software tenían que pasar por un arduo ritual de edición de Makefiles y archivos de configuración, que sólo funcionaban realmente en Unix y dejaban sin soporte a Windows y MacOS. Los usuarios de Python se enfrentaban a instrucciones de instalación muy diferentes que variaban entre los distintos paquetes de extensión, lo que hacía que la administración de una instalación de Python fuera una tarea ardua.</p>
<p class="translated">El SIG para utilidades de distribución, dirigido por Greg Ward, ha creado Distutils, un sistema para facilitar enormemente la instalación de paquetes. Forman el paquete <code class="docutils literal notranslate"><span class="pre">distutils</span></code>, una nueva parte de la biblioteca estándar de Python. En el mejor de los casos, instalar un módulo Python desde el código fuente requerirá los mismos pasos: primero, simplemente hay que descomprimir el archivo tarball o zip y ejecutar «<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></code>». La plataforma se detectará automáticamente, se reconocerá el compilador, se compilarán los módulos de extensión de C y se instalará la distribución en el directorio adecuado. Los argumentos opcionales de la línea de comandos proporcionan más control sobre el proceso de instalación; el paquete distutils ofrece muchos lugares para anular los valores predeterminados, separando la compilación de la instalación, compilando o instalando en directorios que no sean los predeterminados, y más.</p>
<p class="translated">Para usar las Distutils, necesitas escribir un script <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code>. Para el caso simple, cuando el software contiene sólo archivos .py, un <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> mínimo puede tener sólo unas pocas líneas:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">distutils.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">setup</span>
<span class="n">setup</span> <span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;1.0&quot;</span><span class="p">,</span>
       <span class="n">py_modules</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;module1&quot;</span><span class="p">,</span> <span class="s2">&quot;module2&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p class="translated">El archivo <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> no es mucho más complicado si el software consta de unos pocos paquetes:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">distutils.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">setup</span>
<span class="n">setup</span> <span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;1.0&quot;</span><span class="p">,</span>
       <span class="n">packages</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;package&quot;</span><span class="p">,</span> <span class="s2">&quot;package.subpackage&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p class="translated">Una extensión en C puede ser el caso más complicado; he aquí un ejemplo tomado del paquete PyXML:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">distutils.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Extension</span>

<span class="n">expat_extension</span> <span class="o">=</span> <span class="n">Extension</span><span class="p">(</span><span class="s1">&#39;xml.parsers.pyexpat&#39;</span><span class="p">,</span>
     <span class="n">define_macros</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;XML_NS&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)],</span>
     <span class="n">include_dirs</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;extensions/expat/xmltok&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;extensions/expat/xmlparse&#39;</span> <span class="p">],</span>
     <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;extensions/pyexpat.c&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;extensions/expat/xmltok/xmltok.c&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;extensions/expat/xmltok/xmlrole.c&#39;</span><span class="p">,</span> <span class="p">]</span>
       <span class="p">)</span>
<span class="n">setup</span> <span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;PyXML&quot;</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;0.5.4&quot;</span><span class="p">,</span>
       <span class="n">ext_modules</span> <span class="o">=</span><span class="p">[</span> <span class="n">expat_extension</span> <span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p class="translated">Las Distutils también pueden encargarse de crear distribuciones fuente y binarias. El comando «sdist», ejecutado por «<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">sdist</span></code>, construye una distribución fuente como <code class="file docutils literal notranslate"><span class="pre">foo-1.0.tar.gz</span></code>. Añadir nuevos comandos no es difícil, ya se han aportado los comandos «bdist_rpm» y «bdist_wininst» para crear una distribución RPM y un instalador de Windows para el software, respectivamente. Los comandos para crear otros formatos de distribución, como los paquetes de Debian y los archivos <code class="file docutils literal notranslate"><span class="pre">.pkg</span></code> de Solaris, se encuentran en diversas etapas de desarrollo.</p>
<p class="translated">Todo esto está documentado en un nuevo manual, <em>Distribución de módulos de Python</em>, que se une al conjunto básico de documentación de Python.</p>
</section>
<section id="xml-modules">
<h2 class="translated">Módulos XML<a class="headerlink" href="#xml-modules" title="Link to this heading">¶</a></h2>
<p class="translated">Python 1.5.2 incluía un analizador XML simple en forma del módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmllib</span></code>, aportado por Sjoerd Mullender. Desde el lanzamiento de la versión 1.5.2, se han vuelto comunes dos interfaces diferentes para procesar XML: SAX2 (versión 2 de la API simple para XML) proporciona una interfaz basada en eventos con algunas similitudes con <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmllib</span></code>, y DOM (Document Object Model) proporciona una interfaz basada en árboles, transformando un documento XML en un árbol de nodos que se puede recorrer y modificar. Python 2.0 incluye una interfaz SAX2 y una interfaz DOM simplificada como parte del paquete <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a>. Aquí daremos una breve descripción general de estas nuevas interfaces; consulte la documentación de Python o el código fuente para obtener detalles completos. El SIG de XML de Python también está trabajando en una documentación mejorada.</p>
<section id="sax2-support">
<h3 class="translated">Soporte de SAX2<a class="headerlink" href="#sax2-support" title="Link to this heading">¶</a></h3>
<p class="translated">SAX define una interfaz controlada por eventos para analizar XML. Para utilizar SAX, debe escribir una clase controladora de SAX. Las clases controladoras heredan de varias clases proporcionadas por SAX y reemplazan varios métodos que luego llamará el analizador XML. Por ejemplo, los métodos <a class="reference internal" href="../library/xml.sax.handler.html#xml.sax.handler.ContentHandler.startElement" title="xml.sax.handler.ContentHandler.startElement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startElement()</span></code></a> y <a class="reference internal" href="../library/xml.sax.handler.html#xml.sax.handler.ContentHandler.endElement" title="xml.sax.handler.ContentHandler.endElement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">endElement()</span></code></a> se llaman para cada etiqueta de inicio y fin que encuentre el analizador, el método <a class="reference internal" href="../library/xml.sax.handler.html#xml.sax.handler.ContentHandler.characters" title="xml.sax.handler.ContentHandler.characters"><code class="xref py py-meth docutils literal notranslate"><span class="pre">characters()</span></code></a> se llama para cada fragmento de datos de caracteres, y así sucesivamente.</p>
<p class="translated">La ventaja del enfoque basado en eventos es que todo el documento no tiene que residir en la memoria en un momento dado, lo cual es importante si estás procesando documentos realmente enormes. Sin embargo, escribir la clase manejadora de SAX puede ser muy complicado si se intenta modificar la estructura del documento de alguna manera elaborada.</p>
<p class="translated">Por ejemplo, este pequeño programa de ejemplo define un manejador que imprime un mensaje para cada etiqueta inicial y final, y luego analiza el archivo <code class="file docutils literal notranslate"><span class="pre">hamlet.xml</span></code> usándolo:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">xml</span><span class="w"> </span><span class="kn">import</span> <span class="n">sax</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SimpleHandler</span><span class="p">(</span><span class="n">sax</span><span class="o">.</span><span class="n">ContentHandler</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">startElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;Start of element:&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">endElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;End of element:&#39;</span><span class="p">,</span> <span class="n">name</span>

<span class="c1"># Create a parser object</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">sax</span><span class="o">.</span><span class="n">make_parser</span><span class="p">()</span>

<span class="c1"># Tell it what handler to use</span>
<span class="n">handler</span> <span class="o">=</span> <span class="n">SimpleHandler</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">setContentHandler</span><span class="p">(</span> <span class="n">handler</span> <span class="p">)</span>

<span class="c1"># Parse a file!</span>
<span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span> <span class="s1">&#39;hamlet.xml&#39;</span> <span class="p">)</span>
</pre></div>
</div>
<p class="translated">Para más información, consulte la documentación de Python o el XML HOWTO en <a class="reference external" href="https://pyxml.sourceforge.net/topics/howto/xml-howto.html">https://pyxml.sourceforge.net/topics/howto/xml-howto.html</a>.</p>
</section>
<section id="dom-support">
<h3 class="translated">Soporte DOM<a class="headerlink" href="#dom-support" title="Link to this heading">¶</a></h3>
<p class="translated">El modelo de objetos de documento es una representación basada en árboles para un documento XML. Una instancia <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code> de nivel superior es la raíz del árbol y tiene un único elemento secundario que es la instancia <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> de nivel superior. Este <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> tiene nodos secundarios que representan datos de caracteres y cualquier subelemento, que puede tener otros elementos secundarios propios, y así sucesivamente. Con el DOM, puede recorrer el árbol resultante de la forma que desee, acceder a los valores de los elementos y atributos, insertar y eliminar nodos y convertir el árbol nuevamente en XML.</p>
<p class="translated">El DOM es útil para modificar documentos XML, porque se puede crear un árbol DOM, modificarlo añadiendo nuevos nodos o reordenando subárboles, y luego producir un nuevo documento XML como salida. También se puede construir un árbol DOM manualmente y convertirlo en XML, lo que puede ser una forma más flexible de producir una salida XML que simplemente escribir <code class="docutils literal notranslate"><span class="pre">&lt;tag1&gt;</span></code>…<code class="docutils literal notranslate"><span class="pre">&lt;/tag1&gt;</span></code> un archivo.</p>
<p class="translated">La implementación del DOM incluida con Python se encuentra en el módulo <a class="reference internal" href="../library/xml.dom.minidom.html#module-xml.dom.minidom" title="xml.dom.minidom: Minimal Document Object Model (DOM) implementation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.dom.minidom</span></code></a>. Es una implementación liviana del DOM de nivel 1 con soporte para espacios de nombres XML. Las funciones de conveniencia <code class="xref py py-func docutils literal notranslate"><span class="pre">parse()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">parseString()</span></code> se proporcionan para generar un árbol DOM:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">xml.dom</span><span class="w"> </span><span class="kn">import</span> <span class="n">minidom</span>
<span class="n">doc</span> <span class="o">=</span> <span class="n">minidom</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;hamlet.xml&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">doc</span></code> es una instancia de <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code>. <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code>, al igual que todas las demás clases DOM como <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> y <code class="xref py py-class docutils literal notranslate"><span class="pre">Text</span></code>, es una subclase de la clase base <code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code>. Por lo tanto, todos los nodos de un árbol DOM admiten ciertos métodos comunes, como <code class="xref py py-meth docutils literal notranslate"><span class="pre">toxml()</span></code>, que devuelve una cadena que contiene la representación XML del nodo y sus hijos. Cada clase también tiene sus propios métodos especiales; por ejemplo, las instancias <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> y <code class="xref py py-class docutils literal notranslate"><span class="pre">Document</span></code> tienen un método para encontrar todos los elementos secundarios con un nombre de etiqueta determinado. Continuando con el ejemplo anterior de 2 líneas:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">perslist</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">getElementsByTagName</span><span class="p">(</span> <span class="s1">&#39;PERSONA&#39;</span> <span class="p">)</span>
<span class="nb">print</span> <span class="n">perslist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">toxml</span><span class="p">()</span>
<span class="nb">print</span> <span class="n">perslist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">toxml</span><span class="p">()</span>
</pre></div>
</div>
<p class="translated">Para el archivo XML <em>Hamlet</em>, las líneas anteriores dan como resultado:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">PERSONA</span><span class="o">&gt;</span><span class="n">CLAUDIO</span><span class="p">,</span> <span class="n">rey</span> <span class="n">de</span> <span class="n">Dinamarca</span><span class="o">.</span> <span class="o">&lt;/</span><span class="n">PERSONA</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">PERSONA</span><span class="o">&gt;</span><span class="n">HAMLET</span><span class="p">,</span> <span class="n">hijo</span> <span class="k">del</span> <span class="n">difunto</span> <span class="n">rey</span> <span class="n">y</span> <span class="n">sobrino</span> <span class="k">del</span> <span class="n">actual</span><span class="o">.&lt;/</span><span class="n">PERSONA</span><span class="o">&gt;</span>
</pre></div>
</div>
<p class="translated">El elemento raíz del documento está disponible como <code class="docutils literal notranslate"><span class="pre">doc.documentElement</span></code>, y sus hijos pueden modificarse fácilmente borrando, añadiendo o eliminando nodos:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">documentElement</span>

<span class="c1"># Eliminar el primer hijo</span>
<span class="n">root</span><span class="o">.</span><span class="n">removeChild</span><span class="p">(</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>

<span class="c1"># Mover el nuevo primer hijo al final</span>
<span class="n">root</span><span class="o">.</span><span class="n">appendChild</span><span class="p">(</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>

<span class="c1"># Insertar el nuevo primer hijo (originalmente,</span>
<span class="c1"># el tercer hijo) antes del hijo número 20.</span>
<span class="n">root</span><span class="o">.</span><span class="n">insertBefore</span><span class="p">(</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">root</span><span class="o">.</span><span class="n">childNodes</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p class="translated">Una vez más, te remito a la documentación de Python para obtener una lista completa de las diferentes clases <code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code> y sus diversos métodos.</p>
</section>
<section id="relationship-to-pyxml">
<h3 class="translated">Relación con PyXML<a class="headerlink" href="#relationship-to-pyxml" title="Link to this heading">¶</a></h3>
<p class="translated">El Grupo de Interés Especial XML lleva un tiempo trabajando en código Python relacionado con XML. Su distribución de código, llamada PyXML, está disponible en las páginas web del SIG en <a class="reference external" href="https://www.python.org/community/sigs/current/xml-sig">https://www.python.org/community/sigs/current/xml-sig</a>. La distribución de PyXML también utiliza el nombre de paquete <code class="docutils literal notranslate"><span class="pre">xml</span></code>. Si has escrito programas que utilizan PyXML, probablemente te preguntes sobre su compatibilidad con el paquete 2.0 <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a>.</p>
<p class="translated">La respuesta es que el paquete <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> de Python 2.0 no es compatible con PyXML, pero puede hacerse compatible instalando una versión reciente de PyXML. Muchas aplicaciones pueden arreglárselas con el soporte XML que se incluye en Python 2.0, pero las aplicaciones más complicadas requerirán que se instale el paquete PyXML completo. Cuando se instala, las versiones 0.6.0 o superiores de PyXML sustituyen al paquete <a class="reference internal" href="../library/xml.html#module-xml" title="xml: Package containing XML processing modules"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml</span></code></a> que se entrega con Python, y son un estricto superconjunto del paquete estándar, añadiendo un montón de características adicionales. Algunas de las características adicionales de PyXML incluyen:</p>
<ul class="simple">
<li><p class="translated">4DOM, una implementación completa de DOM de FourThought, Inc.</p></li>
<li><p class="translated">El parser de validación xmlproc, escrito por Lars Marius Garshol.</p></li>
<li><p class="translated">El módulo acelerador del parser <code class="xref py py-mod docutils literal notranslate"><span class="pre">sgmlop</span></code>, escrito por Fredrik Lundh.</p></li>
</ul>
</section>
</section>
<section id="module-changes">
<h2 class="translated">Cambios en los módulos<a class="headerlink" href="#module-changes" title="Link to this heading">¶</a></h2>
<p class="translated">Se realizaron muchas mejoras y correcciones de errores en la extensa biblioteca estándar de Python; algunos de los módulos afectados incluyen <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a>, <a class="reference internal" href="../library/configparser.html#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ConfigParser</span></code></a>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">cgi</span></code>, <a class="reference internal" href="../library/calendar.html#module-calendar" title="calendar: Functions for working with calendars, including some emulation of the Unix cal program."><code class="xref py py-mod docutils literal notranslate"><span class="pre">calendar</span></code></a>, <a class="reference internal" href="../library/posix.html#module-posix" title="posix: The most common POSIX system calls (normally used via module os). (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">posix</span></code></a>, <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmllib</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">aifc</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">chunk</span></code>, <a class="reference internal" href="../library/wave.html#module-wave" title="wave: Provide an interface to the WAV sound format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">wave</span></code></a>, <a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a>, <a class="reference internal" href="../library/shelve.html#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shelve</span></code></a> y <code class="xref py py-mod docutils literal notranslate"><span class="pre">nntplib</span></code>. Consulte los registros CVS para obtener detalles exactos de cada parche.</p>
<p class="translated">Brian Gallew contribuyó con la compatibilidad con OpenSSL para el módulo <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a>. OpenSSL es una implementación de la capa de sockets seguros, que cifra los datos que se envían a través de un socket. Al compilar Python, puede editar <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> para incluir compatibilidad con SSL, lo que agrega una función adicional al módulo <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a>: <code class="docutils literal notranslate"><span class="pre">socket.ssl(socket,</span> <span class="pre">keyfile,</span> <span class="pre">certfile)</span></code>, que toma un objeto de socket y devuelve un socket SSL. Los módulos <a class="reference internal" href="../library/http.html#module-http" title="http: HTTP status codes and messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code></a> y <a class="reference internal" href="../library/urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> también se modificaron para admitir las URL de <code class="docutils literal notranslate"><span class="pre">https://</span></code>, aunque nadie ha implementado FTP o SMTP sobre SSL.</p>
<p class="translated">Greg Stein ha reescrito el módulo <a class="reference internal" href="../library/http.html#module-http" title="http: HTTP status codes and messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code></a> para admitir HTTP/1.1.</p>
<p class="translated">Se proporciona compatibilidad con versiones anteriores de la versión 1.5 de <code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code>, aunque el uso de funciones HTTP/1.1 como la canalización requerirá reescribir el código para usar un conjunto diferente de interfaces.</p>
<p class="translated">El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> ahora es compatible con las versiones 8.1, 8.2 u 8.3 de Tcl/Tk y se ha eliminado la compatibilidad con las versiones 7.x anteriores. El módulo Tkinter ahora es compatible con la visualización de cadenas Unicode en widgets Tk. Además, Fredrik Lundh contribuyó con una optimización que hace que operaciones como <code class="docutils literal notranslate"><span class="pre">create_line</span></code> y <code class="docutils literal notranslate"><span class="pre">create_polygon</span></code> sean mucho más rápidas, especialmente cuando se utilizan muchas coordenadas.</p>
<p class="translated">El módulo <a class="reference internal" href="../library/curses.html#module-curses" title="curses: An interface to the curses library, providing portable terminal handling. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">curses</span></code></a> ha sido ampliado en gran medida, a partir de la versión mejorada de Oliver Andrich, para proporcionar muchas funciones adicionales de los curses ncurses y SYSV, como el color, el soporte de conjuntos de caracteres alternativos, los pads y el soporte de ratón. Esto significa que el módulo ya no es compatible con los sistemas operativos que sólo tienen curses BSD, pero no parece haber ningún sistema operativo actualmente mantenido que caiga en esta categoría.</p>
<p class="translated">Como se mencionó en la discusión anterior sobre el soporte Unicode de la 2.0, la implementación subyacente de las expresiones regulares proporcionadas por el módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> ha sido cambiada. SRE, un nuevo motor de expresiones regulares escrito por Fredrik Lundh y parcialmente financiado por Hewlett Packard, soporta la comparación con cadenas de 8 bits y cadenas Unicode.</p>
</section>
<section id="new-modules">
<h2 class="translated">Nuevos módulos<a class="headerlink" href="#new-modules" title="Link to this heading">¶</a></h2>
<p class="translated">Se han añadido varios módulos nuevos. Nos limitaremos a enumerarlos con breves descripciones; consulte la documentación de la versión 2.0 para conocer los detalles de un módulo concreto.</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a>:  Para registrar las funciones que serán llamadas antes de que el intérprete de Python salga. El código que actualmente establece <code class="docutils literal notranslate"><span class="pre">sys.exitfunc</span></code> directamente debe cambiarse para usar el módulo <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> en su lugar, importando <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> y llamando a <a class="reference internal" href="../library/atexit.html#atexit.register" title="atexit.register"><code class="xref py py-func docutils literal notranslate"><span class="pre">atexit.register()</span></code></a> con la función a llamar al salir. (Contribución de Skip Montanaro)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings</span></code>, <a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a>:  Añadidos como parte del nuevo soporte de Unicode.</p></li>
<li><p class="translated"><a class="reference internal" href="../library/filecmp.html#module-filecmp" title="filecmp: Compare files efficiently."><code class="xref py py-mod docutils literal notranslate"><span class="pre">filecmp</span></code></a>: Sustituye a los antiguos módulos <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmp</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmpcache</span></code> y <code class="xref py py-mod docutils literal notranslate"><span class="pre">dircmp</span></code>, que han quedado obsoletos. (Contribución de Gordon MacMillan y Moshe Zadka)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/gettext.html#module-gettext" title="gettext: Multilingual internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gettext</span></code></a>: Este módulo proporciona soporte de internacionalización (I18N) y localización (L10N) para los programas de Python, proporcionando una interfaz a la biblioteca de catálogo de mensajes GNU gettext. (Integrado por Barry Warsaw, a partir de contribuciones separadas de Martin von Löwis, Peter Funk y James Henstridge)</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">linuxaudiodev</span></code>: Soporte para el dispositivo <code class="file docutils literal notranslate"><span class="pre">/dev/audio</span></code> en Linux, un gemelo del módulo existente <code class="xref py py-mod docutils literal notranslate"><span class="pre">sunaudiodev</span></code>. (Contribuido por Peter Bosch, con correcciones de Jeremy Hylton)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/mmap.html#module-mmap" title="mmap: Interface to memory-mapped files for Unix and Windows."><code class="xref py py-mod docutils literal notranslate"><span class="pre">mmap</span></code></a>: Una interfaz para archivos mapeados en memoria tanto en Windows como en Unix. El contenido de un fichero puede ser mapeado directamente en memoria, en cuyo momento se comporta como una cadena mutable, por lo que su contenido puede ser leído y modificado. Incluso pueden pasarse a funciones que esperan cadenas ordinarias, como el módulo <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a>. (Contribución de Sam Rushing, con algunas extensiones de A.M. Kuchling)</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyexpat</span></code>: Una interfaz para el analizador XML de Expat. (Contribuido por Paul Prescod.)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/urllib.robotparser.html#module-urllib.robotparser" title="urllib.robotparser: Load a robots.txt file and answer questions about fetchability of other URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">robotparser</span></code></a>: Analiza un archivo <code class="file docutils literal notranslate"><span class="pre">robots.txt</span></code>, que se utiliza para escribir arañas web que evitan amablemente ciertas áreas de un sitio web. El analizador acepta el contenido de un archivo <code class="file docutils literal notranslate"><span class="pre">robots.txt</span></code>, construye un conjunto de reglas a partir de él y puede responder a preguntas sobre la capacidad de búsqueda de una URL determinada. (Contribución de Skip Montanaro)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/tabnanny.html#module-tabnanny" title="tabnanny: Tool for detecting white space related problems in Python source files in a directory tree."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tabnanny</span></code></a>: Un módulo/script para comprobar el código fuente de Python en busca de sangrías ambiguas. (Contribuido por Tim Peters.)</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">UserString</span></code>: Una clase base útil para derivar objetos que se comportan como cadenas.</p></li>
<li><p class="translated"><a class="reference internal" href="../library/webbrowser.html#module-webbrowser" title="webbrowser: Easy-to-use controller for web browsers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">webbrowser</span></code></a>: Un módulo que proporciona una forma independiente de la plataforma para lanzar un navegador web en una URL específica. Para cada plataforma, se prueban varios navegadores en un orden específico. El usuario puede modificar el navegador que se lanza estableciendo la variable de entorno <em>BROWSER</em>. (Originalmente inspirado por el parche de Eric S. Raymond a <a class="reference internal" href="../library/urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> que añadía una funcionalidad similar, pero el módulo final proviene de un código originalmente implementado por Fred Drake como <code class="file docutils literal notranslate"><span class="pre">Tools/idle/BrowserControl.py</span></code>, y adaptado para la biblioteca estándar por Fred)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/winreg.html#module-winreg" title="winreg: Routines and objects for manipulating the Windows registry. (Windows)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code></a>: Una interfaz para el registro de Windows. <code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code> es una adaptación de las funciones que han formado parte de PythonWin desde 1995, pero ahora se ha añadido a la distribución principal, y se ha mejorado para soportar Unicode. <code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code> fue escrito por Bill Tutt y Mark Hammond.</p></li>
<li><p class="translated"><a class="reference internal" href="../library/zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a>: Un módulo para leer y escribir archivos con formato ZIP. Se trata de archivos producidos por <strong class="program">PKZIP</strong> en DOS/Windows o <strong class="program">zip</strong> en Unix, que no deben confundirse con los archivos con formato <strong class="program">gzip</strong> (que son compatibles con el módulo <a class="reference internal" href="../library/gzip.html#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gzip</span></code></a>) (Contribución de James C. Ahlstrom.)</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">imputil</span></code>: Un módulo que proporciona una forma más sencilla de escribir ganchos de importación personalizados, en comparación con el módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">ihooks</span></code> existente. (Implementado por Greg Stein, con mucha discusión en python-dev a lo largo del camino)</p></li>
</ul>
</section>
<section id="idle-improvements">
<h2 class="translated">Mejoras en IDLE<a class="headerlink" href="#idle-improvements" title="Link to this heading">¶</a></h2>
<p class="translated">IDLE es el IDE oficial de Python multiplataforma, escrito con Tkinter. Python 2.0 incluye IDLE 0.6, que añade una serie de nuevas características y mejoras. Una lista parcial:</p>
<ul class="simple">
<li><p class="translated">Mejoras y optimizaciones de la interfaz de usuario, especialmente en el área de resaltado de sintaxis y auto-indentación.</p></li>
<li><p class="translated">El navegador de clases muestra ahora más información, como las funciones de nivel superior de un módulo.</p></li>
<li><p class="translated">El ancho del tabulador es ahora una opción configurable por el usuario. Al abrir un archivo Python existente, IDLE detecta automáticamente las convenciones de sangría y se adapta.</p></li>
<li><p class="translated">Ahora hay soporte para llamar a los navegadores en varias plataformas, utilizado para abrir la documentación de Python en un navegador.</p></li>
<li><p class="translated">IDLE ahora tiene una línea de comandos, que es en gran medida similar al intérprete de Python vainilla.</p></li>
<li><p class="translated">Se añadieron consejos de llamada en muchos lugares.</p></li>
<li><p class="translated">Ahora IDLE puede instalarse como un paquete.</p></li>
<li><p class="translated">En la ventana del editor, ahora hay una barra de líneas/columnas en la parte inferior.</p></li>
<li><p class="translated">Tres nuevos comandos de teclado: Comprobar módulo (<kbd class="kbd docutils literal notranslate">Alt</kbd>-<kbd class="kbd docutils literal notranslate">F5</kbd>), Importar módulo (<kbd class="kbd docutils literal notranslate">F5</kbd>) y Ejecutar script (<kbd class="kbd docutils literal notranslate">Ctrl</kbd>-<kbd class="kbd docutils literal notranslate">F5</kbd>).</p></li>
</ul>
</section>
<section id="deleted-and-deprecated-modules">
<h2 class="translated">Módulos eliminados y obsoletos<a class="headerlink" href="#deleted-and-deprecated-modules" title="Link to this heading">¶</a></h2>
<p class="translated">Se han eliminado algunos módulos porque son obsoletos, o porque ahora hay mejores formas de hacer lo mismo. El módulo <code class="xref py py-mod docutils literal notranslate"><span class="pre">stdwin</span></code> ha desaparecido; era para un conjunto de herramientas de ventanas independientes de la plataforma que ya no se desarrolla.</p>
<p class="translated">Se han movido varios módulos al subdirectorio <code class="file docutils literal notranslate"><span class="pre">lib-old</span></code>: <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmp</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">cmpcache</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">dircmp</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">dump</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">find</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">grep</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">packmail</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">poly</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">util</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">whatsound</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">zmod</span></code>. Si tiene código que depende de un módulo que se ha movido a <code class="file docutils literal notranslate"><span class="pre">lib-old</span></code>, puede simplemente agregar ese directorio a <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> para recuperarlo, pero se le recomienda que actualice cualquier código que use estos módulos.</p>
</section>
<section id="acknowledgements">
<h2 class="translated">Agradecimientos<a class="headerlink" href="#acknowledgements" title="Link to this heading">¶</a></h2>
<p class="translated">Los autores desean agradecer a las siguientes personas sus sugerencias sobre varios borradores de este artículo: David Bolen, Mark Hammond, Gregg Hauser, Jeremy Hylton, Fredrik Lundh, Detlef Lannert, Aahz Maruch, Skip Montanaro, Vladimir Marangozov, Tobias Polzin, Guido van Rossum, Neil Schemenauer y Russ Schmidt.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Qué hay de nuevo en Python 2.0</a><ul>
<li><a class="reference internal" href="#introduction">Introducción</a></li>
<li><a class="reference internal" href="#what-about-python-1-6">¿Qué pasa con Python 1.6?</a></li>
<li><a class="reference internal" href="#new-development-process">Nuevo proceso de desarrollo</a></li>
<li><a class="reference internal" href="#unicode">Unicode</a></li>
<li><a class="reference internal" href="#list-comprehensions">Comprensión de listas</a></li>
<li><a class="reference internal" href="#augmented-assignment">Asignación aumentada</a></li>
<li><a class="reference internal" href="#string-methods">Métodos de cadena de caracteres</a></li>
<li><a class="reference internal" href="#garbage-collection-of-cycles">Recogida de basura de los ciclos</a></li>
<li><a class="reference internal" href="#other-core-changes">Otros cambios en el núcleo</a><ul>
<li><a class="reference internal" href="#minor-language-changes">Cambios menores del lenguaje</a></li>
<li><a class="reference internal" href="#changes-to-built-in-functions">Cambios en las funciones incorporadas</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-2-0">Adaptación a la versión 2.0</a></li>
<li><a class="reference internal" href="#extending-embedding-changes">Extensión/Incorporación de cambios</a></li>
<li><a class="reference internal" href="#distutils-making-modules-easy-to-install">Distutils: Facilitando la instalación de módulos</a></li>
<li><a class="reference internal" href="#xml-modules">Módulos XML</a><ul>
<li><a class="reference internal" href="#sax2-support">Soporte de SAX2</a></li>
<li><a class="reference internal" href="#dom-support">Soporte DOM</a></li>
<li><a class="reference internal" href="#relationship-to-pyxml">Relación con PyXML</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-changes">Cambios en los módulos</a></li>
<li><a class="reference internal" href="#new-modules">Nuevos módulos</a></li>
<li><a class="reference internal" href="#idle-improvements">Mejoras en IDLE</a></li>
<li><a class="reference internal" href="#deleted-and-deprecated-modules">Módulos eliminados y obsoletos</a></li>
<li><a class="reference internal" href="#acknowledgements">Agradecimientos</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="2.1.html"
                          title="capítulo anterior">Qué hay de nuevo en Python 2.1</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="changelog.html"
                          title="próximo capítulo">Registro de cambios</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This page</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">Report a bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.0.rst?plain=1"
            rel="nofollow">Show source
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="Contraer barra lateral">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Índice general"
             >índice</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Índice de Módulos Python"
             >módulos</a> |</li>
        <li class="right" >
          <a href="changelog.html" title="Registro de cambios"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="2.1.html" title="Qué hay de nuevo en Python 2.1"
             >anterior</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.15.0a0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Qué hay de nuevo en Python</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Qué hay de nuevo en Python 2.0</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Búsqueda rápida" aria-label="Búsqueda rápida" type="search" name="q" id="search-box">
          <input type="submit" value="Ir">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Tema
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Claro</option>
        <option value="dark">Oscuro</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Derechos de autor</a> 2001 Python Software Foundation.
    <br>
    Ésta página tiene la licencia Python Software Foundation Versión 2.
    <br>
    Ejemplos, guías, y otro código en la documentación están bajo la licencia adicional Zero Clause BSD.
    <br>
    
      Ver <a href="/license.html">Historia y Licencia</a> para más información.<br>
    
    
    <br>

    La Python Software Foundation es una corporación sin fines de lucro.
<a href="https://www.python.org/psf/donations/">Por favor dona.</a>
<br>
    <br>
      Última actualización en oct 06, 2025 (04:51 UTC).
    
      <a href="/bugs.html">Encontraste un bug</a>?
    
    <br>

    Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a>8.2.3.
    </div>

  </body>
</html>